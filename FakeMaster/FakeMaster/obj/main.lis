 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ;          angle -> X+4
 0000           ;  softwareReset -> X+2
 0000           ;      tempValue -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3808              add SP,8
 0004                   .dbline 103
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>              // part specific constants and macros
 0004           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0004           ; #include "psocdynamic.h"
 0004           ; #include <stdlib.h>
 0004           ; #include <string.h>
 0004           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0004           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0004           ; 
 0004           ; // These defines are used as parameters of the configToggle function.
 0004           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0004           ; #define               PC_MODE                                         (2)
 0004           ; #define               RX_MODE                                         (1)
 0004           ; #define               TX_MODE                                         (0)
 0004           ; 
 0004           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0004           ; #define               PORT_1                                          ('1')
 0004           ; #define               PORT_2                                          ('2')
 0004           ; #define               PORT_3                                          ('3')
 0004           ; #define               PORT_4                                          ('4')
 0004           ; 
 0004           ; // These defines are used as transmission indicators.
 0004           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0004           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0004           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0004           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0004           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0004           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0004           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0004           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0004           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0004           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0004           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0004           ; 
 0004           ; // These defines are used to fill in the instruction we are using on the servo.
 0004           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0004           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0004           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0004           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0004           ; 
 0004           ; // These defines are used for transmission timing.
 0004           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0004           ; 
 0004           ; // These defines are used for the initial probing stage. This module first waits until it hears
 0004           ; // a byte on the bus. Once this happens, this module waits until there is a BUS_CLEAR_TIME
 0004           ; // period of no communication before attempting to probe for modules and assign ID numbers.
 0004           ; // MAX_TIMEOUTS is the number of failed attempts allowed to find an unconfigured module after
 0004           ; // the first module is found. After all of this, this module goes into a PC listening mode.
 0004           ; #define               BUS_CLEAR_TIME                          (100)   // Min time after a byte to assume bus is clear at boot.
 0004           ; #define               BOOT_TIMEOUT                            (300)   // If nothing is heard by this time, we start the init anyway.
 0004           ; #define               MAX_TIMEOUTS                            (10)    // Number of timeouts allowed before hello mode exit.
 0004           ; 
 0004           ; // This is the maximum number of allowable modules per branch out from the master
 0004           ; #define               MAX_MODULES                                     (250)
 0004           ; 
 0004           ; #define               SERVO_START                                     (255)
 0004           ; 
 0004           ; // This function receives a mode identifier as a parameter and toggles the
 0004           ; // system configuration between receive and transmit modes for half duplex UART.
 0004           ; void configToggle(int mode);
 0004           ; 
 0004           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0004           ; int pingModule(int module_id);
 0004           ; 
 0004           ; // This function assigns an ID to a module.
 0004           ; int assignID(int assigned_ID);
 0004           ; 
 0004           ; int validTransmission(void);
 0004           ; 
 0004           ; void decodeTransmission(void);
 0004           ; 
 0004           ; void busListen(void);
 0004           ; 
 0004           ; void sayHello(void);
 0004           ; 
 0004           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0004           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0004           ; 
 0004           ; int clearConfig(int module_id);
 0004           ; // This function checks the current mode and unloads the configuration for that mode.
 0004           ; void unloadAllConfigs(void);
 0004           ; // This function unloads the configuration corresponding to the number passed to it.
 0004           ; void unloadConfig(int config_num);
 0004           ; // Initialization function for the slave module controllers.
 0004           ; void initializeSlaves(void);
 0004           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0004           ; void xmitWait(void);
 0004           ; 
 0004           ; // This flag is set if there is a timeout.
 0004           ; int TIMEOUT;
 0004           ; 
 0004           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0004           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0004           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0004           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0004           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0004           ; int STATE;                                    // Stores the current configuration state of the system.
 0004           ; 
 0004           ; void main()
 0004           ; {     
 0004                   .dbline 104
 0004           ;       int tempValue = 0;
 0004 560100            mov [X+1],0
 0007 560000            mov [X+0],0
 000A                   .dbline 105
 000A           ;       int softwareReset = 0;
 000A 560300            mov [X+3],0
 000D 560200            mov [X+2],0
 0010                   .dbline 106
 0010           ;       float angle = 0;
 0010 560400            mov [X+4],0
 0013 560500            mov [X+5],0
 0016 560600            mov [X+6],0
 0019 560700            mov [X+7],0
 001C                   .dbline 109
 001C           ;       
 001C           ;       // M8C_ClearWDTAndSleep;                                                        // Initialize the watchdog and sleep timers.
 001C           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);              // Activate GPIO ISR
 001C 43E020            or REG[0xe0],32
 001F                   .dbline 112
 001F           ;       // M8C_EnableIntMask(INT_MSK0, INT_MSK0_SLEEP); // Activate Sleep Timer
 001F           ;       
 001F           ;       M8C_EnableGInt;         // Turn on global interrupts for the transmission timeout timer.
 001F 7101                      or  F, 01h
 0021           
 0021                   .dbline 115
 0021           ;       
 0021           ;       // Initialize all of the slave modules.
 0021           ;       initializeSlaves();
 0021 7C0C8C            xcall _initializeSlaves
 0024 800F              xjmp L3
 0026           L2:
 0026                   .dbline 118
 0026           ;       
 0026           ;       while(1)
 0026           ;       {
 0026                   .dbline 123
 0026           ;               // Clear the Watchdog Timer
 0026           ;               // M8C_ClearWDT;
 0026           ;               
 0026           ;               // If there's a command from the computer, read it.
 0026           ;               if(COMP_SERIAL_bCmdCheck())
 0026 10                push X
 0027 7C0000            xcall _COMP_SERIAL_bCmdCheck
 002A 62D000            mov REG[0xd0],>__r0
 002D 20                pop X
 002E 3900              cmp A,0
 0030 A003              jz L5
 0032                   .dbline 124
 0032           ;               {
 0032                   .dbline 125
 0032           ;                       decodeTransmission();
 0032 942F              xcall _decodeTransmission
 0034                   .dbline 126
 0034           ;               }
 0034           L5:
 0034                   .dbline 127
 0034           ;       }
 0034           L3:
 0034                   .dbline 117
 0034 8FF1              xjmp L2
 0036           X0:
 0036                   .dbline -2
 0036           L1:
 0036 38F8              add SP,-8
 0038 20                pop X
 0039                   .dbline 0 ; func end
 0039 8FFF              jmp .
 003B                   .dbsym l angle 4 D
 003B                   .dbsym l softwareReset 2 I
 003B                   .dbsym l tempValue 0 I
 003B                   .dbend
 003B                   .dbfunc e pingModule _pingModule fI
 003B           ;       response -> X+0
 003B           ;      module_id -> X-5
 003B           _pingModule::
 003B                   .dbline -1
 003B 10                push X
 003C 4F                mov X,SP
 003D 3802              add SP,2
 003F                   .dbline 131
 003F           ; }
 003F           ; 
 003F           ; int pingModule(int module_id)
 003F           ; {
 003F                   .dbline 132
 003F           ;       int response = 0;
 003F 560100            mov [X+1],0
 0042 560000            mov [X+0],0
 0045                   .dbline 134
 0045           ;       
 0045           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0045 5000              mov A,0
 0047 08                push A
 0048 08                push A
 0049 7C0B0A            xcall _configToggle
 004C 38FE              add SP,-2
 004E                   .dbline 137
 004E           ;                       
 004E           ;       // Transmit a hello.
 004E           ;       TRANSMIT_PutChar(START_TRANSMIT);
 004E 10                push X
 004F 50FC              mov A,-4
 0051 7C0000            xcall _TRANSMIT_PutChar
 0054 20                pop X
 0055                   .dbline 138
 0055           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0055 10                push X
 0056 50FC              mov A,-4
 0058 7C0000            xcall _TRANSMIT_PutChar
 005B 20                pop X
 005C                   .dbline 139
 005C           ;       TRANSMIT_PutChar(MASTER_ID);
 005C 10                push X
 005D 5000              mov A,0
 005F 7C0000            xcall _TRANSMIT_PutChar
 0062 20                pop X
 0063                   .dbline 140
 0063           ;       TRANSMIT_PutChar(module_id);
 0063 62D000            mov REG[0xd0],>__r0
 0066 52FC              mov A,[X-4]
 0068 10                push X
 0069 7C0000            xcall _TRANSMIT_PutChar
 006C 20                pop X
 006D                   .dbline 141
 006D           ;       TRANSMIT_PutChar(PING);
 006D 10                push X
 006E 50CB              mov A,-53
 0070 7C0000            xcall _TRANSMIT_PutChar
 0073 20                pop X
 0074                   .dbline 142
 0074           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0074 10                push X
 0075 50FD              mov A,-3
 0077 7C0000            xcall _TRANSMIT_PutChar
 007A 20                pop X
 007B                   .dbline 143
 007B           ;       TRANSMIT_PutChar(END_TRANSMIT);
 007B 10                push X
 007C 50FD              mov A,-3
 007E 7C0000            xcall _TRANSMIT_PutChar
 0081 20                pop X
 0082           L8:
 0082                   .dbline 146
 0082           ;       
 0082           ;       // Wait for the transmission to finish.
 0082           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0082           L9:
 0082                   .dbline 146
 0082 10                push X
 0083 7C0000            xcall _TRANSMIT_bReadTxStatus
 0086 62D000            mov REG[0xd0],>__r0
 0089 20                pop X
 008A 5300              mov [__r0],A
 008C 470020            tst [__r0],32
 008F AFF2              jz L8
 0091                   .dbline 148
 0091           ;       
 0091           ;       xmitWait();
 0091 7C0DCA            xcall _xmitWait
 0094                   .dbline 150
 0094           ;       
 0094           ;       configToggle(RX_MODE);  // Listen for the response.
 0094 5000              mov A,0
 0096 08                push A
 0097 5001              mov A,1
 0099 08                push A
 009A 7C0B0A            xcall _configToggle
 009D 38FE              add SP,-2
 009F                   .dbline 152
 009F           ;       
 009F           ;       RX_TIMEOUT_Stop();
 009F 10                push X
 00A0 7C0000            xcall _RX_TIMEOUT_Stop
 00A3 20                pop X
 00A4                   .dbline 153
 00A4           ;       TIMEOUT = 0;
 00A4 62D000            mov REG[0xd0],>_TIMEOUT
 00A7 550100            mov [_TIMEOUT+1],0
 00AA 550000            mov [_TIMEOUT],0
 00AD                   .dbline 154
 00AD           ;       RX_TIMEOUT_Start();
 00AD 10                push X
 00AE 7C0000            xcall _RX_TIMEOUT_Start
 00B1 20                pop X
 00B2 803C              xjmp L12
 00B4           L11:
 00B4                   .dbline 157
 00B4           ;       
 00B4           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 00B4           ;       {
 00B4                   .dbline 158
 00B4           ;               if(validTransmission())
 00B4 92B9              xcall _validTransmission
 00B6 62D000            mov REG[0xd0],>__r0
 00B9 3C0000            cmp [__r0],0
 00BC B006              jnz X1
 00BE 3C0000            cmp [__r1],0
 00C1 A02D              jz L14
 00C3           X1:
 00C3                   .dbline 159
 00C3           ;               {
 00C3                   .dbline 160
 00C3           ;                       if(COMMAND_TYPE == PING)        // This is the response we are looking for.
 00C3 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00C6 3C00CB            cmp [_COMMAND_TYPE],-53
 00C9 B025              jnz L16
 00CB                   .dbline 161
 00CB           ;                       {
 00CB                   .dbline 163
 00CB           ;                               // If this is for me, check who it was from.
 00CB           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 00CB 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00CE 3C0000            cmp [_COMMAND_DESTINATION],0
 00D1 B01D              jnz L18
 00D3                   .dbline 164
 00D3           ;                               {
 00D3                   .dbline 165
 00D3           ;                                       if(COMMAND_SOURCE == module_id)
 00D3 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 00D6 5100              mov A,[_COMMAND_SOURCE]
 00D8 62D000            mov REG[0xd0],>__r0
 00DB 5300              mov [__r1],A
 00DD 5000              mov A,0
 00DF 3BFB              cmp A,[X-5]
 00E1 B00D              jnz L20
 00E3 5100              mov A,[__r1]
 00E5 3BFC              cmp A,[X-4]
 00E7 B007              jnz L20
 00E9           X2:
 00E9                   .dbline 166
 00E9           ;                                       {
 00E9                   .dbline 167
 00E9           ;                                               response = 1;
 00E9 560101            mov [X+1],1
 00EC 560000            mov [X+0],0
 00EF                   .dbline 168
 00EF           ;                                       }
 00EF           L20:
 00EF                   .dbline 169
 00EF           ;                               }
 00EF           L18:
 00EF                   .dbline 170
 00EF           ;                       }
 00EF           L16:
 00EF                   .dbline 171
 00EF           ;               }
 00EF           L14:
 00EF                   .dbline 172
 00EF           ;       }
 00EF           L12:
 00EF                   .dbline 156
 00EF 62D000            mov REG[0xd0],>_TIMEOUT
 00F2 5101              mov A,[_TIMEOUT+1]
 00F4 1105              sub A,5
 00F6 5100              mov A,[_TIMEOUT]
 00F8 3180              xor A,-128
 00FA 1980              sbb A,(0 ^ 0x80)
 00FC D00B              jnc L22
 00FE           X3:
 00FE 3D0000            cmp [X+0],0
 0101 B006              jnz X4
 0103 3D0100            cmp [X+1],0
 0106 AFAD              jz L11
 0108           X4:
 0108           L22:
 0108                   .dbline 174
 0108           ;       
 0108           ;       RX_TIMEOUT_Stop();
 0108 10                push X
 0109 7C0000            xcall _RX_TIMEOUT_Stop
 010C 20                pop X
 010D                   .dbline 175
 010D           ;       TIMEOUT = 0;
 010D 62D000            mov REG[0xd0],>_TIMEOUT
 0110 550100            mov [_TIMEOUT+1],0
 0113 550000            mov [_TIMEOUT],0
 0116                   .dbline 176
 0116           ;       RX_TIMEOUT_Start();
 0116 10                push X
 0117 7C0000            xcall _RX_TIMEOUT_Start
 011A 20                pop X
 011B                   .dbline 178
 011B           ;       
 011B           ;       return response;
 011B 62D000            mov REG[0xd0],>__r0
 011E 5201              mov A,[X+1]
 0120 5300              mov [__r1],A
 0122 5200              mov A,[X+0]
 0124 5300              mov [__r0],A
 0126                   .dbline -2
 0126           L7:
 0126 38FE              add SP,-2
 0128 20                pop X
 0129                   .dbline 0 ; func end
 0129 7F                ret
 012A                   .dbsym l response 0 I
 012A                   .dbsym l module_id -5 I
 012A                   .dbend
 012A                   .dbfunc e assignID _assignID fI
 012A           ;        success -> X+0
 012A           ;    assigned_ID -> X-5
 012A           _assignID::
 012A                   .dbline -1
 012A 10                push X
 012B 4F                mov X,SP
 012C 3802              add SP,2
 012E                   .dbline 182
 012E           ; }
 012E           ; 
 012E           ; int assignID(int assigned_ID)
 012E           ; {
 012E                   .dbline 183
 012E           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 012E 560100            mov [X+1],0
 0131 560000            mov [X+0],0
 0134                   .dbline 185
 0134           ;       
 0134           ;       configToggle(TX_MODE);  // Switch to TX mode.
 0134 5000              mov A,0
 0136 08                push A
 0137 08                push A
 0138 7C0B0A            xcall _configToggle
 013B 38FE              add SP,-2
 013D                   .dbline 188
 013D           ; 
 013D           ;       // Transmit the assignment.
 013D           ;       TRANSMIT_PutChar(START_TRANSMIT);
 013D 10                push X
 013E 50FC              mov A,-4
 0140 7C0000            xcall _TRANSMIT_PutChar
 0143 20                pop X
 0144                   .dbline 189
 0144           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0144 10                push X
 0145 50FC              mov A,-4
 0147 7C0000            xcall _TRANSMIT_PutChar
 014A 20                pop X
 014B                   .dbline 190
 014B           ;       TRANSMIT_PutChar(MASTER_ID);
 014B 10                push X
 014C 5000              mov A,0
 014E 7C0000            xcall _TRANSMIT_PutChar
 0151 20                pop X
 0152                   .dbline 191
 0152           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0152 10                push X
 0153 50FB              mov A,-5
 0155 7C0000            xcall _TRANSMIT_PutChar
 0158 20                pop X
 0159                   .dbline 192
 0159           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 0159 10                push X
 015A 50C9              mov A,-55
 015C 7C0000            xcall _TRANSMIT_PutChar
 015F 20                pop X
 0160                   .dbline 193
 0160           ;       TRANSMIT_PutChar(assigned_ID);
 0160 62D000            mov REG[0xd0],>__r0
 0163 52FC              mov A,[X-4]
 0165 10                push X
 0166 7C0000            xcall _TRANSMIT_PutChar
 0169 20                pop X
 016A                   .dbline 194
 016A           ;       TRANSMIT_PutChar(END_TRANSMIT);
 016A 10                push X
 016B 50FD              mov A,-3
 016D 7C0000            xcall _TRANSMIT_PutChar
 0170 20                pop X
 0171                   .dbline 195
 0171           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0171 10                push X
 0172 50FD              mov A,-3
 0174 7C0000            xcall _TRANSMIT_PutChar
 0177 20                pop X
 0178           L24:
 0178                   .dbline 198
 0178           ;       
 0178           ;       // Wait for the transmission to finish.
 0178           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0178           L25:
 0178                   .dbline 198
 0178 10                push X
 0179 7C0000            xcall _TRANSMIT_bReadTxStatus
 017C 62D000            mov REG[0xd0],>__r0
 017F 20                pop X
 0180 5300              mov [__r0],A
 0182 470020            tst [__r0],32
 0185 AFF2              jz L24
 0187                   .dbline 200
 0187           ;       
 0187           ;       xmitWait();
 0187 7C0DCA            xcall _xmitWait
 018A                   .dbline 202
 018A           ;       
 018A           ;       configToggle(RX_MODE);  // Switch back to receive mode.
 018A 5000              mov A,0
 018C 08                push A
 018D 5001              mov A,1
 018F 08                push A
 0190 7C0B0A            xcall _configToggle
 0193 38FE              add SP,-2
 0195                   .dbline 204
 0195           ;       
 0195           ;       RX_TIMEOUT_Stop();
 0195 10                push X
 0196 7C0000            xcall _RX_TIMEOUT_Stop
 0199 20                pop X
 019A                   .dbline 205
 019A           ;       TIMEOUT = 0;
 019A 62D000            mov REG[0xd0],>_TIMEOUT
 019D 550100            mov [_TIMEOUT+1],0
 01A0 550000            mov [_TIMEOUT],0
 01A3                   .dbline 206
 01A3           ;       RX_TIMEOUT_Start();
 01A3 10                push X
 01A4 7C0000            xcall _RX_TIMEOUT_Start
 01A7 20                pop X
 01A8 803C              xjmp L28
 01AA           L27:
 01AA                   .dbline 209
 01AA           ;       
 01AA           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!success))
 01AA           ;       {
 01AA                   .dbline 210
 01AA           ;               if(validTransmission())
 01AA 91C3              xcall _validTransmission
 01AC 62D000            mov REG[0xd0],>__r0
 01AF 3C0000            cmp [__r0],0
 01B2 B006              jnz X5
 01B4 3C0000            cmp [__r1],0
 01B7 A02D              jz L30
 01B9           X5:
 01B9                   .dbline 211
 01B9           ;               {
 01B9                   .dbline 212
 01B9           ;                       if(COMMAND_TYPE == ID_ASSIGN_OK)        // This is the response we are looking for.
 01B9 62D000            mov REG[0xd0],>_COMMAND_TYPE
 01BC 3C00CA            cmp [_COMMAND_TYPE],-54
 01BF B025              jnz L32
 01C1                   .dbline 213
 01C1           ;                       {
 01C1                   .dbline 215
 01C1           ;                               // If this is for me, check who it was from.
 01C1           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 01C1 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 01C4 3C0000            cmp [_COMMAND_DESTINATION],0
 01C7 B01D              jnz L34
 01C9                   .dbline 216
 01C9           ;                               {
 01C9                   .dbline 217
 01C9           ;                                       if(COMMAND_SOURCE == assigned_ID)
 01C9 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 01CC 5100              mov A,[_COMMAND_SOURCE]
 01CE 62D000            mov REG[0xd0],>__r0
 01D1 5300              mov [__r1],A
 01D3 5000              mov A,0
 01D5 3BFB              cmp A,[X-5]
 01D7 B00D              jnz L36
 01D9 5100              mov A,[__r1]
 01DB 3BFC              cmp A,[X-4]
 01DD B007              jnz L36
 01DF           X6:
 01DF                   .dbline 218
 01DF           ;                                       {
 01DF                   .dbline 219
 01DF           ;                                               success = 1;
 01DF 560101            mov [X+1],1
 01E2 560000            mov [X+0],0
 01E5                   .dbline 220
 01E5           ;                                       }
 01E5           L36:
 01E5                   .dbline 221
 01E5           ;                               }
 01E5           L34:
 01E5                   .dbline 222
 01E5           ;                       }
 01E5           L32:
 01E5                   .dbline 223
 01E5           ;               }
 01E5           L30:
 01E5                   .dbline 224
 01E5           ;       }
 01E5           L28:
 01E5                   .dbline 208
 01E5 62D000            mov REG[0xd0],>_TIMEOUT
 01E8 5101              mov A,[_TIMEOUT+1]
 01EA 1105              sub A,5
 01EC 5100              mov A,[_TIMEOUT]
 01EE 3180              xor A,-128
 01F0 1980              sbb A,(0 ^ 0x80)
 01F2 D00B              jnc L38
 01F4           X7:
 01F4 3D0000            cmp [X+0],0
 01F7 B006              jnz X8
 01F9 3D0100            cmp [X+1],0
 01FC AFAD              jz L27
 01FE           X8:
 01FE           L38:
 01FE                   .dbline 226
 01FE           ;       
 01FE           ;       RX_TIMEOUT_Stop();
 01FE 10                push X
 01FF 7C0000            xcall _RX_TIMEOUT_Stop
 0202 20                pop X
 0203                   .dbline 227
 0203           ;       TIMEOUT = 0;
 0203 62D000            mov REG[0xd0],>_TIMEOUT
 0206 550100            mov [_TIMEOUT+1],0
 0209 550000            mov [_TIMEOUT],0
 020C                   .dbline 228
 020C           ;       RX_TIMEOUT_Start();
 020C 10                push X
 020D 7C0000            xcall _RX_TIMEOUT_Start
 0210 20                pop X
 0211                   .dbline 230
 0211           ;       
 0211           ;       return success;
 0211 62D000            mov REG[0xd0],>__r0
 0214 5201              mov A,[X+1]
 0216 5300              mov [__r1],A
 0218 5200              mov A,[X+0]
 021A 5300              mov [__r0],A
 021C                   .dbline -2
 021C           L23:
 021C 38FE              add SP,-2
 021E 20                pop X
 021F                   .dbline 0 ; func end
 021F 7F                ret
 0220                   .dbsym l success 0 I
 0220                   .dbsym l assigned_ID -5 I
 0220                   .dbend
 0220                   .dbfunc e clearConfig _clearConfig fI
 0220           ;       response -> X+0
 0220           ;      module_id -> X-5
 0220           _clearConfig::
 0220                   .dbline -1
 0220 10                push X
 0221 4F                mov X,SP
 0222 3802              add SP,2
 0224                   .dbline 234
 0224           ; }
 0224           ; 
 0224           ; int clearConfig(int module_id)
 0224           ; {
 0224                   .dbline 235
 0224           ;       int response = 0;
 0224 560100            mov [X+1],0
 0227 560000            mov [X+0],0
 022A                   .dbline 237
 022A           ;       
 022A           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 022A 5000              mov A,0
 022C 08                push A
 022D 08                push A
 022E 7C0B0A            xcall _configToggle
 0231 38FE              add SP,-2
 0233                   .dbline 240
 0233           ;                       
 0233           ;       // Transmit a hello.
 0233           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0233 10                push X
 0234 50FC              mov A,-4
 0236 7C0000            xcall _TRANSMIT_PutChar
 0239 20                pop X
 023A                   .dbline 241
 023A           ;       TRANSMIT_PutChar(START_TRANSMIT);
 023A 10                push X
 023B 50FC              mov A,-4
 023D 7C0000            xcall _TRANSMIT_PutChar
 0240 20                pop X
 0241                   .dbline 242
 0241           ;       TRANSMIT_PutChar(MASTER_ID);
 0241 10                push X
 0242 5000              mov A,0
 0244 7C0000            xcall _TRANSMIT_PutChar
 0247 20                pop X
 0248                   .dbline 243
 0248           ;       TRANSMIT_PutChar(module_id);
 0248 62D000            mov REG[0xd0],>__r0
 024B 52FC              mov A,[X-4]
 024D 10                push X
 024E 7C0000            xcall _TRANSMIT_PutChar
 0251 20                pop X
 0252                   .dbline 244
 0252           ;       TRANSMIT_PutChar(CLEAR_CONFIG);
 0252 10                push X
 0253 50CC              mov A,-52
 0255 7C0000            xcall _TRANSMIT_PutChar
 0258 20                pop X
 0259                   .dbline 245
 0259           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0259 10                push X
 025A 50FD              mov A,-3
 025C 7C0000            xcall _TRANSMIT_PutChar
 025F 20                pop X
 0260                   .dbline 246
 0260           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0260 10                push X
 0261 50FD              mov A,-3
 0263 7C0000            xcall _TRANSMIT_PutChar
 0266 20                pop X
 0267           L40:
 0267                   .dbline 249
 0267           ;       
 0267           ;       // Wait for the transmission to finish.
 0267           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0267           L41:
 0267                   .dbline 249
 0267 10                push X
 0268 7C0000            xcall _TRANSMIT_bReadTxStatus
 026B 62D000            mov REG[0xd0],>__r0
 026E 20                pop X
 026F 5300              mov [__r0],A
 0271 470020            tst [__r0],32
 0274 AFF2              jz L40
 0276                   .dbline 251
 0276           ;       
 0276           ;       xmitWait();
 0276 7C0DCA            xcall _xmitWait
 0279                   .dbline 253
 0279           ;       
 0279           ;       configToggle(RX_MODE);  // Listen for the response.
 0279 5000              mov A,0
 027B 08                push A
 027C 5001              mov A,1
 027E 08                push A
 027F 7C0B0A            xcall _configToggle
 0282 38FE              add SP,-2
 0284                   .dbline 255
 0284           ;       
 0284           ;       if(module_id != BROADCAST)
 0284 3DFB00            cmp [X-5],0
 0287 B006              jnz X9
 0289 3DFCFE            cmp [X-4],-2
 028C A07D              jz L43
 028E           X9:
 028E                   .dbline 256
 028E           ;       {
 028E                   .dbline 257
 028E           ;               RX_TIMEOUT_Stop();
 028E 10                push X
 028F 7C0000            xcall _RX_TIMEOUT_Stop
 0292 20                pop X
 0293                   .dbline 258
 0293           ;               TIMEOUT = 0;
 0293 62D000            mov REG[0xd0],>_TIMEOUT
 0296 550100            mov [_TIMEOUT+1],0
 0299 550000            mov [_TIMEOUT],0
 029C                   .dbline 259
 029C           ;               RX_TIMEOUT_Start();
 029C 10                push X
 029D 7C0000            xcall _RX_TIMEOUT_Start
 02A0 20                pop X
 02A1 803C              xjmp L46
 02A3           L45:
 02A3                   .dbline 262
 02A3           ;               
 02A3           ;               while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 02A3           ;               {
 02A3                   .dbline 263
 02A3           ;                       if(validTransmission())
 02A3 90CA              xcall _validTransmission
 02A5 62D000            mov REG[0xd0],>__r0
 02A8 3C0000            cmp [__r0],0
 02AB B006              jnz X10
 02AD 3C0000            cmp [__r1],0
 02B0 A02D              jz L48
 02B2           X10:
 02B2                   .dbline 264
 02B2           ;                       {
 02B2                   .dbline 265
 02B2           ;                               if(COMMAND_TYPE == CONFIG_CLEARED)      // This is the response we are looking for.
 02B2 62D000            mov REG[0xd0],>_COMMAND_TYPE
 02B5 3C00CD            cmp [_COMMAND_TYPE],-51
 02B8 B025              jnz L50
 02BA                   .dbline 266
 02BA           ;                               {
 02BA                   .dbline 268
 02BA           ;                                       // If this is for me, check who it was from.
 02BA           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 02BA 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 02BD 3C0000            cmp [_COMMAND_DESTINATION],0
 02C0 B01D              jnz L52
 02C2                   .dbline 269
 02C2           ;                                       {
 02C2                   .dbline 270
 02C2           ;                                               if(COMMAND_SOURCE == module_id)
 02C2 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 02C5 5100              mov A,[_COMMAND_SOURCE]
 02C7 62D000            mov REG[0xd0],>__r0
 02CA 5300              mov [__r1],A
 02CC 5000              mov A,0
 02CE 3BFB              cmp A,[X-5]
 02D0 B00D              jnz L54
 02D2 5100              mov A,[__r1]
 02D4 3BFC              cmp A,[X-4]
 02D6 B007              jnz L54
 02D8           X11:
 02D8                   .dbline 271
 02D8           ;                                               {
 02D8                   .dbline 272
 02D8           ;                                                       response = 1;
 02D8 560101            mov [X+1],1
 02DB 560000            mov [X+0],0
 02DE                   .dbline 273
 02DE           ;                                               }
 02DE           L54:
 02DE                   .dbline 274
 02DE           ;                                       }
 02DE           L52:
 02DE                   .dbline 275
 02DE           ;                               }
 02DE           L50:
 02DE                   .dbline 276
 02DE           ;                       }
 02DE           L48:
 02DE                   .dbline 277
 02DE           ;               }
 02DE           L46:
 02DE                   .dbline 261
 02DE 62D000            mov REG[0xd0],>_TIMEOUT
 02E1 5101              mov A,[_TIMEOUT+1]
 02E3 1105              sub A,5
 02E5 5100              mov A,[_TIMEOUT]
 02E7 3180              xor A,-128
 02E9 1980              sbb A,(0 ^ 0x80)
 02EB D00B              jnc L56
 02ED           X12:
 02ED 3D0000            cmp [X+0],0
 02F0 B006              jnz X13
 02F2 3D0100            cmp [X+1],0
 02F5 AFAD              jz L45
 02F7           X13:
 02F7           L56:
 02F7                   .dbline 279
 02F7           ;               
 02F7           ;               RX_TIMEOUT_Stop();
 02F7 10                push X
 02F8 7C0000            xcall _RX_TIMEOUT_Stop
 02FB 20                pop X
 02FC                   .dbline 280
 02FC           ;               TIMEOUT = 0;
 02FC 62D000            mov REG[0xd0],>_TIMEOUT
 02FF 550100            mov [_TIMEOUT+1],0
 0302 550000            mov [_TIMEOUT],0
 0305                   .dbline 281
 0305           ;               RX_TIMEOUT_Start();
 0305 10                push X
 0306 7C0000            xcall _RX_TIMEOUT_Start
 0309 20                pop X
 030A                   .dbline 282
 030A           ;       }
 030A           L43:
 030A                   .dbline 284
 030A           ;       
 030A           ;       return response;
 030A 62D000            mov REG[0xd0],>__r0
 030D 5201              mov A,[X+1]
 030F 5300              mov [__r1],A
 0311 5200              mov A,[X+0]
 0313 5300              mov [__r0],A
 0315                   .dbline -2
 0315           L39:
 0315 38FE              add SP,-2
 0317 20                pop X
 0318                   .dbline 0 ; func end
 0318 7F                ret
 0319                   .dbsym l response 0 I
 0319                   .dbsym l module_id -5 I
 0319                   .dbend
 0319                   .dbfunc e sayHello _sayHello fV
 0319           _sayHello::
 0319                   .dbline -1
 0319                   .dbline 289
 0319           ; }
 0319           ; 
 0319           ; // This function transmits a hello message.
 0319           ; void sayHello(void)
 0319           ; {
 0319                   .dbline 290
 0319           ;       configToggle(TX_MODE);                          // Toggle into TX mode.
 0319 5000              mov A,0
 031B 08                push A
 031C 08                push A
 031D 97EB              xcall _configToggle
 031F 38FE              add SP,-2
 0321                   .dbline 293
 0321           ;                       
 0321           ;       // Transmit a hello.
 0321           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0321 10                push X
 0322 50FC              mov A,-4
 0324 7C0000            xcall _TRANSMIT_PutChar
 0327 20                pop X
 0328                   .dbline 294
 0328           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0328 10                push X
 0329 50FC              mov A,-4
 032B 7C0000            xcall _TRANSMIT_PutChar
 032E 20                pop X
 032F                   .dbline 295
 032F           ;       TRANSMIT_PutChar(MASTER_ID);
 032F 10                push X
 0330 5000              mov A,0
 0332 7C0000            xcall _TRANSMIT_PutChar
 0335 20                pop X
 0336                   .dbline 296
 0336           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0336 10                push X
 0337 50FB              mov A,-5
 0339 7C0000            xcall _TRANSMIT_PutChar
 033C 20                pop X
 033D                   .dbline 297
 033D           ;       TRANSMIT_PutChar(HELLO_BYTE);
 033D 10                push X
 033E 50C8              mov A,-56
 0340 7C0000            xcall _TRANSMIT_PutChar
 0343 20                pop X
 0344                   .dbline 298
 0344           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0344 10                push X
 0345 50FD              mov A,-3
 0347 7C0000            xcall _TRANSMIT_PutChar
 034A 20                pop X
 034B                   .dbline 299
 034B           ;       TRANSMIT_PutChar(END_TRANSMIT);
 034B 10                push X
 034C 50FD              mov A,-3
 034E 7C0000            xcall _TRANSMIT_PutChar
 0351 20                pop X
 0352           L58:
 0352                   .dbline 302
 0352           ;       
 0352           ;       // Wait for the transmission to finish.
 0352           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0352           L59:
 0352                   .dbline 302
 0352 10                push X
 0353 7C0000            xcall _TRANSMIT_bReadTxStatus
 0356 62D000            mov REG[0xd0],>__r0
 0359 20                pop X
 035A 5300              mov [__r0],A
 035C 470020            tst [__r0],32
 035F AFF2              jz L58
 0361                   .dbline 304
 0361           ;       
 0361           ;       xmitWait();
 0361 7C0DCA            xcall _xmitWait
 0364                   .dbline 306
 0364           ;       
 0364           ;       configToggle(RX_MODE);                          // Listen for the response.
 0364 5000              mov A,0
 0366 08                push A
 0367 5001              mov A,1
 0369 08                push A
 036A 979E              xcall _configToggle
 036C 38FE              add SP,-2
 036E                   .dbline -2
 036E           L57:
 036E                   .dbline 0 ; func end
 036E 7F                ret
 036F                   .dbend
 036F                   .dbfunc e validTransmission _validTransmission fI
 036F           ; valid_transmit -> X+3
 036F           ;              i -> X+1
 036F           ;       tempByte -> X+0
 036F           _validTransmission::
 036F                   .dbline -1
 036F 10                push X
 0370 4F                mov X,SP
 0371 3805              add SP,5
 0373                   .dbline 311
 0373           ; }
 0373           ; 
 0373           ; // This function returns whether or not a valid transmission has been received.
 0373           ; int validTransmission(void)
 0373           ; {
 0373                   .dbline 312
 0373           ;       int valid_transmit = 0;
 0373 560400            mov [X+4],0
 0376 560300            mov [X+3],0
 0379                   .dbline 313
 0379           ;       int i = 0;
 0379 560200            mov [X+2],0
 037C 560100            mov [X+1],0
 037F                   .dbline 314
 037F           ;       char tempByte = 0;
 037F 560000            mov [X+0],0
 0382 80C2              xjmp L63
 0384           L62:
 0384                   .dbline 317
 0384           ;       
 0384           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0384           ;       {
 0384                   .dbline 318
 0384           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0384 10                push X
 0385 7C0000            xcall _RECEIVE_cReadChar
 0388 62D000            mov REG[0xd0],>__r0
 038B 20                pop X
 038C 39FC              cmp A,-4
 038E B0B6              jnz L65
 0390                   .dbline 319
 0390           ;               {
 0390 80A5              xjmp L68
 0392           L67:
 0392                   .dbline 321
 0392           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0392           ;                       {
 0392                   .dbline 322
 0392           ;                               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0392 10                push X
 0393 7C0000            xcall _RECEIVE_cReadChar
 0396 62D000            mov REG[0xd0],>__r0
 0399 20                pop X
 039A 39FC              cmp A,-4
 039C B099              jnz L70
 039E                   .dbline 323
 039E           ;                               {
 039E 8088              xjmp L73
 03A0           L72:
 03A0                   .dbline 325
 03A0           ;                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 03A0           ;                                       {
 03A0                   .dbline 326
 03A0           ;                                               if(tempByte = RECEIVE_cReadChar())
 03A0 10                push X
 03A1 7C0000            xcall _RECEIVE_cReadChar
 03A4 20                pop X
 03A5 5400              mov [X+0],A
 03A7 3900              cmp A,0
 03A9 A07D              jz L75
 03AB                   .dbline 327
 03AB           ;                                               {
 03AB                   .dbline 328
 03AB           ;                                                       COMMAND_SOURCE = tempByte;
 03AB 5200              mov A,[X+0]
 03AD 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 03B0 5300              mov [_COMMAND_SOURCE],A
 03B2 8065              xjmp L78
 03B4           L77:
 03B4                   .dbline 331
 03B4           ;                                                       
 03B4           ;                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 03B4           ;                                                       {
 03B4                   .dbline 332
 03B4           ;                                                               if(tempByte = RECEIVE_cReadChar())
 03B4 10                push X
 03B5 7C0000            xcall _RECEIVE_cReadChar
 03B8 62D000            mov REG[0xd0],>__r0
 03BB 20                pop X
 03BC 5400              mov [X+0],A
 03BE 3900              cmp A,0
 03C0 A057              jz L80
 03C2                   .dbline 333
 03C2           ;                                                               {
 03C2                   .dbline 334
 03C2           ;                                                                       if(tempByte >= HELLO_BYTE)
 03C2 3D00C8            cmp [X+0],-56
 03C5 C052              jc L82
 03C7           X14:
 03C7                   .dbline 335
 03C7           ;                                                                       {
 03C7                   .dbline 336
 03C7           ;                                                                               COMMAND_TYPE = tempByte;
 03C7 5200              mov A,[X+0]
 03C9 62D000            mov REG[0xd0],>_COMMAND_TYPE
 03CC 5300              mov [_COMMAND_TYPE],A
 03CE 803A              xjmp L85
 03D0           L84:
 03D0                   .dbline 339
 03D0           ;                                                                               
 03D0           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 03D0           ;                                                                               {
 03D0                   .dbline 340
 03D0           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 03D0 10                push X
 03D1 7C0000            xcall _RECEIVE_cReadChar
 03D4 62D000            mov REG[0xd0],>__r0
 03D7 20                pop X
 03D8 5400              mov [X+0],A
 03DA 3900              cmp A,0
 03DC A02C              jz L87
 03DE                   .dbline 341
 03DE           ;                                                                                       {
 03DE                   .dbline 342
 03DE           ;                                                                                               if(tempByte != END_TRANSMIT)
 03DE 3D00FD            cmp [X+0],-3
 03E1 A018              jz L89
 03E3                   .dbline 343
 03E3           ;                                                                                               {
 03E3                   .dbline 344
 03E3           ;                                                                                                       PARAM[i] = tempByte;
 03E3 5202              mov A,[X+2]
 03E5 0100              add A,<_PARAM
 03E7 5300              mov [__r1],A
 03E9 5201              mov A,[X+1]
 03EB 0900              adc A,>_PARAM
 03ED 60D5              mov REG[0xd5],A
 03EF 5200              mov A,[X+0]
 03F1 3F00              mvi [__r1],A
 03F3                   .dbline 345
 03F3           ;                                                                                                       i++;
 03F3 7702              inc [X+2]
 03F5 0F0100            adc [X+1],0
 03F8                   .dbline 346
 03F8           ;                                                                                               }
 03F8 8010              xjmp L90
 03FA           L89:
 03FA                   .dbline 348
 03FA           ;                                                                                               else
 03FA           ;                                                                                               {
 03FA                   .dbline 349
 03FA           ;                                                                                                       valid_transmit = 1;
 03FA 560401            mov [X+4],1
 03FD 560300            mov [X+3],0
 0400                   .dbline 350
 0400           ;                                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 0400 62D000            mov REG[0xd0],>_TIMEOUT
 0403 550105            mov [_TIMEOUT+1],5
 0406 550000            mov [_TIMEOUT],0
 0409                   .dbline 351
 0409           ;                                                                                               }
 0409           L90:
 0409                   .dbline 352
 0409           ;                                                                                       }
 0409           L87:
 0409                   .dbline 353
 0409           ;                                                                               }
 0409           L85:
 0409                   .dbline 338
 0409 62D000            mov REG[0xd0],>_TIMEOUT
 040C 5101              mov A,[_TIMEOUT+1]
 040E 1105              sub A,5
 0410 5100              mov A,[_TIMEOUT]
 0412 3180              xor A,-128
 0414 1980              sbb A,(0 ^ 0x80)
 0416 CFB9              jc L84
 0418           X15:
 0418                   .dbline 354
 0418           ;                                                                       }
 0418           L82:
 0418                   .dbline 355
 0418           ;                                                               }
 0418           L80:
 0418                   .dbline 356
 0418           ;                                                       }
 0418           L78:
 0418                   .dbline 330
 0418 62D000            mov REG[0xd0],>_TIMEOUT
 041B 5101              mov A,[_TIMEOUT+1]
 041D 1105              sub A,5
 041F 5100              mov A,[_TIMEOUT]
 0421 3180              xor A,-128
 0423 1980              sbb A,(0 ^ 0x80)
 0425 CF8E              jc L77
 0427           X16:
 0427                   .dbline 357
 0427           ;                                               }
 0427           L75:
 0427                   .dbline 358
 0427           ;                                       }
 0427           L73:
 0427                   .dbline 324
 0427 62D000            mov REG[0xd0],>_TIMEOUT
 042A 5101              mov A,[_TIMEOUT+1]
 042C 1105              sub A,5
 042E 5100              mov A,[_TIMEOUT]
 0430 3180              xor A,-128
 0432 1980              sbb A,(0 ^ 0x80)
 0434 CF6B              jc L72
 0436           X17:
 0436                   .dbline 359
 0436           ;                               }
 0436           L70:
 0436                   .dbline 360
 0436           ;                       }
 0436           L68:
 0436                   .dbline 320
 0436 62D000            mov REG[0xd0],>_TIMEOUT
 0439 5101              mov A,[_TIMEOUT+1]
 043B 1105              sub A,5
 043D 5100              mov A,[_TIMEOUT]
 043F 3180              xor A,-128
 0441 1980              sbb A,(0 ^ 0x80)
 0443 CF4E              jc L67
 0445           X18:
 0445                   .dbline 361
 0445           ;               }
 0445           L65:
 0445                   .dbline 362
 0445           ;       }
 0445           L63:
 0445                   .dbline 316
 0445 62D000            mov REG[0xd0],>_TIMEOUT
 0448 5101              mov A,[_TIMEOUT+1]
 044A 1105              sub A,5
 044C 5100              mov A,[_TIMEOUT]
 044E 3180              xor A,-128
 0450 1980              sbb A,(0 ^ 0x80)
 0452 CF31              jc L62
 0454           X19:
 0454                   .dbline 364
 0454           ;       
 0454           ;       return valid_transmit;
 0454 62D000            mov REG[0xd0],>__r0
 0457 5204              mov A,[X+4]
 0459 5300              mov [__r1],A
 045B 5203              mov A,[X+3]
 045D 5300              mov [__r0],A
 045F                   .dbline -2
 045F           L61:
 045F 38FB              add SP,-5
 0461 20                pop X
 0462                   .dbline 0 ; func end
 0462 7F                ret
 0463                   .dbsym l valid_transmit 3 I
 0463                   .dbsym l i 1 I
 0463                   .dbsym l tempByte 0 c
 0463                   .dbend
 0463                   .dbfunc e decodeTransmission _decodeTransmission fV
 0463           ;       tempByte -> X+7
 0463           ;          angle -> X+5
 0463           ;             ID -> X+4
 0463           ;          total -> X+2
 0463           ;          param -> X+0
 0463           _decodeTransmission::
 0463                   .dbline -1
 0463 10                push X
 0464 4F                mov X,SP
 0465 3808              add SP,8
 0467                   .dbline 369
 0467           ; }
 0467           ; 
 0467           ; // This function decodes the transmission and takes the correct action.
 0467           ; void decodeTransmission(void)
 0467           ; {
 0467                   .dbline 374
 0467           ;       char* param;
 0467           ;       char ID;
 0467           ;       char tempByte;
 0467           ;       char angle[2];
 0467           ;       int total = 0;
 0467 560300            mov [X+3],0
 046A 560200            mov [X+2],0
 046D                   .dbline 376
 046D           ;       
 046D           ;       if(param = COMP_SERIAL_szGetParam())
 046D 10                push X
 046E 7C0000            xcall _COMP_SERIAL_szGetParam
 0471 62D000            mov REG[0xd0],>__r0
 0474 5300              mov [__r0],A
 0476 5A00              mov [__r1],X
 0478 20                pop X
 0479 5100              mov A,[__r1]
 047B 5401              mov [X+1],A
 047D 5100              mov A,[__r0]
 047F 5400              mov [X+0],A
 0481 3C0000            cmp [__r0],0
 0484 B006              jnz X20
 0486 3C0000            cmp [__r1],0
 0489 A506              jz L92
 048B           X20:
 048B                   .dbline 377
 048B           ;       {
 048B                   .dbline 378
 048B           ;               if((param[0] == 'n') || (param[0] == 'N'))
 048B 62D000            mov REG[0xd0],>__r0
 048E 5201              mov A,[X+1]
 0490 5300              mov [__r1],A
 0492 5200              mov A,[X+0]
 0494 60D4              mov REG[0xd4],A
 0496 3E00              mvi A,[__r1]
 0498 5300              mov [__r1],A
 049A 550000            mov [__r0],0
 049D 3C0000            cmp [__r0],0
 04A0 B005              jnz X21
 04A2 396E              cmp A,110
 04A4 A00E              jz L96
 04A6           X21:
 04A6 62D000            mov REG[0xd0],>__r0
 04A9 3C0000            cmp [__r0],0
 04AC B03A              jnz L94
 04AE 3C004E            cmp [__r1],78
 04B1 B035              jnz L94
 04B3           X22:
 04B3           L96:
 04B3                   .dbline 379
 04B3           ;               {
 04B3                   .dbline 380
 04B3           ;                       COMP_SERIAL_CmdReset();
 04B3 10                push X
 04B4 7C0000            xcall _COMP_SERIAL_CmdReset
 04B7 20                pop X
 04B8                   .dbline 381
 04B8           ;                       itoa(param,NUM_MODULES,10);
 04B8 5000              mov A,0
 04BA 08                push A
 04BB 500A              mov A,10
 04BD 08                push A
 04BE 62D000            mov REG[0xd0],>_NUM_MODULES
 04C1 5100              mov A,[_NUM_MODULES]
 04C3 08                push A
 04C4 5101              mov A,[_NUM_MODULES+1]
 04C6 08                push A
 04C7 5200              mov A,[X+0]
 04C9 08                push A
 04CA 5201              mov A,[X+1]
 04CC 08                push A
 04CD 7C0000            xcall _itoa
 04D0 38FA              add SP,-6
 04D2                   .dbline 382
 04D2           ;                       COMP_SERIAL_PutString(param);
 04D2 10                push X
 04D3 5200              mov A,[X+0]
 04D5 08                push A
 04D6 5201              mov A,[X+1]
 04D8 5C                mov X,A
 04D9 18                pop A
 04DA 7C0000            xcall _COMP_SERIAL_PutString
 04DD 20                pop X
 04DE                   .dbline 383
 04DE           ;                       COMP_SERIAL_PutChar('\n');
 04DE 10                push X
 04DF 500A              mov A,10
 04E1 7C0000            xcall _COMP_SERIAL_PutChar
 04E4 20                pop X
 04E5                   .dbline 384
 04E5           ;               }
 04E5 84AA              xjmp L95
 04E7           L94:
 04E7                   .dbline 385
 04E7           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 04E7 62D000            mov REG[0xd0],>__r0
 04EA 5201              mov A,[X+1]
 04EC 5300              mov [__r1],A
 04EE 5200              mov A,[X+0]
 04F0 60D4              mov REG[0xd4],A
 04F2 3E00              mvi A,[__r1]
 04F4 5300              mov [__r1],A
 04F6 550000            mov [__r0],0
 04F9 3C0000            cmp [__r0],0
 04FC B005              jnz X23
 04FE 3977              cmp A,119
 0500 A00E              jz L99
 0502           X23:
 0502 62D000            mov REG[0xd0],>__r0
 0505 3C0000            cmp [__r0],0
 0508 B16B              jnz L97
 050A 3C0057            cmp [__r1],87
 050D B166              jnz L97
 050F           X24:
 050F           L99:
 050F                   .dbline 386
 050F           ;               {
 050F                   .dbline 387
 050F           ;                       if(param = COMP_SERIAL_szGetParam())
 050F 10                push X
 0510 7C0000            xcall _COMP_SERIAL_szGetParam
 0513 62D000            mov REG[0xd0],>__r0
 0516 5300              mov [__r0],A
 0518 5A00              mov [__r1],X
 051A 20                pop X
 051B 5100              mov A,[__r1]
 051D 5401              mov [X+1],A
 051F 5100              mov A,[__r0]
 0521 5400              mov [X+0],A
 0523 3C0000            cmp [__r0],0
 0526 B006              jnz X25
 0528 3C0000            cmp [__r1],0
 052B A464              jz L98
 052D           X25:
 052D                   .dbline 388
 052D           ;                       {
 052D                   .dbline 389
 052D           ;                               ID = atoi(param);
 052D 5200              mov A,[X+0]
 052F 08                push A
 0530 5201              mov A,[X+1]
 0532 08                push A
 0533 7C0000            xcall _atoi
 0536 38FE              add SP,-2
 0538 62D000            mov REG[0xd0],>__r0
 053B 5100              mov A,[__r1]
 053D 5404              mov [X+4],A
 053F                   .dbline 390
 053F           ;                               if(param = COMP_SERIAL_szGetParam())
 053F 10                push X
 0540 7C0000            xcall _COMP_SERIAL_szGetParam
 0543 62D000            mov REG[0xd0],>__r0
 0546 5300              mov [__r0],A
 0548 5A00              mov [__r1],X
 054A 20                pop X
 054B 5100              mov A,[__r1]
 054D 5401              mov [X+1],A
 054F 5100              mov A,[__r0]
 0551 5400              mov [X+0],A
 0553 3C0000            cmp [__r0],0
 0556 B006              jnz X26
 0558 3C0000            cmp [__r1],0
 055B A434              jz L98
 055D           X26:
 055D                   .dbline 391
 055D           ;                               {
 055D                   .dbline 392
 055D           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 055D 62D000            mov REG[0xd0],>__r0
 0560 5201              mov A,[X+1]
 0562 5300              mov [__r1],A
 0564 5200              mov A,[X+0]
 0566 60D4              mov REG[0xd4],A
 0568 3E00              mvi A,[__r1]
 056A 5300              mov [__r1],A
 056C 550000            mov [__r0],0
 056F 3C0000            cmp [__r0],0
 0572 B005              jnz X27
 0574 3961              cmp A,97
 0576 A00E              jz L106
 0578           X27:
 0578 62D000            mov REG[0xd0],>__r0
 057B 3C0000            cmp [__r0],0
 057E B089              jnz L104
 0580 3C0041            cmp [__r1],65
 0583 B084              jnz L104
 0585           X28:
 0585           L106:
 0585                   .dbline 393
 0585           ;                                       {
 0585                   .dbline 394
 0585           ;                                               if(param = COMP_SERIAL_szGetParam())
 0585 10                push X
 0586 7C0000            xcall _COMP_SERIAL_szGetParam
 0589 62D000            mov REG[0xd0],>__r0
 058C 5300              mov [__r0],A
 058E 5A00              mov [__r1],X
 0590 20                pop X
 0591 5100              mov A,[__r1]
 0593 5401              mov [X+1],A
 0595 5100              mov A,[__r0]
 0597 5400              mov [X+0],A
 0599 3C0000            cmp [__r0],0
 059C B006              jnz X29
 059E 3C0000            cmp [__r1],0
 05A1 A3EE              jz L98
 05A3           X29:
 05A3                   .dbline 395
 05A3           ;                                               {
 05A3                   .dbline 396
 05A3           ;                                                       COMP_SERIAL_CmdReset();
 05A3 10                push X
 05A4 7C0000            xcall _COMP_SERIAL_CmdReset
 05A7 20                pop X
 05A8                   .dbline 397
 05A8           ;                                                       total = atoi(param);
 05A8 5200              mov A,[X+0]
 05AA 08                push A
 05AB 5201              mov A,[X+1]
 05AD 08                push A
 05AE 7C0000            xcall _atoi
 05B1 38FE              add SP,-2
 05B3 62D000            mov REG[0xd0],>__r0
 05B6 5100              mov A,[__r1]
 05B8 5403              mov [X+3],A
 05BA 5100              mov A,[__r0]
 05BC 5402              mov [X+2],A
 05BE                   .dbline 398
 05BE           ;                                                       angle[0] = total%256;
 05BE 5001              mov A,1
 05C0 08                push A
 05C1 5000              mov A,0
 05C3 08                push A
 05C4 5202              mov A,[X+2]
 05C6 08                push A
 05C7 5203              mov A,[X+3]
 05C9 08                push A
 05CA 7C0000            xcall __divmod_16X16_16
 05CD 38FE              add SP,-2
 05CF 18                pop A
 05D0 5300              mov [__r1],A
 05D2 18                pop A
 05D3 5100              mov A,[__r1]
 05D5 5405              mov [X+5],A
 05D7                   .dbline 399
 05D7           ;                                                       angle[1] = total/256;
 05D7 5001              mov A,1
 05D9 08                push A
 05DA 5000              mov A,0
 05DC 08                push A
 05DD 5202              mov A,[X+2]
 05DF 08                push A
 05E0 5203              mov A,[X+3]
 05E2 08                push A
 05E3 7C0000            xcall __divmod_16X16_16
 05E6 18                pop A
 05E7 5300              mov [__r1],A
 05E9 18                pop A
 05EA 38FE              add SP,-2
 05EC 5100              mov A,[__r1]
 05EE 5406              mov [X+6],A
 05F0                   .dbline 400
 05F0           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 05F0 5206              mov A,[X+6]
 05F2 08                push A
 05F3 5205              mov A,[X+5]
 05F5 08                push A
 05F6 501E              mov A,30
 05F8 08                push A
 05F9 5003              mov A,3
 05FB 08                push A
 05FC 5005              mov A,5
 05FE 08                push A
 05FF 5204              mov A,[X+4]
 0601 08                push A
 0602 9455              xcall _longServoInstruction
 0604 38FA              add SP,-6
 0606                   .dbline 401
 0606           ;                                               }
 0606                   .dbline 402
 0606           ;                                       }
 0606 8389              xjmp L98
 0608           L104:
 0608                   .dbline 403
 0608           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 0608 62D000            mov REG[0xd0],>__r0
 060B 5201              mov A,[X+1]
 060D 5300              mov [__r1],A
 060F 5200              mov A,[X+0]
 0611 60D4              mov REG[0xd4],A
 0613 3E00              mvi A,[__r1]
 0615 5300              mov [__r1],A
 0617 550000            mov [__r0],0
 061A 3C0000            cmp [__r0],0
 061D B005              jnz X30
 061F 3970              cmp A,112
 0621 A00E              jz L113
 0623           X30:
 0623 62D000            mov REG[0xd0],>__r0
 0626 3C0000            cmp [__r0],0
 0629 B366              jnz L98
 062B 3C0050            cmp [__r1],80
 062E B361              jnz L98
 0630           X31:
 0630           L113:
 0630                   .dbline 404
 0630           ;                                       {
 0630                   .dbline 405
 0630           ;                                               if(param = COMP_SERIAL_szGetParam())
 0630 10                push X
 0631 7C0000            xcall _COMP_SERIAL_szGetParam
 0634 62D000            mov REG[0xd0],>__r0
 0637 5300              mov [__r0],A
 0639 5A00              mov [__r1],X
 063B 20                pop X
 063C 5100              mov A,[__r1]
 063E 5401              mov [X+1],A
 0640 5100              mov A,[__r0]
 0642 5400              mov [X+0],A
 0644 3C0000            cmp [__r0],0
 0647 B006              jnz X32
 0649 3C0000            cmp [__r1],0
 064C A343              jz L98
 064E           X32:
 064E                   .dbline 406
 064E           ;                                               {
 064E                   .dbline 407
 064E           ;                                                       COMP_SERIAL_CmdReset();
 064E 10                push X
 064F 7C0000            xcall _COMP_SERIAL_CmdReset
 0652 20                pop X
 0653                   .dbline 408
 0653           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 0653 5200              mov A,[X+0]
 0655 08                push A
 0656 5201              mov A,[X+1]
 0658 08                push A
 0659 7C0000            xcall _atoi
 065C 62D000            mov REG[0xd0],>__r0
 065F 5100              mov A,[__r1]
 0661 08                push A
 0662 5018              mov A,24
 0664 08                push A
 0665 5003              mov A,3
 0667 08                push A
 0668 5004              mov A,4
 066A 08                push A
 066B 5204              mov A,[X+4]
 066D 08                push A
 066E 9346              xcall _servoInstruction
 0670 38F9              add SP,-7
 0672                   .dbline 409
 0672           ;                                               }
 0672                   .dbline 410
 0672           ;                                       }
 0672                   .dbline 411
 0672           ;                               }
 0672                   .dbline 412
 0672           ;                       }
 0672                   .dbline 413
 0672           ;               }
 0672 831D              xjmp L98
 0674           L97:
 0674                   .dbline 414
 0674           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 0674 62D000            mov REG[0xd0],>__r0
 0677 5201              mov A,[X+1]
 0679 5300              mov [__r1],A
 067B 5200              mov A,[X+0]
 067D 60D4              mov REG[0xd4],A
 067F 3E00              mvi A,[__r1]
 0681 5300              mov [__r1],A
 0683 550000            mov [__r0],0
 0686 3C0000            cmp [__r0],0
 0689 B005              jnz X33
 068B 3972              cmp A,114
 068D A00E              jz L118
 068F           X33:
 068F 62D000            mov REG[0xd0],>__r0
 0692 3C0000            cmp [__r0],0
 0695 B2FA              jnz L116
 0697 3C0052            cmp [__r1],82
 069A B2F5              jnz L116
 069C           X34:
 069C           L118:
 069C                   .dbline 415
 069C           ;               {                       
 069C                   .dbline 416
 069C           ;                       if(param = COMP_SERIAL_szGetParam())
 069C 10                push X
 069D 7C0000            xcall _COMP_SERIAL_szGetParam
 06A0 62D000            mov REG[0xd0],>__r0
 06A3 5300              mov [__r0],A
 06A5 5A00              mov [__r1],X
 06A7 20                pop X
 06A8 5100              mov A,[__r1]
 06AA 5401              mov [X+1],A
 06AC 5100              mov A,[__r0]
 06AE 5400              mov [X+0],A
 06B0 3C0000            cmp [__r0],0
 06B3 B006              jnz X35
 06B5 3C0000            cmp [__r1],0
 06B8 A2D7              jz L119
 06BA           X35:
 06BA                   .dbline 417
 06BA           ;                       {
 06BA                   .dbline 418
 06BA           ;                               ID = atoi(param);
 06BA 5200              mov A,[X+0]
 06BC 08                push A
 06BD 5201              mov A,[X+1]
 06BF 08                push A
 06C0 7C0000            xcall _atoi
 06C3 38FE              add SP,-2
 06C5 62D000            mov REG[0xd0],>__r0
 06C8 5100              mov A,[__r1]
 06CA 5404              mov [X+4],A
 06CC                   .dbline 419
 06CC           ;                               if(param = COMP_SERIAL_szGetParam())
 06CC 10                push X
 06CD 7C0000            xcall _COMP_SERIAL_szGetParam
 06D0 62D000            mov REG[0xd0],>__r0
 06D3 5300              mov [__r0],A
 06D5 5A00              mov [__r1],X
 06D7 20                pop X
 06D8 5100              mov A,[__r1]
 06DA 5401              mov [X+1],A
 06DC 5100              mov A,[__r0]
 06DE 5400              mov [X+0],A
 06E0 3C0000            cmp [__r0],0
 06E3 B006              jnz X36
 06E5 3C0000            cmp [__r1],0
 06E8 A2A7              jz L121
 06EA           X36:
 06EA                   .dbline 420
 06EA           ;                               {
 06EA                   .dbline 421
 06EA           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 06EA 62D000            mov REG[0xd0],>__r0
 06ED 5201              mov A,[X+1]
 06EF 5300              mov [__r1],A
 06F1 5200              mov A,[X+0]
 06F3 60D4              mov REG[0xd4],A
 06F5 3E00              mvi A,[__r1]
 06F7 5300              mov [__r1],A
 06F9 550000            mov [__r0],0
 06FC 3C0000            cmp [__r0],0
 06FF B005              jnz X37
 0701 3961              cmp A,97
 0703 A00E              jz L125
 0705           X37:
 0705 62D000            mov REG[0xd0],>__r0
 0708 3C0000            cmp [__r0],0
 070B B0CC              jnz L123
 070D 3C0041            cmp [__r1],65
 0710 B0C7              jnz L123
 0712           X38:
 0712           L125:
 0712                   .dbline 422
 0712           ;                                       {
 0712                   .dbline 423
 0712           ;                                               COMP_SERIAL_CmdReset();
 0712 10                push X
 0713 7C0000            xcall _COMP_SERIAL_CmdReset
 0716 20                pop X
 0717                   .dbline 424
 0717           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 0717 5002              mov A,2
 0719 08                push A
 071A 5024              mov A,36
 071C 08                push A
 071D 5002              mov A,2
 071F 08                push A
 0720 5004              mov A,4
 0722 08                push A
 0723 5204              mov A,[X+4]
 0725 08                push A
 0726 928E              xcall _servoInstruction
 0728                   .dbline 425
 0728           ;                                               configToggle(RX_MODE);
 0728 5000              mov A,0
 072A 08                push A
 072B 5001              mov A,1
 072D 08                push A
 072E 93DA              xcall _configToggle
 0730 38F9              add SP,-7
 0732 8094              xjmp L127
 0734           L126:
 0734                   .dbline 429
 0734           ;                                                       
 0734           ;                                               // Loop until we read a response or time out.
 0734           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0734           ;                                               {
 0734                   .dbline 430
 0734           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 0734 10                push X
 0735 7C0000            xcall _RECEIVE_cReadChar
 0738 62D000            mov REG[0xd0],>__r0
 073B 20                pop X
 073C 39FF              cmp A,-1
 073E B088              jnz L129
 0740                   .dbline 431
 0740           ;                                                       {
 0740                   .dbline 432
 0740           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 0740 10                push X
 0741 7C0000            xcall _RECEIVE_cGetChar
 0744 62D000            mov REG[0xd0],>__r0
 0747 20                pop X
 0748 39FF              cmp A,-1
 074A B07C              jnz L131
 074C                   .dbline 433
 074C           ;                                                               {
 074C                   .dbline 434
 074C           ;                                                                       if(RECEIVE_cGetChar() == ID)
 074C 10                push X
 074D 7C0000            xcall _RECEIVE_cGetChar
 0750 62D000            mov REG[0xd0],>__r0
 0753 20                pop X
 0754 3B04              cmp A,[X+4]
 0756 B070              jnz L133
 0758                   .dbline 435
 0758           ;                                                                       {
 0758                   .dbline 436
 0758           ;                                                                               if(RECEIVE_cGetChar() == 4)
 0758 10                push X
 0759 7C0000            xcall _RECEIVE_cGetChar
 075C 62D000            mov REG[0xd0],>__r0
 075F 20                pop X
 0760 3904              cmp A,4
 0762 B064              jnz L135
 0764                   .dbline 437
 0764           ;                                                                               {
 0764                   .dbline 438
 0764           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 0764 10                push X
 0765 7C0000            xcall _RECEIVE_cGetChar
 0768 62D000            mov REG[0xd0],>__r0
 076B 20                pop X
 076C 3900              cmp A,0
 076E B058              jnz L137
 0770                   .dbline 439
 0770           ;                                                                                       {
 0770                   .dbline 440
 0770           ;                                                                                               angle[0] = RECEIVE_cGetChar();
 0770 10                push X
 0771 7C0000            xcall _RECEIVE_cGetChar
 0774 62D000            mov REG[0xd0],>__r0
 0777 20                pop X
 0778 5405              mov [X+5],A
 077A                   .dbline 441
 077A           ;                                                                                               angle[1] = RECEIVE_cGetChar();
 077A 10                push X
 077B 7C0000            xcall _RECEIVE_cGetChar
 077E 62D000            mov REG[0xd0],>__r0
 0781 20                pop X
 0782 5406              mov [X+6],A
 0784                   .dbline 443
 0784           ;                                                                                               
 0784           ;                                                                                               configToggle(PC_MODE);
 0784 5000              mov A,0
 0786 08                push A
 0787 5002              mov A,2
 0789 08                push A
 078A 937E              xcall _configToggle
 078C                   .dbline 445
 078C           ;                                                                                               
 078C           ;                                                                                               total = ((angle[1])*256) + angle[0];
 078C 5205              mov A,[X+5]
 078E 5403              mov [X+3],A
 0790 5206              mov A,[X+6]
 0792 5402              mov [X+2],A
 0794                   .dbline 446
 0794           ;                                                                                               itoa(param,total,10);
 0794 5000              mov A,0
 0796 08                push A
 0797 500A              mov A,10
 0799 08                push A
 079A 5202              mov A,[X+2]
 079C 08                push A
 079D 5203              mov A,[X+3]
 079F 08                push A
 07A0 5200              mov A,[X+0]
 07A2 08                push A
 07A3 5201              mov A,[X+1]
 07A5 08                push A
 07A6 7C0000            xcall _itoa
 07A9 38F8              add SP,-8
 07AB                   .dbline 447
 07AB           ;                                                                                               COMP_SERIAL_PutString(param);
 07AB 10                push X
 07AC 5200              mov A,[X+0]
 07AE 08                push A
 07AF 5201              mov A,[X+1]
 07B1 5C                mov X,A
 07B2 18                pop A
 07B3 7C0000            xcall _COMP_SERIAL_PutString
 07B6 20                pop X
 07B7                   .dbline 448
 07B7           ;                                                                                               COMP_SERIAL_PutChar('\n');
 07B7 10                push X
 07B8 500A              mov A,10
 07BA 7C0000            xcall _COMP_SERIAL_PutChar
 07BD 20                pop X
 07BE                   .dbline 450
 07BE           ; 
 07BE           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 07BE 62D000            mov REG[0xd0],>_TIMEOUT
 07C1 550105            mov [_TIMEOUT+1],5
 07C4 550000            mov [_TIMEOUT],0
 07C7                   .dbline 451
 07C7           ;                                                                                       }
 07C7           L137:
 07C7                   .dbline 452
 07C7           ;                                                                               }
 07C7           L135:
 07C7                   .dbline 453
 07C7           ;                                                                       }
 07C7           L133:
 07C7                   .dbline 454
 07C7           ;                                                               }
 07C7           L131:
 07C7                   .dbline 455
 07C7           ;                                                       }
 07C7           L129:
 07C7                   .dbline 456
 07C7           ;                                               }
 07C7           L127:
 07C7                   .dbline 428
 07C7 62D000            mov REG[0xd0],>_TIMEOUT
 07CA 5101              mov A,[_TIMEOUT+1]
 07CC 1105              sub A,5
 07CE 5100              mov A,[_TIMEOUT]
 07D0 3180              xor A,-128
 07D2 1980              sbb A,(0 ^ 0x80)
 07D4 CF5F              jc L126
 07D6           X39:
 07D6                   .dbline 457
 07D6           ;                                       }
 07D6 81B9              xjmp L124
 07D8           L123:
 07D8                   .dbline 458
 07D8           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 07D8 62D000            mov REG[0xd0],>__r0
 07DB 5201              mov A,[X+1]
 07DD 5300              mov [__r1],A
 07DF 5200              mov A,[X+0]
 07E1 60D4              mov REG[0xd4],A
 07E3 3E00              mvi A,[__r1]
 07E5 5300              mov [__r1],A
 07E7 550000            mov [__r0],0
 07EA 3C0000            cmp [__r0],0
 07ED B005              jnz X40
 07EF 3970              cmp A,112
 07F1 A00E              jz L143
 07F3           X40:
 07F3 62D000            mov REG[0xd0],>__r0
 07F6 3C0000            cmp [__r0],0
 07F9 B0A5              jnz L141
 07FB 3C0050            cmp [__r1],80
 07FE B0A0              jnz L141
 0800           X41:
 0800           L143:
 0800                   .dbline 459
 0800           ;                                       {
 0800                   .dbline 460
 0800           ;                                               COMP_SERIAL_CmdReset();
 0800 10                push X
 0801 7C0000            xcall _COMP_SERIAL_CmdReset
 0804 20                pop X
 0805                   .dbline 461
 0805           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 0805 5001              mov A,1
 0807 08                push A
 0808 5018              mov A,24
 080A 08                push A
 080B 5002              mov A,2
 080D 08                push A
 080E 5004              mov A,4
 0810 08                push A
 0811 5204              mov A,[X+4]
 0813 08                push A
 0814 91A0              xcall _servoInstruction
 0816                   .dbline 462
 0816           ;                                               configToggle(RX_MODE);
 0816 5000              mov A,0
 0818 08                push A
 0819 5001              mov A,1
 081B 08                push A
 081C 92EC              xcall _configToggle
 081E 38F9              add SP,-7
 0820 806D              xjmp L145
 0822           L144:
 0822                   .dbline 466
 0822           ;                                                       
 0822           ;                                               // Loop until we read a response or time out.
 0822           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0822           ;                                               {
 0822                   .dbline 467
 0822           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 0822 10                push X
 0823 7C0000            xcall _RECEIVE_cReadChar
 0826 62D000            mov REG[0xd0],>__r0
 0829 20                pop X
 082A 39FF              cmp A,-1
 082C B061              jnz L147
 082E                   .dbline 468
 082E           ;                                                       {
 082E                   .dbline 469
 082E           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 082E 10                push X
 082F 7C0000            xcall _RECEIVE_cGetChar
 0832 62D000            mov REG[0xd0],>__r0
 0835 20                pop X
 0836 39FF              cmp A,-1
 0838 B055              jnz L149
 083A                   .dbline 470
 083A           ;                                                               {
 083A                   .dbline 471
 083A           ;                                                                       if(RECEIVE_cGetChar() == ID)
 083A 10                push X
 083B 7C0000            xcall _RECEIVE_cGetChar
 083E 62D000            mov REG[0xd0],>__r0
 0841 20                pop X
 0842 3B04              cmp A,[X+4]
 0844 B049              jnz L151
 0846                   .dbline 472
 0846           ;                                                                       {
 0846                   .dbline 473
 0846           ;                                                                               if(RECEIVE_cGetChar() == 3)
 0846 10                push X
 0847 7C0000            xcall _RECEIVE_cGetChar
 084A 62D000            mov REG[0xd0],>__r0
 084D 20                pop X
 084E 3903              cmp A,3
 0850 B03D              jnz L153
 0852                   .dbline 474
 0852           ;                                                                               {
 0852                   .dbline 475
 0852           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 0852 10                push X
 0853 7C0000            xcall _RECEIVE_cGetChar
 0856 62D000            mov REG[0xd0],>__r0
 0859 20                pop X
 085A 3900              cmp A,0
 085C B031              jnz L155
 085E                   .dbline 476
 085E           ;                                                                                       {
 085E                   .dbline 477
 085E           ;                                                                                               tempByte = RECEIVE_cGetChar();
 085E 10                push X
 085F 7C0000            xcall _RECEIVE_cGetChar
 0862 62D000            mov REG[0xd0],>__r0
 0865 20                pop X
 0866 5407              mov [X+7],A
 0868                   .dbline 479
 0868           ;                                                                                               
 0868           ;                                                                                               configToggle(PC_MODE);
 0868 5000              mov A,0
 086A 08                push A
 086B 5002              mov A,2
 086D 08                push A
 086E 929A              xcall _configToggle
 0870 38FE              add SP,-2
 0872                   .dbline 482
 0872           ;                                                                                               
 0872           ;                                                                                               // Convert tempByte to an ascii value and send.
 0872           ;                                                                                               COMP_SERIAL_PutChar(tempByte + 48);
 0872 62D000            mov REG[0xd0],>__r0
 0875 5207              mov A,[X+7]
 0877 0130              add A,48
 0879 10                push X
 087A 7C0000            xcall _COMP_SERIAL_PutChar
 087D 20                pop X
 087E                   .dbline 483
 087E           ;                                                                                               COMP_SERIAL_PutChar('\n');
 087E 10                push X
 087F 500A              mov A,10
 0881 7C0000            xcall _COMP_SERIAL_PutChar
 0884 20                pop X
 0885                   .dbline 485
 0885           ; 
 0885           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 0885 62D000            mov REG[0xd0],>_TIMEOUT
 0888 550105            mov [_TIMEOUT+1],5
 088B 550000            mov [_TIMEOUT],0
 088E                   .dbline 486
 088E           ;                                                                                       }
 088E           L155:
 088E                   .dbline 487
 088E           ;                                                                               }
 088E           L153:
 088E                   .dbline 488
 088E           ;                                                                       }
 088E           L151:
 088E                   .dbline 489
 088E           ;                                                               }
 088E           L149:
 088E                   .dbline 490
 088E           ;                                                       }
 088E           L147:
 088E                   .dbline 491
 088E           ;                                               }
 088E           L145:
 088E                   .dbline 465
 088E 62D000            mov REG[0xd0],>_TIMEOUT
 0891 5101              mov A,[_TIMEOUT+1]
 0893 1105              sub A,5
 0895 5100              mov A,[_TIMEOUT]
 0897 3180              xor A,-128
 0899 1980              sbb A,(0 ^ 0x80)
 089B CF86              jc L144
 089D           X42:
 089D                   .dbline 492
 089D           ;                                       }
 089D 80F2              xjmp L142
 089F           L141:
 089F                   .dbline 493
 089F           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 089F 62D000            mov REG[0xd0],>__r0
 08A2 5201              mov A,[X+1]
 08A4 5300              mov [__r1],A
 08A6 5200              mov A,[X+0]
 08A8 60D4              mov REG[0xd4],A
 08AA 3E00              mvi A,[__r1]
 08AC 5300              mov [__r1],A
 08AE 550000            mov [__r0],0
 08B1 3C0000            cmp [__r0],0
 08B4 B005              jnz X43
 08B6 3974              cmp A,116
 08B8 A00E              jz L159
 08BA           X43:
 08BA 62D000            mov REG[0xd0],>__r0
 08BD 3C0000            cmp [__r0],0
 08C0 B068              jnz L157
 08C2 3C0054            cmp [__r1],84
 08C5 B063              jnz L157
 08C7           X44:
 08C7           L159:
 08C7                   .dbline 494
 08C7           ;                                       {
 08C7                   .dbline 495
 08C7           ;                                               COMP_SERIAL_CmdReset();
 08C7 10                push X
 08C8 7C0000            xcall _COMP_SERIAL_CmdReset
 08CB 20                pop X
 08CC                   .dbline 496
 08CC           ;                                               if(pingModule(ID))
 08CC 62D000            mov REG[0xd0],>__r0
 08CF 5204              mov A,[X+4]
 08D1 5300              mov [__r1],A
 08D3 5000              mov A,0
 08D5 08                push A
 08D6 5100              mov A,[__r1]
 08D8 08                push A
 08D9 7C003B            xcall _pingModule
 08DC 38FE              add SP,-2
 08DE 62D000            mov REG[0xd0],>__r0
 08E1 3C0000            cmp [__r0],0
 08E4 B006              jnz X45
 08E6 3C0000            cmp [__r1],0
 08E9 A0A6              jz L158
 08EB           X45:
 08EB                   .dbline 497
 08EB           ;                                               {
 08EB                   .dbline 498
 08EB           ;                                                       configToggle(PC_MODE);
 08EB 5000              mov A,0
 08ED 08                push A
 08EE 5002              mov A,2
 08F0 08                push A
 08F1 9217              xcall _configToggle
 08F3                   .dbline 500
 08F3           ;                                                                                               
 08F3           ;                                                       total = PARAM[0];
 08F3 62D000            mov REG[0xd0],>_PARAM
 08F6 5100              mov A,[_PARAM]
 08F8 5403              mov [X+3],A
 08FA 560200            mov [X+2],0
 08FD                   .dbline 501
 08FD           ;                                                       itoa(param,total,10);
 08FD 5000              mov A,0
 08FF 08                push A
 0900 500A              mov A,10
 0902 08                push A
 0903 5202              mov A,[X+2]
 0905 08                push A
 0906 5203              mov A,[X+3]
 0908 08                push A
 0909 5200              mov A,[X+0]
 090B 08                push A
 090C 5201              mov A,[X+1]
 090E 08                push A
 090F 7C0000            xcall _itoa
 0912 38F8              add SP,-8
 0914                   .dbline 502
 0914           ;                                                       COMP_SERIAL_PutString(param);
 0914 10                push X
 0915 5200              mov A,[X+0]
 0917 08                push A
 0918 5201              mov A,[X+1]
 091A 5C                mov X,A
 091B 18                pop A
 091C 7C0000            xcall _COMP_SERIAL_PutString
 091F 20                pop X
 0920                   .dbline 503
 0920           ;                                                       COMP_SERIAL_PutChar('\n');
 0920 10                push X
 0921 500A              mov A,10
 0923 7C0000            xcall _COMP_SERIAL_PutChar
 0926 20                pop X
 0927                   .dbline 504
 0927           ;                                               }
 0927                   .dbline 505
 0927           ;                                       }
 0927 8068              xjmp L158
 0929           L157:
 0929                   .dbline 506
 0929           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 0929 62D000            mov REG[0xd0],>__r0
 092C 5201              mov A,[X+1]
 092E 5300              mov [__r1],A
 0930 5200              mov A,[X+0]
 0932 60D4              mov REG[0xd4],A
 0934 3E00              mvi A,[__r1]
 0936 5300              mov [__r1],A
 0938 550000            mov [__r0],0
 093B 3C0000            cmp [__r0],0
 093E B005              jnz X46
 0940 3963              cmp A,99
 0942 A00E              jz L164
 0944           X46:
 0944 62D000            mov REG[0xd0],>__r0
 0947 3C0000            cmp [__r0],0
 094A B045              jnz L162
 094C 3C0043            cmp [__r1],67
 094F B040              jnz L162
 0951           X47:
 0951           L164:
 0951                   .dbline 507
 0951           ;                                       {
 0951                   .dbline 508
 0951           ;                                               COMP_SERIAL_CmdReset();
 0951 10                push X
 0952 7C0000            xcall _COMP_SERIAL_CmdReset
 0955 20                pop X
 0956                   .dbline 509
 0956           ;                                               if(pingModule(ID))
 0956 62D000            mov REG[0xd0],>__r0
 0959 5204              mov A,[X+4]
 095B 5300              mov [__r1],A
 095D 5000              mov A,0
 095F 08                push A
 0960 5100              mov A,[__r1]
 0962 08                push A
 0963 7C003B            xcall _pingModule
 0966 38FE              add SP,-2
 0968 62D000            mov REG[0xd0],>__r0
 096B 3C0000            cmp [__r0],0
 096E B006              jnz X48
 0970 3C0000            cmp [__r1],0
 0973 A01C              jz L165
 0975           X48:
 0975                   .dbline 510
 0975           ;                                               {       
 0975                   .dbline 511
 0975           ;                                                       configToggle(PC_MODE);
 0975 5000              mov A,0
 0977 08                push A
 0978 5002              mov A,2
 097A 08                push A
 097B 918D              xcall _configToggle
 097D 38FE              add SP,-2
 097F                   .dbline 513
 097F           ;                                                                                               
 097F           ;                                                       COMP_SERIAL_PutChar(PARAM[1]);
 097F 10                push X
 0980 62D000            mov REG[0xd0],>_PARAM
 0983 5101              mov A,[_PARAM+1]
 0985 7C0000            xcall _COMP_SERIAL_PutChar
 0988 20                pop X
 0989                   .dbline 514
 0989           ;                                                       COMP_SERIAL_PutChar('\n');
 0989 10                push X
 098A 500A              mov A,10
 098C 7C0000            xcall _COMP_SERIAL_PutChar
 098F 20                pop X
 0990                   .dbline 515
 0990           ;                                               }
 0990           L165:
 0990                   .dbline 516
 0990           ;                                       }
 0990           L162:
 0990           L158:
 0990           L142:
 0990           L124:
 0990                   .dbline 517
 0990           ;                               }
 0990           L121:
 0990                   .dbline 518
 0990           ;                       }
 0990           L119:
 0990                   .dbline 519
 0990           ;               }
 0990           L116:
 0990           L98:
 0990           L95:
 0990                   .dbline 520
 0990           ;       }
 0990           L92:
 0990                   .dbline 522
 0990           ;       
 0990           ;       if(STATE != PC_MODE)
 0990 62D000            mov REG[0xd0],>_STATE
 0993 3C0000            cmp [_STATE],0
 0996 B006              jnz X49
 0998 3C0102            cmp [_STATE+1],2
 099B A00D              jz L168
 099D           X49:
 099D                   .dbline 523
 099D           ;       {
 099D                   .dbline 524
 099D           ;               configToggle(PC_MODE);
 099D 5000              mov A,0
 099F 08                push A
 09A0 5002              mov A,2
 09A2 08                push A
 09A3 9165              xcall _configToggle
 09A5 38FE              add SP,-2
 09A7                   .dbline 525
 09A7           ;       }
 09A7 800A              xjmp L169
 09A9           L168:
 09A9                   .dbline 527
 09A9           ;       else
 09A9           ;       {
 09A9                   .dbline 528
 09A9           ;               TIMEOUT = 0;
 09A9 62D000            mov REG[0xd0],>_TIMEOUT
 09AC 550100            mov [_TIMEOUT+1],0
 09AF 550000            mov [_TIMEOUT],0
 09B2                   .dbline 529
 09B2           ;       }
 09B2           L169:
 09B2                   .dbline -2
 09B2           L91:
 09B2 38F8              add SP,-8
 09B4 20                pop X
 09B5                   .dbline 0 ; func end
 09B5 7F                ret
 09B6                   .dbsym l tempByte 7 c
 09B6                   .dbsym l angle 5 A[2:2]c
 09B6                   .dbsym l ID 4 c
 09B6                   .dbsym l total 2 I
 09B6                   .dbsym l param 0 pc
 09B6                   .dbend
 09B6                   .dbfunc e servoInstruction _servoInstruction fV
 09B6           ;          total -> X+1
 09B6           ;       checksum -> X+0
 09B6           ;          value -> X-8
 09B6           ;        address -> X-7
 09B6           ;    instruction -> X-6
 09B6           ;         length -> X-5
 09B6           ;             id -> X-4
 09B6           _servoInstruction::
 09B6                   .dbline -1
 09B6 10                push X
 09B7 4F                mov X,SP
 09B8 3803              add SP,3
 09BA                   .dbline 535
 09BA           ; }
 09BA           ; 
 09BA           ; // This function receives a destination, command length, instruction type, address, and value.
 09BA           ; // With these parameters, the function sends a packet to the communication bus.
 09BA           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 09BA           ; {
 09BA                   .dbline 539
 09BA           ;       char checksum;
 09BA           ;       int total;
 09BA           ;       
 09BA           ;       total = id + length + instruction + address + value;
 09BA 62D000            mov REG[0xd0],>__r0
 09BD 52FB              mov A,[X-5]
 09BF 5300              mov [__r1],A
 09C1 550000            mov [__r0],0
 09C4 52FC              mov A,[X-4]
 09C6 0200              add A,[__r1]
 09C8 5300              mov [__r1],A
 09CA 5000              mov A,0
 09CC 0A00              adc A,[__r0]
 09CE 5300              mov [__r0],A
 09D0 52FA              mov A,[X-6]
 09D2 0400              add [__r1],A
 09D4 0E0000            adc [__r0],0
 09D7 52F9              mov A,[X-7]
 09D9 0400              add [__r1],A
 09DB 0E0000            adc [__r0],0
 09DE 52F8              mov A,[X-8]
 09E0 5300              mov [__r3],A
 09E2 550000            mov [__r2],0
 09E5 5100              mov A,[__r1]
 09E7 0200              add A,[__r3]
 09E9 5402              mov [X+2],A
 09EB 5100              mov A,[__r0]
 09ED 0A00              adc A,[__r2]
 09EF 5401              mov [X+1],A
 09F1                   .dbline 542
 09F1           ;       
 09F1           ;       // Calculate the checksum value for our servo communication.
 09F1           ;       checksum = 255-(total%256);
 09F1 5001              mov A,1
 09F3 08                push A
 09F4 5000              mov A,0
 09F6 08                push A
 09F7 5201              mov A,[X+1]
 09F9 08                push A
 09FA 5202              mov A,[X+2]
 09FC 08                push A
 09FD 7C0000            xcall __divmod_16X16_16
 0A00 38FE              add SP,-2
 0A02 18                pop A
 0A03 5300              mov [__r1],A
 0A05 18                pop A
 0A06 50FF              mov A,-1
 0A08 1200              sub A,[__r1]
 0A0A 5400              mov [X+0],A
 0A0C                   .dbline 545
 0A0C           ;       
 0A0C           ;       // Talk to the servo.
 0A0C           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0A0C 10                push X
 0A0D 50FF              mov A,-1
 0A0F 7C0000            xcall _TX_REPEATER_PutChar
 0A12 20                pop X
 0A13                   .dbline 546
 0A13           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0A13 10                push X
 0A14 50FF              mov A,-1
 0A16 7C0000            xcall _TX_REPEATER_PutChar
 0A19 20                pop X
 0A1A                   .dbline 547
 0A1A           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0A1A 10                push X
 0A1B 52FC              mov A,[X-4]
 0A1D 7C0000            xcall _TX_REPEATER_PutChar
 0A20 20                pop X
 0A21                   .dbline 548
 0A21           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0A21 10                push X
 0A22 52FB              mov A,[X-5]
 0A24 7C0000            xcall _TX_REPEATER_PutChar
 0A27 20                pop X
 0A28                   .dbline 549
 0A28           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0A28 10                push X
 0A29 52FA              mov A,[X-6]
 0A2B 7C0000            xcall _TX_REPEATER_PutChar
 0A2E 20                pop X
 0A2F                   .dbline 550
 0A2F           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0A2F 10                push X
 0A30 52F9              mov A,[X-7]
 0A32 7C0000            xcall _TX_REPEATER_PutChar
 0A35 20                pop X
 0A36                   .dbline 551
 0A36           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 0A36 10                push X
 0A37 52F8              mov A,[X-8]
 0A39 7C0000            xcall _TX_REPEATER_PutChar
 0A3C 20                pop X
 0A3D                   .dbline 552
 0A3D           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0A3D 10                push X
 0A3E 5200              mov A,[X+0]
 0A40 7C0000            xcall _TX_REPEATER_PutChar
 0A43 20                pop X
 0A44           L171:
 0A44                   .dbline 555
 0A44           ;       
 0A44           ;       // Wait for the transmission to finish.
 0A44           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0A44           L172:
 0A44                   .dbline 555
 0A44 10                push X
 0A45 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0A48 62D000            mov REG[0xd0],>__r0
 0A4B 20                pop X
 0A4C 5300              mov [__r0],A
 0A4E 470020            tst [__r0],32
 0A51 AFF2              jz L171
 0A53                   .dbline 558
 0A53           ;       
 0A53           ;       // Make completely sure we're done.
 0A53           ;       xmitWait();
 0A53 9375              xcall _xmitWait
 0A55                   .dbline -2
 0A55           L170:
 0A55 38FD              add SP,-3
 0A57 20                pop X
 0A58                   .dbline 0 ; func end
 0A58 7F                ret
 0A59                   .dbsym l total 1 I
 0A59                   .dbsym l checksum 0 c
 0A59                   .dbsym l value -8 c
 0A59                   .dbsym l address -7 c
 0A59                   .dbsym l instruction -6 c
 0A59                   .dbsym l length -5 c
 0A59                   .dbsym l id -4 c
 0A59                   .dbend
 0A59                   .dbfunc e longServoInstruction _longServoInstruction fV
 0A59           ;          total -> X+1
 0A59           ;       checksum -> X+0
 0A59           ;         value2 -> X-9
 0A59           ;         value1 -> X-8
 0A59           ;        address -> X-7
 0A59           ;    instruction -> X-6
 0A59           ;         length -> X-5
 0A59           ;             id -> X-4
 0A59           _longServoInstruction::
 0A59                   .dbline -1
 0A59 10                push X
 0A5A 4F                mov X,SP
 0A5B 3803              add SP,3
 0A5D                   .dbline 563
 0A5D           ; }
 0A5D           ; 
 0A5D           ; // This function receives a destination, command length, instruction type, address, and two values.
 0A5D           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0A5D           ; {
 0A5D                   .dbline 567
 0A5D           ;       char checksum;
 0A5D           ;       int total;
 0A5D           ;       
 0A5D           ;       total = id + length + instruction + address + value1 + value2;
 0A5D 62D000            mov REG[0xd0],>__r0
 0A60 52FB              mov A,[X-5]
 0A62 5300              mov [__r1],A
 0A64 550000            mov [__r0],0
 0A67 52FC              mov A,[X-4]
 0A69 0200              add A,[__r1]
 0A6B 5300              mov [__r1],A
 0A6D 5000              mov A,0
 0A6F 0A00              adc A,[__r0]
 0A71 5300              mov [__r0],A
 0A73 52FA              mov A,[X-6]
 0A75 0400              add [__r1],A
 0A77 0E0000            adc [__r0],0
 0A7A 52F9              mov A,[X-7]
 0A7C 0400              add [__r1],A
 0A7E 0E0000            adc [__r0],0
 0A81 52F8              mov A,[X-8]
 0A83 0400              add [__r1],A
 0A85 0E0000            adc [__r0],0
 0A88 52F7              mov A,[X-9]
 0A8A 5300              mov [__r3],A
 0A8C 550000            mov [__r2],0
 0A8F 5100              mov A,[__r1]
 0A91 0200              add A,[__r3]
 0A93 5402              mov [X+2],A
 0A95 5100              mov A,[__r0]
 0A97 0A00              adc A,[__r2]
 0A99 5401              mov [X+1],A
 0A9B                   .dbline 570
 0A9B           ;       
 0A9B           ;       // Calculate the checksum value for our servo communication.
 0A9B           ;       checksum = 255-(total%256);
 0A9B 5001              mov A,1
 0A9D 08                push A
 0A9E 5000              mov A,0
 0AA0 08                push A
 0AA1 5201              mov A,[X+1]
 0AA3 08                push A
 0AA4 5202              mov A,[X+2]
 0AA6 08                push A
 0AA7 7C0000            xcall __divmod_16X16_16
 0AAA 38FE              add SP,-2
 0AAC 18                pop A
 0AAD 5300              mov [__r1],A
 0AAF 18                pop A
 0AB0 50FF              mov A,-1
 0AB2 1200              sub A,[__r1]
 0AB4 5400              mov [X+0],A
 0AB6                   .dbline 573
 0AB6           ;       
 0AB6           ;       // Talk to the servo.
 0AB6           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0AB6 10                push X
 0AB7 50FF              mov A,-1
 0AB9 7C0000            xcall _TX_REPEATER_PutChar
 0ABC 20                pop X
 0ABD                   .dbline 574
 0ABD           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0ABD 10                push X
 0ABE 50FF              mov A,-1
 0AC0 7C0000            xcall _TX_REPEATER_PutChar
 0AC3 20                pop X
 0AC4                   .dbline 575
 0AC4           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0AC4 10                push X
 0AC5 52FC              mov A,[X-4]
 0AC7 7C0000            xcall _TX_REPEATER_PutChar
 0ACA 20                pop X
 0ACB                   .dbline 576
 0ACB           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0ACB 10                push X
 0ACC 52FB              mov A,[X-5]
 0ACE 7C0000            xcall _TX_REPEATER_PutChar
 0AD1 20                pop X
 0AD2                   .dbline 577
 0AD2           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0AD2 10                push X
 0AD3 52FA              mov A,[X-6]
 0AD5 7C0000            xcall _TX_REPEATER_PutChar
 0AD8 20                pop X
 0AD9                   .dbline 578
 0AD9           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0AD9 10                push X
 0ADA 52F9              mov A,[X-7]
 0ADC 7C0000            xcall _TX_REPEATER_PutChar
 0ADF 20                pop X
 0AE0                   .dbline 579
 0AE0           ;       TX_REPEATER_PutChar(value1);            // The first value to write.
 0AE0 10                push X
 0AE1 52F8              mov A,[X-8]
 0AE3 7C0000            xcall _TX_REPEATER_PutChar
 0AE6 20                pop X
 0AE7                   .dbline 580
 0AE7           ;       TX_REPEATER_PutChar(value2);            // The first value to write.
 0AE7 10                push X
 0AE8 52F7              mov A,[X-9]
 0AEA 7C0000            xcall _TX_REPEATER_PutChar
 0AED 20                pop X
 0AEE                   .dbline 581
 0AEE           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0AEE 10                push X
 0AEF 5200              mov A,[X+0]
 0AF1 7C0000            xcall _TX_REPEATER_PutChar
 0AF4 20                pop X
 0AF5           L175:
 0AF5                   .dbline 584
 0AF5           ;       
 0AF5           ;       // Wait for the transmission to finish.
 0AF5           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0AF5           L176:
 0AF5                   .dbline 584
 0AF5 10                push X
 0AF6 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0AF9 62D000            mov REG[0xd0],>__r0
 0AFC 20                pop X
 0AFD 5300              mov [__r0],A
 0AFF 470020            tst [__r0],32
 0B02 AFF2              jz L175
 0B04                   .dbline 587
 0B04           ;       
 0B04           ;       // Make completely sure we're done.
 0B04           ;       xmitWait();
 0B04 92C4              xcall _xmitWait
 0B06                   .dbline -2
 0B06           L174:
 0B06 38FD              add SP,-3
 0B08 20                pop X
 0B09                   .dbline 0 ; func end
 0B09 7F                ret
 0B0A                   .dbsym l total 1 I
 0B0A                   .dbsym l checksum 0 c
 0B0A                   .dbsym l value2 -9 c
 0B0A                   .dbsym l value1 -8 c
 0B0A                   .dbsym l address -7 c
 0B0A                   .dbsym l instruction -6 c
 0B0A                   .dbsym l length -5 c
 0B0A                   .dbsym l id -4 c
 0B0A                   .dbend
 0B0A                   .dbfunc e configToggle _configToggle fV
 0B0A           ;           mode -> X-5
 0B0A           _configToggle::
 0B0A                   .dbline -1
 0B0A 10                push X
 0B0B 4F                mov X,SP
 0B0C                   .dbline 593
 0B0C           ; }
 0B0C           ; 
 0B0C           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0B0C           ; // half duplex UART serial communication line.
 0B0C           ; void configToggle(int mode)
 0B0C           ; {
 0B0C                   .dbline 595
 0B0C           ;       // Disconnect from the global bus and leave the pin high.
 0B0C           ;       PRT0DR |= 0b10000000;
 0B0C 430080            or REG[0],-128
 0B0F                   .dbline 596
 0B0F           ;       PRT0GS &= 0b01111111;
 0B0F 41027F            and REG[0x2],127
 0B12                   .dbline 600
 0B12           ; 
 0B12           ;       // Unload the configuration of the current state.
 0B12           ;       // If there is no state, blindly wipe all configurations.
 0B12           ;       if(STATE)
 0B12 62D000            mov REG[0xd0],>_STATE
 0B15 3C0000            cmp [_STATE],0
 0B18 B006              jnz X50
 0B1A 3C0100            cmp [_STATE+1],0
 0B1D A010              jz L179
 0B1F           X50:
 0B1F                   .dbline 601
 0B1F           ;       {
 0B1F                   .dbline 602
 0B1F           ;               unloadConfig(STATE);
 0B1F 62D000            mov REG[0xd0],>_STATE
 0B22 5100              mov A,[_STATE]
 0B24 08                push A
 0B25 5101              mov A,[_STATE+1]
 0B27 08                push A
 0B28 90D9              xcall _unloadConfig
 0B2A 38FE              add SP,-2
 0B2C                   .dbline 603
 0B2C           ;       }
 0B2C 8003              xjmp L180
 0B2E           L179:
 0B2E                   .dbline 605
 0B2E           ;       else
 0B2E           ;       {
 0B2E                   .dbline 606
 0B2E           ;               unloadAllConfigs();
 0B2E 90C9              xcall _unloadAllConfigs
 0B30                   .dbline 607
 0B30           ;       }
 0B30           L180:
 0B30                   .dbline 609
 0B30           ;       
 0B30           ;       if(mode == PC_MODE)
 0B30 3DFB00            cmp [X-5],0
 0B33 B032              jnz L181
 0B35 3DFC02            cmp [X-4],2
 0B38 B02D              jnz L181
 0B3A           X51:
 0B3A                   .dbline 610
 0B3A           ;       {
 0B3A                   .dbline 611
 0B3A           ;               LoadConfig_pc_listener();
 0B3A 7C0000            xcall _LoadConfig_pc_listener
 0B3D                   .dbline 614
 0B3D           ;       
 0B3D           ;               //COMP_SERIAL_CmdReset();                                               // Initializes the RX buffer
 0B3D           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 0B3D 10                push X
 0B3E 5001              mov A,1
 0B40 7C0000            xcall _COMP_SERIAL_IntCntl
 0B43 20                pop X
 0B44                   .dbline 615
 0B44           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 0B44 10                push X
 0B45 5000              mov A,0
 0B47 7C0000            xcall _COMP_SERIAL_Start
 0B4A 20                pop X
 0B4B                   .dbline 617
 0B4B           ;               
 0B4B           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0B4B 10                push X
 0B4C 5000              mov A,0
 0B4E 7C0000            xcall _TX_REPEATER_Start
 0B51 20                pop X
 0B52                   .dbline 619
 0B52           ;               
 0B52           ;               TIMEOUT = 0;
 0B52 62D000            mov REG[0xd0],>_TIMEOUT
 0B55 550100            mov [_TIMEOUT+1],0
 0B58 550000            mov [_TIMEOUT],0
 0B5B                   .dbline 620
 0B5B           ;               STATE = PC_MODE;
 0B5B 62D000            mov REG[0xd0],>_STATE
 0B5E 550102            mov [_STATE+1],2
 0B61 550000            mov [_STATE],0
 0B64                   .dbline 621
 0B64           ;       }
 0B64 807A              xjmp L182
 0B66           L181:
 0B66                   .dbline 622
 0B66           ;       else if(mode == RX_MODE)
 0B66 3DFB00            cmp [X-5],0
 0B69 B02C              jnz L183
 0B6B 3DFC01            cmp [X-4],1
 0B6E B027              jnz L183
 0B70           X52:
 0B70                   .dbline 623
 0B70           ;       {
 0B70                   .dbline 624
 0B70           ;               LoadConfig_receiver_config();
 0B70 7C0000            xcall _LoadConfig_receiver_config
 0B73                   .dbline 627
 0B73           ;               
 0B73           ;               // Start the receiver.
 0B73           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0B73 10                push X
 0B74 5000              mov A,0
 0B76 7C0000            xcall _RECEIVE_Start
 0B79 20                pop X
 0B7A                   .dbline 630
 0B7A           ;               
 0B7A           ;               // Start response timeout timer and enable its interrupt routine.
 0B7A           ;               TIMEOUT = 0;
 0B7A 62D000            mov REG[0xd0],>_TIMEOUT
 0B7D 550100            mov [_TIMEOUT+1],0
 0B80 550000            mov [_TIMEOUT],0
 0B83                   .dbline 631
 0B83           ;               RX_TIMEOUT_EnableInt();
 0B83 10                push X
 0B84 7C0000            xcall _RX_TIMEOUT_EnableInt
 0B87                   .dbline 632
 0B87           ;               RX_TIMEOUT_Start();
 0B87 7C0000            xcall _RX_TIMEOUT_Start
 0B8A 20                pop X
 0B8B                   .dbline 634
 0B8B           ;               
 0B8B           ;               STATE = RX_MODE;
 0B8B 62D000            mov REG[0xd0],>_STATE
 0B8E 550101            mov [_STATE+1],1
 0B91 550000            mov [_STATE],0
 0B94                   .dbline 635
 0B94           ;       }
 0B94 804A              xjmp L184
 0B96           L183:
 0B96                   .dbline 636
 0B96           ;       else if(mode == TX_MODE)
 0B96 3DFB00            cmp [X-5],0
 0B99 B045              jnz L185
 0B9B 3DFC00            cmp [X-4],0
 0B9E B040              jnz L185
 0BA0           X53:
 0BA0                   .dbline 637
 0BA0           ;       {
 0BA0                   .dbline 638
 0BA0           ;               LoadConfig_transmitter_config();
 0BA0 7C0000            xcall _LoadConfig_transmitter_config
 0BA3                   .dbline 640
 0BA3           ;               // Start the transmitter.
 0BA3           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 0BA3 10                push X
 0BA4 5000              mov A,0
 0BA6 7C0000            xcall _TRANSMIT_Start
 0BA9 20                pop X
 0BAA                   .dbline 642
 0BAA           ;               
 0BAA           ;               TIMEOUT = 0;
 0BAA 62D000            mov REG[0xd0],>_TIMEOUT
 0BAD 550100            mov [_TIMEOUT+1],0
 0BB0 550000            mov [_TIMEOUT],0
 0BB3                   .dbline 643
 0BB3           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0BB3 10                push X
 0BB4 7C0000            xcall _TX_TIMEOUT_EnableInt
 0BB7                   .dbline 644
 0BB7           ;               TX_TIMEOUT_Start();             // Start the timer.
 0BB7 7C0000            xcall _TX_TIMEOUT_Start
 0BBA 20                pop X
 0BBB           L187:
 0BBB                   .dbline 647
 0BBB           ;               
 0BBB           ;               while(!TIMEOUT)
 0BBB           ;               {
 0BBB                   .dbline 650
 0BBB           ;                       // Do nothing while we wait for one timeout period.
 0BBB           ;                       // This is to allow everyone to get in the right configuration.
 0BBB           ;               }
 0BBB           L188:
 0BBB                   .dbline 646
 0BBB 62D000            mov REG[0xd0],>_TIMEOUT
 0BBE 3C0000            cmp [_TIMEOUT],0
 0BC1 B006              jnz X54
 0BC3 3C0100            cmp [_TIMEOUT+1],0
 0BC6 AFF4              jz L187
 0BC8           X54:
 0BC8                   .dbline 652
 0BC8           ;               
 0BC8           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 0BC8 10                push X
 0BC9 7C0000            xcall _TX_TIMEOUT_Stop
 0BCC 20                pop X
 0BCD                   .dbline 653
 0BCD           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0BCD 62D000            mov REG[0xd0],>_TIMEOUT
 0BD0 550100            mov [_TIMEOUT+1],0
 0BD3 550000            mov [_TIMEOUT],0
 0BD6                   .dbline 655
 0BD6           ;               
 0BD6           ;               STATE = TX_MODE;
 0BD6 62D000            mov REG[0xd0],>_STATE
 0BD9 550100            mov [_STATE+1],0
 0BDC 550000            mov [_STATE],0
 0BDF                   .dbline 656
 0BDF           ;       }
 0BDF           L185:
 0BDF           L184:
 0BDF           L182:
 0BDF                   .dbline 661
 0BDF           ;       
 0BDF           ;       // Make sure to keep the LED on (active low).
 0BDF           ;       //PRT2DR &= 0b11111110;
 0BDF           ;       
 0BDF           ;       if(STATE == TX_MODE)
 0BDF 62D000            mov REG[0xd0],>_STATE
 0BE2 3C0000            cmp [_STATE],0
 0BE5 B00B              jnz L190
 0BE7 3C0100            cmp [_STATE+1],0
 0BEA B006              jnz L190
 0BEC           X55:
 0BEC                   .dbline 662
 0BEC           ;       {
 0BEC                   .dbline 663
 0BEC           ;               PRT1DR |= 0b00000001;
 0BEC 430401            or REG[0x4],1
 0BEF                   .dbline 664
 0BEF           ;       }
 0BEF 8004              xjmp L191
 0BF1           L190:
 0BF1                   .dbline 666
 0BF1           ;       else
 0BF1           ;       {
 0BF1                   .dbline 667
 0BF1           ;               PRT1DR &= 0b11111110;
 0BF1 4104FE            and REG[0x4],-2
 0BF4                   .dbline 669
 0BF4           ;               
 0BF4           ;       }
 0BF4           L191:
 0BF4                   .dbline 672
 0BF4           ;       
 0BF4           ;       // Reconnect to the global bus.
 0BF4           ;       PRT0GS |= 0b10000000;
 0BF4 430280            or REG[0x2],-128
 0BF7                   .dbline -2
 0BF7           L178:
 0BF7 20                pop X
 0BF8                   .dbline 0 ; func end
 0BF8 7F                ret
 0BF9                   .dbsym l mode -5 I
 0BF9                   .dbend
 0BF9                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0BF9           _unloadAllConfigs::
 0BF9                   .dbline -1
 0BF9                   .dbline 681
 0BF9           ;       
 0BF9           ;       // Clear the Watchdog Timer
 0BF9           ;       // M8C_ClearWDT;
 0BF9           ; }
 0BF9           ; 
 0BF9           ; // This function blindly unloads all user configurations. This will be called once,
 0BF9           ; // when the system initially has no known state.
 0BF9           ; void unloadAllConfigs(void)
 0BF9           ; {
 0BF9                   .dbline 682
 0BF9           ;       UnloadConfig_pc_listener();
 0BF9 7C0000            xcall _UnloadConfig_pc_listener
 0BFC                   .dbline 683
 0BFC           ;       UnloadConfig_receiver_config();
 0BFC 7C0000            xcall _UnloadConfig_receiver_config
 0BFF                   .dbline 684
 0BFF           ;       UnloadConfig_transmitter_config();
 0BFF 7C0000            xcall _UnloadConfig_transmitter_config
 0C02                   .dbline -2
 0C02           L192:
 0C02                   .dbline 0 ; func end
 0C02 7F                ret
 0C03                   .dbend
 0C03                   .dbfunc e unloadConfig _unloadConfig fV
 0C03           ;     config_num -> X-5
 0C03           _unloadConfig::
 0C03                   .dbline -1
 0C03 10                push X
 0C04 4F                mov X,SP
 0C05                   .dbline 690
 0C05           ; }
 0C05           ; 
 0C05           ; // This function unloads the configuration corresponding to the config number passed to it.
 0C05           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0C05           ; void unloadConfig(int config_num)
 0C05           ; {
 0C05                   .dbline 691
 0C05           ;       if(config_num == PC_MODE)
 0C05 3DFB00            cmp [X-5],0
 0C08 B00B              jnz L194
 0C0A 3DFC02            cmp [X-4],2
 0C0D B006              jnz L194
 0C0F           X56:
 0C0F                   .dbline 692
 0C0F           ;       {
 0C0F                   .dbline 693
 0C0F           ;               UnloadConfig_pc_listener();
 0C0F 7C0000            xcall _UnloadConfig_pc_listener
 0C12                   .dbline 694
 0C12           ;       }
 0C12 801D              xjmp L195
 0C14           L194:
 0C14                   .dbline 695
 0C14           ;       else if(config_num == RX_MODE)
 0C14 3DFB00            cmp [X-5],0
 0C17 B00B              jnz L196
 0C19 3DFC01            cmp [X-4],1
 0C1C B006              jnz L196
 0C1E           X57:
 0C1E                   .dbline 696
 0C1E           ;       {
 0C1E                   .dbline 697
 0C1E           ;               UnloadConfig_receiver_config();
 0C1E 7C0000            xcall _UnloadConfig_receiver_config
 0C21                   .dbline 698
 0C21           ;       }
 0C21 800E              xjmp L197
 0C23           L196:
 0C23                   .dbline 699
 0C23           ;       else if(config_num == TX_MODE)
 0C23 3DFB00            cmp [X-5],0
 0C26 B009              jnz L198
 0C28 3DFC00            cmp [X-4],0
 0C2B B004              jnz L198
 0C2D           X58:
 0C2D                   .dbline 700
 0C2D           ;       {
 0C2D                   .dbline 701
 0C2D           ;               UnloadConfig_transmitter_config();
 0C2D 7C0000            xcall _UnloadConfig_transmitter_config
 0C30                   .dbline 702
 0C30           ;       }
 0C30           L198:
 0C30           L197:
 0C30           L195:
 0C30                   .dbline -2
 0C30           L193:
 0C30 20                pop X
 0C31                   .dbline 0 ; func end
 0C31 7F                ret
 0C32                   .dbsym l config_num -5 I
 0C32                   .dbend
 0C32                   .dbfunc e busListen _busListen fV
 0C32           _busListen::
 0C32                   .dbline -1
 0C32                   .dbline 706
 0C32           ; }
 0C32           ; 
 0C32           ; void busListen(void)
 0C32           ; {
 0C32                   .dbline 707
 0C32           ;       configToggle(RX_MODE);
 0C32 5000              mov A,0
 0C34 08                push A
 0C35 5001              mov A,1
 0C37 08                push A
 0C38 9ED0              xcall _configToggle
 0C3A 38FE              add SP,-2
 0C3C 8013              xjmp L202
 0C3E           L201:
 0C3E                   .dbline 711
 0C3E           ; 
 0C3E           ;       // Wait for the first byte.
 0C3E           ;       while(TIMEOUT < BOOT_TIMEOUT)
 0C3E           ;       {
 0C3E                   .dbline 715
 0C3E           ;               // Clear the WDT.
 0C3E           ;               // M8C_ClearWDT;
 0C3E           ;               
 0C3E           ;               if(RECEIVE_cGetChar())
 0C3E 10                push X
 0C3F 7C0000            xcall _RECEIVE_cGetChar
 0C42 20                pop X
 0C43 3900              cmp A,0
 0C45 A00A              jz L204
 0C47                   .dbline 716
 0C47           ;               {
 0C47                   .dbline 717
 0C47           ;                       TIMEOUT = BOOT_TIMEOUT;
 0C47 62D000            mov REG[0xd0],>_TIMEOUT
 0C4A 55012C            mov [_TIMEOUT+1],44
 0C4D 550001            mov [_TIMEOUT],1
 0C50                   .dbline 718
 0C50           ;               }
 0C50           L204:
 0C50                   .dbline 719
 0C50           ;       }
 0C50           L202:
 0C50                   .dbline 710
 0C50 62D000            mov REG[0xd0],>_TIMEOUT
 0C53 5101              mov A,[_TIMEOUT+1]
 0C55 112C              sub A,44
 0C57 5100              mov A,[_TIMEOUT]
 0C59 3180              xor A,-128
 0C5B 1981              sbb A,(1 ^ 0x80)
 0C5D CFE0              jc L201
 0C5F           X59:
 0C5F                   .dbline 722
 0C5F           ;       
 0C5F           ;       // Clear the timeout flag.
 0C5F           ;       TIMEOUT = 0;
 0C5F 62D000            mov REG[0xd0],>_TIMEOUT
 0C62 550100            mov [_TIMEOUT+1],0
 0C65 550000            mov [_TIMEOUT],0
 0C68 8013              xjmp L207
 0C6A           L206:
 0C6A                   .dbline 726
 0C6A           ;       
 0C6A           ;       // Wait for BUS_CLEAR_TIME to pass without hearing a byte.
 0C6A           ;       while(TIMEOUT < BUS_CLEAR_TIME)
 0C6A           ;       {
 0C6A                   .dbline 730
 0C6A           ;               // Clear the WDT.
 0C6A           ;               // M8C_ClearWDT;
 0C6A           ;               
 0C6A           ;               if(RECEIVE_cReadChar())
 0C6A 10                push X
 0C6B 7C0000            xcall _RECEIVE_cReadChar
 0C6E 20                pop X
 0C6F 3900              cmp A,0
 0C71 A00A              jz L209
 0C73                   .dbline 731
 0C73           ;               {
 0C73                   .dbline 732
 0C73           ;                       TIMEOUT = 0;    
 0C73 62D000            mov REG[0xd0],>_TIMEOUT
 0C76 550100            mov [_TIMEOUT+1],0
 0C79 550000            mov [_TIMEOUT],0
 0C7C                   .dbline 733
 0C7C           ;               }
 0C7C           L209:
 0C7C                   .dbline 734
 0C7C           ;       }
 0C7C           L207:
 0C7C                   .dbline 725
 0C7C 62D000            mov REG[0xd0],>_TIMEOUT
 0C7F 5101              mov A,[_TIMEOUT+1]
 0C81 1164              sub A,100
 0C83 5100              mov A,[_TIMEOUT]
 0C85 3180              xor A,-128
 0C87 1980              sbb A,(0 ^ 0x80)
 0C89 CFE0              jc L206
 0C8B           X60:
 0C8B                   .dbline -2
 0C8B           L200:
 0C8B                   .dbline 0 ; func end
 0C8B 7F                ret
 0C8C                   .dbend
 0C8C                   .dbfunc e initializeSlaves _initializeSlaves fV
 0C8C           ;   num_timeouts -> X+0
 0C8C           _initializeSlaves::
 0C8C                   .dbline -1
 0C8C 10                push X
 0C8D 4F                mov X,SP
 0C8E 3802              add SP,2
 0C90                   .dbline 738
 0C90           ; }
 0C90           ; 
 0C90           ; void initializeSlaves(void)
 0C90           ; {
 0C90                   .dbline 739
 0C90           ;       int num_timeouts = 0;
 0C90 560100            mov [X+1],0
 0C93 560000            mov [X+0],0
 0C96                   .dbline 742
 0C96           ;       
 0C96           ;       // Set num modules to zero.
 0C96           ;       NUM_MODULES = 0;
 0C96 62D000            mov REG[0xd0],>_NUM_MODULES
 0C99 550100            mov [_NUM_MODULES+1],0
 0C9C 550000            mov [_NUM_MODULES],0
 0C9F                   .dbline 745
 0C9F           ;       
 0C9F           ;       // Block and wait for the bus to be clear.
 0C9F           ;       busListen();
 0C9F 9F91              xcall _busListen
 0CA1                   .dbline 747
 0CA1           ;       
 0CA1           ;       sayHello();
 0CA1 7C0319            xcall _sayHello
 0CA4 810B              xjmp L213
 0CA6           L212:
 0CA6                   .dbline 752
 0CA6           ;       
 0CA6           ;       // This loop continuously probes and listens at intervals
 0CA6           ;       // set by the RX_TIMEOUT_DURATION variable.
 0CA6           ;       while(num_timeouts < MAX_TIMEOUTS)
 0CA6           ;       {
 0CA6                   .dbline 756
 0CA6           ;               // Clear the WDT.
 0CA6           ;               // M8C_ClearWDT;
 0CA6           ;               
 0CA6           ;               if(validTransmission())
 0CA6 7C036F            xcall _validTransmission
 0CA9 62D000            mov REG[0xd0],>__r0
 0CAC 3C0000            cmp [__r0],0
 0CAF B006              jnz X61
 0CB1 3C0000            cmp [__r1],0
 0CB4 A0C8              jz L215
 0CB6           X61:
 0CB6                   .dbline 757
 0CB6           ;               {
 0CB6                   .dbline 758
 0CB6           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0CB6 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0CB9 3C00C8            cmp [_COMMAND_TYPE],-56
 0CBC B0F3              jnz L216
 0CBE                   .dbline 759
 0CBE           ;                       {
 0CBE                   .dbline 761
 0CBE           ;                               // If this is for me, assign them an ID.
 0CBE           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 0CBE 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0CC1 3C0000            cmp [_COMMAND_DESTINATION],0
 0CC4 B0EB              jnz L216
 0CC6                   .dbline 762
 0CC6           ;                               {
 0CC6                   .dbline 763
 0CC6           ;                                       NUM_MODULES++;                  // Increment the number of modules connected.
 0CC6 62D000            mov REG[0xd0],>_NUM_MODULES
 0CC9 7601              inc [_NUM_MODULES+1]
 0CCB 0E0000            adc [_NUM_MODULES],0
 0CCE                   .dbline 764
 0CCE           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0CCE 560100            mov [X+1],0
 0CD1 560000            mov [X+0],0
 0CD4                   .dbline 766
 0CD4           ;               
 0CD4           ;                                       if(!assignID(NUM_MODULES))
 0CD4 5100              mov A,[_NUM_MODULES]
 0CD6 08                push A
 0CD7 5101              mov A,[_NUM_MODULES+1]
 0CD9 08                push A
 0CDA 7C012A            xcall _assignID
 0CDD 38FE              add SP,-2
 0CDF 62D000            mov REG[0xd0],>__r0
 0CE2 3C0000            cmp [__r0],0
 0CE5 B0CA              jnz L216
 0CE7 3C0000            cmp [__r1],0
 0CEA B0C5              jnz L216
 0CEC           X62:
 0CEC                   .dbline 767
 0CEC           ;                                       {
 0CEC                   .dbline 771
 0CEC           ;                                               // If the module did not respond that the ID was assigned,
 0CEC           ;                                               // make an effort to ping it in case that transmission was lost
 0CEC           ;                                               // before ultimately deciding that the module didn't configure.
 0CEC           ;                                               if(!pingModule(NUM_MODULES))
 0CEC 62D000            mov REG[0xd0],>_NUM_MODULES
 0CEF 5100              mov A,[_NUM_MODULES]
 0CF1 08                push A
 0CF2 5101              mov A,[_NUM_MODULES+1]
 0CF4 08                push A
 0CF5 7C003B            xcall _pingModule
 0CF8 38FE              add SP,-2
 0CFA 62D000            mov REG[0xd0],>__r0
 0CFD 3C0000            cmp [__r0],0
 0D00 B0AF              jnz L216
 0D02 3C0000            cmp [__r1],0
 0D05 B0AA              jnz L216
 0D07           X63:
 0D07                   .dbline 772
 0D07           ;                                               {
 0D07                   .dbline 773
 0D07           ;                                                       if(!pingModule(NUM_MODULES))
 0D07 62D000            mov REG[0xd0],>_NUM_MODULES
 0D0A 5100              mov A,[_NUM_MODULES]
 0D0C 08                push A
 0D0D 5101              mov A,[_NUM_MODULES+1]
 0D0F 08                push A
 0D10 7C003B            xcall _pingModule
 0D13 38FE              add SP,-2
 0D15 62D000            mov REG[0xd0],>__r0
 0D18 3C0000            cmp [__r0],0
 0D1B B094              jnz L216
 0D1D 3C0000            cmp [__r1],0
 0D20 B08F              jnz L216
 0D22           X64:
 0D22                   .dbline 774
 0D22           ;                                                       {
 0D22                   .dbline 775
 0D22           ;                                                               if(!pingModule(NUM_MODULES))
 0D22 62D000            mov REG[0xd0],>_NUM_MODULES
 0D25 5100              mov A,[_NUM_MODULES]
 0D27 08                push A
 0D28 5101              mov A,[_NUM_MODULES+1]
 0D2A 08                push A
 0D2B 7C003B            xcall _pingModule
 0D2E 38FE              add SP,-2
 0D30 62D000            mov REG[0xd0],>__r0
 0D33 3C0000            cmp [__r0],0
 0D36 B079              jnz L216
 0D38 3C0000            cmp [__r1],0
 0D3B B074              jnz L216
 0D3D           X65:
 0D3D                   .dbline 776
 0D3D           ;                                                               {
 0D3D                   .dbline 777
 0D3D           ;                                                                       if(!pingModule(NUM_MODULES))
 0D3D 62D000            mov REG[0xd0],>_NUM_MODULES
 0D40 5100              mov A,[_NUM_MODULES]
 0D42 08                push A
 0D43 5101              mov A,[_NUM_MODULES+1]
 0D45 08                push A
 0D46 7C003B            xcall _pingModule
 0D49 38FE              add SP,-2
 0D4B 62D000            mov REG[0xd0],>__r0
 0D4E 3C0000            cmp [__r0],0
 0D51 B05E              jnz L216
 0D53 3C0000            cmp [__r1],0
 0D56 B059              jnz L216
 0D58           X66:
 0D58                   .dbline 778
 0D58           ;                                                                       {
 0D58                   .dbline 779
 0D58           ;                                                                               if(!pingModule(NUM_MODULES))
 0D58 62D000            mov REG[0xd0],>_NUM_MODULES
 0D5B 5100              mov A,[_NUM_MODULES]
 0D5D 08                push A
 0D5E 5101              mov A,[_NUM_MODULES+1]
 0D60 08                push A
 0D61 7C003B            xcall _pingModule
 0D64 38FE              add SP,-2
 0D66 62D000            mov REG[0xd0],>__r0
 0D69 3C0000            cmp [__r0],0
 0D6C B043              jnz L216
 0D6E 3C0000            cmp [__r1],0
 0D71 B03E              jnz L216
 0D73           X67:
 0D73                   .dbline 780
 0D73           ;                                                                               {
 0D73                   .dbline 781
 0D73           ;                                                                                       NUM_MODULES--;
 0D73 62D000            mov REG[0xd0],>_NUM_MODULES
 0D76 7A01              dec [_NUM_MODULES+1]
 0D78 1E0000            sbb [_NUM_MODULES],0
 0D7B                   .dbline 782
 0D7B           ;                                                                               }
 0D7B                   .dbline 783
 0D7B           ;                                                                       }
 0D7B                   .dbline 784
 0D7B           ;                                                               }
 0D7B                   .dbline 785
 0D7B           ;                                                       }
 0D7B                   .dbline 786
 0D7B           ;                                               }
 0D7B                   .dbline 787
 0D7B           ;                                       }
 0D7B                   .dbline 788
 0D7B           ;                               }
 0D7B                   .dbline 789
 0D7B           ;                       }
 0D7B                   .dbline 790
 0D7B           ;               }
 0D7B 8034              xjmp L216
 0D7D           L215:
 0D7D                   .dbline 791
 0D7D           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 0D7D 62D000            mov REG[0xd0],>_TIMEOUT
 0D80 5101              mov A,[_TIMEOUT+1]
 0D82 1105              sub A,5
 0D84 5100              mov A,[_TIMEOUT]
 0D86 3180              xor A,-128
 0D88 1980              sbb A,(0 ^ 0x80)
 0D8A C025              jc L233
 0D8C           X68:
 0D8C                   .dbline 792
 0D8C           ;               {       
 0D8C                   .dbline 794
 0D8C           ;                       // Only count timeouts if we've found at least one module.
 0D8C           ;                       if(NUM_MODULES)
 0D8C 62D000            mov REG[0xd0],>_NUM_MODULES
 0D8F 3C0000            cmp [_NUM_MODULES],0
 0D92 B006              jnz X69
 0D94 3C0100            cmp [_NUM_MODULES+1],0
 0D97 A006              jz L235
 0D99           X69:
 0D99                   .dbline 795
 0D99           ;                       {
 0D99                   .dbline 796
 0D99           ;                               num_timeouts++;
 0D99 7701              inc [X+1]
 0D9B 0F0000            adc [X+0],0
 0D9E                   .dbline 797
 0D9E           ;                       }
 0D9E           L235:
 0D9E                   .dbline 800
 0D9E           ;                       
 0D9E           ;                       // If we are not maxed out on modules, look for more.
 0D9E           ;                       if(NUM_MODULES < MAX_MODULES)
 0D9E 62D000            mov REG[0xd0],>_NUM_MODULES
 0DA1 5101              mov A,[_NUM_MODULES+1]
 0DA3 11FA              sub A,-6
 0DA5 5100              mov A,[_NUM_MODULES]
 0DA7 3180              xor A,-128
 0DA9 1980              sbb A,(0 ^ 0x80)
 0DAB D004              jnc L237
 0DAD           X70:
 0DAD                   .dbline 801
 0DAD           ;                       {
 0DAD                   .dbline 802
 0DAD           ;                               sayHello();
 0DAD 7C0319            xcall _sayHello
 0DB0                   .dbline 803
 0DB0           ;                       }
 0DB0           L237:
 0DB0                   .dbline 804
 0DB0           ;               }
 0DB0           L233:
 0DB0           L216:
 0DB0                   .dbline 805
 0DB0           ;       }
 0DB0           L213:
 0DB0                   .dbline 751
 0DB0 5201              mov A,[X+1]
 0DB2 110A              sub A,10
 0DB4 5200              mov A,[X+0]
 0DB6 3180              xor A,-128
 0DB8 1980              sbb A,(0 ^ 0x80)
 0DBA CEEB              jc L212
 0DBC           X71:
 0DBC                   .dbline 808
 0DBC           ;       
 0DBC           ;       // Switch back to PC mode.
 0DBC           ;       configToggle(PC_MODE);
 0DBC 5000              mov A,0
 0DBE 08                push A
 0DBF 5002              mov A,2
 0DC1 08                push A
 0DC2 9D46              xcall _configToggle
 0DC4 38FE              add SP,-2
 0DC6                   .dbline -2
 0DC6           L211:
 0DC6 38FE              add SP,-2
 0DC8 20                pop X
 0DC9                   .dbline 0 ; func end
 0DC9 7F                ret
 0DCA                   .dbsym l num_timeouts 0 I
 0DCA                   .dbend
 0DCA                   .dbfunc e xmitWait _xmitWait fV
 0DCA           ;              i -> X+0
 0DCA           _xmitWait::
 0DCA                   .dbline -1
 0DCA 10                push X
 0DCB 4F                mov X,SP
 0DCC 3802              add SP,2
 0DCE                   .dbline 812
 0DCE           ; }
 0DCE           ; 
 0DCE           ; void xmitWait(void)
 0DCE           ; {
 0DCE                   .dbline 815
 0DCE           ;       int i;
 0DCE           ;       
 0DCE           ;       for(i = 0; i < 25; i++)
 0DCE 560100            mov [X+1],0
 0DD1 560000            mov [X+0],0
 0DD4           L240:
 0DD4                   .dbline 816
 0DD4           ;       {
 0DD4                   .dbline 818
 0DD4           ;               // Sit here and spin for about 50 microseconds.
 0DD4           ;       }
 0DD4           L241:
 0DD4                   .dbline 815
 0DD4 7701              inc [X+1]
 0DD6 0F0000            adc [X+0],0
 0DD9                   .dbline 815
 0DD9 5201              mov A,[X+1]
 0DDB 1119              sub A,25
 0DDD 5200              mov A,[X+0]
 0DDF 3180              xor A,-128
 0DE1 1980              sbb A,(0 ^ 0x80)
 0DE3 CFF0              jc L240
 0DE5           X72:
 0DE5                   .dbline -2
 0DE5           L239:
 0DE5 38FE              add SP,-2
 0DE7 20                pop X
 0DE8                   .dbline 0 ; func end
 0DE8 7F                ret
 0DE9                   .dbsym l i 0 I
 0DE9                   .dbend
 0DE9                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0DE9           _TX_TIMEOUT_ISR::
 0DE9                   .dbline -1
 0DE9 71C0              or F,-64
 0DEB 08                push A
 0DEC 5DD0              mov A,REG[0xd0]
 0DEE 08                push A
 0DEF                   .dbline 822
 0DEF           ; }
 0DEF           ; 
 0DEF           ; void TX_TIMEOUT_ISR(void)
 0DEF           ; {     
 0DEF                   .dbline 823
 0DEF           ;       TIMEOUT++;
 0DEF 62D000            mov REG[0xd0],>_TIMEOUT
 0DF2 7601              inc [_TIMEOUT+1]
 0DF4 0E0000            adc [_TIMEOUT],0
 0DF7                   .dbline 825
 0DF7           ;       
 0DF7           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0DF7 62DAFD            mov REG[0xda],-3
 0DFA                   .dbline -2
 0DFA           L244:
 0DFA 18                pop A
 0DFB 60D0              mov REG[208],A
 0DFD 18                pop A
 0DFE                   .dbline 0 ; func end
 0DFE 7E                reti
 0DFF                   .dbend
 0DFF                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0DFF           _RX_TIMEOUT_ISR::
 0DFF                   .dbline -1
 0DFF 71C0              or F,-64
 0E01 08                push A
 0E02 5DD0              mov A,REG[0xd0]
 0E04 08                push A
 0E05                   .dbline 829
 0E05           ; }
 0E05           ; 
 0E05           ; void RX_TIMEOUT_ISR(void)
 0E05           ; {     
 0E05                   .dbline 830
 0E05           ;       TIMEOUT++;
 0E05 62D000            mov REG[0xd0],>_TIMEOUT
 0E08 7601              inc [_TIMEOUT+1]
 0E0A 0E0000            adc [_TIMEOUT],0
 0E0D                   .dbline 832
 0E0D           ;       
 0E0D           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0E0D 62DAFD            mov REG[0xda],-3
 0E10                   .dbline -2
 0E10           L245:
 0E10 18                pop A
 0E11 60D0              mov REG[208],A
 0E13 18                pop A
 0E14                   .dbline 0 ; func end
 0E14 7E                reti
 0E15                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
