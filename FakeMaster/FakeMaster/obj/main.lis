 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ;          angle -> X+4
 0000           ;  softwareReset -> X+2
 0000           ;      tempValue -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3808              add SP,8
 0004                   .dbline 97
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>              // part specific constants and macros
 0004           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0004           ; #include "psocdynamic.h"
 0004           ; #include <stdlib.h>
 0004           ; #include <string.h>
 0004           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0004           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0004           ; 
 0004           ; // These defines are used as parameters of the configToggle function.
 0004           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0004           ; #define               PC_MODE                                         (2)
 0004           ; #define               RX_MODE                                         (1)
 0004           ; #define               TX_MODE                                         (0)
 0004           ; 
 0004           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0004           ; #define               PORT_1                                          ('A')
 0004           ; #define               PORT_2                                          ('B')
 0004           ; #define               PORT_3                                          ('C')
 0004           ; #define               PORT_4                                          ('D')
 0004           ; 
 0004           ; // These defines are used as transmission indicators.
 0004           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0004           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0004           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0004           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0004           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0004           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0004           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0004           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0004           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0004           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0004           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0004           ; 
 0004           ; // These defines are used to fill in the instruction we are using on the servo.
 0004           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0004           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0004           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0004           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0004           ; 
 0004           ; // These defines are used for transmission timing.
 0004           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0004           ; 
 0004           ; // These defines are used for the initial probing stage, where receive waits are longer to make
 0004           ; // sure of transmission failure or success.
 0004           ; #define               BOOT_TIMEOUT                            (200)   // This is boot wait time in 1 ms units.
 0004           ; #define               MAX_TIMEOUTS                            (10)    // Number of timeouts allowed before hello mode exit.
 0004           ; 
 0004           ; // This is the maximum number of allowable modules per branch out from the master
 0004           ; #define               MAX_MODULES                                     (250)
 0004           ; 
 0004           ; #define               SERVO_START                                     (255)
 0004           ; 
 0004           ; // This function receives a mode identifier as a parameter and toggles the
 0004           ; // system configuration between receive and transmit modes for half duplex UART.
 0004           ; void configToggle(int mode);
 0004           ; 
 0004           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0004           ; int pingModule(int module_id);
 0004           ; 
 0004           ; // This function assigns an ID to a module.
 0004           ; int assignID(int assigned_ID);
 0004           ; 
 0004           ; int validTransmission(void);
 0004           ; 
 0004           ; void decodeTransmission(void);
 0004           ; 
 0004           ; void sayHello(void);
 0004           ; 
 0004           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0004           ; 
 0004           ; int clearConfig(int module_id);
 0004           ; // This function checks the current mode and unloads the configuration for that mode.
 0004           ; void unloadAllConfigs(void);
 0004           ; // This function unloads the configuration corresponding to the number passed to it.
 0004           ; void unloadConfig(int config_num);
 0004           ; // Initialization function for the slave module controllers.
 0004           ; void initializeSlaves(void);
 0004           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0004           ; void xmitWait(void);
 0004           ; 
 0004           ; // This flag is set if there is a timeout.
 0004           ; int TIMEOUT;
 0004           ; 
 0004           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0004           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0004           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0004           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0004           ; char PARAM;                                   // Stores a parameter that accompanies the command (if any).
 0004           ; 
 0004           ; int STATE;                                    // Stores the current configuration state of the system.
 0004           ; 
 0004           ; void main()
 0004           ; {     
 0004                   .dbline 98
 0004           ;       int tempValue = 0;
 0004 560100            mov [X+1],0
 0007 560000            mov [X+0],0
 000A                   .dbline 99
 000A           ;       int softwareReset = 0;
 000A 560300            mov [X+3],0
 000D 560200            mov [X+2],0
 0010                   .dbline 100
 0010           ;       float angle = 0;
 0010 560400            mov [X+4],0
 0013 560500            mov [X+5],0
 0016 560600            mov [X+6],0
 0019 560700            mov [X+7],0
 001C                   .dbline 102
 001C           ;       
 001C           ;       NUM_MODULES = 0;
 001C 62D000            mov REG[0xd0],>_NUM_MODULES
 001F 550100            mov [_NUM_MODULES+1],0
 0022 550000            mov [_NUM_MODULES],0
 0025                   .dbline 104
 0025           ;       
 0025           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 0025 7101                      or  F, 01h
 0027           
 0027                   .dbline 105
 0027           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); //activate GPIO ISR
 0027 43E020            or REG[0xe0],32
 002A                   .dbline 107
 002A           ;       
 002A           ;       unloadAllConfigs();
 002A 97B7              xcall _unloadAllConfigs
 002C                   .dbline 109
 002C           ;       
 002C           ;       for(tempValue = 0; tempValue < 5; tempValue++)
 002C 560100            mov [X+1],0
 002F 560000            mov [X+0],0
 0032           L2:
 0032                   .dbline 110
 0032           ;       {
 0032                   .dbline 113
 0032           ;               // We test to see if at least one module is set up already.
 0032           ;               // If it is, it means that we had a watchdog reset.
 0032           ;               if(pingModule(1))
 0032 5000              mov A,0
 0034 08                push A
 0035 5001              mov A,1
 0037 08                push A
 0038 9074              xcall _pingModule
 003A 38FE              add SP,-2
 003C 62D000            mov REG[0xd0],>__r0
 003F 3C0000            cmp [__r0],0
 0042 B006              jnz X1
 0044 3C0000            cmp [__r1],0
 0047 A00D              jz L6
 0049           X1:
 0049                   .dbline 114
 0049           ;               {
 0049                   .dbline 115
 0049           ;                       softwareReset = 1;
 0049 560301            mov [X+3],1
 004C 560200            mov [X+2],0
 004F                   .dbline 116
 004F           ;                       tempValue = 5;
 004F 560105            mov [X+1],5
 0052 560000            mov [X+0],0
 0055                   .dbline 117
 0055           ;               }
 0055           L6:
 0055                   .dbline 118
 0055           ;       }
 0055           L3:
 0055                   .dbline 109
 0055 7701              inc [X+1]
 0057 0F0000            adc [X+0],0
 005A                   .dbline 109
 005A 5201              mov A,[X+1]
 005C 1105              sub A,5
 005E 5200              mov A,[X+0]
 0060 3180              xor A,-128
 0062 1980              sbb A,(0 ^ 0x80)
 0064 CFCD              jc L2
 0066           X2:
 0066                   .dbline 122
 0066           ;       
 0066           ;       // If this initialization isn't the result of a hardware reset,
 0066           ;       // do our normal initialization.  Otherwise, start normal operation.
 0066           ;       if(!softwareReset)
 0066 3D0200            cmp [X+2],0
 0069 B023              jnz L8
 006B 3D0300            cmp [X+3],0
 006E B01E              jnz L8
 0070           X3:
 0070                   .dbline 123
 0070           ;       {
 0070                   .dbline 124
 0070           ;               configToggle(RX_MODE);
 0070 5000              mov A,0
 0072 08                push A
 0073 5001              mov A,1
 0075 08                push A
 0076 967C              xcall _configToggle
 0078 38FE              add SP,-2
 007A           L10:
 007A                   .dbline 127
 007A           ;               
 007A           ;               // Sit and wait for the worst case setup time to occur.
 007A           ;               while(TIMEOUT < BOOT_TIMEOUT) { }
 007A                   .dbline 127
 007A           L11:
 007A                   .dbline 127
 007A 62D000            mov REG[0xd0],>_TIMEOUT
 007D 5101              mov A,[_TIMEOUT+1]
 007F 11C8              sub A,-56
 0081 5100              mov A,[_TIMEOUT]
 0083 3180              xor A,-128
 0085 1980              sbb A,(0 ^ 0x80)
 0087 CFF2              jc L10
 0089           X4:
 0089                   .dbline 130
 0089           ;               
 0089           ;               // Initialize all of the slave modules.
 0089           ;               initializeSlaves();
 0089 9791              xcall _initializeSlaves
 008B                   .dbline 131
 008B           ;       }
 008B 801B              xjmp L14
 008D           L8:
 008D                   .dbline 133
 008D           ;       else
 008D           ;       {
 008D                   .dbline 134
 008D           ;               configToggle(PC_MODE);
 008D 5000              mov A,0
 008F 08                push A
 0090 5002              mov A,2
 0092 08                push A
 0093 965F              xcall _configToggle
 0095 38FE              add SP,-2
 0097                   .dbline 135
 0097           ;       }
 0097 800F              xjmp L14
 0099           L13:
 0099                   .dbline 138
 0099           ;       
 0099           ;       while(1)
 0099           ;       {       
 0099                   .dbline 139
 0099           ;               if(COMP_SERIAL_bCmdCheck())
 0099 10                push X
 009A 7C0000            xcall _COMP_SERIAL_bCmdCheck
 009D 62D000            mov REG[0xd0],>__r0
 00A0 20                pop X
 00A1 3900              cmp A,0
 00A3 A003              jz L16
 00A5                   .dbline 140
 00A5           ;               {
 00A5                   .dbline 141
 00A5           ;                       decodeTransmission();
 00A5 93D7              xcall _decodeTransmission
 00A7                   .dbline 142
 00A7           ;               }
 00A7           L16:
 00A7                   .dbline 143
 00A7           ;       }
 00A7           L14:
 00A7                   .dbline 137
 00A7 8FF1              xjmp L13
 00A9           X0:
 00A9                   .dbline -2
 00A9           L1:
 00A9 38F8              add SP,-8
 00AB 20                pop X
 00AC                   .dbline 0 ; func end
 00AC 8FFF              jmp .
 00AE                   .dbsym l angle 4 D
 00AE                   .dbsym l softwareReset 2 I
 00AE                   .dbsym l tempValue 0 I
 00AE                   .dbend
 00AE                   .dbfunc e pingModule _pingModule fI
 00AE           ;       response -> X+0
 00AE           ;      module_id -> X-5
 00AE           _pingModule::
 00AE                   .dbline -1
 00AE 10                push X
 00AF 4F                mov X,SP
 00B0 3802              add SP,2
 00B2                   .dbline 147
 00B2           ; }
 00B2           ; 
 00B2           ; int pingModule(int module_id)
 00B2           ; {
 00B2                   .dbline 148
 00B2           ;       int response = 0;
 00B2 560100            mov [X+1],0
 00B5 560000            mov [X+0],0
 00B8                   .dbline 150
 00B8           ;       
 00B8           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 00B8 5000              mov A,0
 00BA 08                push A
 00BB 08                push A
 00BC 9636              xcall _configToggle
 00BE 38FE              add SP,-2
 00C0                   .dbline 153
 00C0           ;                       
 00C0           ;       // Transmit a hello.
 00C0           ;       TRANSMIT_PutChar(START_TRANSMIT);
 00C0 10                push X
 00C1 50FC              mov A,-4
 00C3 7C0000            xcall _TRANSMIT_PutChar
 00C6 20                pop X
 00C7                   .dbline 154
 00C7           ;       TRANSMIT_PutChar(START_TRANSMIT);
 00C7 10                push X
 00C8 50FC              mov A,-4
 00CA 7C0000            xcall _TRANSMIT_PutChar
 00CD 20                pop X
 00CE                   .dbline 155
 00CE           ;       TRANSMIT_PutChar(MASTER_ID);
 00CE 10                push X
 00CF 5000              mov A,0
 00D1 7C0000            xcall _TRANSMIT_PutChar
 00D4 20                pop X
 00D5                   .dbline 156
 00D5           ;       TRANSMIT_PutChar(module_id);
 00D5 62D000            mov REG[0xd0],>__r0
 00D8 52FC              mov A,[X-4]
 00DA 10                push X
 00DB 7C0000            xcall _TRANSMIT_PutChar
 00DE 20                pop X
 00DF                   .dbline 157
 00DF           ;       TRANSMIT_PutChar(PING);
 00DF 10                push X
 00E0 50CB              mov A,-53
 00E2 7C0000            xcall _TRANSMIT_PutChar
 00E5 20                pop X
 00E6                   .dbline 158
 00E6           ;       TRANSMIT_PutChar(END_TRANSMIT);
 00E6 10                push X
 00E7 50FD              mov A,-3
 00E9 7C0000            xcall _TRANSMIT_PutChar
 00EC 20                pop X
 00ED                   .dbline 159
 00ED           ;       TRANSMIT_PutChar(END_TRANSMIT);
 00ED 10                push X
 00EE 50FD              mov A,-3
 00F0 7C0000            xcall _TRANSMIT_PutChar
 00F3 20                pop X
 00F4           L19:
 00F4                   .dbline 162
 00F4           ;       
 00F4           ;       // Wait for the transmission to finish.
 00F4           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 00F4           L20:
 00F4                   .dbline 162
 00F4 10                push X
 00F5 7C0000            xcall _TRANSMIT_bReadTxStatus
 00F8 62D000            mov REG[0xd0],>__r0
 00FB 20                pop X
 00FC 5300              mov [__r0],A
 00FE 470020            tst [__r0],32
 0101 AFF2              jz L19
 0103                   .dbline 164
 0103           ;       
 0103           ;       xmitWait();
 0103 7C0948            xcall _xmitWait
 0106                   .dbline 166
 0106           ;       
 0106           ;       configToggle(RX_MODE);  // Listen for the response.
 0106 5000              mov A,0
 0108 08                push A
 0109 5001              mov A,1
 010B 08                push A
 010C 95E6              xcall _configToggle
 010E 38FE              add SP,-2
 0110                   .dbline 168
 0110           ;       
 0110           ;       RX_TIMEOUT_Stop();
 0110 10                push X
 0111 7C0000            xcall _RX_TIMEOUT_Stop
 0114 20                pop X
 0115                   .dbline 169
 0115           ;       TIMEOUT = 0;
 0115 62D000            mov REG[0xd0],>_TIMEOUT
 0118 550100            mov [_TIMEOUT+1],0
 011B 550000            mov [_TIMEOUT],0
 011E                   .dbline 170
 011E           ;       RX_TIMEOUT_Start();
 011E 10                push X
 011F 7C0000            xcall _RX_TIMEOUT_Start
 0122 20                pop X
 0123 8048              xjmp L23
 0125           L22:
 0125                   .dbline 173
 0125           ;       
 0125           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 0125           ;       {
 0125                   .dbline 174
 0125           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0125 10                push X
 0126 7C0000            xcall _RECEIVE_cReadChar
 0129 62D000            mov REG[0xd0],>__r0
 012C 20                pop X
 012D 39FC              cmp A,-4
 012F B03C              jnz L25
 0131                   .dbline 175
 0131           ;               {       
 0131                   .dbline 176
 0131           ;                       if(validTransmission())
 0131 92F8              xcall _validTransmission
 0133 62D000            mov REG[0xd0],>__r0
 0136 3C0000            cmp [__r0],0
 0139 B006              jnz X5
 013B 3C0000            cmp [__r1],0
 013E A02D              jz L27
 0140           X5:
 0140                   .dbline 177
 0140           ;                       {
 0140                   .dbline 178
 0140           ;                               if(COMMAND_TYPE == PING)        // This is the response we are looking for.
 0140 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0143 3C00CB            cmp [_COMMAND_TYPE],-53
 0146 B025              jnz L29
 0148                   .dbline 179
 0148           ;                               {
 0148                   .dbline 181
 0148           ;                                       // If this is for me, check who it was from.
 0148           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 0148 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 014B 3C0000            cmp [_COMMAND_DESTINATION],0
 014E B01D              jnz L31
 0150                   .dbline 182
 0150           ;                                       {
 0150                   .dbline 183
 0150           ;                                               if(COMMAND_SOURCE == module_id)
 0150 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0153 5100              mov A,[_COMMAND_SOURCE]
 0155 62D000            mov REG[0xd0],>__r0
 0158 5300              mov [__r1],A
 015A 5000              mov A,0
 015C 3BFB              cmp A,[X-5]
 015E B00D              jnz L33
 0160 5100              mov A,[__r1]
 0162 3BFC              cmp A,[X-4]
 0164 B007              jnz L33
 0166           X6:
 0166                   .dbline 184
 0166           ;                                               {
 0166                   .dbline 185
 0166           ;                                                       response = 1;
 0166 560101            mov [X+1],1
 0169 560000            mov [X+0],0
 016C                   .dbline 186
 016C           ;                                               }
 016C           L33:
 016C                   .dbline 187
 016C           ;                                       }
 016C           L31:
 016C                   .dbline 188
 016C           ;                               }
 016C           L29:
 016C                   .dbline 189
 016C           ;                       }
 016C           L27:
 016C                   .dbline 190
 016C           ;               }
 016C           L25:
 016C                   .dbline 191
 016C           ;       }
 016C           L23:
 016C                   .dbline 172
 016C 62D000            mov REG[0xd0],>_TIMEOUT
 016F 5101              mov A,[_TIMEOUT+1]
 0171 1105              sub A,5
 0173 5100              mov A,[_TIMEOUT]
 0175 3180              xor A,-128
 0177 1980              sbb A,(0 ^ 0x80)
 0179 D00B              jnc L35
 017B           X7:
 017B 3D0000            cmp [X+0],0
 017E B006              jnz X8
 0180 3D0100            cmp [X+1],0
 0183 AFA1              jz L22
 0185           X8:
 0185           L35:
 0185                   .dbline 193
 0185           ;       
 0185           ;       RX_TIMEOUT_Stop();
 0185 10                push X
 0186 7C0000            xcall _RX_TIMEOUT_Stop
 0189 20                pop X
 018A                   .dbline 194
 018A           ;       TIMEOUT = 0;
 018A 62D000            mov REG[0xd0],>_TIMEOUT
 018D 550100            mov [_TIMEOUT+1],0
 0190 550000            mov [_TIMEOUT],0
 0193                   .dbline 195
 0193           ;       RX_TIMEOUT_Start();
 0193 10                push X
 0194 7C0000            xcall _RX_TIMEOUT_Start
 0197 20                pop X
 0198                   .dbline 197
 0198           ;       
 0198           ;       return response;
 0198 62D000            mov REG[0xd0],>__r0
 019B 5201              mov A,[X+1]
 019D 5300              mov [__r1],A
 019F 5200              mov A,[X+0]
 01A1 5300              mov [__r0],A
 01A3                   .dbline -2
 01A3           L18:
 01A3 38FE              add SP,-2
 01A5 20                pop X
 01A6                   .dbline 0 ; func end
 01A6 7F                ret
 01A7                   .dbsym l response 0 I
 01A7                   .dbsym l module_id -5 I
 01A7                   .dbend
 01A7                   .dbfunc e assignID _assignID fI
 01A7           ;        success -> X+0
 01A7           ;    assigned_ID -> X-5
 01A7           _assignID::
 01A7                   .dbline -1
 01A7 10                push X
 01A8 4F                mov X,SP
 01A9 3802              add SP,2
 01AB                   .dbline 201
 01AB           ; }
 01AB           ; 
 01AB           ; int assignID(int assigned_ID)
 01AB           ; {
 01AB                   .dbline 202
 01AB           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 01AB 560100            mov [X+1],0
 01AE 560000            mov [X+0],0
 01B1                   .dbline 204
 01B1           ;       
 01B1           ;       configToggle(TX_MODE);  // Switch to TX mode.
 01B1 5000              mov A,0
 01B3 08                push A
 01B4 08                push A
 01B5 953D              xcall _configToggle
 01B7 38FE              add SP,-2
 01B9                   .dbline 207
 01B9           ; 
 01B9           ;       // Transmit the assignment.
 01B9           ;       TRANSMIT_PutChar(START_TRANSMIT);
 01B9 10                push X
 01BA 50FC              mov A,-4
 01BC 7C0000            xcall _TRANSMIT_PutChar
 01BF 20                pop X
 01C0                   .dbline 208
 01C0           ;       TRANSMIT_PutChar(START_TRANSMIT);
 01C0 10                push X
 01C1 50FC              mov A,-4
 01C3 7C0000            xcall _TRANSMIT_PutChar
 01C6 20                pop X
 01C7                   .dbline 209
 01C7           ;       TRANSMIT_PutChar(MASTER_ID);
 01C7 10                push X
 01C8 5000              mov A,0
 01CA 7C0000            xcall _TRANSMIT_PutChar
 01CD 20                pop X
 01CE                   .dbline 210
 01CE           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 01CE 10                push X
 01CF 50FB              mov A,-5
 01D1 7C0000            xcall _TRANSMIT_PutChar
 01D4 20                pop X
 01D5                   .dbline 211
 01D5           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 01D5 10                push X
 01D6 50C9              mov A,-55
 01D8 7C0000            xcall _TRANSMIT_PutChar
 01DB 20                pop X
 01DC                   .dbline 212
 01DC           ;       TRANSMIT_PutChar(assigned_ID);
 01DC 62D000            mov REG[0xd0],>__r0
 01DF 52FC              mov A,[X-4]
 01E1 10                push X
 01E2 7C0000            xcall _TRANSMIT_PutChar
 01E5 20                pop X
 01E6                   .dbline 213
 01E6           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01E6 10                push X
 01E7 50FD              mov A,-3
 01E9 7C0000            xcall _TRANSMIT_PutChar
 01EC 20                pop X
 01ED                   .dbline 214
 01ED           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01ED 10                push X
 01EE 50FD              mov A,-3
 01F0 7C0000            xcall _TRANSMIT_PutChar
 01F3 20                pop X
 01F4           L37:
 01F4                   .dbline 217
 01F4           ;       
 01F4           ;       // Wait for the transmission to finish.
 01F4           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 01F4           L38:
 01F4                   .dbline 217
 01F4 10                push X
 01F5 7C0000            xcall _TRANSMIT_bReadTxStatus
 01F8 62D000            mov REG[0xd0],>__r0
 01FB 20                pop X
 01FC 5300              mov [__r0],A
 01FE 470020            tst [__r0],32
 0201 AFF2              jz L37
 0203                   .dbline 219
 0203           ;       
 0203           ;       xmitWait();
 0203 9743              xcall _xmitWait
 0205                   .dbline 221
 0205           ;       
 0205           ;       configToggle(RX_MODE);  // Switch back to receive mode.
 0205 5000              mov A,0
 0207 08                push A
 0208 5001              mov A,1
 020A 08                push A
 020B 94E7              xcall _configToggle
 020D 38FE              add SP,-2
 020F                   .dbline 223
 020F           ;       
 020F           ;       RX_TIMEOUT_Stop();
 020F 10                push X
 0210 7C0000            xcall _RX_TIMEOUT_Stop
 0213 20                pop X
 0214                   .dbline 224
 0214           ;       TIMEOUT = 0;
 0214 62D000            mov REG[0xd0],>_TIMEOUT
 0217 550100            mov [_TIMEOUT+1],0
 021A 550000            mov [_TIMEOUT],0
 021D                   .dbline 225
 021D           ;       RX_TIMEOUT_Start();
 021D 10                push X
 021E 7C0000            xcall _RX_TIMEOUT_Start
 0221 20                pop X
 0222 8048              xjmp L41
 0224           L40:
 0224                   .dbline 228
 0224           ;       
 0224           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!success))
 0224           ;       {
 0224                   .dbline 229
 0224           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0224 10                push X
 0225 7C0000            xcall _RECEIVE_cReadChar
 0228 62D000            mov REG[0xd0],>__r0
 022B 20                pop X
 022C 39FC              cmp A,-4
 022E B03C              jnz L43
 0230                   .dbline 230
 0230           ;               {       
 0230                   .dbline 231
 0230           ;                       if(validTransmission())
 0230 91F9              xcall _validTransmission
 0232 62D000            mov REG[0xd0],>__r0
 0235 3C0000            cmp [__r0],0
 0238 B006              jnz X9
 023A 3C0000            cmp [__r1],0
 023D A02D              jz L45
 023F           X9:
 023F                   .dbline 232
 023F           ;                       {
 023F                   .dbline 233
 023F           ;                               if(COMMAND_TYPE == ID_ASSIGN_OK)        // This is the response we are looking for.
 023F 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0242 3C00CA            cmp [_COMMAND_TYPE],-54
 0245 B025              jnz L47
 0247                   .dbline 234
 0247           ;                               {
 0247                   .dbline 236
 0247           ;                                       // If this is for me, check who it was from.
 0247           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 0247 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 024A 3C0000            cmp [_COMMAND_DESTINATION],0
 024D B01D              jnz L49
 024F                   .dbline 237
 024F           ;                                       {
 024F                   .dbline 238
 024F           ;                                               if(COMMAND_SOURCE == assigned_ID)
 024F 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0252 5100              mov A,[_COMMAND_SOURCE]
 0254 62D000            mov REG[0xd0],>__r0
 0257 5300              mov [__r1],A
 0259 5000              mov A,0
 025B 3BFB              cmp A,[X-5]
 025D B00D              jnz L51
 025F 5100              mov A,[__r1]
 0261 3BFC              cmp A,[X-4]
 0263 B007              jnz L51
 0265           X10:
 0265                   .dbline 239
 0265           ;                                               {
 0265                   .dbline 240
 0265           ;                                                       success = 1;
 0265 560101            mov [X+1],1
 0268 560000            mov [X+0],0
 026B                   .dbline 241
 026B           ;                                               }
 026B           L51:
 026B                   .dbline 242
 026B           ;                                       }
 026B           L49:
 026B                   .dbline 243
 026B           ;                               }
 026B           L47:
 026B                   .dbline 244
 026B           ;                       }
 026B           L45:
 026B                   .dbline 245
 026B           ;               }
 026B           L43:
 026B                   .dbline 246
 026B           ;       }
 026B           L41:
 026B                   .dbline 227
 026B 62D000            mov REG[0xd0],>_TIMEOUT
 026E 5101              mov A,[_TIMEOUT+1]
 0270 1105              sub A,5
 0272 5100              mov A,[_TIMEOUT]
 0274 3180              xor A,-128
 0276 1980              sbb A,(0 ^ 0x80)
 0278 D00B              jnc L53
 027A           X11:
 027A 3D0000            cmp [X+0],0
 027D B006              jnz X12
 027F 3D0100            cmp [X+1],0
 0282 AFA1              jz L40
 0284           X12:
 0284           L53:
 0284                   .dbline 248
 0284           ;       
 0284           ;       LCD_1_Start();
 0284 10                push X
 0285 7C0000            xcall _LCD_1_Start
 0288 20                pop X
 0289                   .dbline 249
 0289           ;       LCD_1_Position(0,0);
 0289 10                push X
 028A 5000              mov A,0
 028C 5C                mov X,A
 028D 7C0000            xcall _LCD_1_Position
 0290 20                pop X
 0291                   .dbline 250
 0291           ;       LCD_1_PrHexInt(NUM_MODULES);
 0291 10                push X
 0292 62D000            mov REG[0xd0],>_NUM_MODULES
 0295 5100              mov A,[_NUM_MODULES]
 0297 08                push A
 0298 5101              mov A,[_NUM_MODULES+1]
 029A 20                pop X
 029B 7C0000            xcall _LCD_1_PrHexInt
 029E 20                pop X
 029F                   .dbline 251
 029F           ;       LCD_1_Position(0,5);
 029F 10                push X
 02A0 5705              mov X,5
 02A2 5000              mov A,0
 02A4 7C0000            xcall _LCD_1_Position
 02A7 20                pop X
 02A8                   .dbline 252
 02A8           ;       LCD_1_PrCString("Modules!");
 02A8 10                push X
 02A9 5000              mov A,>L54
 02AB 08                push A
 02AC 5000              mov A,<L54
 02AE 5C                mov X,A
 02AF 18                pop A
 02B0 7C0000            xcall _LCD_1_PrCString
 02B3                   .dbline 254
 02B3           ;       
 02B3           ;       RX_TIMEOUT_Stop();
 02B3 7C0000            xcall _RX_TIMEOUT_Stop
 02B6 20                pop X
 02B7                   .dbline 255
 02B7           ;       TIMEOUT = 0;
 02B7 62D000            mov REG[0xd0],>_TIMEOUT
 02BA 550100            mov [_TIMEOUT+1],0
 02BD 550000            mov [_TIMEOUT],0
 02C0                   .dbline 256
 02C0           ;       RX_TIMEOUT_Start();
 02C0 10                push X
 02C1 7C0000            xcall _RX_TIMEOUT_Start
 02C4 20                pop X
 02C5                   .dbline 258
 02C5           ;       
 02C5           ;       return success;
 02C5 62D000            mov REG[0xd0],>__r0
 02C8 5201              mov A,[X+1]
 02CA 5300              mov [__r1],A
 02CC 5200              mov A,[X+0]
 02CE 5300              mov [__r0],A
 02D0                   .dbline -2
 02D0           L36:
 02D0 38FE              add SP,-2
 02D2 20                pop X
 02D3                   .dbline 0 ; func end
 02D3 7F                ret
 02D4                   .dbsym l success 0 I
 02D4                   .dbsym l assigned_ID -5 I
 02D4                   .dbend
 02D4                   .dbfunc e clearConfig _clearConfig fI
 02D4           ;       response -> X+0
 02D4           ;      module_id -> X-5
 02D4           _clearConfig::
 02D4                   .dbline -1
 02D4 10                push X
 02D5 4F                mov X,SP
 02D6 3802              add SP,2
 02D8                   .dbline 262
 02D8           ; }
 02D8           ; 
 02D8           ; int clearConfig(int module_id)
 02D8           ; {
 02D8                   .dbline 263
 02D8           ;       int response = 0;
 02D8 560100            mov [X+1],0
 02DB 560000            mov [X+0],0
 02DE                   .dbline 265
 02DE           ;       
 02DE           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 02DE 5000              mov A,0
 02E0 08                push A
 02E1 08                push A
 02E2 9410              xcall _configToggle
 02E4 38FE              add SP,-2
 02E6                   .dbline 268
 02E6           ;                       
 02E6           ;       // Transmit a hello.
 02E6           ;       TRANSMIT_PutChar(START_TRANSMIT);
 02E6 10                push X
 02E7 50FC              mov A,-4
 02E9 7C0000            xcall _TRANSMIT_PutChar
 02EC 20                pop X
 02ED                   .dbline 269
 02ED           ;       TRANSMIT_PutChar(START_TRANSMIT);
 02ED 10                push X
 02EE 50FC              mov A,-4
 02F0 7C0000            xcall _TRANSMIT_PutChar
 02F3 20                pop X
 02F4                   .dbline 270
 02F4           ;       TRANSMIT_PutChar(MASTER_ID);
 02F4 10                push X
 02F5 5000              mov A,0
 02F7 7C0000            xcall _TRANSMIT_PutChar
 02FA 20                pop X
 02FB                   .dbline 271
 02FB           ;       TRANSMIT_PutChar(module_id);
 02FB 62D000            mov REG[0xd0],>__r0
 02FE 52FC              mov A,[X-4]
 0300 10                push X
 0301 7C0000            xcall _TRANSMIT_PutChar
 0304 20                pop X
 0305                   .dbline 272
 0305           ;       TRANSMIT_PutChar(CLEAR_CONFIG);
 0305 10                push X
 0306 50CC              mov A,-52
 0308 7C0000            xcall _TRANSMIT_PutChar
 030B 20                pop X
 030C                   .dbline 273
 030C           ;       TRANSMIT_PutChar(END_TRANSMIT);
 030C 10                push X
 030D 50FD              mov A,-3
 030F 7C0000            xcall _TRANSMIT_PutChar
 0312 20                pop X
 0313                   .dbline 274
 0313           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0313 10                push X
 0314 50FD              mov A,-3
 0316 7C0000            xcall _TRANSMIT_PutChar
 0319 20                pop X
 031A           L56:
 031A                   .dbline 277
 031A           ;       
 031A           ;       // Wait for the transmission to finish.
 031A           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 031A           L57:
 031A                   .dbline 277
 031A 10                push X
 031B 7C0000            xcall _TRANSMIT_bReadTxStatus
 031E 62D000            mov REG[0xd0],>__r0
 0321 20                pop X
 0322 5300              mov [__r0],A
 0324 470020            tst [__r0],32
 0327 AFF2              jz L56
 0329                   .dbline 279
 0329           ;       
 0329           ;       xmitWait();
 0329 961D              xcall _xmitWait
 032B                   .dbline 281
 032B           ;       
 032B           ;       configToggle(RX_MODE);  // Listen for the response.
 032B 5000              mov A,0
 032D 08                push A
 032E 5001              mov A,1
 0330 08                push A
 0331 93C1              xcall _configToggle
 0333 38FE              add SP,-2
 0335                   .dbline 283
 0335           ;       
 0335           ;       if(module_id != BROADCAST)
 0335 3DFB00            cmp [X-5],0
 0338 B006              jnz X13
 033A 3DFCFE            cmp [X-4],-2
 033D A089              jz L59
 033F           X13:
 033F                   .dbline 284
 033F           ;       {
 033F                   .dbline 285
 033F           ;               RX_TIMEOUT_Stop();
 033F 10                push X
 0340 7C0000            xcall _RX_TIMEOUT_Stop
 0343 20                pop X
 0344                   .dbline 286
 0344           ;               TIMEOUT = 0;
 0344 62D000            mov REG[0xd0],>_TIMEOUT
 0347 550100            mov [_TIMEOUT+1],0
 034A 550000            mov [_TIMEOUT],0
 034D                   .dbline 287
 034D           ;               RX_TIMEOUT_Start();
 034D 10                push X
 034E 7C0000            xcall _RX_TIMEOUT_Start
 0351 20                pop X
 0352 8048              xjmp L62
 0354           L61:
 0354                   .dbline 290
 0354           ;               
 0354           ;               while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 0354           ;               {
 0354                   .dbline 291
 0354           ;                       if(RECEIVE_cReadChar() == START_TRANSMIT)
 0354 10                push X
 0355 7C0000            xcall _RECEIVE_cReadChar
 0358 62D000            mov REG[0xd0],>__r0
 035B 20                pop X
 035C 39FC              cmp A,-4
 035E B03C              jnz L64
 0360                   .dbline 292
 0360           ;                       {       
 0360                   .dbline 293
 0360           ;                               if(validTransmission())
 0360 90C9              xcall _validTransmission
 0362 62D000            mov REG[0xd0],>__r0
 0365 3C0000            cmp [__r0],0
 0368 B006              jnz X14
 036A 3C0000            cmp [__r1],0
 036D A02D              jz L66
 036F           X14:
 036F                   .dbline 294
 036F           ;                               {
 036F                   .dbline 295
 036F           ;                                       if(COMMAND_TYPE == CONFIG_CLEARED)      // This is the response we are looking for.
 036F 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0372 3C00CD            cmp [_COMMAND_TYPE],-51
 0375 B025              jnz L68
 0377                   .dbline 296
 0377           ;                                       {
 0377                   .dbline 298
 0377           ;                                               // If this is for me, check who it was from.
 0377           ;                                               if(COMMAND_DESTINATION == MASTER_ID)
 0377 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 037A 3C0000            cmp [_COMMAND_DESTINATION],0
 037D B01D              jnz L70
 037F                   .dbline 299
 037F           ;                                               {
 037F                   .dbline 300
 037F           ;                                                       if(COMMAND_SOURCE == module_id)
 037F 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0382 5100              mov A,[_COMMAND_SOURCE]
 0384 62D000            mov REG[0xd0],>__r0
 0387 5300              mov [__r1],A
 0389 5000              mov A,0
 038B 3BFB              cmp A,[X-5]
 038D B00D              jnz L72
 038F 5100              mov A,[__r1]
 0391 3BFC              cmp A,[X-4]
 0393 B007              jnz L72
 0395           X15:
 0395                   .dbline 301
 0395           ;                                                       {
 0395                   .dbline 302
 0395           ;                                                               response = 1;
 0395 560101            mov [X+1],1
 0398 560000            mov [X+0],0
 039B                   .dbline 303
 039B           ;                                                       }
 039B           L72:
 039B                   .dbline 304
 039B           ;                                               }
 039B           L70:
 039B                   .dbline 305
 039B           ;                                       }
 039B           L68:
 039B                   .dbline 306
 039B           ;                               }
 039B           L66:
 039B                   .dbline 307
 039B           ;                       }
 039B           L64:
 039B                   .dbline 308
 039B           ;               }
 039B           L62:
 039B                   .dbline 289
 039B 62D000            mov REG[0xd0],>_TIMEOUT
 039E 5101              mov A,[_TIMEOUT+1]
 03A0 1105              sub A,5
 03A2 5100              mov A,[_TIMEOUT]
 03A4 3180              xor A,-128
 03A6 1980              sbb A,(0 ^ 0x80)
 03A8 D00B              jnc L74
 03AA           X16:
 03AA 3D0000            cmp [X+0],0
 03AD B006              jnz X17
 03AF 3D0100            cmp [X+1],0
 03B2 AFA1              jz L61
 03B4           X17:
 03B4           L74:
 03B4                   .dbline 310
 03B4           ;               
 03B4           ;               RX_TIMEOUT_Stop();
 03B4 10                push X
 03B5 7C0000            xcall _RX_TIMEOUT_Stop
 03B8 20                pop X
 03B9                   .dbline 311
 03B9           ;               TIMEOUT = 0;
 03B9 62D000            mov REG[0xd0],>_TIMEOUT
 03BC 550100            mov [_TIMEOUT+1],0
 03BF 550000            mov [_TIMEOUT],0
 03C2                   .dbline 312
 03C2           ;               RX_TIMEOUT_Start();
 03C2 10                push X
 03C3 7C0000            xcall _RX_TIMEOUT_Start
 03C6 20                pop X
 03C7                   .dbline 313
 03C7           ;       }
 03C7           L59:
 03C7                   .dbline 315
 03C7           ;       
 03C7           ;       return response;
 03C7 62D000            mov REG[0xd0],>__r0
 03CA 5201              mov A,[X+1]
 03CC 5300              mov [__r1],A
 03CE 5200              mov A,[X+0]
 03D0 5300              mov [__r0],A
 03D2                   .dbline -2
 03D2           L55:
 03D2 38FE              add SP,-2
 03D4 20                pop X
 03D5                   .dbline 0 ; func end
 03D5 7F                ret
 03D6                   .dbsym l response 0 I
 03D6                   .dbsym l module_id -5 I
 03D6                   .dbend
 03D6                   .dbfunc e sayHello _sayHello fV
 03D6           _sayHello::
 03D6                   .dbline -1
 03D6                   .dbline 320
 03D6           ; }
 03D6           ; 
 03D6           ; // This function transmits a hello message.
 03D6           ; void sayHello(void)
 03D6           ; {
 03D6                   .dbline 321
 03D6           ;       configToggle(TX_MODE);                          // Toggle into TX mode.
 03D6 5000              mov A,0
 03D8 08                push A
 03D9 08                push A
 03DA 9318              xcall _configToggle
 03DC 38FE              add SP,-2
 03DE                   .dbline 324
 03DE           ;                       
 03DE           ;       // Transmit a hello.
 03DE           ;       TRANSMIT_PutChar(START_TRANSMIT);
 03DE 10                push X
 03DF 50FC              mov A,-4
 03E1 7C0000            xcall _TRANSMIT_PutChar
 03E4 20                pop X
 03E5                   .dbline 325
 03E5           ;       TRANSMIT_PutChar(START_TRANSMIT);
 03E5 10                push X
 03E6 50FC              mov A,-4
 03E8 7C0000            xcall _TRANSMIT_PutChar
 03EB 20                pop X
 03EC                   .dbline 326
 03EC           ;       TRANSMIT_PutChar(MASTER_ID);
 03EC 10                push X
 03ED 5000              mov A,0
 03EF 7C0000            xcall _TRANSMIT_PutChar
 03F2 20                pop X
 03F3                   .dbline 327
 03F3           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 03F3 10                push X
 03F4 50FB              mov A,-5
 03F6 7C0000            xcall _TRANSMIT_PutChar
 03F9 20                pop X
 03FA                   .dbline 328
 03FA           ;       TRANSMIT_PutChar(HELLO_BYTE);
 03FA 10                push X
 03FB 50C8              mov A,-56
 03FD 7C0000            xcall _TRANSMIT_PutChar
 0400 20                pop X
 0401                   .dbline 329
 0401           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0401 10                push X
 0402 50FD              mov A,-3
 0404 7C0000            xcall _TRANSMIT_PutChar
 0407 20                pop X
 0408                   .dbline 330
 0408           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0408 10                push X
 0409 50FD              mov A,-3
 040B 7C0000            xcall _TRANSMIT_PutChar
 040E 20                pop X
 040F           L76:
 040F                   .dbline 333
 040F           ;       
 040F           ;       // Wait for the transmission to finish.
 040F           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 040F           L77:
 040F                   .dbline 333
 040F 10                push X
 0410 7C0000            xcall _TRANSMIT_bReadTxStatus
 0413 62D000            mov REG[0xd0],>__r0
 0416 20                pop X
 0417 5300              mov [__r0],A
 0419 470020            tst [__r0],32
 041C AFF2              jz L76
 041E                   .dbline 335
 041E           ;       
 041E           ;       xmitWait();
 041E 9528              xcall _xmitWait
 0420                   .dbline 337
 0420           ;       
 0420           ;       configToggle(RX_MODE);                          // Listen for the response.
 0420 5000              mov A,0
 0422 08                push A
 0423 5001              mov A,1
 0425 08                push A
 0426 92CC              xcall _configToggle
 0428 38FE              add SP,-2
 042A                   .dbline -2
 042A           L75:
 042A                   .dbline 0 ; func end
 042A 7F                ret
 042B                   .dbend
 042B                   .dbfunc e validTransmission _validTransmission fI
 042B           ; valid_transmit -> X+0
 042B           _validTransmission::
 042B                   .dbline -1
 042B 10                push X
 042C 4F                mov X,SP
 042D 3802              add SP,2
 042F                   .dbline 342
 042F           ; }
 042F           ; 
 042F           ; // This function returns whether or not a valid transmission has been received.
 042F           ; int validTransmission(void)
 042F           ; {
 042F                   .dbline 343
 042F           ;       int valid_transmit = 0;
 042F 560100            mov [X+1],0
 0432 560000            mov [X+0],0
 0435                   .dbline 345
 0435           ;       
 0435           ;       if(RECEIVE_cGetChar() == START_TRANSMIT)
 0435 10                push X
 0436 7C0000            xcall _RECEIVE_cGetChar
 0439 62D000            mov REG[0xd0],>__r0
 043C 20                pop X
 043D 39FC              cmp A,-4
 043F B02F              jnz L80
 0441                   .dbline 346
 0441           ;       {
 0441                   .dbline 347
 0441           ;               COMMAND_SOURCE = RECEIVE_cGetChar();
 0441 10                push X
 0442 7C0000            xcall _RECEIVE_cGetChar
 0445 20                pop X
 0446 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0449 5300              mov [_COMMAND_SOURCE],A
 044B                   .dbline 348
 044B           ;               COMMAND_DESTINATION = RECEIVE_cGetChar();
 044B 10                push X
 044C 7C0000            xcall _RECEIVE_cGetChar
 044F 20                pop X
 0450 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0453 5300              mov [_COMMAND_DESTINATION],A
 0455                   .dbline 349
 0455           ;               COMMAND_TYPE = RECEIVE_cGetChar();
 0455 10                push X
 0456 7C0000            xcall _RECEIVE_cGetChar
 0459 20                pop X
 045A 62D000            mov REG[0xd0],>_COMMAND_TYPE
 045D 5300              mov [_COMMAND_TYPE],A
 045F                   .dbline 350
 045F           ;               PARAM = RECEIVE_cGetChar();
 045F 10                push X
 0460 7C0000            xcall _RECEIVE_cGetChar
 0463 20                pop X
 0464 62D000            mov REG[0xd0],>_PARAM
 0467 5300              mov [_PARAM],A
 0469                   .dbline 352
 0469           ;               
 0469           ;               valid_transmit = 1;
 0469 560101            mov [X+1],1
 046C 560000            mov [X+0],0
 046F                   .dbline 353
 046F           ;       }
 046F           L80:
 046F                   .dbline 355
 046F           ;       
 046F           ;       return valid_transmit;
 046F 62D000            mov REG[0xd0],>__r0
 0472 5201              mov A,[X+1]
 0474 5300              mov [__r1],A
 0476 5200              mov A,[X+0]
 0478 5300              mov [__r0],A
 047A                   .dbline -2
 047A           L79:
 047A 38FE              add SP,-2
 047C 20                pop X
 047D                   .dbline 0 ; func end
 047D 7F                ret
 047E                   .dbsym l valid_transmit 0 I
 047E                   .dbend
 047E                   .dbfunc e decodeTransmission _decodeTransmission fV
 047E           ;       tempByte -> X+7
 047E           ;          angle -> X+5
 047E           ;             ID -> X+4
 047E           ;          total -> X+2
 047E           ;          param -> X+0
 047E           _decodeTransmission::
 047E                   .dbline -1
 047E 10                push X
 047F 4F                mov X,SP
 0480 3808              add SP,8
 0482                   .dbline 360
 0482           ; }
 0482           ; 
 0482           ; // This function decodes the transmission and takes the correct action.
 0482           ; void decodeTransmission(void)
 0482           ; {
 0482                   .dbline 365
 0482           ;       char* param;
 0482           ;       char ID;
 0482           ;       char tempByte;
 0482           ;       char angle[2];
 0482           ;       int total = 0;
 0482 560300            mov [X+3],0
 0485 560200            mov [X+2],0
 0488                   .dbline 367
 0488           ;       
 0488           ;       if(param = COMP_SERIAL_szGetParam())
 0488 10                push X
 0489 7C0000            xcall _COMP_SERIAL_szGetParam
 048C 62D000            mov REG[0xd0],>__r0
 048F 5300              mov [__r0],A
 0491 5A00              mov [__r1],X
 0493 20                pop X
 0494 5100              mov A,[__r1]
 0496 5401              mov [X+1],A
 0498 5100              mov A,[__r0]
 049A 5400              mov [X+0],A
 049C 3C0000            cmp [__r0],0
 049F B006              jnz X18
 04A1 3C0000            cmp [__r1],0
 04A4 A1B4              jz L83
 04A6           X18:
 04A6                   .dbline 368
 04A6           ;       {
 04A6                   .dbline 369
 04A6           ;               if((param[0] == 'w') || (param[0] == 'W'))
 04A6 62D000            mov REG[0xd0],>__r0
 04A9 5201              mov A,[X+1]
 04AB 5300              mov [__r1],A
 04AD 5200              mov A,[X+0]
 04AF 60D4              mov REG[0xd4],A
 04B1 3E00              mvi A,[__r1]
 04B3 5300              mov [__r1],A
 04B5 550000            mov [__r0],0
 04B8 3C0000            cmp [__r0],0
 04BB B005              jnz X19
 04BD 3977              cmp A,119
 04BF A00E              jz L87
 04C1           X19:
 04C1 62D000            mov REG[0xd0],>__r0
 04C4 3C0000            cmp [__r0],0
 04C7 B026              jnz L85
 04C9 3C0057            cmp [__r1],87
 04CC B021              jnz L85
 04CE           X20:
 04CE           L87:
 04CE                   .dbline 370
 04CE           ;               {
 04CE                   .dbline 371
 04CE           ;                       if(param = COMP_SERIAL_szGetParam())
 04CE 10                push X
 04CF 7C0000            xcall _COMP_SERIAL_szGetParam
 04D2 62D000            mov REG[0xd0],>__r0
 04D5 5300              mov [__r0],A
 04D7 5A00              mov [__r1],X
 04D9 20                pop X
 04DA 5100              mov A,[__r1]
 04DC 5401              mov [X+1],A
 04DE 5100              mov A,[__r0]
 04E0 5400              mov [X+0],A
 04E2 3C0000            cmp [__r0],0
 04E5 B006              jnz X21
 04E7 3C0000            cmp [__r1],0
 04EA A16E              jz L86
 04EC           X21:
 04EC                   .dbline 372
 04EC           ;                       {
 04EC                   .dbline 374
 04EC           ;                               
 04EC           ;                       }
 04EC                   .dbline 375
 04EC           ;               }
 04EC 816C              xjmp L86
 04EE           L85:
 04EE                   .dbline 376
 04EE           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 04EE 62D000            mov REG[0xd0],>__r0
 04F1 5201              mov A,[X+1]
 04F3 5300              mov [__r1],A
 04F5 5200              mov A,[X+0]
 04F7 60D4              mov REG[0xd4],A
 04F9 3E00              mvi A,[__r1]
 04FB 5300              mov [__r1],A
 04FD 550000            mov [__r0],0
 0500 3C0000            cmp [__r0],0
 0503 B005              jnz X22
 0505 3972              cmp A,114
 0507 A00E              jz L92
 0509           X22:
 0509 62D000            mov REG[0xd0],>__r0
 050C 3C0000            cmp [__r0],0
 050F B149              jnz L90
 0511 3C0052            cmp [__r1],82
 0514 B144              jnz L90
 0516           X23:
 0516           L92:
 0516                   .dbline 377
 0516           ;               {                       
 0516                   .dbline 378
 0516           ;                       if(param = COMP_SERIAL_szGetParam())
 0516 10                push X
 0517 7C0000            xcall _COMP_SERIAL_szGetParam
 051A 62D000            mov REG[0xd0],>__r0
 051D 5300              mov [__r0],A
 051F 5A00              mov [__r1],X
 0521 20                pop X
 0522 5100              mov A,[__r1]
 0524 5401              mov [X+1],A
 0526 5100              mov A,[__r0]
 0528 5400              mov [X+0],A
 052A 3C0000            cmp [__r0],0
 052D B006              jnz X24
 052F 3C0000            cmp [__r1],0
 0532 A126              jz L93
 0534           X24:
 0534                   .dbline 379
 0534           ;                       {
 0534                   .dbline 380
 0534           ;                               ID = atoi(param);
 0534 5200              mov A,[X+0]
 0536 08                push A
 0537 5201              mov A,[X+1]
 0539 08                push A
 053A 7C0000            xcall _atoi
 053D 38FE              add SP,-2
 053F 62D000            mov REG[0xd0],>__r0
 0542 5100              mov A,[__r1]
 0544 5404              mov [X+4],A
 0546                   .dbline 381
 0546           ;                               if(param = COMP_SERIAL_szGetParam())
 0546 10                push X
 0547 7C0000            xcall _COMP_SERIAL_szGetParam
 054A 62D000            mov REG[0xd0],>__r0
 054D 5300              mov [__r0],A
 054F 5A00              mov [__r1],X
 0551 20                pop X
 0552 5100              mov A,[__r1]
 0554 5401              mov [X+1],A
 0556 5100              mov A,[__r0]
 0558 5400              mov [X+0],A
 055A 3C0000            cmp [__r0],0
 055D B006              jnz X25
 055F 3C0000            cmp [__r1],0
 0562 A0F6              jz L95
 0564           X25:
 0564                   .dbline 382
 0564           ;                               {
 0564                   .dbline 383
 0564           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 0564 62D000            mov REG[0xd0],>__r0
 0567 5201              mov A,[X+1]
 0569 5300              mov [__r1],A
 056B 5200              mov A,[X+0]
 056D 60D4              mov REG[0xd4],A
 056F 3E00              mvi A,[__r1]
 0571 5300              mov [__r1],A
 0573 550000            mov [__r0],0
 0576 3C0000            cmp [__r0],0
 0579 B005              jnz X26
 057B 3961              cmp A,97
 057D A00E              jz L99
 057F           X26:
 057F 62D000            mov REG[0xd0],>__r0
 0582 3C0000            cmp [__r0],0
 0585 B0D3              jnz L97
 0587 3C0041            cmp [__r1],65
 058A B0CE              jnz L97
 058C           X27:
 058C           L99:
 058C                   .dbline 384
 058C           ;                                       {
 058C                   .dbline 385
 058C           ;                                               COMP_SERIAL_CmdReset();
 058C 10                push X
 058D 7C0000            xcall _COMP_SERIAL_CmdReset
 0590 20                pop X
 0591                   .dbline 386
 0591           ;                                               servoInstruction(ID,4,2,36,2);
 0591 5002              mov A,2
 0593 08                push A
 0594 5024              mov A,36
 0596 08                push A
 0597 5002              mov A,2
 0599 08                push A
 059A 5004              mov A,4
 059C 08                push A
 059D 5204              mov A,[X+4]
 059F 08                push A
 05A0 90BB              xcall _servoInstruction
 05A2                   .dbline 387
 05A2           ;                                               configToggle(RX_MODE);
 05A2 5000              mov A,0
 05A4 08                push A
 05A5 5001              mov A,1
 05A7 08                push A
 05A8 914A              xcall _configToggle
 05AA 38F9              add SP,-7
 05AC 8094              xjmp L101
 05AE           L100:
 05AE                   .dbline 391
 05AE           ;                                               
 05AE           ;                                               // Loop until we read a response or time out.
 05AE           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 05AE           ;                                               {                                       
 05AE                   .dbline 392
 05AE           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 05AE 10                push X
 05AF 7C0000            xcall _RECEIVE_cReadChar
 05B2 62D000            mov REG[0xd0],>__r0
 05B5 20                pop X
 05B6 39FF              cmp A,-1
 05B8 B088              jnz L103
 05BA                   .dbline 393
 05BA           ;                                                       {
 05BA                   .dbline 394
 05BA           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 05BA 10                push X
 05BB 7C0000            xcall _RECEIVE_cGetChar
 05BE 62D000            mov REG[0xd0],>__r0
 05C1 20                pop X
 05C2 39FF              cmp A,-1
 05C4 B07C              jnz L105
 05C6                   .dbline 395
 05C6           ;                                                               {
 05C6                   .dbline 396
 05C6           ;                                                                       if(RECEIVE_cGetChar() == ID)
 05C6 10                push X
 05C7 7C0000            xcall _RECEIVE_cGetChar
 05CA 62D000            mov REG[0xd0],>__r0
 05CD 20                pop X
 05CE 3B04              cmp A,[X+4]
 05D0 B070              jnz L107
 05D2                   .dbline 397
 05D2           ;                                                                       {
 05D2                   .dbline 398
 05D2           ;                                                                               if(RECEIVE_cGetChar() == 4)
 05D2 10                push X
 05D3 7C0000            xcall _RECEIVE_cGetChar
 05D6 62D000            mov REG[0xd0],>__r0
 05D9 20                pop X
 05DA 3904              cmp A,4
 05DC B064              jnz L109
 05DE                   .dbline 399
 05DE           ;                                                                               {
 05DE                   .dbline 400
 05DE           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 05DE 10                push X
 05DF 7C0000            xcall _RECEIVE_cGetChar
 05E2 62D000            mov REG[0xd0],>__r0
 05E5 20                pop X
 05E6 3900              cmp A,0
 05E8 B058              jnz L111
 05EA                   .dbline 401
 05EA           ;                                                                                       {
 05EA                   .dbline 402
 05EA           ;                                                                                               angle[0] = RECEIVE_cGetChar();
 05EA 10                push X
 05EB 7C0000            xcall _RECEIVE_cGetChar
 05EE 62D000            mov REG[0xd0],>__r0
 05F1 20                pop X
 05F2 5405              mov [X+5],A
 05F4                   .dbline 403
 05F4           ;                                                                                               angle[1] = RECEIVE_cGetChar();
 05F4 10                push X
 05F5 7C0000            xcall _RECEIVE_cGetChar
 05F8 62D000            mov REG[0xd0],>__r0
 05FB 20                pop X
 05FC 5406              mov [X+6],A
 05FE                   .dbline 405
 05FE           ;                                                                                               
 05FE           ;                                                                                               configToggle(PC_MODE);
 05FE 5000              mov A,0
 0600 08                push A
 0601 5002              mov A,2
 0603 08                push A
 0604 90EE              xcall _configToggle
 0606                   .dbline 407
 0606           ;                                                                                               
 0606           ;                                                                                               total = ((angle[1])*256) + angle[0];
 0606 5205              mov A,[X+5]
 0608 5403              mov [X+3],A
 060A 5206              mov A,[X+6]
 060C 5402              mov [X+2],A
 060E                   .dbline 408
 060E           ;                                                                                               itoa(param,total,10);
 060E 5000              mov A,0
 0610 08                push A
 0611 500A              mov A,10
 0613 08                push A
 0614 5202              mov A,[X+2]
 0616 08                push A
 0617 5203              mov A,[X+3]
 0619 08                push A
 061A 5200              mov A,[X+0]
 061C 08                push A
 061D 5201              mov A,[X+1]
 061F 08                push A
 0620 7C0000            xcall _itoa
 0623 38F8              add SP,-8
 0625                   .dbline 409
 0625           ;                                                                                               COMP_SERIAL_PutString(param);
 0625 10                push X
 0626 5200              mov A,[X+0]
 0628 08                push A
 0629 5201              mov A,[X+1]
 062B 5C                mov X,A
 062C 18                pop A
 062D 7C0000            xcall _COMP_SERIAL_PutString
 0630 20                pop X
 0631                   .dbline 410
 0631           ;                                                                                               COMP_SERIAL_PutChar('\n');
 0631 10                push X
 0632 500A              mov A,10
 0634 7C0000            xcall _COMP_SERIAL_PutChar
 0637 20                pop X
 0638                   .dbline 412
 0638           ; 
 0638           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 0638 62D000            mov REG[0xd0],>_TIMEOUT
 063B 550105            mov [_TIMEOUT+1],5
 063E 550000            mov [_TIMEOUT],0
 0641                   .dbline 413
 0641           ;                                                                                       }
 0641           L111:
 0641                   .dbline 414
 0641           ;                                                                               }
 0641           L109:
 0641                   .dbline 415
 0641           ;                                                                       }
 0641           L107:
 0641                   .dbline 416
 0641           ;                                                               }
 0641           L105:
 0641                   .dbline 417
 0641           ;                                                       }
 0641           L103:
 0641                   .dbline 418
 0641           ;                                               }
 0641           L101:
 0641                   .dbline 390
 0641 62D000            mov REG[0xd0],>_TIMEOUT
 0644 5101              mov A,[_TIMEOUT+1]
 0646 1105              sub A,5
 0648 5100              mov A,[_TIMEOUT]
 064A 3180              xor A,-128
 064C 1980              sbb A,(0 ^ 0x80)
 064E CF5F              jc L100
 0650           X28:
 0650                   .dbline 420
 0650           ;                                               
 0650           ;                                               TIMEOUT = 0;
 0650 62D000            mov REG[0xd0],>_TIMEOUT
 0653 550100            mov [_TIMEOUT+1],0
 0656 550000            mov [_TIMEOUT],0
 0659                   .dbline 421
 0659           ;                                       }
 0659           L97:
 0659                   .dbline 422
 0659           ;                               }
 0659           L95:
 0659                   .dbline 423
 0659           ;                       }
 0659           L93:
 0659                   .dbline 424
 0659           ;               }
 0659           L90:
 0659           L86:
 0659                   .dbline 425
 0659           ;       }
 0659           L83:
 0659                   .dbline -2
 0659           L82:
 0659 38F8              add SP,-8
 065B 20                pop X
 065C                   .dbline 0 ; func end
 065C 7F                ret
 065D                   .dbsym l tempByte 7 c
 065D                   .dbsym l angle 5 A[2:2]c
 065D                   .dbsym l ID 4 c
 065D                   .dbsym l total 2 I
 065D                   .dbsym l param 0 pc
 065D                   .dbend
 065D                   .dbfunc e servoInstruction _servoInstruction fV
 065D           ;       checksum -> X+0
 065D           ;          value -> X-8
 065D           ;        address -> X-7
 065D           ;    instruction -> X-6
 065D           ;         length -> X-5
 065D           ;             id -> X-4
 065D           _servoInstruction::
 065D                   .dbline -1
 065D 10                push X
 065E 4F                mov X,SP
 065F 3801              add SP,1
 0661                   .dbline 431
 0661           ; }
 0661           ; 
 0661           ; // This function receives a destination, command length, instruction type, address, and value.
 0661           ; // With these parameters, the function sends a packet to the communication bus.
 0661           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 0661           ; {
 0661                   .dbline 435
 0661           ;       char checksum;
 0661           ;       
 0661           ;       // Calculate the checksum value for our servo communication.
 0661           ;       checksum = 255-((id + length + instruction + address + value)%256);
 0661 62D000            mov REG[0xd0],>__r0
 0664 52FB              mov A,[X-5]
 0666 5300              mov [__r1],A
 0668 550000            mov [__r0],0
 066B 52FC              mov A,[X-4]
 066D 0200              add A,[__r1]
 066F 5300              mov [__r1],A
 0671 5000              mov A,0
 0673 0A00              adc A,[__r0]
 0675 5300              mov [__r0],A
 0677 52FA              mov A,[X-6]
 0679 0400              add [__r1],A
 067B 0E0000            adc [__r0],0
 067E 52F9              mov A,[X-7]
 0680 0400              add [__r1],A
 0682 0E0000            adc [__r0],0
 0685 52F8              mov A,[X-8]
 0687 0400              add [__r1],A
 0689 0E0000            adc [__r0],0
 068C 5001              mov A,1
 068E 08                push A
 068F 5000              mov A,0
 0691 08                push A
 0692 5100              mov A,[__r0]
 0694 08                push A
 0695 5100              mov A,[__r1]
 0697 08                push A
 0698 7C0000            xcall __divmod_16X16_16
 069B 38FE              add SP,-2
 069D 18                pop A
 069E 5300              mov [__r1],A
 06A0 18                pop A
 06A1 50FF              mov A,-1
 06A3 1200              sub A,[__r1]
 06A5 5400              mov [X+0],A
 06A7                   .dbline 438
 06A7           ;       
 06A7           ;       // Talk to the servo.
 06A7           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 06A7 10                push X
 06A8 50FF              mov A,-1
 06AA 7C0000            xcall _TX_REPEATER_PutChar
 06AD 20                pop X
 06AE                   .dbline 439
 06AE           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 06AE 10                push X
 06AF 50FF              mov A,-1
 06B1 7C0000            xcall _TX_REPEATER_PutChar
 06B4 20                pop X
 06B5                   .dbline 440
 06B5           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 06B5 10                push X
 06B6 52FC              mov A,[X-4]
 06B8 7C0000            xcall _TX_REPEATER_PutChar
 06BB 20                pop X
 06BC                   .dbline 441
 06BC           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 06BC 10                push X
 06BD 52FB              mov A,[X-5]
 06BF 7C0000            xcall _TX_REPEATER_PutChar
 06C2 20                pop X
 06C3                   .dbline 442
 06C3           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 06C3 10                push X
 06C4 52FA              mov A,[X-6]
 06C6 7C0000            xcall _TX_REPEATER_PutChar
 06C9 20                pop X
 06CA                   .dbline 443
 06CA           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 06CA 10                push X
 06CB 52F9              mov A,[X-7]
 06CD 7C0000            xcall _TX_REPEATER_PutChar
 06D0 20                pop X
 06D1                   .dbline 444
 06D1           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 06D1 10                push X
 06D2 52F8              mov A,[X-8]
 06D4 7C0000            xcall _TX_REPEATER_PutChar
 06D7 20                pop X
 06D8                   .dbline 445
 06D8           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 06D8 10                push X
 06D9 5200              mov A,[X+0]
 06DB 7C0000            xcall _TX_REPEATER_PutChar
 06DE 20                pop X
 06DF           L116:
 06DF                   .dbline 448
 06DF           ;       
 06DF           ;       // Wait for the transmission to finish.
 06DF           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 06DF           L117:
 06DF                   .dbline 448
 06DF 10                push X
 06E0 7C0000            xcall _TX_REPEATER_bReadTxStatus
 06E3 62D000            mov REG[0xd0],>__r0
 06E6 20                pop X
 06E7 5300              mov [__r0],A
 06E9 470020            tst [__r0],32
 06EC AFF2              jz L116
 06EE                   .dbline 451
 06EE           ;       
 06EE           ;       // Make completely sure we're done.
 06EE           ;       xmitWait();
 06EE 9258              xcall _xmitWait
 06F0                   .dbline -2
 06F0           L115:
 06F0 38FF              add SP,-1
 06F2 20                pop X
 06F3                   .dbline 0 ; func end
 06F3 7F                ret
 06F4                   .dbsym l checksum 0 c
 06F4                   .dbsym l value -8 c
 06F4                   .dbsym l address -7 c
 06F4                   .dbsym l instruction -6 c
 06F4                   .dbsym l length -5 c
 06F4                   .dbsym l id -4 c
 06F4                   .dbend
 06F4                   .dbfunc e configToggle _configToggle fV
 06F4           ;           mode -> X-5
 06F4           _configToggle::
 06F4                   .dbline -1
 06F4 10                push X
 06F5 4F                mov X,SP
 06F6                   .dbline 457
 06F6           ; }
 06F6           ; 
 06F6           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 06F6           ; // half duplex UART serial communication line.
 06F6           ; void configToggle(int mode)
 06F6           ; {
 06F6                   .dbline 459
 06F6           ;       // Disconnect from the global bus and leave the pin high.
 06F6           ;       PRT0DR |= 0b10000000;
 06F6 430080            or REG[0],-128
 06F9                   .dbline 460
 06F9           ;       PRT0GS &= 0b01111111;
 06F9 41027F            and REG[0x2],127
 06FC                   .dbline 464
 06FC           ; 
 06FC           ;       // Unload the configuration of the current state.
 06FC           ;       // If there is no state, blindly wipe all configurations.
 06FC           ;       if(STATE)
 06FC 62D000            mov REG[0xd0],>_STATE
 06FF 3C0000            cmp [_STATE],0
 0702 B006              jnz X29
 0704 3C0100            cmp [_STATE+1],0
 0707 A010              jz L120
 0709           X29:
 0709                   .dbline 465
 0709           ;       {
 0709                   .dbline 466
 0709           ;               unloadConfig(STATE);
 0709 62D000            mov REG[0xd0],>_STATE
 070C 5100              mov A,[_STATE]
 070E 08                push A
 070F 5101              mov A,[_STATE+1]
 0711 08                push A
 0712 90D9              xcall _unloadConfig
 0714 38FE              add SP,-2
 0716                   .dbline 467
 0716           ;       }
 0716 8003              xjmp L121
 0718           L120:
 0718                   .dbline 469
 0718           ;       else
 0718           ;       {
 0718                   .dbline 470
 0718           ;               unloadAllConfigs();
 0718 90C9              xcall _unloadAllConfigs
 071A                   .dbline 471
 071A           ;       }
 071A           L121:
 071A                   .dbline 473
 071A           ;       
 071A           ;       if(mode == PC_MODE)
 071A 3DFB00            cmp [X-5],0
 071D B032              jnz L122
 071F 3DFC02            cmp [X-4],2
 0722 B02D              jnz L122
 0724           X30:
 0724                   .dbline 474
 0724           ;       {
 0724                   .dbline 475
 0724           ;               LoadConfig_pc_listener();
 0724 7C0000            xcall _LoadConfig_pc_listener
 0727                   .dbline 478
 0727           ;               
 0727           ;               //COMP_SERIAL_CmdReset();                                               // Initializes the RX buffer
 0727           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 0727 10                push X
 0728 5001              mov A,1
 072A 7C0000            xcall _COMP_SERIAL_IntCntl
 072D 20                pop X
 072E                   .dbline 479
 072E           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 072E 10                push X
 072F 5000              mov A,0
 0731 7C0000            xcall _COMP_SERIAL_Start
 0734 20                pop X
 0735                   .dbline 481
 0735           ;               
 0735           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0735 10                push X
 0736 5000              mov A,0
 0738 7C0000            xcall _TX_REPEATER_Start
 073B 20                pop X
 073C                   .dbline 483
 073C           ;               
 073C           ;               TIMEOUT = 0;
 073C 62D000            mov REG[0xd0],>_TIMEOUT
 073F 550100            mov [_TIMEOUT+1],0
 0742 550000            mov [_TIMEOUT],0
 0745                   .dbline 484
 0745           ;               STATE = PC_MODE;
 0745 62D000            mov REG[0xd0],>_STATE
 0748 550102            mov [_STATE+1],2
 074B 550000            mov [_STATE],0
 074E                   .dbline 485
 074E           ;       }
 074E 807A              xjmp L123
 0750           L122:
 0750                   .dbline 486
 0750           ;       else if(mode == RX_MODE)
 0750 3DFB00            cmp [X-5],0
 0753 B02C              jnz L124
 0755 3DFC01            cmp [X-4],1
 0758 B027              jnz L124
 075A           X31:
 075A                   .dbline 487
 075A           ;       {
 075A                   .dbline 488
 075A           ;               LoadConfig_receiver_config();
 075A 7C0000            xcall _LoadConfig_receiver_config
 075D                   .dbline 493
 075D           ;               
 075D           ;               // Clear the buffer.
 075D           ;               //RECEIVE_CmdReset();
 075D           ;               // Start the receiver.
 075D           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 075D 10                push X
 075E 5000              mov A,0
 0760 7C0000            xcall _RECEIVE_Start
 0763 20                pop X
 0764                   .dbline 496
 0764           ;               
 0764           ;               // Start response timeout timer and enable its interrupt routine.
 0764           ;               TIMEOUT = 0;
 0764 62D000            mov REG[0xd0],>_TIMEOUT
 0767 550100            mov [_TIMEOUT+1],0
 076A 550000            mov [_TIMEOUT],0
 076D                   .dbline 497
 076D           ;               RX_TIMEOUT_EnableInt();
 076D 10                push X
 076E 7C0000            xcall _RX_TIMEOUT_EnableInt
 0771                   .dbline 498
 0771           ;               RX_TIMEOUT_Start();
 0771 7C0000            xcall _RX_TIMEOUT_Start
 0774 20                pop X
 0775                   .dbline 500
 0775           ;               
 0775           ;               STATE = RX_MODE;
 0775 62D000            mov REG[0xd0],>_STATE
 0778 550101            mov [_STATE+1],1
 077B 550000            mov [_STATE],0
 077E                   .dbline 501
 077E           ;       }
 077E 804A              xjmp L125
 0780           L124:
 0780                   .dbline 502
 0780           ;       else if(mode == TX_MODE)
 0780 3DFB00            cmp [X-5],0
 0783 B045              jnz L126
 0785 3DFC00            cmp [X-4],0
 0788 B040              jnz L126
 078A           X32:
 078A                   .dbline 503
 078A           ;       {
 078A                   .dbline 504
 078A           ;               LoadConfig_transmitter_config();
 078A 7C0000            xcall _LoadConfig_transmitter_config
 078D                   .dbline 506
 078D           ;               // Start the transmitter.
 078D           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 078D 10                push X
 078E 5000              mov A,0
 0790 7C0000            xcall _TRANSMIT_Start
 0793 20                pop X
 0794                   .dbline 508
 0794           ;               
 0794           ;               TIMEOUT = 0;
 0794 62D000            mov REG[0xd0],>_TIMEOUT
 0797 550100            mov [_TIMEOUT+1],0
 079A 550000            mov [_TIMEOUT],0
 079D                   .dbline 509
 079D           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 079D 10                push X
 079E 7C0000            xcall _TX_TIMEOUT_EnableInt
 07A1                   .dbline 510
 07A1           ;               TX_TIMEOUT_Start();             // Start the timer.
 07A1 7C0000            xcall _TX_TIMEOUT_Start
 07A4 20                pop X
 07A5           L128:
 07A5                   .dbline 513
 07A5           ;               
 07A5           ;               while(!TIMEOUT)
 07A5           ;               {
 07A5                   .dbline 516
 07A5           ;                       // Do nothing while we wait for one timeout period.
 07A5           ;                       // This is to allow everyone to get in the right configuration.
 07A5           ;               }
 07A5           L129:
 07A5                   .dbline 512
 07A5 62D000            mov REG[0xd0],>_TIMEOUT
 07A8 3C0000            cmp [_TIMEOUT],0
 07AB B006              jnz X33
 07AD 3C0100            cmp [_TIMEOUT+1],0
 07B0 AFF4              jz L128
 07B2           X33:
 07B2                   .dbline 518
 07B2           ;               
 07B2           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 07B2 10                push X
 07B3 7C0000            xcall _TX_TIMEOUT_Stop
 07B6 20                pop X
 07B7                   .dbline 519
 07B7           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 07B7 62D000            mov REG[0xd0],>_TIMEOUT
 07BA 550100            mov [_TIMEOUT+1],0
 07BD 550000            mov [_TIMEOUT],0
 07C0                   .dbline 521
 07C0           ;               
 07C0           ;               STATE = TX_MODE;
 07C0 62D000            mov REG[0xd0],>_STATE
 07C3 550100            mov [_STATE+1],0
 07C6 550000            mov [_STATE],0
 07C9                   .dbline 522
 07C9           ;       }
 07C9           L126:
 07C9           L125:
 07C9           L123:
 07C9                   .dbline 527
 07C9           ;       
 07C9           ;       // Make sure to keep the LED on (active low).
 07C9           ;       //PRT2DR &= 0b11111110;
 07C9           ;       
 07C9           ;       if(STATE == TX_MODE)
 07C9 62D000            mov REG[0xd0],>_STATE
 07CC 3C0000            cmp [_STATE],0
 07CF B00B              jnz L131
 07D1 3C0100            cmp [_STATE+1],0
 07D4 B006              jnz L131
 07D6           X34:
 07D6                   .dbline 528
 07D6           ;       {
 07D6                   .dbline 529
 07D6           ;               PRT1DR |= 0b00000001;
 07D6 430401            or REG[0x4],1
 07D9                   .dbline 530
 07D9           ;       }
 07D9 8004              xjmp L132
 07DB           L131:
 07DB                   .dbline 532
 07DB           ;       else
 07DB           ;       {
 07DB                   .dbline 533
 07DB           ;               PRT1DR &= 0b11111110;
 07DB 4104FE            and REG[0x4],-2
 07DE                   .dbline 535
 07DE           ;               
 07DE           ;       }
 07DE           L132:
 07DE                   .dbline 538
 07DE           ;       
 07DE           ;       // Reconnect to the global bus.
 07DE           ;       PRT0GS |= 0b10000000;
 07DE 430280            or REG[0x2],-128
 07E1                   .dbline -2
 07E1           L119:
 07E1 20                pop X
 07E2                   .dbline 0 ; func end
 07E2 7F                ret
 07E3                   .dbsym l mode -5 I
 07E3                   .dbend
 07E3                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 07E3           _unloadAllConfigs::
 07E3                   .dbline -1
 07E3                   .dbline 544
 07E3           ; }
 07E3           ; 
 07E3           ; // This function blindly unloads all user configurations. This will be called once,
 07E3           ; // when the system initially has no known state.
 07E3           ; void unloadAllConfigs(void)
 07E3           ; {
 07E3                   .dbline 545
 07E3           ;       UnloadConfig_pc_listener();
 07E3 7C0000            xcall _UnloadConfig_pc_listener
 07E6                   .dbline 546
 07E6           ;       UnloadConfig_receiver_config();
 07E6 7C0000            xcall _UnloadConfig_receiver_config
 07E9                   .dbline 547
 07E9           ;       UnloadConfig_transmitter_config();
 07E9 7C0000            xcall _UnloadConfig_transmitter_config
 07EC                   .dbline -2
 07EC           L133:
 07EC                   .dbline 0 ; func end
 07EC 7F                ret
 07ED                   .dbend
 07ED                   .dbfunc e unloadConfig _unloadConfig fV
 07ED           ;     config_num -> X-5
 07ED           _unloadConfig::
 07ED                   .dbline -1
 07ED 10                push X
 07EE 4F                mov X,SP
 07EF                   .dbline 553
 07EF           ; }
 07EF           ; 
 07EF           ; // This function unloads the configuration corresponding to the config number passed to it.
 07EF           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 07EF           ; void unloadConfig(int config_num)
 07EF           ; {
 07EF                   .dbline 554
 07EF           ;       if(config_num == PC_MODE)
 07EF 3DFB00            cmp [X-5],0
 07F2 B00B              jnz L135
 07F4 3DFC02            cmp [X-4],2
 07F7 B006              jnz L135
 07F9           X35:
 07F9                   .dbline 555
 07F9           ;       {
 07F9                   .dbline 556
 07F9           ;               UnloadConfig_pc_listener();
 07F9 7C0000            xcall _UnloadConfig_pc_listener
 07FC                   .dbline 557
 07FC           ;       }
 07FC 801D              xjmp L136
 07FE           L135:
 07FE                   .dbline 558
 07FE           ;       else if(config_num == RX_MODE)
 07FE 3DFB00            cmp [X-5],0
 0801 B00B              jnz L137
 0803 3DFC01            cmp [X-4],1
 0806 B006              jnz L137
 0808           X36:
 0808                   .dbline 559
 0808           ;       {
 0808                   .dbline 560
 0808           ;               UnloadConfig_receiver_config();
 0808 7C0000            xcall _UnloadConfig_receiver_config
 080B                   .dbline 561
 080B           ;       }
 080B 800E              xjmp L138
 080D           L137:
 080D                   .dbline 562
 080D           ;       else if(config_num == TX_MODE)
 080D 3DFB00            cmp [X-5],0
 0810 B009              jnz L139
 0812 3DFC00            cmp [X-4],0
 0815 B004              jnz L139
 0817           X37:
 0817                   .dbline 563
 0817           ;       {
 0817                   .dbline 564
 0817           ;               UnloadConfig_transmitter_config();
 0817 7C0000            xcall _UnloadConfig_transmitter_config
 081A                   .dbline 565
 081A           ;       }
 081A           L139:
 081A           L138:
 081A           L136:
 081A                   .dbline -2
 081A           L134:
 081A 20                pop X
 081B                   .dbline 0 ; func end
 081B 7F                ret
 081C                   .dbsym l config_num -5 I
 081C                   .dbend
 081C                   .dbfunc e initializeSlaves _initializeSlaves fV
 081C           ;   num_timeouts -> X+0
 081C           _initializeSlaves::
 081C                   .dbline -1
 081C 10                push X
 081D 4F                mov X,SP
 081E 3802              add SP,2
 0820                   .dbline 569
 0820           ; }
 0820           ; 
 0820           ; void initializeSlaves(void)
 0820           ; {
 0820                   .dbline 570
 0820           ;       int num_timeouts = 0;
 0820 560100            mov [X+1],0
 0823 560000            mov [X+0],0
 0826                   .dbline 572
 0826           ;       
 0826           ;       sayHello();
 0826 9BAE              xcall _sayHello
 0828 8105              xjmp L143
 082A           L142:
 082A                   .dbline 577
 082A           ;       
 082A           ;       // This loop continuously probes and listens at intervals
 082A           ;       // set by the RX_TIMEOUT_DURATION variable.
 082A           ;       while(num_timeouts < MAX_TIMEOUTS)
 082A           ;       {                                       
 082A                   .dbline 578
 082A           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 082A 10                push X
 082B 7C0000            xcall _RECEIVE_cReadChar
 082E 62D000            mov REG[0xd0],>__r0
 0831 20                pop X
 0832 39FC              cmp A,-4
 0834 B0D4              jnz L145
 0836                   .dbline 579
 0836           ;               {       
 0836                   .dbline 580
 0836           ;                       if(validTransmission())
 0836 9BF3              xcall _validTransmission
 0838 62D000            mov REG[0xd0],>__r0
 083B 3C0000            cmp [__r0],0
 083E B006              jnz X38
 0840 3C0000            cmp [__r1],0
 0843 A0EA              jz L146
 0845           X38:
 0845                   .dbline 581
 0845           ;                       {
 0845                   .dbline 582
 0845           ;                               if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0845 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0848 3C00C8            cmp [_COMMAND_TYPE],-56
 084B B0E2              jnz L146
 084D                   .dbline 583
 084D           ;                               {
 084D                   .dbline 585
 084D           ;                                       // If this is for me, assign them an ID.
 084D           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 084D 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0850 3C0000            cmp [_COMMAND_DESTINATION],0
 0853 B0DA              jnz L146
 0855                   .dbline 586
 0855           ;                                       {
 0855                   .dbline 587
 0855           ;                                               NUM_MODULES++;                  // Increment the number of modules connected.
 0855 62D000            mov REG[0xd0],>_NUM_MODULES
 0858 7601              inc [_NUM_MODULES+1]
 085A 0E0000            adc [_NUM_MODULES],0
 085D                   .dbline 588
 085D           ;                                               num_timeouts = 0;               // Reset number of timeouts since we found someone.
 085D 560100            mov [X+1],0
 0860 560000            mov [X+0],0
 0863                   .dbline 590
 0863           ;                       
 0863           ;                                               if(!assignID(NUM_MODULES))
 0863 5100              mov A,[_NUM_MODULES]
 0865 08                push A
 0866 5101              mov A,[_NUM_MODULES+1]
 0868 08                push A
 0869 993C              xcall _assignID
 086B 38FE              add SP,-2
 086D 62D000            mov REG[0xd0],>__r0
 0870 3C0000            cmp [__r0],0
 0873 B0BA              jnz L146
 0875 3C0000            cmp [__r1],0
 0878 B0B5              jnz L146
 087A           X39:
 087A                   .dbline 591
 087A           ;                                               {
 087A                   .dbline 595
 087A           ;                                                       // If the module did not respond that the ID was assigned,
 087A           ;                                                       // make an effort to ping it in case that transmission was lost
 087A           ;                                                       // before ultimately deciding that the module didn't configure.
 087A           ;                                                       if(!pingModule(NUM_MODULES))
 087A 62D000            mov REG[0xd0],>_NUM_MODULES
 087D 5100              mov A,[_NUM_MODULES]
 087F 08                push A
 0880 5101              mov A,[_NUM_MODULES+1]
 0882 08                push A
 0883 9829              xcall _pingModule
 0885 38FE              add SP,-2
 0887 62D000            mov REG[0xd0],>__r0
 088A 3C0000            cmp [__r0],0
 088D B0A0              jnz L146
 088F 3C0000            cmp [__r1],0
 0892 B09B              jnz L146
 0894           X40:
 0894                   .dbline 596
 0894           ;                                                       {
 0894                   .dbline 597
 0894           ;                                                               if(!pingModule(NUM_MODULES))
 0894 62D000            mov REG[0xd0],>_NUM_MODULES
 0897 5100              mov A,[_NUM_MODULES]
 0899 08                push A
 089A 5101              mov A,[_NUM_MODULES+1]
 089C 08                push A
 089D 980F              xcall _pingModule
 089F 38FE              add SP,-2
 08A1 62D000            mov REG[0xd0],>__r0
 08A4 3C0000            cmp [__r0],0
 08A7 B086              jnz L146
 08A9 3C0000            cmp [__r1],0
 08AC B081              jnz L146
 08AE           X41:
 08AE                   .dbline 598
 08AE           ;                                                               {
 08AE                   .dbline 599
 08AE           ;                                                                       if(!pingModule(NUM_MODULES))
 08AE 62D000            mov REG[0xd0],>_NUM_MODULES
 08B1 5100              mov A,[_NUM_MODULES]
 08B3 08                push A
 08B4 5101              mov A,[_NUM_MODULES+1]
 08B6 08                push A
 08B7 7C00AE            xcall _pingModule
 08BA 38FE              add SP,-2
 08BC 62D000            mov REG[0xd0],>__r0
 08BF 3C0000            cmp [__r0],0
 08C2 B06B              jnz L146
 08C4 3C0000            cmp [__r1],0
 08C7 B066              jnz L146
 08C9           X42:
 08C9                   .dbline 600
 08C9           ;                                                                       {
 08C9                   .dbline 601
 08C9           ;                                                                               if(!pingModule(NUM_MODULES))
 08C9 62D000            mov REG[0xd0],>_NUM_MODULES
 08CC 5100              mov A,[_NUM_MODULES]
 08CE 08                push A
 08CF 5101              mov A,[_NUM_MODULES+1]
 08D1 08                push A
 08D2 7C00AE            xcall _pingModule
 08D5 38FE              add SP,-2
 08D7 62D000            mov REG[0xd0],>__r0
 08DA 3C0000            cmp [__r0],0
 08DD B050              jnz L146
 08DF 3C0000            cmp [__r1],0
 08E2 B04B              jnz L146
 08E4           X43:
 08E4                   .dbline 602
 08E4           ;                                                                               {
 08E4                   .dbline 603
 08E4           ;                                                                                       if(!pingModule(NUM_MODULES))
 08E4 62D000            mov REG[0xd0],>_NUM_MODULES
 08E7 5100              mov A,[_NUM_MODULES]
 08E9 08                push A
 08EA 5101              mov A,[_NUM_MODULES+1]
 08EC 08                push A
 08ED 7C00AE            xcall _pingModule
 08F0 38FE              add SP,-2
 08F2 62D000            mov REG[0xd0],>__r0
 08F5 3C0000            cmp [__r0],0
 08F8 B035              jnz L146
 08FA 3C0000            cmp [__r1],0
 08FD B030              jnz L146
 08FF           X44:
 08FF                   .dbline 604
 08FF           ;                                                                                       {
 08FF                   .dbline 605
 08FF           ;                                                                                               NUM_MODULES--;
 08FF 62D000            mov REG[0xd0],>_NUM_MODULES
 0902 7A01              dec [_NUM_MODULES+1]
 0904 1E0000            sbb [_NUM_MODULES],0
 0907                   .dbline 606
 0907           ;                                                                                       }
 0907                   .dbline 607
 0907           ;                                                                               }
 0907                   .dbline 608
 0907           ;                                                                       }
 0907                   .dbline 609
 0907           ;                                                               }
 0907                   .dbline 610
 0907           ;                                                       }
 0907                   .dbline 611
 0907           ;                                               }
 0907                   .dbline 612
 0907           ;                                       }
 0907                   .dbline 613
 0907           ;                               }
 0907                   .dbline 614
 0907           ;                       }
 0907                   .dbline 615
 0907           ;               }
 0907 8026              xjmp L146
 0909           L145:
 0909                   .dbline 616
 0909           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 0909 62D000            mov REG[0xd0],>_TIMEOUT
 090C 5101              mov A,[_TIMEOUT+1]
 090E 1105              sub A,5
 0910 5100              mov A,[_TIMEOUT]
 0912 3180              xor A,-128
 0914 1980              sbb A,(0 ^ 0x80)
 0916 C017              jc L165
 0918           X45:
 0918                   .dbline 617
 0918           ;               {       
 0918                   .dbline 618
 0918           ;                       num_timeouts++;
 0918 7701              inc [X+1]
 091A 0F0000            adc [X+0],0
 091D                   .dbline 621
 091D           ;                       
 091D           ;                       // If we are not maxed out on modules, look for more.
 091D           ;                       if(NUM_MODULES < MAX_MODULES)
 091D 62D000            mov REG[0xd0],>_NUM_MODULES
 0920 5101              mov A,[_NUM_MODULES+1]
 0922 11FA              sub A,-6
 0924 5100              mov A,[_NUM_MODULES]
 0926 3180              xor A,-128
 0928 1980              sbb A,(0 ^ 0x80)
 092A D003              jnc L167
 092C           X46:
 092C                   .dbline 622
 092C           ;                       {
 092C                   .dbline 623
 092C           ;                               sayHello();
 092C 9AA8              xcall _sayHello
 092E                   .dbline 624
 092E           ;                       }
 092E           L167:
 092E                   .dbline 625
 092E           ;               }
 092E           L165:
 092E           L146:
 092E                   .dbline 626
 092E           ;       }
 092E           L143:
 092E                   .dbline 576
 092E 5201              mov A,[X+1]
 0930 110A              sub A,10
 0932 5200              mov A,[X+0]
 0934 3180              xor A,-128
 0936 1980              sbb A,(0 ^ 0x80)
 0938 CEF1              jc L142
 093A           X47:
 093A                   .dbline 629
 093A           ;       
 093A           ;       // Switch back to PC mode.
 093A           ;       configToggle(PC_MODE);
 093A 5000              mov A,0
 093C 08                push A
 093D 5002              mov A,2
 093F 08                push A
 0940 9DB2              xcall _configToggle
 0942 38FE              add SP,-2
 0944                   .dbline -2
 0944           L141:
 0944 38FE              add SP,-2
 0946 20                pop X
 0947                   .dbline 0 ; func end
 0947 7F                ret
 0948                   .dbsym l num_timeouts 0 I
 0948                   .dbend
 0948                   .dbfunc e xmitWait _xmitWait fV
 0948           ;              i -> X+0
 0948           _xmitWait::
 0948                   .dbline -1
 0948 10                push X
 0949 4F                mov X,SP
 094A 3802              add SP,2
 094C                   .dbline 633
 094C           ; }
 094C           ; 
 094C           ; void xmitWait(void)
 094C           ; {
 094C                   .dbline 636
 094C           ;       int i;
 094C           ;       
 094C           ;       for(i = 0; i < 25; i++)
 094C 560100            mov [X+1],0
 094F 560000            mov [X+0],0
 0952           L170:
 0952                   .dbline 637
 0952           ;       {
 0952                   .dbline 639
 0952           ;               // Sit here and spin for about 50 microseconds.
 0952           ;       }
 0952           L171:
 0952                   .dbline 636
 0952 7701              inc [X+1]
 0954 0F0000            adc [X+0],0
 0957                   .dbline 636
 0957 5201              mov A,[X+1]
 0959 1119              sub A,25
 095B 5200              mov A,[X+0]
 095D 3180              xor A,-128
 095F 1980              sbb A,(0 ^ 0x80)
 0961 CFF0              jc L170
 0963           X48:
 0963                   .dbline -2
 0963           L169:
 0963 38FE              add SP,-2
 0965 20                pop X
 0966                   .dbline 0 ; func end
 0966 7F                ret
 0967                   .dbsym l i 0 I
 0967                   .dbend
 0967                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0967           _TX_TIMEOUT_ISR::
 0967                   .dbline -1
 0967 71C0              or F,-64
 0969 08                push A
 096A 5DD0              mov A,REG[0xd0]
 096C 08                push A
 096D                   .dbline 643
 096D           ; }
 096D           ; 
 096D           ; void TX_TIMEOUT_ISR(void)
 096D           ; {     
 096D                   .dbline 644
 096D           ;       TIMEOUT++;
 096D 62D000            mov REG[0xd0],>_TIMEOUT
 0970 7601              inc [_TIMEOUT+1]
 0972 0E0000            adc [_TIMEOUT],0
 0975                   .dbline 646
 0975           ;       
 0975           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0975 62DAFD            mov REG[0xda],-3
 0978                   .dbline -2
 0978           L174:
 0978 18                pop A
 0979 60D0              mov REG[208],A
 097B 18                pop A
 097C                   .dbline 0 ; func end
 097C 7E                reti
 097D                   .dbend
 097D                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 097D           _RX_TIMEOUT_ISR::
 097D                   .dbline -1
 097D 71C0              or F,-64
 097F 08                push A
 0980 5DD0              mov A,REG[0xd0]
 0982 08                push A
 0983                   .dbline 650
 0983           ; }
 0983           ; 
 0983           ; void RX_TIMEOUT_ISR(void)
 0983           ; {     
 0983                   .dbline 651
 0983           ;       TIMEOUT++;
 0983 62D000            mov REG[0xd0],>_TIMEOUT
 0986 7601              inc [_TIMEOUT+1]
 0988 0E0000            adc [_TIMEOUT],0
 098B                   .dbline 653
 098B           ;       
 098B           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 098B 62DAFD            mov REG[0xda],-3
 098E                   .dbline -2
 098E           L175:
 098E 18                pop A
 098F 60D0              mov REG[208],A
 0991 18                pop A
 0992                   .dbline 0 ; func end
 0992 7E                reti
 0993                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _PARAM::
 0000 00                .byte 0
 0001                   .dbsym e PARAM _PARAM c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area lit(rom, con, rel)
 0000           L54:
 0000 4D6F64756C65732100        .byte 'M,'o,'d,'u,'l,'e,'s,33,0
