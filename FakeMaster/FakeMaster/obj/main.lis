 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000                   .dbfunc e main _main fV
 0000           _main::
 0000                   .dbline -1
 0000                   .dbline 124
 0000           ; // Author: Jason Tennyson
 0000           ; // Date: 7-10-11
 0000           ; // File: main.c
 0000           ; //
 0000           ; // This is the design for the parent module of Jason Tennyson's Thesis.
 0000           ; // This design is made for a PSoC CY8C28433-24PVXI.
 0000           ; //
 0000           ; // Controller Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // All Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
 0000           ; //
 0000           ; // Servo Packet Structure (each field is a byte)
 0000           ; // -----------------------------------------------------
 0000           ; // Source Packets:
 0000           ; // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
 0000           ; //
 0000           ; // Return Packets:
 0000           ; // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
 0000           ; 
 0000           ; #include <m8c.h>              // Part-specific constants and macros.
 0000           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules.
 0000           ; #include "psocdynamic.h"      // Required for dynamically swapping configurations at run time.
 0000           ; #include <stdlib.h>                   // Required for converting character arrays to and from floats and ints.
 0000           ; 
 0000           ; //#include <string.h>
 0000           ; 
 0000           ; // These are declarations of all of the timer interrupts that are used for all configurations.
 0000           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0000           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0000           ; 
 0000           ; // These defines are used as parameters of the configToggle function.
 0000           ; // Passing one or the other in the function call switches the system between PC and RX modes.
 0000           ; #define               PC_MODE                                         (1)
 0000           ; #define               RX_MODE                                         (2)
 0000           ; 
 0000           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0000           ; #define               PORT_1                                          ('1')
 0000           ; #define               PORT_2                                          ('2')
 0000           ; #define               PORT_3                                          ('3')
 0000           ; #define               PORT_4                                          ('4')
 0000           ; 
 0000           ; // This is the module type identifier.
 0000           ; #define               TYPE                                            ('2')
 0000           ; 
 0000           ; // These defines are used as transmission indicators.
 0000           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0000           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0000           ; #define               COMMAND_TYPE_SPACE                      (200)   // The number where reserved command types start.
 0000           ; #define               HELLO_BYTE                                      (200)   // Indicates parent is ready to talk.
 0000           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the parent.
 0000           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0000           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0000           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the parent is asking for a config clear.
 0000           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0000           ; #define               PARENT_ID                                       (0)             // The parent node's ID.
 0000           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0000           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0000           ; #define               SERVO_START                                     (255)   // The start byte of a servo.
 0000           ; 
 0000           ; // These defines are used to fill in the instruction we are using on the servo.
 0000           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0000           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0000           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0000           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0000           ; 
 0000           ; // These defines are used for transmission timing.
 0000           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0000           ; 
 0000           ; // These defines are used for the initial probing stage.
 0000           ; #define               BOOT_WAIT_TIME                          (500)   // The time in milliseconds to wait at startup.
 0000           ; #define               INIT_WAIT_TIME                          (2)             // Initial wait time between module probes.
 0000           ; #define               MAX_TIMEOUTS                            (50)    // Number of timeouts allowed before hello mode exit.
 0000           ; 
 0000           ; // This is the maximum number of allowable modules per branch out from the parent.
 0000           ; #define               MAX_MODULES                                     (250)
 0000           ; 
 0000           ; // Receives a mode identifier and toggles to that mode.
 0000           ; void configToggle(int mode);
 0000           ; // Pings the index passed to it. Returns 1 on success, 0 on fail.
 0000           ; int pingModule(int module_id);
 0000           ; // Assigns an ID to a module.
 0000           ; int assignID(int assigned_ID);
 0000           ; // Attempts to read a valid transmission and store it.
 0000           ; int validTransmission(void);
 0000           ; // Reads a PC command and translates it to the correct packet type.
 0000           ; void decodeTransmission(void);
 0000           ; // Sends out a hello message packet.
 0000           ; void sayHello(void);
 0000           ; // Servo instruction function that sends read or write commands.
 0000           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0000           ; // Servo instruction function that sends long two-byte write commands.
 0000           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0000           ; // Immediately performs a non-blocking read char operation, and returns 0 upon failure.
 0000           ; char iReadChar(void);
 0000           ; // Performs a blocking read char operation.
 0000           ; char readChar(void);
 0000           ; // Checks the current mode and unloads the configuration for that mode.
 0000           ; void unloadAllConfigs(void);
 0000           ; // Unloads the configuration corresponding to the number passed to it.
 0000           ; void unloadConfig(int config_num);
 0000           ; // Initialization function for the child module controllers.
 0000           ; void initializeChildren(void);
 0000           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0000           ; void xmitWait(void);
 0000           ; // Wait before transmitting in the case of repetitive transmissions.
 0000           ; void preXmitWait(int currentState);
 0000           ; // Function that waits for BOOT_WAIT_TIME milliseconds.
 0000           ; void bootWait(void);
 0000           ; // Listen for a child and record the port value.
 0000           ; int childListen(void);
 0000           ; 
 0000           ; int TIMEOUT;                          // This flag is incremented if there is a timeout.
 0000           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0000           ; int STATE;                                    // Stores the current configuration state of the system.
 0000           ; char CHILD;                                   // The child port value stored from initialization.
 0000           ; 
 0000           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0000           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0000           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0000           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0000           ; 
 0000           ; void main()
 0000           ; {     
 0000                   .dbline 125
 0000           ;       NUM_MODULES = 0;        // Initialize the number of modules.
 0000 62D000            mov REG[0xd0],>_NUM_MODULES
 0003 550100            mov [_NUM_MODULES+1],0
 0006 550000            mov [_NUM_MODULES],0
 0009                   .dbline 126
 0009           ;       STATE = 0;                      // Initialize the current hardware state.
 0009 62D000            mov REG[0xd0],>_STATE
 000C 550100            mov [_STATE+1],0
 000F 550000            mov [_STATE],0
 0012                   .dbline 129
 0012           ;       
 0012           ;       // Activate GPIO ISR.
 0012           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
 0012 43E020            or REG[0xe0],32
 0015                   .dbline 132
 0015           ;       
 0015           ;       // Turn on global interrupts for the transmission timeout timer.
 0015           ;       M8C_EnableGInt;
 0015 7101                      or  F, 01h
 0017           
 0017                   .dbline 135
 0017           ;       
 0017           ;       // Unload all of the configurations.
 0017           ;       unloadAllConfigs();
 0017 7C0C3B            xcall _unloadAllConfigs
 001A                   .dbline 138
 001A           ;       
 001A           ;       // Wait for every module to boot.
 001A           ;       bootWait();
 001A 7C0FC9            xcall _bootWait
 001D 8021              xjmp L3
 001F           L2:
 001F                   .dbline 141
 001F           ;       
 001F           ;       while(1)
 001F           ;       {
 001F                   .dbline 143
 001F           ;               // If there are no modules, find some. Otherwise, look for computer commands.
 001F           ;               if(!NUM_MODULES)
 001F 62D000            mov REG[0xd0],>_NUM_MODULES
 0022 3C0000            cmp [_NUM_MODULES],0
 0025 B00B              jnz L5
 0027 3C0100            cmp [_NUM_MODULES+1],0
 002A B006              jnz L5
 002C           X1:
 002C                   .dbline 144
 002C           ;               {
 002C                   .dbline 145
 002C           ;                       initializeChildren();
 002C 7C0C62            xcall _initializeChildren
 002F                   .dbline 146
 002F           ;               }
 002F 800F              xjmp L6
 0031           L5:
 0031                   .dbline 147
 0031           ;               else if(COMP_SERIAL_bCmdCheck())
 0031 10                push X
 0032 7C0000            xcall _COMP_SERIAL_bCmdCheck
 0035 62D000            mov REG[0xd0],>__r0
 0038 20                pop X
 0039 3900              cmp A,0
 003B A003              jz L7
 003D                   .dbline 148
 003D           ;               {
 003D                   .dbline 149
 003D           ;                       decodeTransmission();
 003D 9330              xcall _decodeTransmission
 003F                   .dbline 150
 003F           ;               }
 003F           L7:
 003F           L6:
 003F                   .dbline 151
 003F           ;       }
 003F           L3:
 003F                   .dbline 140
 003F 8FDF              xjmp L2
 0041           X0:
 0041                   .dbline -2
 0041           L1:
 0041                   .dbline 0 ; func end
 0041 8FFF              jmp .
 0043                   .dbend
 0043                   .dbfunc e pingModule _pingModule fI
 0043           ;      module_id -> X-5
 0043           _pingModule::
 0043                   .dbline -1
 0043 10                push X
 0044 4F                mov X,SP
 0045                   .dbline 155
 0045           ; }
 0045           ; 
 0045           ; int pingModule(int module_id)
 0045           ; {
 0045                   .dbline 157
 0045           ;       // Toggle into PC mode.
 0045           ;       configToggle(PC_MODE);
 0045 5000              mov A,0
 0047 08                push A
 0048 5001              mov A,1
 004A 08                push A
 004B 7C0B94            xcall _configToggle
 004E 38FE              add SP,-2
 0050                   .dbline 160
 0050           ;       
 0050           ;       // Transmit a ping to everyone.
 0050           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte one
 0050 10                push X
 0051 50FC              mov A,-4
 0053 7C0000            xcall _TX_REPEATER_14_PutChar
 0056 20                pop X
 0057                   .dbline 161
 0057           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte one
 0057 10                push X
 0058 50FC              mov A,-4
 005A 7C0000            xcall _TX_REPEATER_23_PutChar
 005D 20                pop X
 005E                   .dbline 162
 005E           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte two
 005E 10                push X
 005F 50FC              mov A,-4
 0061 7C0000            xcall _TX_REPEATER_14_PutChar
 0064 20                pop X
 0065                   .dbline 163
 0065           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte two
 0065 10                push X
 0066 50FC              mov A,-4
 0068 7C0000            xcall _TX_REPEATER_23_PutChar
 006B 20                pop X
 006C                   .dbline 164
 006C           ;       TX_REPEATER_14_PutChar(PARENT_ID);                      // My ID
 006C 10                push X
 006D 5000              mov A,0
 006F 7C0000            xcall _TX_REPEATER_14_PutChar
 0072 20                pop X
 0073                   .dbline 165
 0073           ;       TX_REPEATER_23_PutChar(PARENT_ID);                      // My ID
 0073 10                push X
 0074 5000              mov A,0
 0076 7C0000            xcall _TX_REPEATER_23_PutChar
 0079 20                pop X
 007A                   .dbline 166
 007A           ;       TX_REPEATER_14_PutChar(module_id);                      // Destination ID
 007A 62D000            mov REG[0xd0],>__r0
 007D 52FC              mov A,[X-4]
 007F 10                push X
 0080 7C0000            xcall _TX_REPEATER_14_PutChar
 0083 20                pop X
 0084                   .dbline 167
 0084           ;       TX_REPEATER_23_PutChar(module_id);                      // Destination ID
 0084 62D000            mov REG[0xd0],>__r0
 0087 52FC              mov A,[X-4]
 0089 10                push X
 008A 7C0000            xcall _TX_REPEATER_23_PutChar
 008D 20                pop X
 008E                   .dbline 168
 008E           ;       TX_REPEATER_14_PutChar(PING);                           // This is a ping response
 008E 10                push X
 008F 50CB              mov A,-53
 0091 7C0000            xcall _TX_REPEATER_14_PutChar
 0094 20                pop X
 0095                   .dbline 169
 0095           ;       TX_REPEATER_23_PutChar(PING);                           // This is a ping response
 0095 10                push X
 0096 50CB              mov A,-53
 0098 7C0000            xcall _TX_REPEATER_23_PutChar
 009B 20                pop X
 009C                   .dbline 170
 009C           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 009C 10                push X
 009D 50FD              mov A,-3
 009F 7C0000            xcall _TX_REPEATER_14_PutChar
 00A2 20                pop X
 00A3                   .dbline 171
 00A3           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 00A3 10                push X
 00A4 50FD              mov A,-3
 00A6 7C0000            xcall _TX_REPEATER_23_PutChar
 00A9 20                pop X
 00AA                   .dbline 172
 00AA           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 00AA 10                push X
 00AB 50FD              mov A,-3
 00AD 7C0000            xcall _TX_REPEATER_14_PutChar
 00B0 20                pop X
 00B1                   .dbline 173
 00B1           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 00B1 10                push X
 00B2 50FD              mov A,-3
 00B4 7C0000            xcall _TX_REPEATER_23_PutChar
 00B7 20                pop X
 00B8                   .dbline 176
 00B8           ;       
 00B8           ;       // Make completely sure we're done.
 00B8           ;       xmitWait();
 00B8 7C0FE3            xcall _xmitWait
 00BB                   .dbline 179
 00BB           ;       
 00BB           ;       // Switch to listening mode.
 00BB           ;       configToggle(RX_MODE);
 00BB 5000              mov A,0
 00BD 08                push A
 00BE 5002              mov A,2
 00C0 08                push A
 00C1 7C0B94            xcall _configToggle
 00C4 38FE              add SP,-2
 00C6 8041              xjmp L11
 00C8           L10:
 00C8                   .dbline 183
 00C8           ;       
 00C8           ;       // Listen for the response.
 00C8           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 00C8           ;       {
 00C8                   .dbline 184
 00C8           ;               if(validTransmission())
 00C8 91DD              xcall _validTransmission
 00CA 62D000            mov REG[0xd0],>__r0
 00CD 3C0000            cmp [__r0],0
 00D0 B006              jnz X2
 00D2 3C0000            cmp [__r1],0
 00D5 A032              jz L13
 00D7           X2:
 00D7                   .dbline 185
 00D7           ;               {
 00D7                   .dbline 187
 00D7           ;                       // If the response is what we are looking for.
 00D7           ;                       if(COMMAND_TYPE == PING)
 00D7 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00DA 3C00CB            cmp [_COMMAND_TYPE],-53
 00DD B02A              jnz L15
 00DF                   .dbline 188
 00DF           ;                       {
 00DF                   .dbline 190
 00DF           ;                               // If this is for me, check who it was from.
 00DF           ;                               if(COMMAND_DESTINATION == PARENT_ID)
 00DF 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00E2 3C0000            cmp [_COMMAND_DESTINATION],0
 00E5 B022              jnz L17
 00E7                   .dbline 191
 00E7           ;                               {
 00E7                   .dbline 193
 00E7           ;                                       // If it's from the right module, return 1.
 00E7           ;                                       if(COMMAND_SOURCE == module_id)
 00E7 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 00EA 5100              mov A,[_COMMAND_SOURCE]
 00EC 62D000            mov REG[0xd0],>__r0
 00EF 5300              mov [__r1],A
 00F1 5000              mov A,0
 00F3 3BFB              cmp A,[X-5]
 00F5 B012              jnz L19
 00F7 5100              mov A,[__r1]
 00F9 3BFC              cmp A,[X-4]
 00FB B00C              jnz L19
 00FD           X3:
 00FD                   .dbline 194
 00FD           ;                                       {
 00FD                   .dbline 195
 00FD           ;                                               return 1;
 00FD 62D000            mov REG[0xd0],>__r0
 0100 550001            mov [__r1],1
 0103 550000            mov [__r0],0
 0106 8027              xjmp L9
 0108           L19:
 0108                   .dbline 197
 0108           ;                                       }
 0108           ;                               }
 0108           L17:
 0108                   .dbline 198
 0108           ;                       }
 0108           L15:
 0108                   .dbline 199
 0108           ;               }
 0108           L13:
 0108                   .dbline 200
 0108           ;       }
 0108           L11:
 0108                   .dbline 182
 0108 62D000            mov REG[0xd0],>_TIMEOUT
 010B 5101              mov A,[_TIMEOUT+1]
 010D 1105              sub A,5
 010F 5100              mov A,[_TIMEOUT]
 0111 3180              xor A,-128
 0113 1980              sbb A,(0 ^ 0x80)
 0115 CFB2              jc L10
 0117           X4:
 0117                   .dbline 202
 0117           ; 
 0117           ;       RX_TIMEOUT_Stop();
 0117 10                push X
 0118 7C0000            xcall _RX_TIMEOUT_Stop
 011B 20                pop X
 011C                   .dbline 203
 011C           ;       TIMEOUT = 0;
 011C 62D000            mov REG[0xd0],>_TIMEOUT
 011F 550100            mov [_TIMEOUT+1],0
 0122 550000            mov [_TIMEOUT],0
 0125                   .dbline 205
 0125           ;       
 0125           ;       return 0;
 0125 62D000            mov REG[0xd0],>__r0
 0128 550000            mov [__r1],0
 012B 550000            mov [__r0],0
 012E                   .dbline -2
 012E           L9:
 012E 20                pop X
 012F                   .dbline 0 ; func end
 012F 7F                ret
 0130                   .dbsym l module_id -5 I
 0130                   .dbend
 0130                   .dbfunc e assignID _assignID fI
 0130           ;    assigned_ID -> X-5
 0130           _assignID::
 0130                   .dbline -1
 0130 10                push X
 0131 4F                mov X,SP
 0132                   .dbline 209
 0132           ; }
 0132           ; 
 0132           ; int assignID(int assigned_ID)
 0132           ; {     
 0132                   .dbline 211
 0132           ;       // Switch to PC mode.
 0132           ;       configToggle(PC_MODE);
 0132 5000              mov A,0
 0134 08                push A
 0135 5001              mov A,1
 0137 08                push A
 0138 7C0B94            xcall _configToggle
 013B 38FE              add SP,-2
 013D                   .dbline 214
 013D           ; 
 013D           ;       // Transmit an ID assignment.
 013D           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte one
 013D 10                push X
 013E 50FC              mov A,-4
 0140 7C0000            xcall _TX_REPEATER_14_PutChar
 0143 20                pop X
 0144                   .dbline 215
 0144           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte one
 0144 10                push X
 0145 50FC              mov A,-4
 0147 7C0000            xcall _TX_REPEATER_23_PutChar
 014A 20                pop X
 014B                   .dbline 216
 014B           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte two
 014B 10                push X
 014C 50FC              mov A,-4
 014E 7C0000            xcall _TX_REPEATER_14_PutChar
 0151 20                pop X
 0152                   .dbline 217
 0152           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte two
 0152 10                push X
 0153 50FC              mov A,-4
 0155 7C0000            xcall _TX_REPEATER_23_PutChar
 0158 20                pop X
 0159                   .dbline 218
 0159           ;       TX_REPEATER_14_PutChar(PARENT_ID);                      // My ID
 0159 10                push X
 015A 5000              mov A,0
 015C 7C0000            xcall _TX_REPEATER_14_PutChar
 015F 20                pop X
 0160                   .dbline 219
 0160           ;       TX_REPEATER_23_PutChar(PARENT_ID);                      // My ID
 0160 10                push X
 0161 5000              mov A,0
 0163 7C0000            xcall _TX_REPEATER_23_PutChar
 0166 20                pop X
 0167                   .dbline 220
 0167           ;       TX_REPEATER_14_PutChar(BLANK_MODULE_ID);        // Destination ID
 0167 10                push X
 0168 50FB              mov A,-5
 016A 7C0000            xcall _TX_REPEATER_14_PutChar
 016D 20                pop X
 016E                   .dbline 221
 016E           ;       TX_REPEATER_23_PutChar(BLANK_MODULE_ID);        // Destination ID
 016E 10                push X
 016F 50FB              mov A,-5
 0171 7C0000            xcall _TX_REPEATER_23_PutChar
 0174 20                pop X
 0175                   .dbline 222
 0175           ;       TX_REPEATER_14_PutChar(ID_ASSIGNMENT);          // This is an ID assignment
 0175 10                push X
 0176 50C9              mov A,-55
 0178 7C0000            xcall _TX_REPEATER_14_PutChar
 017B 20                pop X
 017C                   .dbline 223
 017C           ;       TX_REPEATER_23_PutChar(ID_ASSIGNMENT);          // This is an ID assignment
 017C 10                push X
 017D 50C9              mov A,-55
 017F 7C0000            xcall _TX_REPEATER_23_PutChar
 0182 20                pop X
 0183                   .dbline 224
 0183           ;       TX_REPEATER_14_PutChar(assigned_ID);            // This is the new ID
 0183 62D000            mov REG[0xd0],>__r0
 0186 52FC              mov A,[X-4]
 0188 10                push X
 0189 7C0000            xcall _TX_REPEATER_14_PutChar
 018C 20                pop X
 018D                   .dbline 225
 018D           ;       TX_REPEATER_23_PutChar(assigned_ID);            // This is the new ID
 018D 62D000            mov REG[0xd0],>__r0
 0190 52FC              mov A,[X-4]
 0192 10                push X
 0193 7C0000            xcall _TX_REPEATER_23_PutChar
 0196 20                pop X
 0197                   .dbline 226
 0197           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 0197 10                push X
 0198 50FD              mov A,-3
 019A 7C0000            xcall _TX_REPEATER_14_PutChar
 019D 20                pop X
 019E                   .dbline 227
 019E           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 019E 10                push X
 019F 50FD              mov A,-3
 01A1 7C0000            xcall _TX_REPEATER_23_PutChar
 01A4 20                pop X
 01A5                   .dbline 228
 01A5           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 01A5 10                push X
 01A6 50FD              mov A,-3
 01A8 7C0000            xcall _TX_REPEATER_14_PutChar
 01AB 20                pop X
 01AC                   .dbline 229
 01AC           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 01AC 10                push X
 01AD 50FD              mov A,-3
 01AF 7C0000            xcall _TX_REPEATER_23_PutChar
 01B2 20                pop X
 01B3                   .dbline 232
 01B3           ;       
 01B3           ;       // Make completely sure we're done.
 01B3           ;       xmitWait();
 01B3 7C0FE3            xcall _xmitWait
 01B6                   .dbline 235
 01B6           ;       
 01B6           ;       // Switch to listening mode.
 01B6           ;       configToggle(RX_MODE);
 01B6 5000              mov A,0
 01B8 08                push A
 01B9 5002              mov A,2
 01BB 08                push A
 01BC 7C0B94            xcall _configToggle
 01BF 38FE              add SP,-2
 01C1 8041              xjmp L23
 01C3           L22:
 01C3                   .dbline 239
 01C3           ;       
 01C3           ;       // Listen for the response.
 01C3           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 01C3           ;       {
 01C3                   .dbline 240
 01C3           ;               if(validTransmission())
 01C3 90E2              xcall _validTransmission
 01C5 62D000            mov REG[0xd0],>__r0
 01C8 3C0000            cmp [__r0],0
 01CB B006              jnz X5
 01CD 3C0000            cmp [__r1],0
 01D0 A032              jz L25
 01D2           X5:
 01D2                   .dbline 241
 01D2           ;               {
 01D2                   .dbline 243
 01D2           ;                       // If this is the response we are looking for.
 01D2           ;                       if(COMMAND_TYPE == ID_ASSIGN_OK)
 01D2 62D000            mov REG[0xd0],>_COMMAND_TYPE
 01D5 3C00CA            cmp [_COMMAND_TYPE],-54
 01D8 B02A              jnz L27
 01DA                   .dbline 244
 01DA           ;                       {
 01DA                   .dbline 246
 01DA           ;                               // If this is for me, check who it was from.
 01DA           ;                               if(COMMAND_DESTINATION == PARENT_ID)
 01DA 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 01DD 3C0000            cmp [_COMMAND_DESTINATION],0
 01E0 B022              jnz L29
 01E2                   .dbline 247
 01E2           ;                               {
 01E2                   .dbline 249
 01E2           ;                                       // If it is from the right module, return 1.
 01E2           ;                                       if(COMMAND_SOURCE == assigned_ID)
 01E2 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 01E5 5100              mov A,[_COMMAND_SOURCE]
 01E7 62D000            mov REG[0xd0],>__r0
 01EA 5300              mov [__r1],A
 01EC 5000              mov A,0
 01EE 3BFB              cmp A,[X-5]
 01F0 B012              jnz L31
 01F2 5100              mov A,[__r1]
 01F4 3BFC              cmp A,[X-4]
 01F6 B00C              jnz L31
 01F8           X6:
 01F8                   .dbline 250
 01F8           ;                                       {
 01F8                   .dbline 251
 01F8           ;                                               return 1;
 01F8 62D000            mov REG[0xd0],>__r0
 01FB 550001            mov [__r1],1
 01FE 550000            mov [__r0],0
 0201 8027              xjmp L21
 0203           L31:
 0203                   .dbline 253
 0203           ;                                       }
 0203           ;                               }
 0203           L29:
 0203                   .dbline 254
 0203           ;                       }
 0203           L27:
 0203                   .dbline 255
 0203           ;               }
 0203           L25:
 0203                   .dbline 256
 0203           ;       }
 0203           L23:
 0203                   .dbline 238
 0203 62D000            mov REG[0xd0],>_TIMEOUT
 0206 5101              mov A,[_TIMEOUT+1]
 0208 1105              sub A,5
 020A 5100              mov A,[_TIMEOUT]
 020C 3180              xor A,-128
 020E 1980              sbb A,(0 ^ 0x80)
 0210 CFB2              jc L22
 0212           X7:
 0212                   .dbline 258
 0212           ;       
 0212           ;       RX_TIMEOUT_Stop();
 0212 10                push X
 0213 7C0000            xcall _RX_TIMEOUT_Stop
 0216 20                pop X
 0217                   .dbline 259
 0217           ;       TIMEOUT = 0;
 0217 62D000            mov REG[0xd0],>_TIMEOUT
 021A 550100            mov [_TIMEOUT+1],0
 021D 550000            mov [_TIMEOUT],0
 0220                   .dbline 261
 0220           ;       
 0220           ;       return 0;
 0220 62D000            mov REG[0xd0],>__r0
 0223 550000            mov [__r1],0
 0226 550000            mov [__r0],0
 0229                   .dbline -2
 0229           L21:
 0229 20                pop X
 022A                   .dbline 0 ; func end
 022A 7F                ret
 022B                   .dbsym l assigned_ID -5 I
 022B                   .dbend
 022B                   .dbfunc e sayHello _sayHello fV
 022B           _sayHello::
 022B                   .dbline -1
 022B                   .dbline 266
 022B           ; }
 022B           ; 
 022B           ; // This function transmits a hello message.
 022B           ; void sayHello(void)
 022B           ; {
 022B                   .dbline 268
 022B           ;       // Toggle into PC mode.
 022B           ;       configToggle(PC_MODE);
 022B 5000              mov A,0
 022D 08                push A
 022E 5001              mov A,1
 0230 08                push A
 0231 7C0B94            xcall _configToggle
 0234 38FE              add SP,-2
 0236                   .dbline 271
 0236           ;       
 0236           ;       // Transmit an ID assignment.
 0236           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte one
 0236 10                push X
 0237 50FC              mov A,-4
 0239 7C0000            xcall _TX_REPEATER_14_PutChar
 023C 20                pop X
 023D                   .dbline 272
 023D           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte one
 023D 10                push X
 023E 50FC              mov A,-4
 0240 7C0000            xcall _TX_REPEATER_23_PutChar
 0243 20                pop X
 0244                   .dbline 273
 0244           ;       TX_REPEATER_14_PutChar(START_TRANSMIT); // Start byte two
 0244 10                push X
 0245 50FC              mov A,-4
 0247 7C0000            xcall _TX_REPEATER_14_PutChar
 024A 20                pop X
 024B                   .dbline 274
 024B           ;       TX_REPEATER_23_PutChar(START_TRANSMIT);         // Start byte two
 024B 10                push X
 024C 50FC              mov A,-4
 024E 7C0000            xcall _TX_REPEATER_23_PutChar
 0251 20                pop X
 0252                   .dbline 275
 0252           ;       TX_REPEATER_14_PutChar(PARENT_ID);                      // My ID
 0252 10                push X
 0253 5000              mov A,0
 0255 7C0000            xcall _TX_REPEATER_14_PutChar
 0258 20                pop X
 0259                   .dbline 276
 0259           ;       TX_REPEATER_23_PutChar(PARENT_ID);                      // My ID
 0259 10                push X
 025A 5000              mov A,0
 025C 7C0000            xcall _TX_REPEATER_23_PutChar
 025F 20                pop X
 0260                   .dbline 277
 0260           ;       TX_REPEATER_14_PutChar(BLANK_MODULE_ID);        // Destination ID
 0260 10                push X
 0261 50FB              mov A,-5
 0263 7C0000            xcall _TX_REPEATER_14_PutChar
 0266 20                pop X
 0267                   .dbline 278
 0267           ;       TX_REPEATER_23_PutChar(BLANK_MODULE_ID);        // Destination ID
 0267 10                push X
 0268 50FB              mov A,-5
 026A 7C0000            xcall _TX_REPEATER_23_PutChar
 026D 20                pop X
 026E                   .dbline 279
 026E           ;       TX_REPEATER_14_PutChar(HELLO_BYTE);             // This is a hello message
 026E 10                push X
 026F 50C8              mov A,-56
 0271 7C0000            xcall _TX_REPEATER_14_PutChar
 0274 20                pop X
 0275                   .dbline 280
 0275           ;       TX_REPEATER_23_PutChar(HELLO_BYTE);                     // This is a hello message
 0275 10                push X
 0276 50C8              mov A,-56
 0278 7C0000            xcall _TX_REPEATER_23_PutChar
 027B 20                pop X
 027C                   .dbline 281
 027C           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 027C 10                push X
 027D 50FD              mov A,-3
 027F 7C0000            xcall _TX_REPEATER_14_PutChar
 0282 20                pop X
 0283                   .dbline 282
 0283           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 0283 10                push X
 0284 50FD              mov A,-3
 0286 7C0000            xcall _TX_REPEATER_23_PutChar
 0289 20                pop X
 028A                   .dbline 283
 028A           ;       TX_REPEATER_14_PutChar(END_TRANSMIT);           // This is the end of this transmission
 028A 10                push X
 028B 50FD              mov A,-3
 028D 7C0000            xcall _TX_REPEATER_14_PutChar
 0290 20                pop X
 0291                   .dbline 284
 0291           ;       TX_REPEATER_23_PutChar(END_TRANSMIT);           // This is the end of this transmission
 0291 10                push X
 0292 50FD              mov A,-3
 0294 7C0000            xcall _TX_REPEATER_23_PutChar
 0297 20                pop X
 0298                   .dbline 287
 0298           ;       
 0298           ;       // Make completely sure we're done.
 0298           ;       xmitWait();
 0298 7C0FE3            xcall _xmitWait
 029B                   .dbline 290
 029B           ;       
 029B           ;       // Switch back to listening mode.
 029B           ;       configToggle(RX_MODE);
 029B 5000              mov A,0
 029D 08                push A
 029E 5002              mov A,2
 02A0 08                push A
 02A1 7C0B94            xcall _configToggle
 02A4 38FE              add SP,-2
 02A6                   .dbline -2
 02A6           L33:
 02A6                   .dbline 0 ; func end
 02A6 7F                ret
 02A7                   .dbend
 02A7                   .dbfunc e validTransmission _validTransmission fI
 02A7           ;              i -> X+1
 02A7           ;       tempByte -> X+0
 02A7           _validTransmission::
 02A7                   .dbline -1
 02A7 10                push X
 02A8 4F                mov X,SP
 02A9 3803              add SP,3
 02AB                   .dbline 295
 02AB           ; }
 02AB           ; 
 02AB           ; // This function returns whether or not a valid transmission has been received.
 02AB           ; int validTransmission(void)
 02AB           ; {
 02AB                   .dbline 296
 02AB           ;       int i = 0;                      // Index for looping.
 02AB 560200            mov [X+2],0
 02AE 560100            mov [X+1],0
 02B1                   .dbline 297
 02B1           ;       char tempByte = 0;      // Temporary byte storage.
 02B1 560000            mov [X+0],0
 02B4 809E              xjmp L36
 02B6           L35:
 02B6                   .dbline 302
 02B6           ;       
 02B6           ;       // These loops and conditionals are arranged in a way that allows this read
 02B6           ;       // operation to be completely non-blocking.
 02B6           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 02B6           ;       {
 02B6                   .dbline 304
 02B6           ;               // Wait until we read a start transmit byte.
 02B6           ;               if(iReadChar() == START_TRANSMIT)
 02B6 7C0F2D            xcall _iReadChar
 02B9 62D000            mov REG[0xd0],>__r0
 02BC 39FC              cmp A,-4
 02BE B094              jnz L38
 02C0                   .dbline 305
 02C0           ;               {
 02C0 8083              xjmp L41
 02C2           L40:
 02C2                   .dbline 308
 02C2           ;                       // While we haven't timed out, look for something other than a start byte.
 02C2           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 02C2           ;                       {
 02C2                   .dbline 310
 02C2           ;                               // If we find a nonzero byte...
 02C2           ;                               if(tempByte = iReadChar())
 02C2 7C0F2D            xcall _iReadChar
 02C5 5400              mov [X+0],A
 02C7 3900              cmp A,0
 02C9 A07A              jz L43
 02CB                   .dbline 311
 02CB           ;                               {
 02CB                   .dbline 313
 02CB           ;                                       // If the byte we found isn't a start byte...
 02CB           ;                                       if(tempByte != START_TRANSMIT)
 02CB 3D00FC            cmp [X+0],-4
 02CE A075              jz L45
 02D0                   .dbline 314
 02D0           ;                                       {
 02D0                   .dbline 316
 02D0           ;                                               // This byte is probably the command source.
 02D0           ;                                               COMMAND_SOURCE = tempByte;
 02D0 5200              mov A,[X+0]
 02D2 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 02D5 5300              mov [_COMMAND_SOURCE],A
 02D7 805D              xjmp L48
 02D9           L47:
 02D9                   .dbline 320
 02D9           ;                                               
 02D9           ;                                               // Look for the rest of the command before we time out.
 02D9           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 02D9           ;                                               {
 02D9                   .dbline 322
 02D9           ;                                                       // If we read another nonzero byte...
 02D9           ;                                                       if(tempByte = iReadChar())
 02D9 7C0F2D            xcall _iReadChar
 02DC 62D000            mov REG[0xd0],>__r0
 02DF 5400              mov [X+0],A
 02E1 3900              cmp A,0
 02E3 A051              jz L50
 02E5                   .dbline 323
 02E5           ;                                                       {
 02E5                   .dbline 325
 02E5           ;                                                               // If that byte is in the command type indicator space...
 02E5           ;                                                               if(tempByte >= COMMAND_TYPE_SPACE)
 02E5 3D00C8            cmp [X+0],-56
 02E8 C04C              jc L52
 02EA           X8:
 02EA                   .dbline 326
 02EA           ;                                                               {
 02EA                   .dbline 328
 02EA           ;                                                                       // Store the command type.
 02EA           ;                                                                       COMMAND_TYPE = tempByte;
 02EA 5200              mov A,[X+0]
 02EC 62D000            mov REG[0xd0],>_COMMAND_TYPE
 02EF 5300              mov [_COMMAND_TYPE],A
 02F1 8034              xjmp L55
 02F3           L54:
 02F3                   .dbline 332
 02F3           ;                                                                       
 02F3           ;                                                                       // Continue reading if we have not timed out yet.
 02F3           ;                                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 02F3           ;                                                                       {
 02F3                   .dbline 334
 02F3           ;                                                                               // If we read a nonzero byte...
 02F3           ;                                                                               if(tempByte = iReadChar())
 02F3 7C0F2D            xcall _iReadChar
 02F6 62D000            mov REG[0xd0],>__r0
 02F9 5400              mov [X+0],A
 02FB 3900              cmp A,0
 02FD A028              jz L57
 02FF                   .dbline 335
 02FF           ;                                                                               {
 02FF                   .dbline 337
 02FF           ;                                                                                       // Store the parameter if it is not the end indicator.
 02FF           ;                                                                                       if(tempByte != END_TRANSMIT)
 02FF 3D00FD            cmp [X+0],-3
 0302 A018              jz L59
 0304                   .dbline 338
 0304           ;                                                                                       {
 0304                   .dbline 339
 0304           ;                                                                                               PARAM[i] = tempByte;
 0304 5202              mov A,[X+2]
 0306 0100              add A,<_PARAM
 0308 5300              mov [__r1],A
 030A 5201              mov A,[X+1]
 030C 0900              adc A,>_PARAM
 030E 60D5              mov REG[0xd5],A
 0310 5200              mov A,[X+0]
 0312 3F00              mvi [__r1],A
 0314                   .dbline 340
 0314           ;                                                                                               i++;
 0314 7702              inc [X+2]
 0316 0F0100            adc [X+1],0
 0319                   .dbline 341
 0319           ;                                                                                       }
 0319 800C              xjmp L60
 031B           L59:
 031B                   .dbline 343
 031B           ;                                                                                       else
 031B           ;                                                                                       {
 031B                   .dbline 344
 031B           ;                                                                                               return 1;
 031B 62D000            mov REG[0xd0],>__r0
 031E 550001            mov [__r1],1
 0321 550000            mov [__r0],0
 0324 8046              xjmp L34
 0326           L60:
 0326                   .dbline 346
 0326           ;                                                                                       }
 0326           ;                                                                               }
 0326           L57:
 0326                   .dbline 347
 0326           ;                                                                       }
 0326           L55:
 0326                   .dbline 331
 0326 62D000            mov REG[0xd0],>_TIMEOUT
 0329 5101              mov A,[_TIMEOUT+1]
 032B 1105              sub A,5
 032D 5100              mov A,[_TIMEOUT]
 032F 3180              xor A,-128
 0331 1980              sbb A,(0 ^ 0x80)
 0333 CFBF              jc L54
 0335           X9:
 0335                   .dbline 348
 0335           ;                                                               }
 0335           L52:
 0335                   .dbline 349
 0335           ;                                                       }
 0335           L50:
 0335                   .dbline 350
 0335           ;                                               }
 0335           L48:
 0335                   .dbline 319
 0335 62D000            mov REG[0xd0],>_TIMEOUT
 0338 5101              mov A,[_TIMEOUT+1]
 033A 1105              sub A,5
 033C 5100              mov A,[_TIMEOUT]
 033E 3180              xor A,-128
 0340 1980              sbb A,(0 ^ 0x80)
 0342 CF96              jc L47
 0344           X10:
 0344                   .dbline 351
 0344           ;                                       }
 0344           L45:
 0344                   .dbline 352
 0344           ;                               }
 0344           L43:
 0344                   .dbline 353
 0344           ;                       }
 0344           L41:
 0344                   .dbline 307
 0344 62D000            mov REG[0xd0],>_TIMEOUT
 0347 5101              mov A,[_TIMEOUT+1]
 0349 1105              sub A,5
 034B 5100              mov A,[_TIMEOUT]
 034D 3180              xor A,-128
 034F 1980              sbb A,(0 ^ 0x80)
 0351 CF70              jc L40
 0353           X11:
 0353                   .dbline 354
 0353           ;               }
 0353           L38:
 0353                   .dbline 355
 0353           ;       }
 0353           L36:
 0353                   .dbline 301
 0353 62D000            mov REG[0xd0],>_TIMEOUT
 0356 5101              mov A,[_TIMEOUT+1]
 0358 1105              sub A,5
 035A 5100              mov A,[_TIMEOUT]
 035C 3180              xor A,-128
 035E 1980              sbb A,(0 ^ 0x80)
 0360 CF55              jc L35
 0362           X12:
 0362                   .dbline 357
 0362           ;       
 0362           ;       return 0;
 0362 62D000            mov REG[0xd0],>__r0
 0365 550000            mov [__r1],0
 0368 550000            mov [__r0],0
 036B                   .dbline -2
 036B           L34:
 036B 38FD              add SP,-3
 036D 20                pop X
 036E                   .dbline 0 ; func end
 036E 7F                ret
 036F                   .dbsym l i 1 I
 036F                   .dbsym l tempByte 0 c
 036F                   .dbend
 036F                   .dbfunc e decodeTransmission _decodeTransmission fV
 036F           ;          speed -> X+10
 036F           ;          angle -> X+8
 036F           ;          total -> X+6
 036F           ;             ID -> X+5
 036F           ;   runningTotal -> X+3
 036F           ;       tempByte -> X+2
 036F           ;          param -> X+0
 036F           _decodeTransmission::
 036F                   .dbline -1
 036F 10                push X
 0370 4F                mov X,SP
 0371 380C              add SP,12
 0373                   .dbline 362
 0373           ; }
 0373           ; 
 0373           ; // This function decodes the transmission and takes the correct action.
 0373           ; void decodeTransmission(void)
 0373           ; {
 0373                   .dbline 364
 0373           ;       char* param;                    // Stores the most recent parameter from the buffer.
 0373           ;       char ID = 0;                    // Stores the target module ID.
 0373 560500            mov [X+5],0
 0376                   .dbline 365
 0376           ;       char tempByte = 0;              // Temporary byte storage.
 0376 560200            mov [X+2],0
 0379                   .dbline 368
 0379           ;       char angle[2];                  // Store the two angle bytes for the servo.
 0379           ;       char speed[2];                  // Store the two speed bytes for the servo.
 0379           ;       int total = 0;                  // Used to store the converted total of angle or speed bytes.
 0379 560700            mov [X+7],0
 037C 560600            mov [X+6],0
 037F                   .dbline 369
 037F           ;       int runningTotal = 0;   // Used as part of the dynamic checksum calculation.
 037F 560400            mov [X+4],0
 0382 560300            mov [X+3],0
 0385                   .dbline 372
 0385           ;       
 0385           ;       // Read a parameter from the buffer.
 0385           ;       if(param = COMP_SERIAL_szGetParam())
 0385 10                push X
 0386 7C0000            xcall _COMP_SERIAL_szGetParam
 0389 62D000            mov REG[0xd0],>__r0
 038C 5300              mov [__r0],A
 038E 5A00              mov [__r1],X
 0390 20                pop X
 0391 5100              mov A,[__r1]
 0393 5401              mov [X+1],A
 0395 5100              mov A,[__r0]
 0397 5400              mov [X+0],A
 0399 3C0000            cmp [__r0],0
 039C B006              jnz X13
 039E 3C0000            cmp [__r1],0
 03A1 A61A              jz L62
 03A3           X13:
 03A3                   .dbline 373
 03A3           ;       {
 03A3                   .dbline 374
 03A3           ;               if((param[0] == 'x') || (param[0] == 'X'))
 03A3 62D000            mov REG[0xd0],>__r0
 03A6 5201              mov A,[X+1]
 03A8 5300              mov [__r1],A
 03AA 5200              mov A,[X+0]
 03AC 60D4              mov REG[0xd4],A
 03AE 3E00              mvi A,[__r1]
 03B0 5300              mov [__r1],A
 03B2 550000            mov [__r0],0
 03B5 3C0000            cmp [__r0],0
 03B8 B005              jnz X14
 03BA 3978              cmp A,120
 03BC A00E              jz L66
 03BE           X14:
 03BE 62D000            mov REG[0xd0],>__r0
 03C1 3C0000            cmp [__r0],0
 03C4 B011              jnz L64
 03C6 3C0058            cmp [__r1],88
 03C9 B00C              jnz L64
 03CB           X15:
 03CB           L66:
 03CB                   .dbline 375
 03CB           ;               {
 03CB                   .dbline 377
 03CB           ;                       // Reset the robot.
 03CB           ;                       NUM_MODULES = 0;
 03CB 62D000            mov REG[0xd0],>_NUM_MODULES
 03CE 550100            mov [_NUM_MODULES+1],0
 03D1 550000            mov [_NUM_MODULES],0
 03D4                   .dbline 378
 03D4           ;               }
 03D4 85E7              xjmp L65
 03D6           L64:
 03D6                   .dbline 379
 03D6           ;               else if((param[0] == 'n') || (param[0] == 'N'))
 03D6 62D000            mov REG[0xd0],>__r0
 03D9 5201              mov A,[X+1]
 03DB 5300              mov [__r1],A
 03DD 5200              mov A,[X+0]
 03DF 60D4              mov REG[0xd4],A
 03E1 3E00              mvi A,[__r1]
 03E3 5300              mov [__r1],A
 03E5 550000            mov [__r0],0
 03E8 3C0000            cmp [__r0],0
 03EB B005              jnz X16
 03ED 396E              cmp A,110
 03EF A00E              jz L69
 03F1           X16:
 03F1 62D000            mov REG[0xd0],>__r0
 03F4 3C0000            cmp [__r0],0
 03F7 B035              jnz L67
 03F9 3C004E            cmp [__r1],78
 03FC B030              jnz L67
 03FE           X17:
 03FE           L69:
 03FE                   .dbline 380
 03FE           ;               {
 03FE                   .dbline 381
 03FE           ;                       itoa(param,NUM_MODULES,10);             // Convert the NUM_MODULES int to a char array.
 03FE 5000              mov A,0
 0400 08                push A
 0401 500A              mov A,10
 0403 08                push A
 0404 62D000            mov REG[0xd0],>_NUM_MODULES
 0407 5100              mov A,[_NUM_MODULES]
 0409 08                push A
 040A 5101              mov A,[_NUM_MODULES+1]
 040C 08                push A
 040D 5200              mov A,[X+0]
 040F 08                push A
 0410 5201              mov A,[X+1]
 0412 08                push A
 0413 7C0000            xcall _itoa
 0416 38FA              add SP,-6
 0418                   .dbline 382
 0418           ;                       COMP_SERIAL_PutString(param);   // Send that array out to the PC.
 0418 10                push X
 0419 5200              mov A,[X+0]
 041B 08                push A
 041C 5201              mov A,[X+1]
 041E 5C                mov X,A
 041F 18                pop A
 0420 7C0000            xcall _COMP_SERIAL_PutString
 0423 20                pop X
 0424                   .dbline 383
 0424           ;                       COMP_SERIAL_PutChar('\n');              // End the transmission with the PC.
 0424 10                push X
 0425 500A              mov A,10
 0427 7C0000            xcall _COMP_SERIAL_PutChar
 042A 20                pop X
 042B                   .dbline 384
 042B           ;               }
 042B 8590              xjmp L68
 042D           L67:
 042D                   .dbline 385
 042D           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 042D 62D000            mov REG[0xd0],>__r0
 0430 5201              mov A,[X+1]
 0432 5300              mov [__r1],A
 0434 5200              mov A,[X+0]
 0436 60D4              mov REG[0xd4],A
 0438 3E00              mvi A,[__r1]
 043A 5300              mov [__r1],A
 043C 550000            mov [__r0],0
 043F 3C0000            cmp [__r0],0
 0442 B005              jnz X18
 0444 3977              cmp A,119
 0446 A00E              jz L72
 0448           X18:
 0448 62D000            mov REG[0xd0],>__r0
 044B 3C0000            cmp [__r0],0
 044E B214              jnz L70
 0450 3C0057            cmp [__r1],87
 0453 B20F              jnz L70
 0455           X19:
 0455           L72:
 0455                   .dbline 386
 0455           ;               {
 0455                   .dbline 387
 0455           ;                       if(param = COMP_SERIAL_szGetParam())
 0455 10                push X
 0456 7C0000            xcall _COMP_SERIAL_szGetParam
 0459 62D000            mov REG[0xd0],>__r0
 045C 5300              mov [__r0],A
 045E 5A00              mov [__r1],X
 0460 20                pop X
 0461 5100              mov A,[__r1]
 0463 5401              mov [X+1],A
 0465 5100              mov A,[__r0]
 0467 5400              mov [X+0],A
 0469 3C0000            cmp [__r0],0
 046C B006              jnz X20
 046E 3C0000            cmp [__r1],0
 0471 A54A              jz L71
 0473           X20:
 0473                   .dbline 388
 0473           ;                       {
 0473                   .dbline 390
 0473           ;                               // Convert the ID parameter to a char byte.
 0473           ;                               ID = atoi(param);
 0473 5200              mov A,[X+0]
 0475 08                push A
 0476 5201              mov A,[X+1]
 0478 08                push A
 0479 7C0000            xcall _atoi
 047C 38FE              add SP,-2
 047E 62D000            mov REG[0xd0],>__r0
 0481 5100              mov A,[__r1]
 0483 5405              mov [X+5],A
 0485                   .dbline 392
 0485           ;                               
 0485           ;                               if(param = COMP_SERIAL_szGetParam())
 0485 10                push X
 0486 7C0000            xcall _COMP_SERIAL_szGetParam
 0489 62D000            mov REG[0xd0],>__r0
 048C 5300              mov [__r0],A
 048E 5A00              mov [__r1],X
 0490 20                pop X
 0491 5100              mov A,[__r1]
 0493 5401              mov [X+1],A
 0495 5100              mov A,[__r0]
 0497 5400              mov [X+0],A
 0499 3C0000            cmp [__r0],0
 049C B006              jnz X21
 049E 3C0000            cmp [__r1],0
 04A1 A51A              jz L71
 04A3           X21:
 04A3                   .dbline 393
 04A3           ;                               {
 04A3                   .dbline 394
 04A3           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 04A3 62D000            mov REG[0xd0],>__r0
 04A6 5201              mov A,[X+1]
 04A8 5300              mov [__r1],A
 04AA 5200              mov A,[X+0]
 04AC 60D4              mov REG[0xd4],A
 04AE 3E00              mvi A,[__r1]
 04B0 5300              mov [__r1],A
 04B2 550000            mov [__r0],0
 04B5 3C0000            cmp [__r0],0
 04B8 B005              jnz X22
 04BA 3961              cmp A,97
 04BC A00E              jz L79
 04BE           X22:
 04BE 62D000            mov REG[0xd0],>__r0
 04C1 3C0000            cmp [__r0],0
 04C4 B084              jnz L77
 04C6 3C0041            cmp [__r1],65
 04C9 B07F              jnz L77
 04CB           X23:
 04CB           L79:
 04CB                   .dbline 395
 04CB           ;                                       {
 04CB                   .dbline 396
 04CB           ;                                               if(param = COMP_SERIAL_szGetParam())
 04CB 10                push X
 04CC 7C0000            xcall _COMP_SERIAL_szGetParam
 04CF 62D000            mov REG[0xd0],>__r0
 04D2 5300              mov [__r0],A
 04D4 5A00              mov [__r1],X
 04D6 20                pop X
 04D7 5100              mov A,[__r1]
 04D9 5401              mov [X+1],A
 04DB 5100              mov A,[__r0]
 04DD 5400              mov [X+0],A
 04DF 3C0000            cmp [__r0],0
 04E2 B006              jnz X24
 04E4 3C0000            cmp [__r1],0
 04E7 A4D4              jz L71
 04E9           X24:
 04E9                   .dbline 397
 04E9           ;                                               {
 04E9                   .dbline 399
 04E9           ;                                                       // Get the angle parameter and convert it to an integer.
 04E9           ;                                                       total = atoi(param);
 04E9 5200              mov A,[X+0]
 04EB 08                push A
 04EC 5201              mov A,[X+1]
 04EE 08                push A
 04EF 7C0000            xcall _atoi
 04F2 38FE              add SP,-2
 04F4 62D000            mov REG[0xd0],>__r0
 04F7 5100              mov A,[__r1]
 04F9 5407              mov [X+7],A
 04FB 5100              mov A,[__r0]
 04FD 5406              mov [X+6],A
 04FF                   .dbline 402
 04FF           ;                                                       
 04FF           ;                                                       // Convert the integer into bytes.
 04FF           ;                                                       angle[0] = total%256;
 04FF 5001              mov A,1
 0501 08                push A
 0502 5000              mov A,0
 0504 08                push A
 0505 5206              mov A,[X+6]
 0507 08                push A
 0508 5207              mov A,[X+7]
 050A 08                push A
 050B 7C0000            xcall __divmod_16X16_16
 050E 38FE              add SP,-2
 0510 18                pop A
 0511 5300              mov [__r1],A
 0513 18                pop A
 0514 5100              mov A,[__r1]
 0516 5408              mov [X+8],A
 0518                   .dbline 403
 0518           ;                                                       angle[1] = total/256;
 0518 5001              mov A,1
 051A 08                push A
 051B 5000              mov A,0
 051D 08                push A
 051E 5206              mov A,[X+6]
 0520 08                push A
 0521 5207              mov A,[X+7]
 0523 08                push A
 0524 7C0000            xcall __divmod_16X16_16
 0527 18                pop A
 0528 5300              mov [__r1],A
 052A 18                pop A
 052B 38FE              add SP,-2
 052D 5100              mov A,[__r1]
 052F 5409              mov [X+9],A
 0531                   .dbline 406
 0531           ;                                                       
 0531           ;                                                       // Send the servo the angle.
 0531           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 0531 5209              mov A,[X+9]
 0533 08                push A
 0534 5208              mov A,[X+8]
 0536 08                push A
 0537 501E              mov A,30
 0539 08                push A
 053A 5003              mov A,3
 053C 08                push A
 053D 5005              mov A,5
 053F 08                push A
 0540 5205              mov A,[X+5]
 0542 08                push A
 0543 956E              xcall _longServoInstruction
 0545 38FA              add SP,-6
 0547                   .dbline 407
 0547           ;                                               }
 0547                   .dbline 408
 0547           ;                                       }
 0547 8474              xjmp L71
 0549           L77:
 0549                   .dbline 409
 0549           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 0549 62D000            mov REG[0xd0],>__r0
 054C 5201              mov A,[X+1]
 054E 5300              mov [__r1],A
 0550 5200              mov A,[X+0]
 0552 60D4              mov REG[0xd4],A
 0554 3E00              mvi A,[__r1]
 0556 5300              mov [__r1],A
 0558 550000            mov [__r0],0
 055B 3C0000            cmp [__r0],0
 055E B005              jnz X25
 0560 3970              cmp A,112
 0562 A00E              jz L86
 0564           X25:
 0564 62D000            mov REG[0xd0],>__r0
 0567 3C0000            cmp [__r0],0
 056A B045              jnz L84
 056C 3C0050            cmp [__r1],80
 056F B040              jnz L84
 0571           X26:
 0571           L86:
 0571                   .dbline 410
 0571           ;                                       {
 0571                   .dbline 411
 0571           ;                                               if(param = COMP_SERIAL_szGetParam())
 0571 10                push X
 0572 7C0000            xcall _COMP_SERIAL_szGetParam
 0575 62D000            mov REG[0xd0],>__r0
 0578 5300              mov [__r0],A
 057A 5A00              mov [__r1],X
 057C 20                pop X
 057D 5100              mov A,[__r1]
 057F 5401              mov [X+1],A
 0581 5100              mov A,[__r0]
 0583 5400              mov [X+0],A
 0585 3C0000            cmp [__r0],0
 0588 B006              jnz X27
 058A 3C0000            cmp [__r1],0
 058D A42E              jz L71
 058F           X27:
 058F                   .dbline 412
 058F           ;                                               {
 058F                   .dbline 414
 058F           ;                                                       // Send the servo the desired power value.
 058F           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 058F 5200              mov A,[X+0]
 0591 08                push A
 0592 5201              mov A,[X+1]
 0594 08                push A
 0595 7C0000            xcall _atoi
 0598 62D000            mov REG[0xd0],>__r0
 059B 5100              mov A,[__r1]
 059D 08                push A
 059E 5018              mov A,24
 05A0 08                push A
 05A1 5003              mov A,3
 05A3 08                push A
 05A4 5004              mov A,4
 05A6 08                push A
 05A7 5205              mov A,[X+5]
 05A9 08                push A
 05AA 943B              xcall _servoInstruction
 05AC 38F9              add SP,-7
 05AE                   .dbline 415
 05AE           ;                                               }
 05AE                   .dbline 416
 05AE           ;                                       }
 05AE 840D              xjmp L71
 05B0           L84:
 05B0                   .dbline 417
 05B0           ;                                       else if((param[0] == 's') || (param[0] == 'S'))
 05B0 62D000            mov REG[0xd0],>__r0
 05B3 5201              mov A,[X+1]
 05B5 5300              mov [__r1],A
 05B7 5200              mov A,[X+0]
 05B9 60D4              mov REG[0xd4],A
 05BB 3E00              mvi A,[__r1]
 05BD 5300              mov [__r1],A
 05BF 550000            mov [__r0],0
 05C2 3C0000            cmp [__r0],0
 05C5 B005              jnz X28
 05C7 3973              cmp A,115
 05C9 A00E              jz L91
 05CB           X28:
 05CB 62D000            mov REG[0xd0],>__r0
 05CE 3C0000            cmp [__r0],0
 05D1 B3EA              jnz L71
 05D3 3C0053            cmp [__r1],83
 05D6 B3E5              jnz L71
 05D8           X29:
 05D8           L91:
 05D8                   .dbline 418
 05D8           ;                                       {
 05D8                   .dbline 419
 05D8           ;                                               if(param = COMP_SERIAL_szGetParam())
 05D8 10                push X
 05D9 7C0000            xcall _COMP_SERIAL_szGetParam
 05DC 62D000            mov REG[0xd0],>__r0
 05DF 5300              mov [__r0],A
 05E1 5A00              mov [__r1],X
 05E3 20                pop X
 05E4 5100              mov A,[__r1]
 05E6 5401              mov [X+1],A
 05E8 5100              mov A,[__r0]
 05EA 5400              mov [X+0],A
 05EC 3C0000            cmp [__r0],0
 05EF B006              jnz X30
 05F1 3C0000            cmp [__r1],0
 05F4 A3C7              jz L71
 05F6           X30:
 05F6                   .dbline 420
 05F6           ;                                               {
 05F6                   .dbline 422
 05F6           ;                                                       // Get the speed parameter and convert it to an integer.
 05F6           ;                                                       total = atoi(param);
 05F6 5200              mov A,[X+0]
 05F8 08                push A
 05F9 5201              mov A,[X+1]
 05FB 08                push A
 05FC 7C0000            xcall _atoi
 05FF 38FE              add SP,-2
 0601 62D000            mov REG[0xd0],>__r0
 0604 5100              mov A,[__r1]
 0606 5407              mov [X+7],A
 0608 5100              mov A,[__r0]
 060A 5406              mov [X+6],A
 060C                   .dbline 425
 060C           ;                                                       
 060C           ;                                                       // If no total, do nothing because 0 is no speed control (undesired).
 060C           ;                                                       if(total)
 060C 3D0600            cmp [X+6],0
 060F B006              jnz X31
 0611 3D0700            cmp [X+7],0
 0614 A3A7              jz L71
 0616           X31:
 0616                   .dbline 426
 0616           ;                                                       {
 0616                   .dbline 428
 0616           ;                                                               // Convert the integer into bytes.
 0616           ;                                                               speed[0] = total%256;
 0616 62D000            mov REG[0xd0],>__r0
 0619 5001              mov A,1
 061B 08                push A
 061C 5000              mov A,0
 061E 08                push A
 061F 5206              mov A,[X+6]
 0621 08                push A
 0622 5207              mov A,[X+7]
 0624 08                push A
 0625 7C0000            xcall __divmod_16X16_16
 0628 38FE              add SP,-2
 062A 18                pop A
 062B 5300              mov [__r1],A
 062D 18                pop A
 062E 5100              mov A,[__r1]
 0630 540A              mov [X+10],A
 0632                   .dbline 429
 0632           ;                                                               speed[1] = total/256;
 0632 5001              mov A,1
 0634 08                push A
 0635 5000              mov A,0
 0637 08                push A
 0638 5206              mov A,[X+6]
 063A 08                push A
 063B 5207              mov A,[X+7]
 063D 08                push A
 063E 7C0000            xcall __divmod_16X16_16
 0641 18                pop A
 0642 5300              mov [__r1],A
 0644 18                pop A
 0645 38FE              add SP,-2
 0647 5100              mov A,[__r1]
 0649 540B              mov [X+11],A
 064B                   .dbline 432
 064B           ;                                                               
 064B           ;                                                               // Write the speed value to the servo.
 064B           ;                                                               longServoInstruction(ID,5,WRITE_SERVO,32,speed[0],speed[1]);
 064B 520B              mov A,[X+11]
 064D 08                push A
 064E 520A              mov A,[X+10]
 0650 08                push A
 0651 5020              mov A,32
 0653 08                push A
 0654 5003              mov A,3
 0656 08                push A
 0657 5005              mov A,5
 0659 08                push A
 065A 5205              mov A,[X+5]
 065C 08                push A
 065D 9454              xcall _longServoInstruction
 065F 38FA              add SP,-6
 0661                   .dbline 433
 0661           ;                                                       }
 0661                   .dbline 434
 0661           ;                                               }
 0661                   .dbline 435
 0661           ;                                       }
 0661                   .dbline 436
 0661           ;                               }
 0661                   .dbline 437
 0661           ;                       }
 0661                   .dbline 438
 0661           ;               }
 0661 835A              xjmp L71
 0663           L70:
 0663                   .dbline 439
 0663           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 0663 62D000            mov REG[0xd0],>__r0
 0666 5201              mov A,[X+1]
 0668 5300              mov [__r1],A
 066A 5200              mov A,[X+0]
 066C 60D4              mov REG[0xd4],A
 066E 3E00              mvi A,[__r1]
 0670 5300              mov [__r1],A
 0672 550000            mov [__r0],0
 0675 3C0000            cmp [__r0],0
 0678 B005              jnz X32
 067A 3972              cmp A,114
 067C A00E              jz L100
 067E           X32:
 067E 62D000            mov REG[0xd0],>__r0
 0681 3C0000            cmp [__r0],0
 0684 B337              jnz L98
 0686 3C0052            cmp [__r1],82
 0689 B332              jnz L98
 068B           X33:
 068B           L100:
 068B                   .dbline 440
 068B           ;               {                       
 068B                   .dbline 441
 068B           ;                       if(param = COMP_SERIAL_szGetParam())
 068B 10                push X
 068C 7C0000            xcall _COMP_SERIAL_szGetParam
 068F 62D000            mov REG[0xd0],>__r0
 0692 5300              mov [__r0],A
 0694 5A00              mov [__r1],X
 0696 20                pop X
 0697 5100              mov A,[__r1]
 0699 5401              mov [X+1],A
 069B 5100              mov A,[__r0]
 069D 5400              mov [X+0],A
 069F 3C0000            cmp [__r0],0
 06A2 B006              jnz X34
 06A4 3C0000            cmp [__r1],0
 06A7 A314              jz L101
 06A9           X34:
 06A9                   .dbline 442
 06A9           ;                       {
 06A9                   .dbline 444
 06A9           ;                               // Extract the target ID param and convert it to an integer.
 06A9           ;                               ID = atoi(param);
 06A9 5200              mov A,[X+0]
 06AB 08                push A
 06AC 5201              mov A,[X+1]
 06AE 08                push A
 06AF 7C0000            xcall _atoi
 06B2 38FE              add SP,-2
 06B4 62D000            mov REG[0xd0],>__r0
 06B7 5100              mov A,[__r1]
 06B9 5405              mov [X+5],A
 06BB                   .dbline 446
 06BB           ;                               
 06BB           ;                               if(param = COMP_SERIAL_szGetParam())
 06BB 10                push X
 06BC 7C0000            xcall _COMP_SERIAL_szGetParam
 06BF 62D000            mov REG[0xd0],>__r0
 06C2 5300              mov [__r0],A
 06C4 5A00              mov [__r1],X
 06C6 20                pop X
 06C7 5100              mov A,[__r1]
 06C9 5401              mov [X+1],A
 06CB 5100              mov A,[__r0]
 06CD 5400              mov [X+0],A
 06CF 3C0000            cmp [__r0],0
 06D2 B006              jnz X35
 06D4 3C0000            cmp [__r1],0
 06D7 A2E4              jz L103
 06D9           X35:
 06D9                   .dbline 447
 06D9           ;                               {
 06D9                   .dbline 448
 06D9           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 06D9 62D000            mov REG[0xd0],>__r0
 06DC 5201              mov A,[X+1]
 06DE 5300              mov [__r1],A
 06E0 5200              mov A,[X+0]
 06E2 60D4              mov REG[0xd4],A
 06E4 3E00              mvi A,[__r1]
 06E6 5300              mov [__r1],A
 06E8 550000            mov [__r0],0
 06EB 3C0000            cmp [__r0],0
 06EE B005              jnz X36
 06F0 3961              cmp A,97
 06F2 A00E              jz L107
 06F4           X36:
 06F4 62D000            mov REG[0xd0],>__r0
 06F7 3C0000            cmp [__r0],0
 06FA B0C6              jnz L105
 06FC 3C0041            cmp [__r1],65
 06FF B0C1              jnz L105
 0701           X37:
 0701           L107:
 0701                   .dbline 449
 0701           ;                                       {
 0701                   .dbline 451
 0701           ;                                               // Initialize the angle bytes to 0.
 0701           ;                                               angle[0] = 0;
 0701 560800            mov [X+8],0
 0704                   .dbline 452
 0704           ;                                               angle[1] = 0;
 0704 560900            mov [X+9],0
 0707                   .dbline 455
 0707           ;                                               
 0707           ;                                               // Send a request to the servo for its angle.
 0707           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 0707 5002              mov A,2
 0709 08                push A
 070A 5024              mov A,36
 070C 08                push A
 070D 5002              mov A,2
 070F 08                push A
 0710 5004              mov A,4
 0712 08                push A
 0713 5205              mov A,[X+5]
 0715 08                push A
 0716 92CF              xcall _servoInstruction
 0718                   .dbline 458
 0718           ;                                               
 0718           ;                                               // Switch to read the response.
 0718           ;                                               configToggle(RX_MODE);
 0718 5000              mov A,0
 071A 08                push A
 071B 5002              mov A,2
 071D 08                push A
 071E 9474              xcall _configToggle
 0720 38F9              add SP,-7
 0722 808D              xjmp L110
 0724           L109:
 0724                   .dbline 462
 0724           ;                                                       
 0724           ;                                               // Loop until we read a response or time out.
 0724           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0724           ;                                               {
 0724                   .dbline 464
 0724           ;                                                       // If the response is from the right ID...
 0724           ;                                                       if(iReadChar() == ID)
 0724 7C0F2D            xcall _iReadChar
 0727 62D000            mov REG[0xd0],>__r0
 072A 3B05              cmp A,[X+5]
 072C B083              jnz L112
 072E                   .dbline 465
 072E           ;                                                       {
 072E 8072              xjmp L115
 0730           L114:
 0730                   .dbline 467
 0730           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0730           ;                                                               {
 0730                   .dbline 469
 0730           ;                                                                       // The length of the response remainder should be 4.
 0730           ;                                                                       if(iReadChar() == 4)
 0730 97FB              xcall _iReadChar
 0732 62D000            mov REG[0xd0],>__r0
 0735 3904              cmp A,4
 0737 B069              jnz L117
 0739                   .dbline 470
 0739           ;                                                                       {
 0739                   .dbline 472
 0739           ;                                                                               // The error value should be 0 if successful.
 0739           ;                                                                               if(readChar() == 0)
 0739 7C0F7B            xcall _readChar
 073C 62D000            mov REG[0xd0],>__r0
 073F 3900              cmp A,0
 0741 B056              jnz L119
 0743                   .dbline 473
 0743           ;                                                                               {
 0743                   .dbline 475
 0743           ;                                                                                       // Grab the bytes from the buffer.
 0743           ;                                                                                       angle[0] = readChar();
 0743 7C0F7B            xcall _readChar
 0746 62D000            mov REG[0xd0],>__r0
 0749 5408              mov [X+8],A
 074B                   .dbline 476
 074B           ;                                                                                       angle[1] = readChar();
 074B 7C0F7B            xcall _readChar
 074E 62D000            mov REG[0xd0],>__r0
 0751 5409              mov [X+9],A
 0753                   .dbline 479
 0753           ;                                                                                       
 0753           ;                                                                                       // Switch to PC mode to forward the response.
 0753           ;                                                                                       configToggle(PC_MODE);
 0753 5000              mov A,0
 0755 08                push A
 0756 5001              mov A,1
 0758 08                push A
 0759 9439              xcall _configToggle
 075B                   .dbline 482
 075B           ;                                                                                       
 075B           ;                                                                                       // Convert the bytes to an integer.
 075B           ;                                                                                       total = ((angle[1])*256) + angle[0];
 075B 5208              mov A,[X+8]
 075D 5407              mov [X+7],A
 075F 5209              mov A,[X+9]
 0761 5406              mov [X+6],A
 0763                   .dbline 485
 0763           ;                                                                                       
 0763           ;                                                                                       // Convert the integer to a character array.
 0763           ;                                                                                       itoa(param,total,10);
 0763 5000              mov A,0
 0765 08                push A
 0766 500A              mov A,10
 0768 08                push A
 0769 5206              mov A,[X+6]
 076B 08                push A
 076C 5207              mov A,[X+7]
 076E 08                push A
 076F 5200              mov A,[X+0]
 0771 08                push A
 0772 5201              mov A,[X+1]
 0774 08                push A
 0775 7C0000            xcall _itoa
 0778 38F8              add SP,-8
 077A                   .dbline 488
 077A           ;                                                                                       
 077A           ;                                                                                       // Write the response to the computer.
 077A           ;                                                                                       COMP_SERIAL_PutString(param);
 077A 10                push X
 077B 5200              mov A,[X+0]
 077D 08                push A
 077E 5201              mov A,[X+1]
 0780 5C                mov X,A
 0781 18                pop A
 0782 7C0000            xcall _COMP_SERIAL_PutString
 0785 20                pop X
 0786                   .dbline 489
 0786           ;                                                                                       COMP_SERIAL_PutChar('\n');
 0786 10                push X
 0787 500A              mov A,10
 0789 7C0000            xcall _COMP_SERIAL_PutChar
 078C 20                pop X
 078D                   .dbline 492
 078D           ; 
 078D           ;                                                                                       // Force a timeout to exit all loops.
 078D           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 078D 62D000            mov REG[0xd0],>_TIMEOUT
 0790 550105            mov [_TIMEOUT+1],5
 0793 550000            mov [_TIMEOUT],0
 0796                   .dbline 493
 0796           ;                                                                               }
 0796 800A              xjmp L120
 0798           L119:
 0798                   .dbline 495
 0798           ;                                                                               else
 0798           ;                                                                               {
 0798                   .dbline 497
 0798           ;                                                                                       // Force a timeout to exit all loops.
 0798           ;                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 0798 62D000            mov REG[0xd0],>_TIMEOUT
 079B 550105            mov [_TIMEOUT+1],5
 079E 550000            mov [_TIMEOUT],0
 07A1                   .dbline 498
 07A1           ;                                                                               }
 07A1           L120:
 07A1                   .dbline 499
 07A1           ;                                                                       }
 07A1           L117:
 07A1                   .dbline 500
 07A1           ;                                                               }
 07A1           L115:
 07A1                   .dbline 466
 07A1 62D000            mov REG[0xd0],>_TIMEOUT
 07A4 5101              mov A,[_TIMEOUT+1]
 07A6 1105              sub A,5
 07A8 5100              mov A,[_TIMEOUT]
 07AA 3180              xor A,-128
 07AC 1980              sbb A,(0 ^ 0x80)
 07AE CF81              jc L114
 07B0           X38:
 07B0                   .dbline 501
 07B0           ;                                                       }
 07B0           L112:
 07B0                   .dbline 502
 07B0           ;                                               }
 07B0           L110:
 07B0                   .dbline 461
 07B0 62D000            mov REG[0xd0],>_TIMEOUT
 07B3 5101              mov A,[_TIMEOUT+1]
 07B5 1105              sub A,5
 07B7 5100              mov A,[_TIMEOUT]
 07B9 3180              xor A,-128
 07BB 1980              sbb A,(0 ^ 0x80)
 07BD CF66              jc L109
 07BF           X39:
 07BF                   .dbline 503
 07BF           ;                                       }
 07BF 81FC              xjmp L106
 07C1           L105:
 07C1                   .dbline 504
 07C1           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 07C1 62D000            mov REG[0xd0],>__r0
 07C4 5201              mov A,[X+1]
 07C6 5300              mov [__r1],A
 07C8 5200              mov A,[X+0]
 07CA 60D4              mov REG[0xd4],A
 07CC 3E00              mvi A,[__r1]
 07CE 5300              mov [__r1],A
 07D0 550000            mov [__r0],0
 07D3 3C0000            cmp [__r0],0
 07D6 B005              jnz X40
 07D8 3970              cmp A,112
 07DA A00E              jz L125
 07DC           X40:
 07DC 62D000            mov REG[0xd0],>__r0
 07DF 3C0000            cmp [__r0],0
 07E2 B0E6              jnz L123
 07E4 3C0050            cmp [__r1],80
 07E7 B0E1              jnz L123
 07E9           X41:
 07E9           L125:
 07E9                   .dbline 505
 07E9           ;                                       {
 07E9                   .dbline 507
 07E9           ;                                               // Send a request to the servo for its power status.
 07E9           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 07E9 5001              mov A,1
 07EB 08                push A
 07EC 5018              mov A,24
 07EE 08                push A
 07EF 5002              mov A,2
 07F1 08                push A
 07F2 5004              mov A,4
 07F4 08                push A
 07F5 5205              mov A,[X+5]
 07F7 08                push A
 07F8 91ED              xcall _servoInstruction
 07FA                   .dbline 510
 07FA           ;                                               
 07FA           ;                                               // Switch to read the response.
 07FA           ;                                               configToggle(RX_MODE);
 07FA 5000              mov A,0
 07FC 08                push A
 07FD 5002              mov A,2
 07FF 08                push A
 0800 9392              xcall _configToggle
 0802 38F9              add SP,-7
 0804 80B3              xjmp L127
 0806           L126:
 0806                   .dbline 514
 0806           ;                                               
 0806           ;                                               // Loop until we read a response or time out.
 0806           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0806           ;                                               {
 0806                   .dbline 515
 0806           ;                                                       if(iReadChar() == ID)
 0806 9725              xcall _iReadChar
 0808 62D000            mov REG[0xd0],>__r0
 080B 3B05              cmp A,[X+5]
 080D B0AA              jnz L129
 080F                   .dbline 516
 080F           ;                                                       {
 080F                   .dbline 517
 080F           ;                                                               runningTotal = ID;
 080F 5205              mov A,[X+5]
 0811 5404              mov [X+4],A
 0813 560300            mov [X+3],0
 0816 8092              xjmp L132
 0818           L131:
 0818                   .dbline 520
 0818           ;                                                               // Loop until we read a response or time out.
 0818           ;                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0818           ;                                                               {
 0818                   .dbline 522
 0818           ;                                                                       // Check the length of the packet.
 0818           ;                                                                       if(iReadChar() == 3)
 0818 9713              xcall _iReadChar
 081A 62D000            mov REG[0xd0],>__r0
 081D 3903              cmp A,3
 081F B089              jnz L134
 0821                   .dbline 523
 0821           ;                                                                       {
 0821                   .dbline 525
 0821           ;                                                                               // Tack the value onto our running total.
 0821           ;                                                                               runningTotal += 3;
 0821 070403            add [X+4],3
 0824 0F0300            adc [X+3],0
 0827 8072              xjmp L137
 0829           L136:
 0829                   .dbline 529
 0829           ;                                                                               
 0829           ;                                                                               // Loop until we read a response or time out.
 0829           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0829           ;                                                                               {
 0829                   .dbline 531
 0829           ;                                                                                       // Check for the checksum or 1.
 0829           ;                                                                                       if(tempByte = iReadChar())
 0829 9702              xcall _iReadChar
 082B 62D000            mov REG[0xd0],>__r0
 082E 5402              mov [X+2],A
 0830 3900              cmp A,0
 0832 A067              jz L139
 0834                   .dbline 532
 0834           ;                                                                                       {
 0834                   .dbline 534
 0834           ;                                                                                               // Switch to PC mode to forward the result.
 0834           ;                                                                                               configToggle(PC_MODE);
 0834 5000              mov A,0
 0836 08                push A
 0837 5001              mov A,1
 0839 08                push A
 083A 9358              xcall _configToggle
 083C 38FE              add SP,-2
 083E                   .dbline 536
 083E           ;                                                                                               
 083E           ;                                                                                               if((runningTotal%256) == (255-tempByte))
 083E 62D000            mov REG[0xd0],>__r0
 0841 5202              mov A,[X+2]
 0843 5300              mov [__r1],A
 0845 550000            mov [__r0],0
 0848 50FF              mov A,-1
 084A 1200              sub A,[__r1]
 084C 5300              mov [__r1],A
 084E 5000              mov A,0
 0850 1A00              sbb A,[__r0]
 0852 5300              mov [__r0],A
 0854 5001              mov A,1
 0856 08                push A
 0857 5000              mov A,0
 0859 08                push A
 085A 5203              mov A,[X+3]
 085C 08                push A
 085D 5204              mov A,[X+4]
 085F 08                push A
 0860 7C0000            xcall __divmod_16X16_16
 0863 38FE              add SP,-2
 0865 18                pop A
 0866 5300              mov [__r3],A
 0868 18                pop A
 0869 3A00              cmp A,[__r0]
 086B B017              jnz L141
 086D 5100              mov A,[__r3]
 086F 3A00              cmp A,[__r1]
 0871 B011              jnz L141
 0873           X42:
 0873                   .dbline 537
 0873           ;                                                                                               {
 0873                   .dbline 539
 0873           ;                                                                                                       // Send a 0 if we hit the checksum.
 0873           ;                                                                                                       COMP_SERIAL_PutChar('0');
 0873 10                push X
 0874 5030              mov A,48
 0876 7C0000            xcall _COMP_SERIAL_PutChar
 0879 20                pop X
 087A                   .dbline 540
 087A           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 087A 10                push X
 087B 500A              mov A,10
 087D 7C0000            xcall _COMP_SERIAL_PutChar
 0880 20                pop X
 0881                   .dbline 541
 0881           ;                                                                                               }
 0881 800F              xjmp L142
 0883           L141:
 0883                   .dbline 543
 0883           ;                                                                                               else
 0883           ;                                                                                               {
 0883                   .dbline 545
 0883           ;                                                                                                       // Send a 1 if we hit it first.
 0883           ;                                                                                                       COMP_SERIAL_PutChar('1');
 0883 10                push X
 0884 5031              mov A,49
 0886 7C0000            xcall _COMP_SERIAL_PutChar
 0889 20                pop X
 088A                   .dbline 546
 088A           ;                                                                                                       COMP_SERIAL_PutChar('\n');
 088A 10                push X
 088B 500A              mov A,10
 088D 7C0000            xcall _COMP_SERIAL_PutChar
 0890 20                pop X
 0891                   .dbline 547
 0891           ;                                                                                               }
 0891           L142:
 0891                   .dbline 549
 0891           ;               
 0891           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 0891 62D000            mov REG[0xd0],>_TIMEOUT
 0894 550105            mov [_TIMEOUT+1],5
 0897 550000            mov [_TIMEOUT],0
 089A                   .dbline 550
 089A           ;                                                                                       }
 089A           L139:
 089A                   .dbline 551
 089A           ;                                                                               }
 089A           L137:
 089A                   .dbline 528
 089A 62D000            mov REG[0xd0],>_TIMEOUT
 089D 5101              mov A,[_TIMEOUT+1]
 089F 1105              sub A,5
 08A1 5100              mov A,[_TIMEOUT]
 08A3 3180              xor A,-128
 08A5 1980              sbb A,(0 ^ 0x80)
 08A7 CF81              jc L136
 08A9           X43:
 08A9                   .dbline 552
 08A9           ;                                                                       }
 08A9           L134:
 08A9                   .dbline 553
 08A9           ;                                                               }
 08A9           L132:
 08A9                   .dbline 519
 08A9 62D000            mov REG[0xd0],>_TIMEOUT
 08AC 5101              mov A,[_TIMEOUT+1]
 08AE 1105              sub A,5
 08B0 5100              mov A,[_TIMEOUT]
 08B2 3180              xor A,-128
 08B4 1980              sbb A,(0 ^ 0x80)
 08B6 CF61              jc L131
 08B8           X44:
 08B8                   .dbline 554
 08B8           ;                                                       }
 08B8           L129:
 08B8                   .dbline 555
 08B8           ;                                               }
 08B8           L127:
 08B8                   .dbline 513
 08B8 62D000            mov REG[0xd0],>_TIMEOUT
 08BB 5101              mov A,[_TIMEOUT+1]
 08BD 1105              sub A,5
 08BF 5100              mov A,[_TIMEOUT]
 08C1 3180              xor A,-128
 08C3 1980              sbb A,(0 ^ 0x80)
 08C5 CF40              jc L126
 08C7           X45:
 08C7                   .dbline 556
 08C7           ;                                       }
 08C7 80F4              xjmp L124
 08C9           L123:
 08C9                   .dbline 557
 08C9           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 08C9 62D000            mov REG[0xd0],>__r0
 08CC 5201              mov A,[X+1]
 08CE 5300              mov [__r1],A
 08D0 5200              mov A,[X+0]
 08D2 60D4              mov REG[0xd4],A
 08D4 3E00              mvi A,[__r1]
 08D6 5300              mov [__r1],A
 08D8 550000            mov [__r0],0
 08DB 3C0000            cmp [__r0],0
 08DE B005              jnz X46
 08E0 3974              cmp A,116
 08E2 A00E              jz L145
 08E4           X46:
 08E4 62D000            mov REG[0xd0],>__r0
 08E7 3C0000            cmp [__r0],0
 08EA B057              jnz L143
 08EC 3C0054            cmp [__r1],84
 08EF B052              jnz L143
 08F1           X47:
 08F1           L145:
 08F1                   .dbline 558
 08F1           ;                                       {
 08F1                   .dbline 561
 08F1           ;                                               // If this isn't for the parent, ping the module to get a
 08F1           ;                                               // status packet and return the data.
 08F1           ;                                               if(ID == 0)
 08F1 3D0500            cmp [X+5],0
 08F4 B011              jnz L146
 08F6                   .dbline 562
 08F6           ;                                               {
 08F6                   .dbline 563
 08F6           ;                                                       COMP_SERIAL_PutChar(TYPE);
 08F6 10                push X
 08F7 5032              mov A,50
 08F9 7C0000            xcall _COMP_SERIAL_PutChar
 08FC 20                pop X
 08FD                   .dbline 564
 08FD           ;                                                       COMP_SERIAL_PutChar('\n');
 08FD 10                push X
 08FE 500A              mov A,10
 0900 7C0000            xcall _COMP_SERIAL_PutChar
 0903 20                pop X
 0904                   .dbline 565
 0904           ;                                               }
 0904 80B7              xjmp L144
 0906           L146:
 0906                   .dbline 566
 0906           ;                                               else if(pingModule(ID))
 0906 62D000            mov REG[0xd0],>__r0
 0909 5205              mov A,[X+5]
 090B 5300              mov [__r1],A
 090D 5000              mov A,0
 090F 08                push A
 0910 5100              mov A,[__r1]
 0912 08                push A
 0913 7C0043            xcall _pingModule
 0916 38FE              add SP,-2
 0918 62D000            mov REG[0xd0],>__r0
 091B 3C0000            cmp [__r0],0
 091E B006              jnz X48
 0920 3C0000            cmp [__r1],0
 0923 A098              jz L144
 0925           X48:
 0925                   .dbline 567
 0925           ;                                               {
 0925                   .dbline 568
 0925           ;                                                       configToggle(PC_MODE);
 0925 5000              mov A,0
 0927 08                push A
 0928 5001              mov A,1
 092A 08                push A
 092B 9267              xcall _configToggle
 092D 38FE              add SP,-2
 092F                   .dbline 570
 092F           ;                                                                                               
 092F           ;                                                       COMP_SERIAL_PutChar(PARAM[0]);
 092F 10                push X
 0930 62D000            mov REG[0xd0],>_PARAM
 0933 5100              mov A,[_PARAM]
 0935 7C0000            xcall _COMP_SERIAL_PutChar
 0938 20                pop X
 0939                   .dbline 571
 0939           ;                                                       COMP_SERIAL_PutChar('\n');
 0939 10                push X
 093A 500A              mov A,10
 093C 7C0000            xcall _COMP_SERIAL_PutChar
 093F 20                pop X
 0940                   .dbline 572
 0940           ;                                               }
 0940                   .dbline 573
 0940           ;                                       }
 0940 807B              xjmp L144
 0942           L143:
 0942                   .dbline 574
 0942           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 0942 62D000            mov REG[0xd0],>__r0
 0945 5201              mov A,[X+1]
 0947 5300              mov [__r1],A
 0949 5200              mov A,[X+0]
 094B 60D4              mov REG[0xd4],A
 094D 3E00              mvi A,[__r1]
 094F 5300              mov [__r1],A
 0951 550000            mov [__r0],0
 0954 3C0000            cmp [__r0],0
 0957 B005              jnz X49
 0959 3963              cmp A,99
 095B A00E              jz L152
 095D           X49:
 095D 62D000            mov REG[0xd0],>__r0
 0960 3C0000            cmp [__r0],0
 0963 B058              jnz L150
 0965 3C0043            cmp [__r1],67
 0968 B053              jnz L150
 096A           X50:
 096A           L152:
 096A                   .dbline 575
 096A           ;                                       {
 096A                   .dbline 578
 096A           ;                                               // If this isn't for the parent, ping the module to get a
 096A           ;                                               // status packet and return the data.
 096A           ;                                               if(ID == 0)
 096A 3D0500            cmp [X+5],0
 096D B014              jnz L153
 096F                   .dbline 579
 096F           ;                                               {
 096F                   .dbline 580
 096F           ;                                                       COMP_SERIAL_PutChar(CHILD);
 096F 10                push X
 0970 62D000            mov REG[0xd0],>_CHILD
 0973 5100              mov A,[_CHILD]
 0975 7C0000            xcall _COMP_SERIAL_PutChar
 0978 20                pop X
 0979                   .dbline 581
 0979           ;                                                       COMP_SERIAL_PutChar('\n');
 0979 10                push X
 097A 500A              mov A,10
 097C 7C0000            xcall _COMP_SERIAL_PutChar
 097F 20                pop X
 0980                   .dbline 582
 0980           ;                                               }
 0980 803B              xjmp L154
 0982           L153:
 0982                   .dbline 583
 0982           ;                                               else if(pingModule(ID))
 0982 62D000            mov REG[0xd0],>__r0
 0985 5205              mov A,[X+5]
 0987 5300              mov [__r1],A
 0989 5000              mov A,0
 098B 08                push A
 098C 5100              mov A,[__r1]
 098E 08                push A
 098F 7C0043            xcall _pingModule
 0992 38FE              add SP,-2
 0994 62D000            mov REG[0xd0],>__r0
 0997 3C0000            cmp [__r0],0
 099A B006              jnz X51
 099C 3C0000            cmp [__r1],0
 099F A01C              jz L155
 09A1           X51:
 09A1                   .dbline 584
 09A1           ;                                               {       
 09A1                   .dbline 585
 09A1           ;                                                       configToggle(PC_MODE);
 09A1 5000              mov A,0
 09A3 08                push A
 09A4 5001              mov A,1
 09A6 08                push A
 09A7 91EB              xcall _configToggle
 09A9 38FE              add SP,-2
 09AB                   .dbline 587
 09AB           ;                                                       
 09AB           ;                                                       COMP_SERIAL_PutChar(PARAM[1]);
 09AB 10                push X
 09AC 62D000            mov REG[0xd0],>_PARAM
 09AF 5101              mov A,[_PARAM+1]
 09B1 7C0000            xcall _COMP_SERIAL_PutChar
 09B4 20                pop X
 09B5                   .dbline 588
 09B5           ;                                                       COMP_SERIAL_PutChar('\n');
 09B5 10                push X
 09B6 500A              mov A,10
 09B8 7C0000            xcall _COMP_SERIAL_PutChar
 09BB 20                pop X
 09BC                   .dbline 589
 09BC           ;                                               }
 09BC           L155:
 09BC           L154:
 09BC                   .dbline 590
 09BC           ;                                       }
 09BC           L150:
 09BC           L144:
 09BC           L124:
 09BC           L106:
 09BC                   .dbline 591
 09BC           ;                               }
 09BC           L103:
 09BC                   .dbline 592
 09BC           ;                       }
 09BC           L101:
 09BC                   .dbline 593
 09BC           ;               }
 09BC           L98:
 09BC           L71:
 09BC           L68:
 09BC           L65:
 09BC                   .dbline 594
 09BC           ;       }
 09BC           L62:
 09BC                   .dbline 597
 09BC           ;       
 09BC           ;       // Reset the timeout and switch to PC mode.
 09BC           ;       if(STATE != PC_MODE)
 09BC 62D000            mov REG[0xd0],>_STATE
 09BF 3C0000            cmp [_STATE],0
 09C2 B006              jnz X52
 09C4 3C0101            cmp [_STATE+1],1
 09C7 A00D              jz L158
 09C9           X52:
 09C9                   .dbline 598
 09C9           ;       {
 09C9                   .dbline 599
 09C9           ;               configToggle(PC_MODE);
 09C9 5000              mov A,0
 09CB 08                push A
 09CC 5001              mov A,1
 09CE 08                push A
 09CF 91C3              xcall _configToggle
 09D1 38FE              add SP,-2
 09D3                   .dbline 600
 09D3           ;       }
 09D3 800F              xjmp L159
 09D5           L158:
 09D5                   .dbline 602
 09D5           ;       else
 09D5           ;       {
 09D5                   .dbline 603
 09D5           ;               TIMEOUT = 0;
 09D5 62D000            mov REG[0xd0],>_TIMEOUT
 09D8 550100            mov [_TIMEOUT+1],0
 09DB 550000            mov [_TIMEOUT],0
 09DE                   .dbline 604
 09DE           ;               COMP_SERIAL_CmdReset();
 09DE 10                push X
 09DF 7C0000            xcall _COMP_SERIAL_CmdReset
 09E2 20                pop X
 09E3                   .dbline 605
 09E3           ;       }
 09E3           L159:
 09E3                   .dbline -2
 09E3           L61:
 09E3 38F4              add SP,-12
 09E5 20                pop X
 09E6                   .dbline 0 ; func end
 09E6 7F                ret
 09E7                   .dbsym l speed 10 A[2:2]c
 09E7                   .dbsym l angle 8 A[2:2]c
 09E7                   .dbsym l total 6 I
 09E7                   .dbsym l ID 5 c
 09E7                   .dbsym l runningTotal 3 I
 09E7                   .dbsym l tempByte 2 c
 09E7                   .dbsym l param 0 pc
 09E7                   .dbend
 09E7                   .dbfunc e servoInstruction _servoInstruction fV
 09E7           ;          total -> X+1
 09E7           ;       checksum -> X+0
 09E7           ;          value -> X-8
 09E7           ;        address -> X-7
 09E7           ;    instruction -> X-6
 09E7           ;         length -> X-5
 09E7           ;             id -> X-4
 09E7           _servoInstruction::
 09E7                   .dbline -1
 09E7 10                push X
 09E8 4F                mov X,SP
 09E9 3803              add SP,3
 09EB                   .dbline 611
 09EB           ; }
 09EB           ; 
 09EB           ; // This function receives a destination, command length, instruction type, address, and value.
 09EB           ; // With these parameters, the function sends a packet to the communication bus.
 09EB           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 09EB           ; {
 09EB                   .dbline 616
 09EB           ;       char checksum;  // The checksum byte value.
 09EB           ;       int total;              // The total for use in calculating the checksum.
 09EB           ;       
 09EB           ;       // Get the total of all bytes.
 09EB           ;       total = id + length + instruction + address + value;
 09EB 62D000            mov REG[0xd0],>__r0
 09EE 52FB              mov A,[X-5]
 09F0 5300              mov [__r1],A
 09F2 550000            mov [__r0],0
 09F5 52FC              mov A,[X-4]
 09F7 0200              add A,[__r1]
 09F9 5300              mov [__r1],A
 09FB 5000              mov A,0
 09FD 0A00              adc A,[__r0]
 09FF 5300              mov [__r0],A
 0A01 52FA              mov A,[X-6]
 0A03 0400              add [__r1],A
 0A05 0E0000            adc [__r0],0
 0A08 52F9              mov A,[X-7]
 0A0A 0400              add [__r1],A
 0A0C 0E0000            adc [__r0],0
 0A0F 52F8              mov A,[X-8]
 0A11 5300              mov [__r3],A
 0A13 550000            mov [__r2],0
 0A16 5100              mov A,[__r1]
 0A18 0200              add A,[__r3]
 0A1A 5402              mov [X+2],A
 0A1C 5100              mov A,[__r0]
 0A1E 0A00              adc A,[__r2]
 0A20 5401              mov [X+1],A
 0A22                   .dbline 619
 0A22           ;       
 0A22           ;       // Calculate the checksum value for our servo communication.
 0A22           ;       checksum = 255-(total%256);
 0A22 5001              mov A,1
 0A24 08                push A
 0A25 5000              mov A,0
 0A27 08                push A
 0A28 5201              mov A,[X+1]
 0A2A 08                push A
 0A2B 5202              mov A,[X+2]
 0A2D 08                push A
 0A2E 7C0000            xcall __divmod_16X16_16
 0A31 38FE              add SP,-2
 0A33 18                pop A
 0A34 5300              mov [__r1],A
 0A36 18                pop A
 0A37 50FF              mov A,-1
 0A39 1200              sub A,[__r1]
 0A3B 5400              mov [X+0],A
 0A3D                   .dbline 622
 0A3D           ;       
 0A3D           ;       // Talk to the servo.
 0A3D           ;       TX_REPEATER_14_PutChar(SERVO_START);    // Start byte one
 0A3D 10                push X
 0A3E 50FF              mov A,-1
 0A40 7C0000            xcall _TX_REPEATER_14_PutChar
 0A43 20                pop X
 0A44                   .dbline 623
 0A44           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte one
 0A44 10                push X
 0A45 50FF              mov A,-1
 0A47 7C0000            xcall _TX_REPEATER_23_PutChar
 0A4A 20                pop X
 0A4B                   .dbline 624
 0A4B           ;       TX_REPEATER_14_PutChar(SERVO_START);    // Start byte two
 0A4B 10                push X
 0A4C 50FF              mov A,-1
 0A4E 7C0000            xcall _TX_REPEATER_14_PutChar
 0A51 20                pop X
 0A52                   .dbline 625
 0A52           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte two
 0A52 10                push X
 0A53 50FF              mov A,-1
 0A55 7C0000            xcall _TX_REPEATER_23_PutChar
 0A58 20                pop X
 0A59                   .dbline 626
 0A59           ;       TX_REPEATER_14_PutChar(id);                     // The servo ID
 0A59 10                push X
 0A5A 52FC              mov A,[X-4]
 0A5C 7C0000            xcall _TX_REPEATER_14_PutChar
 0A5F 20                pop X
 0A60                   .dbline 627
 0A60           ;       TX_REPEATER_23_PutChar(id);                             // The servo ID
 0A60 10                push X
 0A61 52FC              mov A,[X-4]
 0A63 7C0000            xcall _TX_REPEATER_23_PutChar
 0A66 20                pop X
 0A67                   .dbline 628
 0A67           ;       TX_REPEATER_14_PutChar(length);         // Remaining packet length
 0A67 10                push X
 0A68 52FB              mov A,[X-5]
 0A6A 7C0000            xcall _TX_REPEATER_14_PutChar
 0A6D 20                pop X
 0A6E                   .dbline 629
 0A6E           ;       TX_REPEATER_23_PutChar(length);                 // Remaining packet length
 0A6E 10                push X
 0A6F 52FB              mov A,[X-5]
 0A71 7C0000            xcall _TX_REPEATER_23_PutChar
 0A74 20                pop X
 0A75                   .dbline 630
 0A75           ;       TX_REPEATER_14_PutChar(instruction);    // Servo instruction
 0A75 10                push X
 0A76 52FA              mov A,[X-6]
 0A78 7C0000            xcall _TX_REPEATER_14_PutChar
 0A7B 20                pop X
 0A7C                   .dbline 631
 0A7C           ;       TX_REPEATER_23_PutChar(instruction);    // Servo instruction
 0A7C 10                push X
 0A7D 52FA              mov A,[X-6]
 0A7F 7C0000            xcall _TX_REPEATER_23_PutChar
 0A82 20                pop X
 0A83                   .dbline 632
 0A83           ;       TX_REPEATER_14_PutChar(address);                // Target memory address on the servo EEPROM
 0A83 10                push X
 0A84 52F9              mov A,[X-7]
 0A86 7C0000            xcall _TX_REPEATER_14_PutChar
 0A89 20                pop X
 0A8A                   .dbline 633
 0A8A           ;       TX_REPEATER_23_PutChar(address);                // Target memory address on the servo EEPROM
 0A8A 10                push X
 0A8B 52F9              mov A,[X-7]
 0A8D 7C0000            xcall _TX_REPEATER_23_PutChar
 0A90 20                pop X
 0A91                   .dbline 634
 0A91           ;       TX_REPEATER_14_PutChar(value);                  // The write value or number of bytes to read
 0A91 10                push X
 0A92 52F8              mov A,[X-8]
 0A94 7C0000            xcall _TX_REPEATER_14_PutChar
 0A97 20                pop X
 0A98                   .dbline 635
 0A98           ;       TX_REPEATER_23_PutChar(value);                  // The write value or number of bytes to read
 0A98 10                push X
 0A99 52F8              mov A,[X-8]
 0A9B 7C0000            xcall _TX_REPEATER_23_PutChar
 0A9E 20                pop X
 0A9F                   .dbline 636
 0A9F           ;       TX_REPEATER_14_PutChar(checksum);               // This is the end of this transmission
 0A9F 10                push X
 0AA0 5200              mov A,[X+0]
 0AA2 7C0000            xcall _TX_REPEATER_14_PutChar
 0AA5 20                pop X
 0AA6                   .dbline 637
 0AA6           ;       TX_REPEATER_23_PutChar(checksum);               // This is the end of this transmission
 0AA6 10                push X
 0AA7 5200              mov A,[X+0]
 0AA9 7C0000            xcall _TX_REPEATER_23_PutChar
 0AAC 20                pop X
 0AAD                   .dbline 640
 0AAD           ;       
 0AAD           ;       // Make completely sure we're done.
 0AAD           ;       xmitWait();
 0AAD 9534              xcall _xmitWait
 0AAF                   .dbline -2
 0AAF           L160:
 0AAF 38FD              add SP,-3
 0AB1 20                pop X
 0AB2                   .dbline 0 ; func end
 0AB2 7F                ret
 0AB3                   .dbsym l total 1 I
 0AB3                   .dbsym l checksum 0 c
 0AB3                   .dbsym l value -8 c
 0AB3                   .dbsym l address -7 c
 0AB3                   .dbsym l instruction -6 c
 0AB3                   .dbsym l length -5 c
 0AB3                   .dbsym l id -4 c
 0AB3                   .dbend
 0AB3                   .dbfunc e longServoInstruction _longServoInstruction fV
 0AB3           ;          total -> X+1
 0AB3           ;       checksum -> X+0
 0AB3           ;         value2 -> X-9
 0AB3           ;         value1 -> X-8
 0AB3           ;        address -> X-7
 0AB3           ;    instruction -> X-6
 0AB3           ;         length -> X-5
 0AB3           ;             id -> X-4
 0AB3           _longServoInstruction::
 0AB3                   .dbline -1
 0AB3 10                push X
 0AB4 4F                mov X,SP
 0AB5 3803              add SP,3
 0AB7                   .dbline 645
 0AB7           ; }
 0AB7           ; 
 0AB7           ; // This function receives a destination, command length, instruction type, address, and two values.
 0AB7           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0AB7           ; {
 0AB7                   .dbline 650
 0AB7           ;       char checksum;  // The checksum byte value.
 0AB7           ;       int total;              // The total for use in calculating the checksum.
 0AB7           ;       
 0AB7           ;       // Get the total of all bytes.
 0AB7           ;       total = id + length + instruction + address + value1 + value2;
 0AB7 62D000            mov REG[0xd0],>__r0
 0ABA 52FB              mov A,[X-5]
 0ABC 5300              mov [__r1],A
 0ABE 550000            mov [__r0],0
 0AC1 52FC              mov A,[X-4]
 0AC3 0200              add A,[__r1]
 0AC5 5300              mov [__r1],A
 0AC7 5000              mov A,0
 0AC9 0A00              adc A,[__r0]
 0ACB 5300              mov [__r0],A
 0ACD 52FA              mov A,[X-6]
 0ACF 0400              add [__r1],A
 0AD1 0E0000            adc [__r0],0
 0AD4 52F9              mov A,[X-7]
 0AD6 0400              add [__r1],A
 0AD8 0E0000            adc [__r0],0
 0ADB 52F8              mov A,[X-8]
 0ADD 0400              add [__r1],A
 0ADF 0E0000            adc [__r0],0
 0AE2 52F7              mov A,[X-9]
 0AE4 5300              mov [__r3],A
 0AE6 550000            mov [__r2],0
 0AE9 5100              mov A,[__r1]
 0AEB 0200              add A,[__r3]
 0AED 5402              mov [X+2],A
 0AEF 5100              mov A,[__r0]
 0AF1 0A00              adc A,[__r2]
 0AF3 5401              mov [X+1],A
 0AF5                   .dbline 653
 0AF5           ;       
 0AF5           ;       // Calculate the checksum value for our servo communication.
 0AF5           ;       checksum = 255-(total%256);
 0AF5 5001              mov A,1
 0AF7 08                push A
 0AF8 5000              mov A,0
 0AFA 08                push A
 0AFB 5201              mov A,[X+1]
 0AFD 08                push A
 0AFE 5202              mov A,[X+2]
 0B00 08                push A
 0B01 7C0000            xcall __divmod_16X16_16
 0B04 38FE              add SP,-2
 0B06 18                pop A
 0B07 5300              mov [__r1],A
 0B09 18                pop A
 0B0A 50FF              mov A,-1
 0B0C 1200              sub A,[__r1]
 0B0E 5400              mov [X+0],A
 0B10                   .dbline 656
 0B10           ;       
 0B10           ;       // Talk to the servo.
 0B10           ;       TX_REPEATER_14_PutChar(SERVO_START);    // Start byte one
 0B10 10                push X
 0B11 50FF              mov A,-1
 0B13 7C0000            xcall _TX_REPEATER_14_PutChar
 0B16 20                pop X
 0B17                   .dbline 657
 0B17           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte one
 0B17 10                push X
 0B18 50FF              mov A,-1
 0B1A 7C0000            xcall _TX_REPEATER_23_PutChar
 0B1D 20                pop X
 0B1E                   .dbline 658
 0B1E           ;       TX_REPEATER_14_PutChar(SERVO_START);    // Start byte two
 0B1E 10                push X
 0B1F 50FF              mov A,-1
 0B21 7C0000            xcall _TX_REPEATER_14_PutChar
 0B24 20                pop X
 0B25                   .dbline 659
 0B25           ;       TX_REPEATER_23_PutChar(SERVO_START);    // Start byte two
 0B25 10                push X
 0B26 50FF              mov A,-1
 0B28 7C0000            xcall _TX_REPEATER_23_PutChar
 0B2B 20                pop X
 0B2C                   .dbline 660
 0B2C           ;       TX_REPEATER_14_PutChar(id);                     // The servo ID
 0B2C 10                push X
 0B2D 52FC              mov A,[X-4]
 0B2F 7C0000            xcall _TX_REPEATER_14_PutChar
 0B32 20                pop X
 0B33                   .dbline 661
 0B33           ;       TX_REPEATER_23_PutChar(id);                             // The servo ID
 0B33 10                push X
 0B34 52FC              mov A,[X-4]
 0B36 7C0000            xcall _TX_REPEATER_23_PutChar
 0B39 20                pop X
 0B3A                   .dbline 662
 0B3A           ;       TX_REPEATER_14_PutChar(length);         // Remaining packet length
 0B3A 10                push X
 0B3B 52FB              mov A,[X-5]
 0B3D 7C0000            xcall _TX_REPEATER_14_PutChar
 0B40 20                pop X
 0B41                   .dbline 663
 0B41           ;       TX_REPEATER_23_PutChar(length);                 // Remaining packet length
 0B41 10                push X
 0B42 52FB              mov A,[X-5]
 0B44 7C0000            xcall _TX_REPEATER_23_PutChar
 0B47 20                pop X
 0B48                   .dbline 664
 0B48           ;       TX_REPEATER_14_PutChar(instruction);    // Servo instruction
 0B48 10                push X
 0B49 52FA              mov A,[X-6]
 0B4B 7C0000            xcall _TX_REPEATER_14_PutChar
 0B4E 20                pop X
 0B4F                   .dbline 665
 0B4F           ;       TX_REPEATER_23_PutChar(instruction);    // Servo instruction
 0B4F 10                push X
 0B50 52FA              mov A,[X-6]
 0B52 7C0000            xcall _TX_REPEATER_23_PutChar
 0B55 20                pop X
 0B56                   .dbline 666
 0B56           ;       TX_REPEATER_14_PutChar(address);                // Target memory address on the servo EEPROM
 0B56 10                push X
 0B57 52F9              mov A,[X-7]
 0B59 7C0000            xcall _TX_REPEATER_14_PutChar
 0B5C 20                pop X
 0B5D                   .dbline 667
 0B5D           ;       TX_REPEATER_23_PutChar(address);                // Target memory address on the servo EEPROM
 0B5D 10                push X
 0B5E 52F9              mov A,[X-7]
 0B60 7C0000            xcall _TX_REPEATER_23_PutChar
 0B63 20                pop X
 0B64                   .dbline 668
 0B64           ;       TX_REPEATER_14_PutChar(value1);         // The first write value
 0B64 10                push X
 0B65 52F8              mov A,[X-8]
 0B67 7C0000            xcall _TX_REPEATER_14_PutChar
 0B6A 20                pop X
 0B6B                   .dbline 669
 0B6B           ;       TX_REPEATER_23_PutChar(value1);                 // The first write value
 0B6B 10                push X
 0B6C 52F8              mov A,[X-8]
 0B6E 7C0000            xcall _TX_REPEATER_23_PutChar
 0B71 20                pop X
 0B72                   .dbline 670
 0B72           ;       TX_REPEATER_14_PutChar(value2);         // The second write value
 0B72 10                push X
 0B73 52F7              mov A,[X-9]
 0B75 7C0000            xcall _TX_REPEATER_14_PutChar
 0B78 20                pop X
 0B79                   .dbline 671
 0B79           ;       TX_REPEATER_23_PutChar(value2);                 // The second write value
 0B79 10                push X
 0B7A 52F7              mov A,[X-9]
 0B7C 7C0000            xcall _TX_REPEATER_23_PutChar
 0B7F 20                pop X
 0B80                   .dbline 672
 0B80           ;       TX_REPEATER_14_PutChar(checksum);               // This is the end of this transmission
 0B80 10                push X
 0B81 5200              mov A,[X+0]
 0B83 7C0000            xcall _TX_REPEATER_14_PutChar
 0B86 20                pop X
 0B87                   .dbline 673
 0B87           ;       TX_REPEATER_23_PutChar(checksum);               // This is the end of this transmission
 0B87 10                push X
 0B88 5200              mov A,[X+0]
 0B8A 7C0000            xcall _TX_REPEATER_23_PutChar
 0B8D 20                pop X
 0B8E                   .dbline 676
 0B8E           ;       
 0B8E           ;       // Make completely sure we're done.
 0B8E           ;       xmitWait();
 0B8E 9453              xcall _xmitWait
 0B90                   .dbline -2
 0B90           L161:
 0B90 38FD              add SP,-3
 0B92 20                pop X
 0B93                   .dbline 0 ; func end
 0B93 7F                ret
 0B94                   .dbsym l total 1 I
 0B94                   .dbsym l checksum 0 c
 0B94                   .dbsym l value2 -9 c
 0B94                   .dbsym l value1 -8 c
 0B94                   .dbsym l address -7 c
 0B94                   .dbsym l instruction -6 c
 0B94                   .dbsym l length -5 c
 0B94                   .dbsym l id -4 c
 0B94                   .dbend
 0B94                   .dbfunc e configToggle _configToggle fV
 0B94           ;           mode -> X-5
 0B94           _configToggle::
 0B94                   .dbline -1
 0B94 10                push X
 0B95 4F                mov X,SP
 0B96                   .dbline 682
 0B96           ; }
 0B96           ; 
 0B96           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0B96           ; // half duplex UART serial communication line.
 0B96           ; void configToggle(int mode)
 0B96           ; {
 0B96                   .dbline 684
 0B96           ;       // Disconnect from the global bus and leave the pin high.
 0B96           ;       PRT0DR |= 0b11111111;
 0B96 4300FF            or REG[0],-1
 0B99                   .dbline 685
 0B99           ;       PRT0GS &= 0b00000000;
 0B99 620200            mov REG[0x2],0
 0B9C                   .dbline 689
 0B9C           ; 
 0B9C           ;       // Unload the configuration of the current state.
 0B9C           ;       // If there is no state, blindly wipe all configurations.
 0B9C           ;       if(STATE)
 0B9C 62D000            mov REG[0xd0],>_STATE
 0B9F 3C0000            cmp [_STATE],0
 0BA2 B006              jnz X53
 0BA4 3C0100            cmp [_STATE+1],0
 0BA7 A010              jz L163
 0BA9           X53:
 0BA9                   .dbline 690
 0BA9           ;       {
 0BA9                   .dbline 691
 0BA9           ;               unloadConfig(STATE);
 0BA9 62D000            mov REG[0xd0],>_STATE
 0BAC 5100              mov A,[_STATE]
 0BAE 08                push A
 0BAF 5101              mov A,[_STATE+1]
 0BB1 08                push A
 0BB2 908E              xcall _unloadConfig
 0BB4 38FE              add SP,-2
 0BB6                   .dbline 692
 0BB6           ;       }
 0BB6 8003              xjmp L164
 0BB8           L163:
 0BB8                   .dbline 694
 0BB8           ;       else
 0BB8           ;       {
 0BB8                   .dbline 695
 0BB8           ;               unloadAllConfigs();
 0BB8 9081              xcall _unloadAllConfigs
 0BBA                   .dbline 696
 0BBA           ;       }
 0BBA           L164:
 0BBA                   .dbline 698
 0BBA           ;       
 0BBA           ;       if(mode == PC_MODE)
 0BBA 3DFB00            cmp [X-5],0
 0BBD B035              jnz L165
 0BBF 3DFC01            cmp [X-4],1
 0BC2 B030              jnz L165
 0BC4           X54:
 0BC4                   .dbline 699
 0BC4           ;       {
 0BC4                   .dbline 700
 0BC4           ;               LoadConfig_pc_listener();
 0BC4 7C0000            xcall _LoadConfig_pc_listener
 0BC7                   .dbline 702
 0BC7           ; 
 0BC7           ;               COMP_SERIAL_CmdReset();                                                         // Initialize the buffer.
 0BC7 10                push X
 0BC8 7C0000            xcall _COMP_SERIAL_CmdReset
 0BCB 20                pop X
 0BCC                   .dbline 703
 0BCC           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT);         // Enable RX interrupts  
 0BCC 10                push X
 0BCD 5001              mov A,1
 0BCF 7C0000            xcall _COMP_SERIAL_IntCntl
 0BD2 20                pop X
 0BD3                   .dbline 704
 0BD3           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                            // Starts the UART.
 0BD3 10                push X
 0BD4 5000              mov A,0
 0BD6 7C0000            xcall _COMP_SERIAL_Start
 0BD9 20                pop X
 0BDA                   .dbline 706
 0BDA           ;               
 0BDA           ;               TX_REPEATER_14_Start(TX_REPEATER_14_PARITY_NONE);       // Start the 014 TX repeater.
 0BDA 10                push X
 0BDB 5000              mov A,0
 0BDD 7C0000            xcall _TX_REPEATER_14_Start
 0BE0 20                pop X
 0BE1                   .dbline 707
 0BE1           ;               TX_REPEATER_23_Start(TX_REPEATER_23_PARITY_NONE);       // Start the 23 TX repeater.
 0BE1 10                push X
 0BE2 5000              mov A,0
 0BE4 7C0000            xcall _TX_REPEATER_23_Start
 0BE7 20                pop X
 0BE8                   .dbline 710
 0BE8           ;               
 0BE8           ;               // Store the state.
 0BE8           ;               STATE = PC_MODE;
 0BE8 62D000            mov REG[0xd0],>_STATE
 0BEB 550101            mov [_STATE+1],1
 0BEE 550000            mov [_STATE],0
 0BF1                   .dbline 711
 0BF1           ;       }
 0BF1 8044              xjmp L166
 0BF3           L165:
 0BF3                   .dbline 712
 0BF3           ;       else if(mode == RX_MODE)
 0BF3 3DFB00            cmp [X-5],0
 0BF6 B03F              jnz L167
 0BF8 3DFC02            cmp [X-4],2
 0BFB B03A              jnz L167
 0BFD           X55:
 0BFD                   .dbline 713
 0BFD           ;       {
 0BFD                   .dbline 714
 0BFD           ;               LoadConfig_receiver_config();
 0BFD 7C0000            xcall _LoadConfig_receiver_config
 0C00                   .dbline 718
 0C00           ;               
 0C00           ;               // Start the receivers.
 0C00           ;               // The seemingly unnecessary brackets around each line are unfortunately needed.
 0C00           ;               {
 0C00                   .dbline 720
 0C00           ;               // Start listening for a response through child port 1.
 0C00           ;               RECEIVE_1_Start(RECEIVE_1_PARITY_NONE);
 0C00 10                push X
 0C01 5000              mov A,0
 0C03 7C0000            xcall _RECEIVE_1_Start
 0C06 20                pop X
 0C07                   .dbline 721
 0C07           ;               }
 0C07                   .dbline 723
 0C07           ;               
 0C07           ;               {
 0C07                   .dbline 725
 0C07           ;               // Start listening for a response through child port 2.
 0C07           ;               RECEIVE_2_Start(RECEIVE_2_PARITY_NONE);
 0C07 10                push X
 0C08 5000              mov A,0
 0C0A 7C0000            xcall _RECEIVE_2_Start
 0C0D 20                pop X
 0C0E                   .dbline 726
 0C0E           ;               }
 0C0E                   .dbline 728
 0C0E           ;               
 0C0E           ;               {
 0C0E                   .dbline 730
 0C0E           ;               // Start listening for a response through child port 3.
 0C0E           ;               RECEIVE_3_Start(RECEIVE_3_PARITY_NONE);
 0C0E 10                push X
 0C0F 5000              mov A,0
 0C11 7C0000            xcall _RECEIVE_3_Start
 0C14 20                pop X
 0C15                   .dbline 731
 0C15           ;               }
 0C15                   .dbline 733
 0C15           ;               
 0C15           ;               {
 0C15                   .dbline 735
 0C15           ;               // Start listening for a response through child port 4.
 0C15           ;               RECEIVE_4_Start(RECEIVE_4_PARITY_NONE);
 0C15 10                push X
 0C16 5000              mov A,0
 0C18 7C0000            xcall _RECEIVE_4_Start
 0C1B 20                pop X
 0C1C                   .dbline 736
 0C1C           ;               }
 0C1C                   .dbline 739
 0C1C           ;               
 0C1C           ;               // Start response timeout timer and enable its interrupt routine.
 0C1C           ;               TIMEOUT = 0;
 0C1C 62D000            mov REG[0xd0],>_TIMEOUT
 0C1F 550100            mov [_TIMEOUT+1],0
 0C22 550000            mov [_TIMEOUT],0
 0C25                   .dbline 740
 0C25           ;               RX_TIMEOUT_EnableInt();
 0C25 10                push X
 0C26 7C0000            xcall _RX_TIMEOUT_EnableInt
 0C29                   .dbline 741
 0C29           ;               RX_TIMEOUT_Start();
 0C29 7C0000            xcall _RX_TIMEOUT_Start
 0C2C 20                pop X
 0C2D                   .dbline 744
 0C2D           ;               
 0C2D           ;               // Store the state.
 0C2D           ;               STATE = RX_MODE;
 0C2D 62D000            mov REG[0xd0],>_STATE
 0C30 550102            mov [_STATE+1],2
 0C33 550000            mov [_STATE],0
 0C36                   .dbline 745
 0C36           ;       }
 0C36           L167:
 0C36           L166:
 0C36                   .dbline 748
 0C36           ;       
 0C36           ;       // Reconnect to the global bus.
 0C36           ;       PRT0GS |= 0b11111111;
 0C36 4302FF            or REG[0x2],-1
 0C39                   .dbline -2
 0C39           L162:
 0C39 20                pop X
 0C3A                   .dbline 0 ; func end
 0C3A 7F                ret
 0C3B                   .dbsym l mode -5 I
 0C3B                   .dbend
 0C3B                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0C3B           _unloadAllConfigs::
 0C3B                   .dbline -1
 0C3B                   .dbline 754
 0C3B           ; }
 0C3B           ; 
 0C3B           ; // This function blindly unloads all user configurations. This will be called once,
 0C3B           ; // when the system initially has no known state.
 0C3B           ; void unloadAllConfigs(void)
 0C3B           ; {
 0C3B                   .dbline 755
 0C3B           ;       UnloadConfig_pc_listener();
 0C3B 7C0000            xcall _UnloadConfig_pc_listener
 0C3E                   .dbline 756
 0C3E           ;       UnloadConfig_receiver_config();
 0C3E 7C0000            xcall _UnloadConfig_receiver_config
 0C41                   .dbline -2
 0C41           L169:
 0C41                   .dbline 0 ; func end
 0C41 7F                ret
 0C42                   .dbend
 0C42                   .dbfunc e unloadConfig _unloadConfig fV
 0C42           ;     config_num -> X-5
 0C42           _unloadConfig::
 0C42                   .dbline -1
 0C42 10                push X
 0C43 4F                mov X,SP
 0C44                   .dbline 762
 0C44           ; }
 0C44           ; 
 0C44           ; // This function unloads the configuration corresponding to the config number passed to it.
 0C44           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0C44           ; void unloadConfig(int config_num)
 0C44           ; {
 0C44                   .dbline 763
 0C44           ;       if(config_num == PC_MODE)
 0C44 3DFB00            cmp [X-5],0
 0C47 B00B              jnz L171
 0C49 3DFC01            cmp [X-4],1
 0C4C B006              jnz L171
 0C4E           X56:
 0C4E                   .dbline 764
 0C4E           ;       {
 0C4E                   .dbline 765
 0C4E           ;               UnloadConfig_pc_listener();
 0C4E 7C0000            xcall _UnloadConfig_pc_listener
 0C51                   .dbline 766
 0C51           ;       }
 0C51 800E              xjmp L172
 0C53           L171:
 0C53                   .dbline 767
 0C53           ;       else if(config_num == RX_MODE)
 0C53 3DFB00            cmp [X-5],0
 0C56 B009              jnz L173
 0C58 3DFC02            cmp [X-4],2
 0C5B B004              jnz L173
 0C5D           X57:
 0C5D                   .dbline 768
 0C5D           ;       {
 0C5D                   .dbline 769
 0C5D           ;               UnloadConfig_receiver_config();
 0C5D 7C0000            xcall _UnloadConfig_receiver_config
 0C60                   .dbline 770
 0C60           ;       }
 0C60           L173:
 0C60           L172:
 0C60                   .dbline -2
 0C60           L170:
 0C60 20                pop X
 0C61                   .dbline 0 ; func end
 0C61 7F                ret
 0C62                   .dbsym l config_num -5 I
 0C62                   .dbend
 0C62                   .dbfunc e initializeChildren _initializeChildren fV
 0C62           ;   num_timeouts -> X+4
 0C62           ;     ping_tries -> X+2
 0C62           ;              i -> X+0
 0C62           _initializeChildren::
 0C62                   .dbline -1
 0C62 10                push X
 0C63 4F                mov X,SP
 0C64 3806              add SP,6
 0C66                   .dbline 774
 0C66           ; }
 0C66           ; 
 0C66           ; void initializeChildren(void)
 0C66           ; {
 0C66                   .dbline 775
 0C66           ;       int num_timeouts = 0;   // The number of consecutive timeouts.
 0C66 560500            mov [X+5],0
 0C69 560400            mov [X+4],0
 0C6C                   .dbline 776
 0C6C           ;       int ping_tries = 5;             // The number of times to try a ping on an unregistered module.
 0C6C 560305            mov [X+3],5
 0C6F 560200            mov [X+2],0
 0C72                   .dbline 777
 0C72           ;       int i = 0;                              // An iterator for looping.
 0C72 560100            mov [X+1],0
 0C75 560000            mov [X+0],0
 0C78                   .dbline 780
 0C78           ;       
 0C78           ;       // Set num modules to zero.
 0C78           ;       NUM_MODULES = 0;
 0C78 62D000            mov REG[0xd0],>_NUM_MODULES
 0C7B 550100            mov [_NUM_MODULES+1],0
 0C7E 550000            mov [_NUM_MODULES],0
 0C81                   .dbline 783
 0C81           ;       
 0C81           ;       // Set the child value to zero.
 0C81           ;       CHILD = 0;      
 0C81 62D000            mov REG[0xd0],>_CHILD
 0C84 550000            mov [_CHILD],0
 0C87 8022              xjmp L177
 0C89           L176:
 0C89                   .dbline 786
 0C89           ;       
 0C89           ;       while(CHILD == 0)
 0C89           ;       {
 0C89                   .dbline 788
 0C89           ;               // Send out a probing message.
 0C89           ;               sayHello();
 0C89 7C022B            xcall _sayHello
 0C8C                   .dbline 791
 0C8C           ;               
 0C8C           ;               // Listen for a response.
 0C8C           ;               if(!childListen())
 0C8C 91A2              xcall _childListen
 0C8E 62D000            mov REG[0xd0],>__r0
 0C91 3C0000            cmp [__r0],0
 0C94 B015              jnz L179
 0C96 3C0000            cmp [__r1],0
 0C99 B010              jnz L179
 0C9B           X58:
 0C9B                   .dbline 792
 0C9B           ;               {
 0C9B           L181:
 0C9B                   .dbline 794
 0C9B           ;                       // Wait for INIT_WAIT_TIME before we try again.
 0C9B           ;                       while(TIMEOUT < INIT_WAIT_TIME){ }
 0C9B                   .dbline 794
 0C9B           L182:
 0C9B                   .dbline 794
 0C9B 62D000            mov REG[0xd0],>_TIMEOUT
 0C9E 5101              mov A,[_TIMEOUT+1]
 0CA0 1102              sub A,2
 0CA2 5100              mov A,[_TIMEOUT]
 0CA4 3180              xor A,-128
 0CA6 1980              sbb A,(0 ^ 0x80)
 0CA8 CFF2              jc L181
 0CAA           X59:
 0CAA                   .dbline 795
 0CAA           ;               }
 0CAA           L179:
 0CAA                   .dbline 796
 0CAA           ;       }
 0CAA           L177:
 0CAA                   .dbline 785
 0CAA 62D000            mov REG[0xd0],>_CHILD
 0CAD 3C0000            cmp [_CHILD],0
 0CB0 AFD8              jz L176
 0CB2                   .dbline 830
 0CB2           ;       
 0CB2           ; /*    while(1)
 0CB2           ;       {
 0CB2           ;               PRT1DR |= 0b00000001;
 0CB2           ;               
 0CB2           ;               if(CHILD == PORT_1)
 0CB2           ;               {
 0CB2           ;                       xmitWait();
 0CB2           ;               }
 0CB2           ;               else if(CHILD == PORT_2)
 0CB2           ;               {
 0CB2           ;                       xmitWait();
 0CB2           ;                       xmitWait();
 0CB2           ;               }
 0CB2           ;               else if(CHILD == PORT_3)
 0CB2           ;               {
 0CB2           ;                       xmitWait();
 0CB2           ;                       xmitWait();
 0CB2           ;                       xmitWait();
 0CB2           ;               }
 0CB2           ;               else if(CHILD == PORT_4)
 0CB2           ;               {
 0CB2           ;                       xmitWait();
 0CB2           ;                       xmitWait();
 0CB2           ;                       xmitWait();
 0CB2           ;                       xmitWait();
 0CB2           ;               }
 0CB2           ;               
 0CB2           ;               PRT1DR &= 0b11111110;
 0CB2           ;               xmitWait();
 0CB2           ;       }
 0CB2           ; */    
 0CB2           ;       // Send out a probing message.
 0CB2           ;       sayHello();
 0CB2 7C022B            xcall _sayHello
 0CB5 80F7              xjmp L185
 0CB7           L184:
 0CB7                   .dbline 835
 0CB7           ;       
 0CB7           ;       // This loop continuously probes and listens at intervals
 0CB7           ;       // set by the RX_TIMEOUT_DURATION variable.
 0CB7           ;       while(num_timeouts < MAX_TIMEOUTS)
 0CB7           ;       {       
 0CB7                   .dbline 836
 0CB7           ;               if(validTransmission())
 0CB7 7C02A7            xcall _validTransmission
 0CBA 62D000            mov REG[0xd0],>__r0
 0CBD 3C0000            cmp [__r0],0
 0CC0 B006              jnz X60
 0CC2 3C0000            cmp [__r1],0
 0CC5 A096              jz L187
 0CC7           X60:
 0CC7                   .dbline 837
 0CC7           ;               {
 0CC7                   .dbline 838
 0CC7           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0CC7 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0CCA 3C00C8            cmp [_COMMAND_TYPE],-56
 0CCD B0DF              jnz L188
 0CCF                   .dbline 839
 0CCF           ;                       {
 0CCF                   .dbline 841
 0CCF           ;                               // If this is for me, assign them an ID.
 0CCF           ;                               if(COMMAND_DESTINATION == PARENT_ID)
 0CCF 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0CD2 3C0000            cmp [_COMMAND_DESTINATION],0
 0CD5 B0D7              jnz L188
 0CD7                   .dbline 842
 0CD7           ;                               {
 0CD7                   .dbline 843
 0CD7           ;                                       NUM_MODULES++;                  // Increment the number of modules connected.
 0CD7 62D000            mov REG[0xd0],>_NUM_MODULES
 0CDA 7601              inc [_NUM_MODULES+1]
 0CDC 0E0000            adc [_NUM_MODULES],0
 0CDF                   .dbline 844
 0CDF           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0CDF 560500            mov [X+5],0
 0CE2 560400            mov [X+4],0
 0CE5                   .dbline 846
 0CE5           ;               
 0CE5           ;                                       if(!assignID(NUM_MODULES))
 0CE5 5100              mov A,[_NUM_MODULES]
 0CE7 08                push A
 0CE8 5101              mov A,[_NUM_MODULES+1]
 0CEA 08                push A
 0CEB 7C0130            xcall _assignID
 0CEE 38FE              add SP,-2
 0CF0 62D000            mov REG[0xd0],>__r0
 0CF3 3C0000            cmp [__r0],0
 0CF6 B0B6              jnz L188
 0CF8 3C0000            cmp [__r1],0
 0CFB B0B1              jnz L188
 0CFD           X61:
 0CFD                   .dbline 847
 0CFD           ;                                       {
 0CFD                   .dbline 851
 0CFD           ;                                               // If the module did not respond that the ID was assigned,
 0CFD           ;                                               // make an effort to ping it in case that transmission was lost
 0CFD           ;                                               // before ultimately deciding that the module didn't configure.
 0CFD           ;                                               for(i = 0; i < ping_tries; i++)
 0CFD 560100            mov [X+1],0
 0D00 560000            mov [X+0],0
 0D03 802D              xjmp L198
 0D05           L195:
 0D05                   .dbline 852
 0D05           ;                                               {       
 0D05                   .dbline 853
 0D05           ;                                                       if(pingModule(NUM_MODULES))
 0D05 62D000            mov REG[0xd0],>_NUM_MODULES
 0D08 5100              mov A,[_NUM_MODULES]
 0D0A 08                push A
 0D0B 5101              mov A,[_NUM_MODULES+1]
 0D0D 08                push A
 0D0E 7C0043            xcall _pingModule
 0D11 38FE              add SP,-2
 0D13 62D000            mov REG[0xd0],>__r0
 0D16 3C0000            cmp [__r0],0
 0D19 B006              jnz X62
 0D1B 3C0000            cmp [__r1],0
 0D1E A00D              jz L199
 0D20           X62:
 0D20                   .dbline 854
 0D20           ;                                                       {
 0D20                   .dbline 855
 0D20           ;                                                               i = ping_tries+1;
 0D20 5203              mov A,[X+3]
 0D22 0101              add A,1
 0D24 5401              mov [X+1],A
 0D26 5202              mov A,[X+2]
 0D28 0900              adc A,0
 0D2A 5400              mov [X+0],A
 0D2C                   .dbline 856
 0D2C           ;                                                       }
 0D2C           L199:
 0D2C                   .dbline 857
 0D2C           ;                                               }
 0D2C           L196:
 0D2C                   .dbline 851
 0D2C 7701              inc [X+1]
 0D2E 0F0000            adc [X+0],0
 0D31           L198:
 0D31                   .dbline 851
 0D31 5201              mov A,[X+1]
 0D33 1303              sub A,[X+3]
 0D35 5202              mov A,[X+2]
 0D37 3180              xor A,-128
 0D39 62D000            mov REG[0xd0],>__r0
 0D3C 5300              mov [__rX],A
 0D3E 5200              mov A,[X+0]
 0D40 3180              xor A,-128
 0D42 1A00              sbb A,[__rX]
 0D44 CFC0              jc L195
 0D46           X63:
 0D46                   .dbline 860
 0D46           ;                                               
 0D46           ;                                               // If we landed right at ping_tries, we failed.
 0D46           ;                                               if(i == ping_tries)
 0D46 5200              mov A,[X+0]
 0D48 3B02              cmp A,[X+2]
 0D4A B062              jnz L188
 0D4C 5201              mov A,[X+1]
 0D4E 3B03              cmp A,[X+3]
 0D50 B05C              jnz L188
 0D52           X64:
 0D52                   .dbline 861
 0D52           ;                                               {
 0D52                   .dbline 862
 0D52           ;                                                       NUM_MODULES--;
 0D52 62D000            mov REG[0xd0],>_NUM_MODULES
 0D55 7A01              dec [_NUM_MODULES+1]
 0D57 1E0000            sbb [_NUM_MODULES],0
 0D5A                   .dbline 863
 0D5A           ;                                               }
 0D5A                   .dbline 864
 0D5A           ;                                       }
 0D5A                   .dbline 865
 0D5A           ;                               }
 0D5A                   .dbline 866
 0D5A           ;                       }
 0D5A                   .dbline 867
 0D5A           ;               }
 0D5A 8052              xjmp L188
 0D5C           L187:
 0D5C                   .dbline 868
 0D5C           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 0D5C 62D000            mov REG[0xd0],>_TIMEOUT
 0D5F 5101              mov A,[_TIMEOUT+1]
 0D61 1105              sub A,5
 0D63 5100              mov A,[_TIMEOUT]
 0D65 3180              xor A,-128
 0D67 1980              sbb A,(0 ^ 0x80)
 0D69 C043              jc L203
 0D6B           X65:
 0D6B                   .dbline 869
 0D6B           ;               {       
 0D6B                   .dbline 871
 0D6B           ;                       // Only increment the number of timeouts if we have found a module.
 0D6B           ;                       if(NUM_MODULES)
 0D6B 62D000            mov REG[0xd0],>_NUM_MODULES
 0D6E 3C0000            cmp [_NUM_MODULES],0
 0D71 B006              jnz X66
 0D73 3C0100            cmp [_NUM_MODULES+1],0
 0D76 A008              jz L208
 0D78           X66:
 0D78                   .dbline 872
 0D78           ;                       {
 0D78                   .dbline 873
 0D78           ;                               num_timeouts++;
 0D78 7705              inc [X+5]
 0D7A 0F0400            adc [X+4],0
 0D7D                   .dbline 874
 0D7D           ;                       }
 0D7D 8010              xjmp L206
 0D7F           L207:
 0D7F                   .dbline 879
 0D7F           ;                       else
 0D7F           ;                       {
 0D7F           ;                               // Wait additional time between transmissions if no modules have been found.
 0D7F           ;                               // This is done to give the first child a chance to configure if it hasn't.
 0D7F           ;                               while(TIMEOUT < INIT_WAIT_TIME) { }
 0D7F                   .dbline 879
 0D7F           L208:
 0D7F                   .dbline 879
 0D7F 62D000            mov REG[0xd0],>_TIMEOUT
 0D82 5101              mov A,[_TIMEOUT+1]
 0D84 1102              sub A,2
 0D86 5100              mov A,[_TIMEOUT]
 0D88 3180              xor A,-128
 0D8A 1980              sbb A,(0 ^ 0x80)
 0D8C CFF2              jc L207
 0D8E           X67:
 0D8E                   .dbline 880
 0D8E           ;                       }
 0D8E           L206:
 0D8E                   .dbline 883
 0D8E           ;                       
 0D8E           ;                       // If we are not maxed out on modules, look for more.
 0D8E           ;                       if(NUM_MODULES < MAX_MODULES)
 0D8E 62D000            mov REG[0xd0],>_NUM_MODULES
 0D91 5101              mov A,[_NUM_MODULES+1]
 0D93 11FA              sub A,-6
 0D95 5100              mov A,[_NUM_MODULES]
 0D97 3180              xor A,-128
 0D99 1980              sbb A,(0 ^ 0x80)
 0D9B D011              jnc L210
 0D9D           X68:
 0D9D                   .dbline 884
 0D9D           ;                       {
 0D9D                   .dbline 885
 0D9D           ;                               preXmitWait(STATE);
 0D9D 62D000            mov REG[0xd0],>_STATE
 0DA0 5100              mov A,[_STATE]
 0DA2 08                push A
 0DA3 5101              mov A,[_STATE+1]
 0DA5 08                push A
 0DA6 925A              xcall _preXmitWait
 0DA8 38FE              add SP,-2
 0DAA                   .dbline 886
 0DAA           ;                               sayHello();
 0DAA 7C022B            xcall _sayHello
 0DAD                   .dbline 887
 0DAD           ;                       }
 0DAD           L210:
 0DAD                   .dbline 888
 0DAD           ;               }
 0DAD           L203:
 0DAD           L188:
 0DAD                   .dbline 889
 0DAD           ;       }
 0DAD           L185:
 0DAD                   .dbline 834
 0DAD 5205              mov A,[X+5]
 0DAF 1132              sub A,50
 0DB1 5204              mov A,[X+4]
 0DB3 3180              xor A,-128
 0DB5 1980              sbb A,(0 ^ 0x80)
 0DB7 CEFF              jc L184
 0DB9           X69:
 0DB9                   .dbline 892
 0DB9           ;       
 0DB9           ;       // If we didn't find any new modules, check to see if some already exist.
 0DB9           ;       if(!NUM_MODULES)
 0DB9 62D000            mov REG[0xd0],>_NUM_MODULES
 0DBC 3C0000            cmp [_NUM_MODULES],0
 0DBF B062              jnz L212
 0DC1 3C0100            cmp [_NUM_MODULES+1],0
 0DC4 B05D              jnz L212
 0DC6           X70:
 0DC6                   .dbline 893
 0DC6           ;       {
 0DC6                   .dbline 895
 0DC6           ;               // Try to ping the next module up from our current number ping_tries times.
 0DC6           ;               for(i = 0; i < ping_tries; i++)
 0DC6 560100            mov [X+1],0
 0DC9 560000            mov [X+0],0
 0DCC 8040              xjmp L217
 0DCE           L214:
 0DCE                   .dbline 896
 0DCE           ;               {       
 0DCE                   .dbline 897
 0DCE           ;                       if(pingModule(NUM_MODULES+1))
 0DCE 62D000            mov REG[0xd0],>_NUM_MODULES
 0DD1 5101              mov A,[_NUM_MODULES+1]
 0DD3 0101              add A,1
 0DD5 62D000            mov REG[0xd0],>__r0
 0DD8 5300              mov [__r1],A
 0DDA 62D000            mov REG[0xd0],>_NUM_MODULES
 0DDD 5100              mov A,[_NUM_MODULES]
 0DDF 0900              adc A,0
 0DE1 62D000            mov REG[0xd0],>__r0
 0DE4 08                push A
 0DE5 5100              mov A,[__r1]
 0DE7 08                push A
 0DE8 7C0043            xcall _pingModule
 0DEB 38FE              add SP,-2
 0DED 62D000            mov REG[0xd0],>__r0
 0DF0 3C0000            cmp [__r0],0
 0DF3 B006              jnz X71
 0DF5 3C0000            cmp [__r1],0
 0DF8 A00F              jz L218
 0DFA           X71:
 0DFA                   .dbline 898
 0DFA           ;                       {
 0DFA                   .dbline 899
 0DFA           ;                               NUM_MODULES++;
 0DFA 62D000            mov REG[0xd0],>_NUM_MODULES
 0DFD 7601              inc [_NUM_MODULES+1]
 0DFF 0E0000            adc [_NUM_MODULES],0
 0E02                   .dbline 900
 0E02           ;                               i = 0;
 0E02 560100            mov [X+1],0
 0E05 560000            mov [X+0],0
 0E08                   .dbline 901
 0E08           ;                       }
 0E08           L218:
 0E08                   .dbline 902
 0E08           ;               }
 0E08           L215:
 0E08                   .dbline 895
 0E08 7701              inc [X+1]
 0E0A 0F0000            adc [X+0],0
 0E0D           L217:
 0E0D                   .dbline 895
 0E0D 5201              mov A,[X+1]
 0E0F 1303              sub A,[X+3]
 0E11 5202              mov A,[X+2]
 0E13 3180              xor A,-128
 0E15 62D000            mov REG[0xd0],>__r0
 0E18 5300              mov [__rX],A
 0E1A 5200              mov A,[X+0]
 0E1C 3180              xor A,-128
 0E1E 1A00              sbb A,[__rX]
 0E20 CFAD              jc L214
 0E22           X72:
 0E22                   .dbline 903
 0E22           ;       }
 0E22           L212:
 0E22                   .dbline 906
 0E22           ;       
 0E22           ;       // Switch back to PC mode.
 0E22           ;       configToggle(PC_MODE);
 0E22 5000              mov A,0
 0E24 08                push A
 0E25 5001              mov A,1
 0E27 08                push A
 0E28 9D6A              xcall _configToggle
 0E2A 38FE              add SP,-2
 0E2C                   .dbline -2
 0E2C           L175:
 0E2C 38FA              add SP,-6
 0E2E 20                pop X
 0E2F                   .dbline 0 ; func end
 0E2F 7F                ret
 0E30                   .dbsym l num_timeouts 4 I
 0E30                   .dbsym l ping_tries 2 I
 0E30                   .dbsym l i 0 I
 0E30                   .dbend
 0E30                   .dbfunc e childListen _childListen fI
 0E30           _childListen::
 0E30                   .dbline -1
 0E30                   .dbline 911
 0E30           ; }
 0E30           ; 
 0E30           ; // This function listens for children and registers the port that they talk to.
 0E30           ; int childListen(void)
 0E30           ; {     
 0E30 80E3              xjmp L222
 0E32           L221:
 0E32                   .dbline 914
 0E32           ;       // Wait to either hear a child or time out.
 0E32           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0E32           ;       {               
 0E32                   .dbline 917
 0E32           ;               // Check all of the ports for a start byte. Only one port will produce one.
 0E32           ;               // Only non-blocking commands are used to avoid getting stuck listening downstream.
 0E32           ;               if(RECEIVE_1_cReadChar() == START_TRANSMIT)
 0E32 10                push X
 0E33 7C0000            xcall _RECEIVE_1_cReadChar
 0E36 62D000            mov REG[0xd0],>__r0
 0E39 20                pop X
 0E3A 39FC              cmp A,-4
 0E3C B02E              jnz L224
 0E3E                   .dbline 918
 0E3E           ;               {
 0E3E 801B              xjmp L227
 0E40           L226:
 0E40                   .dbline 920
 0E40           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0E40           ;                       {
 0E40                   .dbline 921
 0E40           ;                               if(RECEIVE_1_cReadChar() == END_TRANSMIT)
 0E40 10                push X
 0E41 7C0000            xcall _RECEIVE_1_cReadChar
 0E44 20                pop X
 0E45 39FD              cmp A,-3
 0E47 B012              jnz L229
 0E49                   .dbline 922
 0E49           ;                               {
 0E49                   .dbline 923
 0E49           ;                                       CHILD = PORT_1;
 0E49 62D000            mov REG[0xd0],>_CHILD
 0E4C 550031            mov [_CHILD],49
 0E4F                   .dbline 924
 0E4F           ;                                       return 1;
 0E4F 62D000            mov REG[0xd0],>__r0
 0E52 550001            mov [__r1],1
 0E55 550000            mov [__r0],0
 0E58 80D3              xjmp L220
 0E5A           L229:
 0E5A                   .dbline 926
 0E5A           ;                               }
 0E5A           ;                       }
 0E5A           L227:
 0E5A                   .dbline 919
 0E5A 62D000            mov REG[0xd0],>_TIMEOUT
 0E5D 5101              mov A,[_TIMEOUT+1]
 0E5F 1105              sub A,5
 0E61 5100              mov A,[_TIMEOUT]
 0E63 3180              xor A,-128
 0E65 1980              sbb A,(0 ^ 0x80)
 0E67 CFD8              jc L226
 0E69           X73:
 0E69                   .dbline 927
 0E69           ;               }
 0E69 80AA              xjmp L225
 0E6B           L224:
 0E6B                   .dbline 928
 0E6B           ;               else if(RECEIVE_2_cReadChar() == START_TRANSMIT)
 0E6B 10                push X
 0E6C 7C0000            xcall _RECEIVE_2_cReadChar
 0E6F 62D000            mov REG[0xd0],>__r0
 0E72 20                pop X
 0E73 39FC              cmp A,-4
 0E75 B02E              jnz L231
 0E77                   .dbline 929
 0E77           ;               {
 0E77 801B              xjmp L234
 0E79           L233:
 0E79                   .dbline 931
 0E79           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0E79           ;                       {
 0E79                   .dbline 932
 0E79           ;                               if(RECEIVE_2_cReadChar() == END_TRANSMIT)
 0E79 10                push X
 0E7A 7C0000            xcall _RECEIVE_2_cReadChar
 0E7D 20                pop X
 0E7E 39FD              cmp A,-3
 0E80 B012              jnz L236
 0E82                   .dbline 933
 0E82           ;                               {
 0E82                   .dbline 934
 0E82           ;                                       CHILD = PORT_2;
 0E82 62D000            mov REG[0xd0],>_CHILD
 0E85 550032            mov [_CHILD],50
 0E88                   .dbline 935
 0E88           ;                                       return 1;
 0E88 62D000            mov REG[0xd0],>__r0
 0E8B 550001            mov [__r1],1
 0E8E 550000            mov [__r0],0
 0E91 809A              xjmp L220
 0E93           L236:
 0E93                   .dbline 937
 0E93           ;                               }
 0E93           ;                       }
 0E93           L234:
 0E93                   .dbline 930
 0E93 62D000            mov REG[0xd0],>_TIMEOUT
 0E96 5101              mov A,[_TIMEOUT+1]
 0E98 1105              sub A,5
 0E9A 5100              mov A,[_TIMEOUT]
 0E9C 3180              xor A,-128
 0E9E 1980              sbb A,(0 ^ 0x80)
 0EA0 CFD8              jc L233
 0EA2           X74:
 0EA2                   .dbline 938
 0EA2           ;               }
 0EA2 8071              xjmp L232
 0EA4           L231:
 0EA4                   .dbline 939
 0EA4           ;               else if(RECEIVE_3_cReadChar() == START_TRANSMIT)
 0EA4 10                push X
 0EA5 7C0000            xcall _RECEIVE_3_cReadChar
 0EA8 62D000            mov REG[0xd0],>__r0
 0EAB 20                pop X
 0EAC 39FC              cmp A,-4
 0EAE B02E              jnz L238
 0EB0                   .dbline 940
 0EB0           ;               {
 0EB0 801B              xjmp L241
 0EB2           L240:
 0EB2                   .dbline 942
 0EB2           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0EB2           ;                       {
 0EB2                   .dbline 943
 0EB2           ;                               if(RECEIVE_3_cReadChar() == END_TRANSMIT)
 0EB2 10                push X
 0EB3 7C0000            xcall _RECEIVE_3_cReadChar
 0EB6 20                pop X
 0EB7 39FD              cmp A,-3
 0EB9 B012              jnz L243
 0EBB                   .dbline 944
 0EBB           ;                               {
 0EBB                   .dbline 945
 0EBB           ;                                       CHILD = PORT_3;
 0EBB 62D000            mov REG[0xd0],>_CHILD
 0EBE 550033            mov [_CHILD],51
 0EC1                   .dbline 946
 0EC1           ;                                       return 1;
 0EC1 62D000            mov REG[0xd0],>__r0
 0EC4 550001            mov [__r1],1
 0EC7 550000            mov [__r0],0
 0ECA 8061              xjmp L220
 0ECC           L243:
 0ECC                   .dbline 948
 0ECC           ;                               }
 0ECC           ;                       }
 0ECC           L241:
 0ECC                   .dbline 941
 0ECC 62D000            mov REG[0xd0],>_TIMEOUT
 0ECF 5101              mov A,[_TIMEOUT+1]
 0ED1 1105              sub A,5
 0ED3 5100              mov A,[_TIMEOUT]
 0ED5 3180              xor A,-128
 0ED7 1980              sbb A,(0 ^ 0x80)
 0ED9 CFD8              jc L240
 0EDB           X75:
 0EDB                   .dbline 949
 0EDB           ;               }
 0EDB 8038              xjmp L239
 0EDD           L238:
 0EDD                   .dbline 950
 0EDD           ;               else if(RECEIVE_4_cReadChar() == START_TRANSMIT)
 0EDD 10                push X
 0EDE 7C0000            xcall _RECEIVE_4_cReadChar
 0EE1 62D000            mov REG[0xd0],>__r0
 0EE4 20                pop X
 0EE5 39FC              cmp A,-4
 0EE7 B02C              jnz L245
 0EE9                   .dbline 951
 0EE9           ;               {
 0EE9 801B              xjmp L248
 0EEB           L247:
 0EEB                   .dbline 953
 0EEB           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 0EEB           ;                       {
 0EEB                   .dbline 954
 0EEB           ;                               if(RECEIVE_4_cReadChar() == END_TRANSMIT)
 0EEB 10                push X
 0EEC 7C0000            xcall _RECEIVE_4_cReadChar
 0EEF 20                pop X
 0EF0 39FD              cmp A,-3
 0EF2 B012              jnz L250
 0EF4                   .dbline 955
 0EF4           ;                               {
 0EF4                   .dbline 956
 0EF4           ;                                       CHILD = PORT_4;
 0EF4 62D000            mov REG[0xd0],>_CHILD
 0EF7 550034            mov [_CHILD],52
 0EFA                   .dbline 957
 0EFA           ;                                       return 1;
 0EFA 62D000            mov REG[0xd0],>__r0
 0EFD 550001            mov [__r1],1
 0F00 550000            mov [__r0],0
 0F03 8028              xjmp L220
 0F05           L250:
 0F05                   .dbline 959
 0F05           ;                               }
 0F05           ;                       }
 0F05           L248:
 0F05                   .dbline 952
 0F05 62D000            mov REG[0xd0],>_TIMEOUT
 0F08 5101              mov A,[_TIMEOUT+1]
 0F0A 1105              sub A,5
 0F0C 5100              mov A,[_TIMEOUT]
 0F0E 3180              xor A,-128
 0F10 1980              sbb A,(0 ^ 0x80)
 0F12 CFD8              jc L247
 0F14           X76:
 0F14                   .dbline 960
 0F14           ;               }
 0F14           L245:
 0F14           L239:
 0F14           L232:
 0F14           L225:
 0F14                   .dbline 961
 0F14           ;       }
 0F14           L222:
 0F14                   .dbline 913
 0F14 62D000            mov REG[0xd0],>_TIMEOUT
 0F17 5101              mov A,[_TIMEOUT+1]
 0F19 1105              sub A,5
 0F1B 5100              mov A,[_TIMEOUT]
 0F1D 3180              xor A,-128
 0F1F 1980              sbb A,(0 ^ 0x80)
 0F21 CF10              jc L221
 0F23           X77:
 0F23                   .dbline 963
 0F23           ;       
 0F23           ;       return 0;
 0F23 62D000            mov REG[0xd0],>__r0
 0F26 550000            mov [__r1],0
 0F29 550000            mov [__r0],0
 0F2C                   .dbline -2
 0F2C           L220:
 0F2C                   .dbline 0 ; func end
 0F2C 7F                ret
 0F2D                   .dbend
 0F2D                   .dbfunc e iReadChar _iReadChar fc
 0F2D           _iReadChar::
 0F2D                   .dbline -1
 0F2D                   .dbline 968
 0F2D           ; }
 0F2D           ; 
 0F2D           ; // This function converts the PSoC cReadChar calls of all ports into a single return.
 0F2D           ; char iReadChar(void)
 0F2D           ; {
 0F2D                   .dbline 969
 0F2D           ;       if(CHILD == PORT_1)
 0F2D 62D000            mov REG[0xd0],>_CHILD
 0F30 3C0031            cmp [_CHILD],49
 0F33 B00B              jnz L253
 0F35                   .dbline 970
 0F35           ;       {
 0F35                   .dbline 971
 0F35           ;               return RECEIVE_1_cReadChar();
 0F35 10                push X
 0F36 7C0000            xcall _RECEIVE_1_cReadChar
 0F39 62D000            mov REG[0xd0],>__r0
 0F3C 20                pop X
 0F3D 803C              xjmp L252
 0F3F           L253:
 0F3F                   .dbline 973
 0F3F           ;       }
 0F3F           ;       else if(CHILD == PORT_2)
 0F3F 62D000            mov REG[0xd0],>_CHILD
 0F42 3C0032            cmp [_CHILD],50
 0F45 B00B              jnz L255
 0F47                   .dbline 974
 0F47           ;       {
 0F47                   .dbline 975
 0F47           ;               return RECEIVE_2_cReadChar();
 0F47 10                push X
 0F48 7C0000            xcall _RECEIVE_2_cReadChar
 0F4B 62D000            mov REG[0xd0],>__r0
 0F4E 20                pop X
 0F4F 802A              xjmp L252
 0F51           L255:
 0F51                   .dbline 977
 0F51           ;       }
 0F51           ;       else if(CHILD == PORT_3)
 0F51 62D000            mov REG[0xd0],>_CHILD
 0F54 3C0033            cmp [_CHILD],51
 0F57 B00B              jnz L257
 0F59                   .dbline 978
 0F59           ;       {
 0F59                   .dbline 979
 0F59           ;               return RECEIVE_3_cReadChar();
 0F59 10                push X
 0F5A 7C0000            xcall _RECEIVE_3_cReadChar
 0F5D 62D000            mov REG[0xd0],>__r0
 0F60 20                pop X
 0F61 8018              xjmp L252
 0F63           L257:
 0F63                   .dbline 981
 0F63           ;       }
 0F63           ;       else if(CHILD == PORT_4)
 0F63 62D000            mov REG[0xd0],>_CHILD
 0F66 3C0034            cmp [_CHILD],52
 0F69 B00B              jnz L259
 0F6B                   .dbline 982
 0F6B           ;       {
 0F6B                   .dbline 983
 0F6B           ;               return RECEIVE_4_cReadChar();
 0F6B 10                push X
 0F6C 7C0000            xcall _RECEIVE_4_cReadChar
 0F6F 62D000            mov REG[0xd0],>__r0
 0F72 20                pop X
 0F73 8006              xjmp L252
 0F75           L259:
 0F75                   .dbline 986
 0F75           ;       }
 0F75           ;       else
 0F75           ;       {
 0F75                   .dbline 987
 0F75           ;               return 0;
 0F75 62D000            mov REG[0xd0],>__r0
 0F78 5000              mov A,0
 0F7A                   .dbline -2
 0F7A           L252:
 0F7A                   .dbline 0 ; func end
 0F7A 7F                ret
 0F7B                   .dbend
 0F7B                   .dbfunc e readChar _readChar fc
 0F7B           _readChar::
 0F7B                   .dbline -1
 0F7B                   .dbline 993
 0F7B           ;       }
 0F7B           ; }
 0F7B           ; 
 0F7B           ; // This function converts the PSoC cGetChar calls of all ports into a single return.
 0F7B           ; char readChar(void)
 0F7B           ; {     
 0F7B                   .dbline 994
 0F7B           ;       if(CHILD == PORT_1)
 0F7B 62D000            mov REG[0xd0],>_CHILD
 0F7E 3C0031            cmp [_CHILD],49
 0F81 B00B              jnz L262
 0F83                   .dbline 995
 0F83           ;       {
 0F83                   .dbline 996
 0F83           ;               return RECEIVE_1_cGetChar();
 0F83 10                push X
 0F84 7C0000            xcall _RECEIVE_1_cGetChar
 0F87 62D000            mov REG[0xd0],>__r0
 0F8A 20                pop X
 0F8B 803C              xjmp L261
 0F8D           L262:
 0F8D                   .dbline 998
 0F8D           ;       }
 0F8D           ;       else if(CHILD == PORT_2)
 0F8D 62D000            mov REG[0xd0],>_CHILD
 0F90 3C0032            cmp [_CHILD],50
 0F93 B00B              jnz L264
 0F95                   .dbline 999
 0F95           ;       {
 0F95                   .dbline 1000
 0F95           ;               return RECEIVE_2_cGetChar();
 0F95 10                push X
 0F96 7C0000            xcall _RECEIVE_2_cGetChar
 0F99 62D000            mov REG[0xd0],>__r0
 0F9C 20                pop X
 0F9D 802A              xjmp L261
 0F9F           L264:
 0F9F                   .dbline 1002
 0F9F           ;       }
 0F9F           ;       else if(CHILD == PORT_3)
 0F9F 62D000            mov REG[0xd0],>_CHILD
 0FA2 3C0033            cmp [_CHILD],51
 0FA5 B00B              jnz L266
 0FA7                   .dbline 1003
 0FA7           ;       {
 0FA7                   .dbline 1004
 0FA7           ;               return RECEIVE_3_cGetChar();
 0FA7 10                push X
 0FA8 7C0000            xcall _RECEIVE_3_cGetChar
 0FAB 62D000            mov REG[0xd0],>__r0
 0FAE 20                pop X
 0FAF 8018              xjmp L261
 0FB1           L266:
 0FB1                   .dbline 1006
 0FB1           ;       }
 0FB1           ;       else if(CHILD == PORT_4)
 0FB1 62D000            mov REG[0xd0],>_CHILD
 0FB4 3C0034            cmp [_CHILD],52
 0FB7 B00B              jnz L268
 0FB9                   .dbline 1007
 0FB9           ;       {
 0FB9                   .dbline 1008
 0FB9           ;               return RECEIVE_4_cGetChar();
 0FB9 10                push X
 0FBA 7C0000            xcall _RECEIVE_4_cGetChar
 0FBD 62D000            mov REG[0xd0],>__r0
 0FC0 20                pop X
 0FC1 8006              xjmp L261
 0FC3           L268:
 0FC3                   .dbline 1011
 0FC3           ;       }
 0FC3           ;       else
 0FC3           ;       {
 0FC3                   .dbline 1012
 0FC3           ;               return 0;
 0FC3 62D000            mov REG[0xd0],>__r0
 0FC6 5000              mov A,0
 0FC8                   .dbline -2
 0FC8           L261:
 0FC8                   .dbline 0 ; func end
 0FC8 7F                ret
 0FC9                   .dbend
 0FC9                   .dbfunc e bootWait _bootWait fV
 0FC9           _bootWait::
 0FC9                   .dbline -1
 0FC9                   .dbline 1017
 0FC9           ;       }
 0FC9           ; }
 0FC9           ; 
 0FC9           ; void bootWait(void)
 0FC9           ; {
 0FC9                   .dbline 1018
 0FC9           ;       configToggle(RX_MODE);
 0FC9 5000              mov A,0
 0FCB 08                push A
 0FCC 5002              mov A,2
 0FCE 08                push A
 0FCF 9BC3              xcall _configToggle
 0FD1 38FE              add SP,-2
 0FD3           L271:
 0FD3                   .dbline 1021
 0FD3           ;       
 0FD3           ;       // Sit and do nothing.
 0FD3           ;       while(TIMEOUT < BOOT_WAIT_TIME){ }
 0FD3                   .dbline 1021
 0FD3           L272:
 0FD3                   .dbline 1021
 0FD3 62D000            mov REG[0xd0],>_TIMEOUT
 0FD6 5101              mov A,[_TIMEOUT+1]
 0FD8 11F4              sub A,-12
 0FDA 5100              mov A,[_TIMEOUT]
 0FDC 3180              xor A,-128
 0FDE 1981              sbb A,(1 ^ 0x80)
 0FE0 CFF2              jc L271
 0FE2           X78:
 0FE2                   .dbline -2
 0FE2           L270:
 0FE2                   .dbline 0 ; func end
 0FE2 7F                ret
 0FE3                   .dbend
 0FE3                   .dbfunc e xmitWait _xmitWait fV
 0FE3           ;              i -> X+0
 0FE3           _xmitWait::
 0FE3                   .dbline -1
 0FE3 10                push X
 0FE4 4F                mov X,SP
 0FE5 3802              add SP,2
 0FE7                   .dbline 1025
 0FE7           ; }
 0FE7           ; 
 0FE7           ; void xmitWait(void)
 0FE7           ; {
 0FE7                   .dbline 1028
 0FE7           ;       int i;
 0FE7           ;       
 0FE7           ;       for(i = 0; i < 25; i++)
 0FE7 560100            mov [X+1],0
 0FEA 560000            mov [X+0],0
 0FED           L275:
 0FED                   .dbline 1029
 0FED           ;       {
 0FED                   .dbline 1031
 0FED           ;               // Sit here and spin for about 50 microseconds.
 0FED           ;       }
 0FED           L276:
 0FED                   .dbline 1028
 0FED 7701              inc [X+1]
 0FEF 0F0000            adc [X+0],0
 0FF2                   .dbline 1028
 0FF2 5201              mov A,[X+1]
 0FF4 1119              sub A,25
 0FF6 5200              mov A,[X+0]
 0FF8 3180              xor A,-128
 0FFA 1980              sbb A,(0 ^ 0x80)
 0FFC CFF0              jc L275
 0FFE           X79:
 0FFE                   .dbline -2
 0FFE           L274:
 0FFE 38FE              add SP,-2
 1000 20                pop X
 1001                   .dbline 0 ; func end
 1001 7F                ret
 1002                   .dbsym l i 0 I
 1002                   .dbend
 1002                   .dbfunc e preXmitWait _preXmitWait fV
 1002           ;   currentState -> X-5
 1002           _preXmitWait::
 1002                   .dbline -1
 1002 10                push X
 1003 4F                mov X,SP
 1004                   .dbline 1035
 1004           ; }
 1004           ; 
 1004           ; void preXmitWait(int currentState)
 1004           ; {
 1004                   .dbline 1036
 1004           ;       if(STATE == PC_MODE)
 1004 62D000            mov REG[0xd0],>_STATE
 1007 3C0000            cmp [_STATE],0
 100A B034              jnz L280
 100C 3C0101            cmp [_STATE+1],1
 100F B02F              jnz L280
 1011           X80:
 1011                   .dbline 1037
 1011           ;       {
 1011                   .dbline 1038
 1011           ;               TIMEOUT = 0;                    // Clear the timeout flag.
 1011 62D000            mov REG[0xd0],>_TIMEOUT
 1014 550100            mov [_TIMEOUT+1],0
 1017 550000            mov [_TIMEOUT],0
 101A                   .dbline 1039
 101A           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 101A 10                push X
 101B 7C0000            xcall _TX_TIMEOUT_EnableInt
 101E                   .dbline 1040
 101E           ;               TX_TIMEOUT_Start();             // Start the timer.
 101E 7C0000            xcall _TX_TIMEOUT_Start
 1021 20                pop X
 1022           L282:
 1022                   .dbline 1043
 1022           ;                       
 1022           ;               // Do nothing while we allow everyone to load the right configuration.
 1022           ;               while(!TIMEOUT){ }
 1022                   .dbline 1043
 1022           L283:
 1022                   .dbline 1043
 1022 62D000            mov REG[0xd0],>_TIMEOUT
 1025 3C0000            cmp [_TIMEOUT],0
 1028 B006              jnz X81
 102A 3C0100            cmp [_TIMEOUT+1],0
 102D AFF4              jz L282
 102F           X81:
 102F                   .dbline 1046
 102F           ;                       
 102F           ;               // Stop the timer and reset the timeout flag.
 102F           ;               TX_TIMEOUT_Stop();
 102F 10                push X
 1030 7C0000            xcall _TX_TIMEOUT_Stop
 1033 20                pop X
 1034                   .dbline 1047
 1034           ;               TIMEOUT = 0;
 1034 62D000            mov REG[0xd0],>_TIMEOUT
 1037 550100            mov [_TIMEOUT+1],0
 103A 550000            mov [_TIMEOUT],0
 103D                   .dbline 1048
 103D           ;       }
 103D 803C              xjmp L281
 103F           L280:
 103F                   .dbline 1049
 103F           ;       else if(STATE == RX_MODE)
 103F 62D000            mov REG[0xd0],>_STATE
 1042 3C0000            cmp [_STATE],0
 1045 B034              jnz L285
 1047 3C0102            cmp [_STATE+1],2
 104A B02F              jnz L285
 104C           X82:
 104C                   .dbline 1050
 104C           ;       {
 104C                   .dbline 1051
 104C           ;               RX_TIMEOUT_Stop();
 104C 10                push X
 104D 7C0000            xcall _RX_TIMEOUT_Stop
 1050 20                pop X
 1051                   .dbline 1052
 1051           ;               TIMEOUT = 0;
 1051 62D000            mov REG[0xd0],>_TIMEOUT
 1054 550100            mov [_TIMEOUT+1],0
 1057 550000            mov [_TIMEOUT],0
 105A                   .dbline 1053
 105A           ;               RX_TIMEOUT_Start();
 105A 10                push X
 105B 7C0000            xcall _RX_TIMEOUT_Start
 105E 20                pop X
 105F           L287:
 105F                   .dbline 1056
 105F           ;               
 105F           ;               // Do nothing while we allow everyone to load the right configuration.
 105F           ;               while(!TIMEOUT){ }
 105F                   .dbline 1056
 105F           L288:
 105F                   .dbline 1056
 105F 62D000            mov REG[0xd0],>_TIMEOUT
 1062 3C0000            cmp [_TIMEOUT],0
 1065 B006              jnz X83
 1067 3C0100            cmp [_TIMEOUT+1],0
 106A AFF4              jz L287
 106C           X83:
 106C                   .dbline 1059
 106C           ;                       
 106C           ;               // Stop the timer and reset the timeout flag.
 106C           ;               RX_TIMEOUT_Stop();
 106C 10                push X
 106D 7C0000            xcall _RX_TIMEOUT_Stop
 1070 20                pop X
 1071                   .dbline 1060
 1071           ;               TIMEOUT = 0;
 1071 62D000            mov REG[0xd0],>_TIMEOUT
 1074 550100            mov [_TIMEOUT+1],0
 1077 550000            mov [_TIMEOUT],0
 107A                   .dbline 1061
 107A           ;       }
 107A           L285:
 107A           L281:
 107A                   .dbline -2
 107A           L279:
 107A 20                pop X
 107B                   .dbline 0 ; func end
 107B 7F                ret
 107C                   .dbsym l currentState -5 I
 107C                   .dbend
 107C                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 107C           _TX_TIMEOUT_ISR::
 107C                   .dbline -1
 107C 71C0              or F,-64
 107E 08                push A
 107F 5DD0              mov A,REG[0xd0]
 1081 08                push A
 1082                   .dbline 1065
 1082           ; }
 1082           ; 
 1082           ; void TX_TIMEOUT_ISR(void)
 1082           ; {     
 1082                   .dbline 1067
 1082           ;       // Increment the number of timeouts.
 1082           ;       TIMEOUT++;
 1082 62D000            mov REG[0xd0],>_TIMEOUT
 1085 7601              inc [_TIMEOUT+1]
 1087 0E0000            adc [_TIMEOUT],0
 108A                   .dbline 1069
 108A           ;       
 108A           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 108A 62DAFD            mov REG[0xda],-3
 108D                   .dbline -2
 108D           L290:
 108D 18                pop A
 108E 60D0              mov REG[208],A
 1090 18                pop A
 1091                   .dbline 0 ; func end
 1091 7E                reti
 1092                   .dbend
 1092                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 1092           _RX_TIMEOUT_ISR::
 1092                   .dbline -1
 1092 71C0              or F,-64
 1094 08                push A
 1095 5DD0              mov A,REG[0xd0]
 1097 08                push A
 1098                   .dbline 1073
 1098           ; }
 1098           ; 
 1098           ; void RX_TIMEOUT_ISR(void)
 1098           ; {     
 1098                   .dbline 1075
 1098           ;       // Increment the number of timeouts.
 1098           ;       TIMEOUT++;
 1098 62D000            mov REG[0xd0],>_TIMEOUT
 109B 7601              inc [_TIMEOUT+1]
 109D 0E0000            adc [_TIMEOUT],0
 10A0                   .dbline 1077
 10A0           ;       
 10A0           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 10A0 62DAFD            mov REG[0xda],-3
 10A3                   .dbline -2
 10A3           L291:
 10A3 18                pop A
 10A4 60D0              mov REG[208],A
 10A6 18                pop A
 10A7                   .dbline 0 ; func end
 10A7 7E                reti
 10A8                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _CHILD::
 0000 00                .byte 0
 0001                   .dbsym e CHILD _CHILD c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
