 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ;          angle -> X+4
 0000           ;  softwareReset -> X+2
 0000           ;      tempValue -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3808              add SP,8
 0004                   .dbline 99
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>              // part specific constants and macros
 0004           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0004           ; #include "psocdynamic.h"
 0004           ; #include <stdlib.h>
 0004           ; #include <string.h>
 0004           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0004           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0004           ; 
 0004           ; // These defines are used as parameters of the configToggle function.
 0004           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0004           ; #define               PC_MODE                                         (2)
 0004           ; #define               RX_MODE                                         (1)
 0004           ; #define               TX_MODE                                         (0)
 0004           ; 
 0004           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0004           ; #define               PORT_1                                          ('A')
 0004           ; #define               PORT_2                                          ('B')
 0004           ; #define               PORT_3                                          ('C')
 0004           ; #define               PORT_4                                          ('D')
 0004           ; 
 0004           ; // These defines are used as transmission indicators.
 0004           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0004           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0004           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0004           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0004           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0004           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0004           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0004           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0004           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0004           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0004           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0004           ; 
 0004           ; // These defines are used to fill in the instruction we are using on the servo.
 0004           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0004           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0004           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0004           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0004           ; 
 0004           ; // These defines are used for transmission timing.
 0004           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0004           ; 
 0004           ; // These defines are used for the initial probing stage, where receive waits are longer to make
 0004           ; // sure of transmission failure or success.
 0004           ; #define               BOOT_TIMEOUT                            (200)   // This is boot wait time in 1 ms units.
 0004           ; #define               MAX_TIMEOUTS                            (10)    // Number of timeouts allowed before hello mode exit.
 0004           ; 
 0004           ; // This is the maximum number of allowable modules per branch out from the master
 0004           ; #define               MAX_MODULES                                     (250)
 0004           ; 
 0004           ; #define               SERVO_START                                     (255)
 0004           ; 
 0004           ; // This function receives a mode identifier as a parameter and toggles the
 0004           ; // system configuration between receive and transmit modes for half duplex UART.
 0004           ; void configToggle(int mode);
 0004           ; 
 0004           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0004           ; int pingModule(int module_id);
 0004           ; 
 0004           ; // This function assigns an ID to a module.
 0004           ; int assignID(int assigned_ID);
 0004           ; 
 0004           ; int validTransmission(void);
 0004           ; 
 0004           ; void decodeTransmission(void);
 0004           ; 
 0004           ; void sayHello(void);
 0004           ; 
 0004           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0004           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0004           ; 
 0004           ; int clearConfig(int module_id);
 0004           ; // This function checks the current mode and unloads the configuration for that mode.
 0004           ; void unloadAllConfigs(void);
 0004           ; // This function unloads the configuration corresponding to the number passed to it.
 0004           ; void unloadConfig(int config_num);
 0004           ; // Initialization function for the slave module controllers.
 0004           ; void initializeSlaves(void);
 0004           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0004           ; void xmitWait(void);
 0004           ; 
 0004           ; // This flag is set if there is a timeout.
 0004           ; int TIMEOUT;
 0004           ; 
 0004           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0004           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0004           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0004           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0004           ; char PARAM1;                          // Stores a parameter that accompanies the command (if any).
 0004           ; char PARAM2;                          // Stores a parameter that accompanies the command (if any).
 0004           ; 
 0004           ; int STATE;                                    // Stores the current configuration state of the system.
 0004           ; 
 0004           ; void main()
 0004           ; {     
 0004                   .dbline 100
 0004           ;       int tempValue = 0;
 0004 560100            mov [X+1],0
 0007 560000            mov [X+0],0
 000A                   .dbline 101
 000A           ;       int softwareReset = 0;
 000A 560300            mov [X+3],0
 000D 560200            mov [X+2],0
 0010                   .dbline 102
 0010           ;       float angle = 0;
 0010 560400            mov [X+4],0
 0013 560500            mov [X+5],0
 0016 560600            mov [X+6],0
 0019 560700            mov [X+7],0
 001C                   .dbline 104
 001C           ;       
 001C           ;       NUM_MODULES = 0;
 001C 62D000            mov REG[0xd0],>_NUM_MODULES
 001F 550100            mov [_NUM_MODULES+1],0
 0022 550000            mov [_NUM_MODULES],0
 0025                   .dbline 106
 0025           ;       
 0025           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 0025 7101                      or  F, 01h
 0027           
 0027                   .dbline 107
 0027           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); //activate GPIO ISR
 0027 43E020            or REG[0xe0],32
 002A                   .dbline 109
 002A           ;       
 002A           ;       unloadAllConfigs();
 002A 7C0ABD            xcall _unloadAllConfigs
 002D                   .dbline 111
 002D           ; 
 002D           ;       configToggle(RX_MODE);
 002D 5000              mov A,0
 002F 08                push A
 0030 5001              mov A,1
 0032 08                push A
 0033 7C09CE            xcall _configToggle
 0036 38FE              add SP,-2
 0038           L2:
 0038                   .dbline 114
 0038           ;               
 0038           ;       // Sit and wait for the worst case setup time to occur.
 0038           ;       while(TIMEOUT < BOOT_TIMEOUT) { }
 0038                   .dbline 114
 0038           L3:
 0038                   .dbline 114
 0038 62D000            mov REG[0xd0],>_TIMEOUT
 003B 5101              mov A,[_TIMEOUT+1]
 003D 11C8              sub A,-56
 003F 5100              mov A,[_TIMEOUT]
 0041 3180              xor A,-128
 0043 1980              sbb A,(0 ^ 0x80)
 0045 CFF2              jc L2
 0047           X1:
 0047                   .dbline 117
 0047           ;               
 0047           ;       // Initialize all of the slave modules.
 0047           ;       initializeSlaves();
 0047 7C0AF6            xcall _initializeSlaves
 004A 800F              xjmp L6
 004C           L5:
 004C                   .dbline 120
 004C           ;       
 004C           ;       while(1)
 004C           ;       {       
 004C                   .dbline 121
 004C           ;               if(COMP_SERIAL_bCmdCheck())
 004C 10                push X
 004D 7C0000            xcall _COMP_SERIAL_bCmdCheck
 0050 62D000            mov REG[0xd0],>__r0
 0053 20                pop X
 0054 3900              cmp A,0
 0056 A003              jz L8
 0058                   .dbline 122
 0058           ;               {
 0058                   .dbline 123
 0058           ;                       decodeTransmission();
 0058 93DE              xcall _decodeTransmission
 005A                   .dbline 124
 005A           ;               }
 005A           L8:
 005A                   .dbline 125
 005A           ;       }
 005A           L6:
 005A                   .dbline 119
 005A 8FF1              xjmp L5
 005C           X0:
 005C                   .dbline -2
 005C           L1:
 005C 38F8              add SP,-8
 005E 20                pop X
 005F                   .dbline 0 ; func end
 005F 8FFF              jmp .
 0061                   .dbsym l angle 4 D
 0061                   .dbsym l softwareReset 2 I
 0061                   .dbsym l tempValue 0 I
 0061                   .dbend
 0061                   .dbfunc e pingModule _pingModule fI
 0061           ;       response -> X+0
 0061           ;      module_id -> X-5
 0061           _pingModule::
 0061                   .dbline -1
 0061 10                push X
 0062 4F                mov X,SP
 0063 3802              add SP,2
 0065                   .dbline 129
 0065           ; }
 0065           ; 
 0065           ; int pingModule(int module_id)
 0065           ; {
 0065                   .dbline 130
 0065           ;       int response = 0;
 0065 560100            mov [X+1],0
 0068 560000            mov [X+0],0
 006B                   .dbline 132
 006B           ;       
 006B           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 006B 5000              mov A,0
 006D 08                push A
 006E 08                push A
 006F 7C09CE            xcall _configToggle
 0072 38FE              add SP,-2
 0074                   .dbline 135
 0074           ;                       
 0074           ;       // Transmit a hello.
 0074           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0074 10                push X
 0075 50FC              mov A,-4
 0077 7C0000            xcall _TRANSMIT_PutChar
 007A 20                pop X
 007B                   .dbline 136
 007B           ;       TRANSMIT_PutChar(START_TRANSMIT);
 007B 10                push X
 007C 50FC              mov A,-4
 007E 7C0000            xcall _TRANSMIT_PutChar
 0081 20                pop X
 0082                   .dbline 137
 0082           ;       TRANSMIT_PutChar(MASTER_ID);
 0082 10                push X
 0083 5000              mov A,0
 0085 7C0000            xcall _TRANSMIT_PutChar
 0088 20                pop X
 0089                   .dbline 138
 0089           ;       TRANSMIT_PutChar(module_id);
 0089 62D000            mov REG[0xd0],>__r0
 008C 52FC              mov A,[X-4]
 008E 10                push X
 008F 7C0000            xcall _TRANSMIT_PutChar
 0092 20                pop X
 0093                   .dbline 139
 0093           ;       TRANSMIT_PutChar(PING);
 0093 10                push X
 0094 50CB              mov A,-53
 0096 7C0000            xcall _TRANSMIT_PutChar
 0099 20                pop X
 009A                   .dbline 140
 009A           ;       TRANSMIT_PutChar(END_TRANSMIT);
 009A 10                push X
 009B 50FD              mov A,-3
 009D 7C0000            xcall _TRANSMIT_PutChar
 00A0 20                pop X
 00A1                   .dbline 141
 00A1           ;       TRANSMIT_PutChar(END_TRANSMIT);
 00A1 10                push X
 00A2 50FD              mov A,-3
 00A4 7C0000            xcall _TRANSMIT_PutChar
 00A7 20                pop X
 00A8           L11:
 00A8                   .dbline 144
 00A8           ;       
 00A8           ;       // Wait for the transmission to finish.
 00A8           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 00A8           L12:
 00A8                   .dbline 144
 00A8 10                push X
 00A9 7C0000            xcall _TRANSMIT_bReadTxStatus
 00AC 62D000            mov REG[0xd0],>__r0
 00AF 20                pop X
 00B0 5300              mov [__r0],A
 00B2 470020            tst [__r0],32
 00B5 AFF2              jz L11
 00B7                   .dbline 146
 00B7           ;       
 00B7           ;       xmitWait();
 00B7 7C0C26            xcall _xmitWait
 00BA                   .dbline 148
 00BA           ;       
 00BA           ;       configToggle(RX_MODE);  // Listen for the response.
 00BA 5000              mov A,0
 00BC 08                push A
 00BD 5001              mov A,1
 00BF 08                push A
 00C0 7C09CE            xcall _configToggle
 00C3 38FE              add SP,-2
 00C5                   .dbline 150
 00C5           ;       
 00C5           ;       RX_TIMEOUT_Stop();
 00C5 10                push X
 00C6 7C0000            xcall _RX_TIMEOUT_Stop
 00C9 20                pop X
 00CA                   .dbline 151
 00CA           ;       TIMEOUT = 0;
 00CA 62D000            mov REG[0xd0],>_TIMEOUT
 00CD 550100            mov [_TIMEOUT+1],0
 00D0 550000            mov [_TIMEOUT],0
 00D3                   .dbline 152
 00D3           ;       RX_TIMEOUT_Start();
 00D3 10                push X
 00D4 7C0000            xcall _RX_TIMEOUT_Start
 00D7 20                pop X
 00D8 8048              xjmp L15
 00DA           L14:
 00DA                   .dbline 155
 00DA           ;       
 00DA           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 00DA           ;       {
 00DA                   .dbline 156
 00DA           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 00DA 10                push X
 00DB 7C0000            xcall _RECEIVE_cReadChar
 00DE 62D000            mov REG[0xd0],>__r0
 00E1 20                pop X
 00E2 39FC              cmp A,-4
 00E4 B03C              jnz L17
 00E6                   .dbline 157
 00E6           ;               {       
 00E6                   .dbline 158
 00E6           ;                       if(validTransmission())
 00E6 92FD              xcall _validTransmission
 00E8 62D000            mov REG[0xd0],>__r0
 00EB 3C0000            cmp [__r0],0
 00EE B006              jnz X2
 00F0 3C0000            cmp [__r1],0
 00F3 A02D              jz L19
 00F5           X2:
 00F5                   .dbline 159
 00F5           ;                       {
 00F5                   .dbline 160
 00F5           ;                               if(COMMAND_TYPE == PING)        // This is the response we are looking for.
 00F5 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00F8 3C00CB            cmp [_COMMAND_TYPE],-53
 00FB B025              jnz L21
 00FD                   .dbline 161
 00FD           ;                               {
 00FD                   .dbline 163
 00FD           ;                                       // If this is for me, check who it was from.
 00FD           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 00FD 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0100 3C0000            cmp [_COMMAND_DESTINATION],0
 0103 B01D              jnz L23
 0105                   .dbline 164
 0105           ;                                       {
 0105                   .dbline 165
 0105           ;                                               if(COMMAND_SOURCE == module_id)
 0105 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0108 5100              mov A,[_COMMAND_SOURCE]
 010A 62D000            mov REG[0xd0],>__r0
 010D 5300              mov [__r1],A
 010F 5000              mov A,0
 0111 3BFB              cmp A,[X-5]
 0113 B00D              jnz L25
 0115 5100              mov A,[__r1]
 0117 3BFC              cmp A,[X-4]
 0119 B007              jnz L25
 011B           X3:
 011B                   .dbline 166
 011B           ;                                               {
 011B                   .dbline 167
 011B           ;                                                       response = 1;
 011B 560101            mov [X+1],1
 011E 560000            mov [X+0],0
 0121                   .dbline 168
 0121           ;                                               }
 0121           L25:
 0121                   .dbline 169
 0121           ;                                       }
 0121           L23:
 0121                   .dbline 170
 0121           ;                               }
 0121           L21:
 0121                   .dbline 171
 0121           ;                       }
 0121           L19:
 0121                   .dbline 172
 0121           ;               }
 0121           L17:
 0121                   .dbline 173
 0121           ;       }
 0121           L15:
 0121                   .dbline 154
 0121 62D000            mov REG[0xd0],>_TIMEOUT
 0124 5101              mov A,[_TIMEOUT+1]
 0126 1105              sub A,5
 0128 5100              mov A,[_TIMEOUT]
 012A 3180              xor A,-128
 012C 1980              sbb A,(0 ^ 0x80)
 012E D00B              jnc L27
 0130           X4:
 0130 3D0000            cmp [X+0],0
 0133 B006              jnz X5
 0135 3D0100            cmp [X+1],0
 0138 AFA1              jz L14
 013A           X5:
 013A           L27:
 013A                   .dbline 175
 013A           ;       
 013A           ;       RX_TIMEOUT_Stop();
 013A 10                push X
 013B 7C0000            xcall _RX_TIMEOUT_Stop
 013E 20                pop X
 013F                   .dbline 176
 013F           ;       TIMEOUT = 0;
 013F 62D000            mov REG[0xd0],>_TIMEOUT
 0142 550100            mov [_TIMEOUT+1],0
 0145 550000            mov [_TIMEOUT],0
 0148                   .dbline 177
 0148           ;       RX_TIMEOUT_Start();
 0148 10                push X
 0149 7C0000            xcall _RX_TIMEOUT_Start
 014C 20                pop X
 014D                   .dbline 179
 014D           ;       
 014D           ;       return response;
 014D 62D000            mov REG[0xd0],>__r0
 0150 5201              mov A,[X+1]
 0152 5300              mov [__r1],A
 0154 5200              mov A,[X+0]
 0156 5300              mov [__r0],A
 0158                   .dbline -2
 0158           L10:
 0158 38FE              add SP,-2
 015A 20                pop X
 015B                   .dbline 0 ; func end
 015B 7F                ret
 015C                   .dbsym l response 0 I
 015C                   .dbsym l module_id -5 I
 015C                   .dbend
 015C                   .dbfunc e assignID _assignID fI
 015C           ;        success -> X+0
 015C           ;    assigned_ID -> X-5
 015C           _assignID::
 015C                   .dbline -1
 015C 10                push X
 015D 4F                mov X,SP
 015E 3802              add SP,2
 0160                   .dbline 183
 0160           ; }
 0160           ; 
 0160           ; int assignID(int assigned_ID)
 0160           ; {
 0160                   .dbline 184
 0160           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 0160 560100            mov [X+1],0
 0163 560000            mov [X+0],0
 0166                   .dbline 186
 0166           ;       
 0166           ;       configToggle(TX_MODE);  // Switch to TX mode.
 0166 5000              mov A,0
 0168 08                push A
 0169 08                push A
 016A 7C09CE            xcall _configToggle
 016D 38FE              add SP,-2
 016F                   .dbline 189
 016F           ; 
 016F           ;       // Transmit the assignment.
 016F           ;       TRANSMIT_PutChar(START_TRANSMIT);
 016F 10                push X
 0170 50FC              mov A,-4
 0172 7C0000            xcall _TRANSMIT_PutChar
 0175 20                pop X
 0176                   .dbline 190
 0176           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0176 10                push X
 0177 50FC              mov A,-4
 0179 7C0000            xcall _TRANSMIT_PutChar
 017C 20                pop X
 017D                   .dbline 191
 017D           ;       TRANSMIT_PutChar(MASTER_ID);
 017D 10                push X
 017E 5000              mov A,0
 0180 7C0000            xcall _TRANSMIT_PutChar
 0183 20                pop X
 0184                   .dbline 192
 0184           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0184 10                push X
 0185 50FB              mov A,-5
 0187 7C0000            xcall _TRANSMIT_PutChar
 018A 20                pop X
 018B                   .dbline 193
 018B           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 018B 10                push X
 018C 50C9              mov A,-55
 018E 7C0000            xcall _TRANSMIT_PutChar
 0191 20                pop X
 0192                   .dbline 194
 0192           ;       TRANSMIT_PutChar(assigned_ID);
 0192 62D000            mov REG[0xd0],>__r0
 0195 52FC              mov A,[X-4]
 0197 10                push X
 0198 7C0000            xcall _TRANSMIT_PutChar
 019B 20                pop X
 019C                   .dbline 195
 019C           ;       TRANSMIT_PutChar(END_TRANSMIT);
 019C 10                push X
 019D 50FD              mov A,-3
 019F 7C0000            xcall _TRANSMIT_PutChar
 01A2 20                pop X
 01A3                   .dbline 196
 01A3           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01A3 10                push X
 01A4 50FD              mov A,-3
 01A6 7C0000            xcall _TRANSMIT_PutChar
 01A9 20                pop X
 01AA           L29:
 01AA                   .dbline 199
 01AA           ;       
 01AA           ;       // Wait for the transmission to finish.
 01AA           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 01AA           L30:
 01AA                   .dbline 199
 01AA 10                push X
 01AB 7C0000            xcall _TRANSMIT_bReadTxStatus
 01AE 62D000            mov REG[0xd0],>__r0
 01B1 20                pop X
 01B2 5300              mov [__r0],A
 01B4 470020            tst [__r0],32
 01B7 AFF2              jz L29
 01B9                   .dbline 201
 01B9           ;       
 01B9           ;       xmitWait();
 01B9 7C0C26            xcall _xmitWait
 01BC                   .dbline 203
 01BC           ;       
 01BC           ;       configToggle(RX_MODE);  // Switch back to receive mode.
 01BC 5000              mov A,0
 01BE 08                push A
 01BF 5001              mov A,1
 01C1 08                push A
 01C2 7C09CE            xcall _configToggle
 01C5 38FE              add SP,-2
 01C7                   .dbline 205
 01C7           ;       
 01C7           ;       RX_TIMEOUT_Stop();
 01C7 10                push X
 01C8 7C0000            xcall _RX_TIMEOUT_Stop
 01CB 20                pop X
 01CC                   .dbline 206
 01CC           ;       TIMEOUT = 0;
 01CC 62D000            mov REG[0xd0],>_TIMEOUT
 01CF 550100            mov [_TIMEOUT+1],0
 01D2 550000            mov [_TIMEOUT],0
 01D5                   .dbline 207
 01D5           ;       RX_TIMEOUT_Start();
 01D5 10                push X
 01D6 7C0000            xcall _RX_TIMEOUT_Start
 01D9 20                pop X
 01DA 8048              xjmp L33
 01DC           L32:
 01DC                   .dbline 210
 01DC           ;       
 01DC           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!success))
 01DC           ;       {
 01DC                   .dbline 211
 01DC           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 01DC 10                push X
 01DD 7C0000            xcall _RECEIVE_cReadChar
 01E0 62D000            mov REG[0xd0],>__r0
 01E3 20                pop X
 01E4 39FC              cmp A,-4
 01E6 B03C              jnz L35
 01E8                   .dbline 212
 01E8           ;               {       
 01E8                   .dbline 213
 01E8           ;                       if(validTransmission())
 01E8 91FB              xcall _validTransmission
 01EA 62D000            mov REG[0xd0],>__r0
 01ED 3C0000            cmp [__r0],0
 01F0 B006              jnz X6
 01F2 3C0000            cmp [__r1],0
 01F5 A02D              jz L37
 01F7           X6:
 01F7                   .dbline 214
 01F7           ;                       {
 01F7                   .dbline 215
 01F7           ;                               if(COMMAND_TYPE == ID_ASSIGN_OK)        // This is the response we are looking for.
 01F7 62D000            mov REG[0xd0],>_COMMAND_TYPE
 01FA 3C00CA            cmp [_COMMAND_TYPE],-54
 01FD B025              jnz L39
 01FF                   .dbline 216
 01FF           ;                               {
 01FF                   .dbline 218
 01FF           ;                                       // If this is for me, check who it was from.
 01FF           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 01FF 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0202 3C0000            cmp [_COMMAND_DESTINATION],0
 0205 B01D              jnz L41
 0207                   .dbline 219
 0207           ;                                       {
 0207                   .dbline 220
 0207           ;                                               if(COMMAND_SOURCE == assigned_ID)
 0207 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 020A 5100              mov A,[_COMMAND_SOURCE]
 020C 62D000            mov REG[0xd0],>__r0
 020F 5300              mov [__r1],A
 0211 5000              mov A,0
 0213 3BFB              cmp A,[X-5]
 0215 B00D              jnz L43
 0217 5100              mov A,[__r1]
 0219 3BFC              cmp A,[X-4]
 021B B007              jnz L43
 021D           X7:
 021D                   .dbline 221
 021D           ;                                               {
 021D                   .dbline 222
 021D           ;                                                       success = 1;
 021D 560101            mov [X+1],1
 0220 560000            mov [X+0],0
 0223                   .dbline 223
 0223           ;                                               }
 0223           L43:
 0223                   .dbline 224
 0223           ;                                       }
 0223           L41:
 0223                   .dbline 225
 0223           ;                               }
 0223           L39:
 0223                   .dbline 226
 0223           ;                       }
 0223           L37:
 0223                   .dbline 227
 0223           ;               }
 0223           L35:
 0223                   .dbline 228
 0223           ;       }
 0223           L33:
 0223                   .dbline 209
 0223 62D000            mov REG[0xd0],>_TIMEOUT
 0226 5101              mov A,[_TIMEOUT+1]
 0228 1105              sub A,5
 022A 5100              mov A,[_TIMEOUT]
 022C 3180              xor A,-128
 022E 1980              sbb A,(0 ^ 0x80)
 0230 D00B              jnc L45
 0232           X8:
 0232 3D0000            cmp [X+0],0
 0235 B006              jnz X9
 0237 3D0100            cmp [X+1],0
 023A AFA1              jz L32
 023C           X9:
 023C           L45:
 023C                   .dbline 230
 023C           ;       
 023C           ;       LCD_1_Start();
 023C 10                push X
 023D 7C0000            xcall _LCD_1_Start
 0240 20                pop X
 0241                   .dbline 231
 0241           ;       LCD_1_Position(0,0);
 0241 10                push X
 0242 5000              mov A,0
 0244 5C                mov X,A
 0245 7C0000            xcall _LCD_1_Position
 0248 20                pop X
 0249                   .dbline 232
 0249           ;       LCD_1_PrHexInt(NUM_MODULES);
 0249 10                push X
 024A 62D000            mov REG[0xd0],>_NUM_MODULES
 024D 5100              mov A,[_NUM_MODULES]
 024F 08                push A
 0250 5101              mov A,[_NUM_MODULES+1]
 0252 20                pop X
 0253 7C0000            xcall _LCD_1_PrHexInt
 0256 20                pop X
 0257                   .dbline 233
 0257           ;       LCD_1_Position(0,5);
 0257 10                push X
 0258 5705              mov X,5
 025A 5000              mov A,0
 025C 7C0000            xcall _LCD_1_Position
 025F 20                pop X
 0260                   .dbline 234
 0260           ;       LCD_1_PrCString("Modules!");
 0260 10                push X
 0261 5000              mov A,>L46
 0263 08                push A
 0264 5000              mov A,<L46
 0266 5C                mov X,A
 0267 18                pop A
 0268 7C0000            xcall _LCD_1_PrCString
 026B                   .dbline 236
 026B           ;       
 026B           ;       RX_TIMEOUT_Stop();
 026B 7C0000            xcall _RX_TIMEOUT_Stop
 026E 20                pop X
 026F                   .dbline 237
 026F           ;       TIMEOUT = 0;
 026F 62D000            mov REG[0xd0],>_TIMEOUT
 0272 550100            mov [_TIMEOUT+1],0
 0275 550000            mov [_TIMEOUT],0
 0278                   .dbline 238
 0278           ;       RX_TIMEOUT_Start();
 0278 10                push X
 0279 7C0000            xcall _RX_TIMEOUT_Start
 027C 20                pop X
 027D                   .dbline 240
 027D           ;       
 027D           ;       return success;
 027D 62D000            mov REG[0xd0],>__r0
 0280 5201              mov A,[X+1]
 0282 5300              mov [__r1],A
 0284 5200              mov A,[X+0]
 0286 5300              mov [__r0],A
 0288                   .dbline -2
 0288           L28:
 0288 38FE              add SP,-2
 028A 20                pop X
 028B                   .dbline 0 ; func end
 028B 7F                ret
 028C                   .dbsym l success 0 I
 028C                   .dbsym l assigned_ID -5 I
 028C                   .dbend
 028C                   .dbfunc e clearConfig _clearConfig fI
 028C           ;       response -> X+0
 028C           ;      module_id -> X-5
 028C           _clearConfig::
 028C                   .dbline -1
 028C 10                push X
 028D 4F                mov X,SP
 028E 3802              add SP,2
 0290                   .dbline 244
 0290           ; }
 0290           ; 
 0290           ; int clearConfig(int module_id)
 0290           ; {
 0290                   .dbline 245
 0290           ;       int response = 0;
 0290 560100            mov [X+1],0
 0293 560000            mov [X+0],0
 0296                   .dbline 247
 0296           ;       
 0296           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0296 5000              mov A,0
 0298 08                push A
 0299 08                push A
 029A 9732              xcall _configToggle
 029C 38FE              add SP,-2
 029E                   .dbline 250
 029E           ;                       
 029E           ;       // Transmit a hello.
 029E           ;       TRANSMIT_PutChar(START_TRANSMIT);
 029E 10                push X
 029F 50FC              mov A,-4
 02A1 7C0000            xcall _TRANSMIT_PutChar
 02A4 20                pop X
 02A5                   .dbline 251
 02A5           ;       TRANSMIT_PutChar(START_TRANSMIT);
 02A5 10                push X
 02A6 50FC              mov A,-4
 02A8 7C0000            xcall _TRANSMIT_PutChar
 02AB 20                pop X
 02AC                   .dbline 252
 02AC           ;       TRANSMIT_PutChar(MASTER_ID);
 02AC 10                push X
 02AD 5000              mov A,0
 02AF 7C0000            xcall _TRANSMIT_PutChar
 02B2 20                pop X
 02B3                   .dbline 253
 02B3           ;       TRANSMIT_PutChar(module_id);
 02B3 62D000            mov REG[0xd0],>__r0
 02B6 52FC              mov A,[X-4]
 02B8 10                push X
 02B9 7C0000            xcall _TRANSMIT_PutChar
 02BC 20                pop X
 02BD                   .dbline 254
 02BD           ;       TRANSMIT_PutChar(CLEAR_CONFIG);
 02BD 10                push X
 02BE 50CC              mov A,-52
 02C0 7C0000            xcall _TRANSMIT_PutChar
 02C3 20                pop X
 02C4                   .dbline 255
 02C4           ;       TRANSMIT_PutChar(END_TRANSMIT);
 02C4 10                push X
 02C5 50FD              mov A,-3
 02C7 7C0000            xcall _TRANSMIT_PutChar
 02CA 20                pop X
 02CB                   .dbline 256
 02CB           ;       TRANSMIT_PutChar(END_TRANSMIT);
 02CB 10                push X
 02CC 50FD              mov A,-3
 02CE 7C0000            xcall _TRANSMIT_PutChar
 02D1 20                pop X
 02D2           L48:
 02D2                   .dbline 259
 02D2           ;       
 02D2           ;       // Wait for the transmission to finish.
 02D2           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 02D2           L49:
 02D2                   .dbline 259
 02D2 10                push X
 02D3 7C0000            xcall _TRANSMIT_bReadTxStatus
 02D6 62D000            mov REG[0xd0],>__r0
 02D9 20                pop X
 02DA 5300              mov [__r0],A
 02DC 470020            tst [__r0],32
 02DF AFF2              jz L48
 02E1                   .dbline 261
 02E1           ;       
 02E1           ;       xmitWait();
 02E1 7C0C26            xcall _xmitWait
 02E4                   .dbline 263
 02E4           ;       
 02E4           ;       configToggle(RX_MODE);  // Listen for the response.
 02E4 5000              mov A,0
 02E6 08                push A
 02E7 5001              mov A,1
 02E9 08                push A
 02EA 96E2              xcall _configToggle
 02EC 38FE              add SP,-2
 02EE                   .dbline 265
 02EE           ;       
 02EE           ;       if(module_id != BROADCAST)
 02EE 3DFB00            cmp [X-5],0
 02F1 B006              jnz X10
 02F3 3DFCFE            cmp [X-4],-2
 02F6 A089              jz L51
 02F8           X10:
 02F8                   .dbline 266
 02F8           ;       {
 02F8                   .dbline 267
 02F8           ;               RX_TIMEOUT_Stop();
 02F8 10                push X
 02F9 7C0000            xcall _RX_TIMEOUT_Stop
 02FC 20                pop X
 02FD                   .dbline 268
 02FD           ;               TIMEOUT = 0;
 02FD 62D000            mov REG[0xd0],>_TIMEOUT
 0300 550100            mov [_TIMEOUT+1],0
 0303 550000            mov [_TIMEOUT],0
 0306                   .dbline 269
 0306           ;               RX_TIMEOUT_Start();
 0306 10                push X
 0307 7C0000            xcall _RX_TIMEOUT_Start
 030A 20                pop X
 030B 8048              xjmp L54
 030D           L53:
 030D                   .dbline 272
 030D           ;               
 030D           ;               while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 030D           ;               {
 030D                   .dbline 273
 030D           ;                       if(RECEIVE_cReadChar() == START_TRANSMIT)
 030D 10                push X
 030E 7C0000            xcall _RECEIVE_cReadChar
 0311 62D000            mov REG[0xd0],>__r0
 0314 20                pop X
 0315 39FC              cmp A,-4
 0317 B03C              jnz L56
 0319                   .dbline 274
 0319           ;                       {       
 0319                   .dbline 275
 0319           ;                               if(validTransmission())
 0319 90CA              xcall _validTransmission
 031B 62D000            mov REG[0xd0],>__r0
 031E 3C0000            cmp [__r0],0
 0321 B006              jnz X11
 0323 3C0000            cmp [__r1],0
 0326 A02D              jz L58
 0328           X11:
 0328                   .dbline 276
 0328           ;                               {
 0328                   .dbline 277
 0328           ;                                       if(COMMAND_TYPE == CONFIG_CLEARED)      // This is the response we are looking for.
 0328 62D000            mov REG[0xd0],>_COMMAND_TYPE
 032B 3C00CD            cmp [_COMMAND_TYPE],-51
 032E B025              jnz L60
 0330                   .dbline 278
 0330           ;                                       {
 0330                   .dbline 280
 0330           ;                                               // If this is for me, check who it was from.
 0330           ;                                               if(COMMAND_DESTINATION == MASTER_ID)
 0330 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0333 3C0000            cmp [_COMMAND_DESTINATION],0
 0336 B01D              jnz L62
 0338                   .dbline 281
 0338           ;                                               {
 0338                   .dbline 282
 0338           ;                                                       if(COMMAND_SOURCE == module_id)
 0338 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 033B 5100              mov A,[_COMMAND_SOURCE]
 033D 62D000            mov REG[0xd0],>__r0
 0340 5300              mov [__r1],A
 0342 5000              mov A,0
 0344 3BFB              cmp A,[X-5]
 0346 B00D              jnz L64
 0348 5100              mov A,[__r1]
 034A 3BFC              cmp A,[X-4]
 034C B007              jnz L64
 034E           X12:
 034E                   .dbline 283
 034E           ;                                                       {
 034E                   .dbline 284
 034E           ;                                                               response = 1;
 034E 560101            mov [X+1],1
 0351 560000            mov [X+0],0
 0354                   .dbline 285
 0354           ;                                                       }
 0354           L64:
 0354                   .dbline 286
 0354           ;                                               }
 0354           L62:
 0354                   .dbline 287
 0354           ;                                       }
 0354           L60:
 0354                   .dbline 288
 0354           ;                               }
 0354           L58:
 0354                   .dbline 289
 0354           ;                       }
 0354           L56:
 0354                   .dbline 290
 0354           ;               }
 0354           L54:
 0354                   .dbline 271
 0354 62D000            mov REG[0xd0],>_TIMEOUT
 0357 5101              mov A,[_TIMEOUT+1]
 0359 1105              sub A,5
 035B 5100              mov A,[_TIMEOUT]
 035D 3180              xor A,-128
 035F 1980              sbb A,(0 ^ 0x80)
 0361 D00B              jnc L66
 0363           X13:
 0363 3D0000            cmp [X+0],0
 0366 B006              jnz X14
 0368 3D0100            cmp [X+1],0
 036B AFA1              jz L53
 036D           X14:
 036D           L66:
 036D                   .dbline 292
 036D           ;               
 036D           ;               RX_TIMEOUT_Stop();
 036D 10                push X
 036E 7C0000            xcall _RX_TIMEOUT_Stop
 0371 20                pop X
 0372                   .dbline 293
 0372           ;               TIMEOUT = 0;
 0372 62D000            mov REG[0xd0],>_TIMEOUT
 0375 550100            mov [_TIMEOUT+1],0
 0378 550000            mov [_TIMEOUT],0
 037B                   .dbline 294
 037B           ;               RX_TIMEOUT_Start();
 037B 10                push X
 037C 7C0000            xcall _RX_TIMEOUT_Start
 037F 20                pop X
 0380                   .dbline 295
 0380           ;       }
 0380           L51:
 0380                   .dbline 297
 0380           ;       
 0380           ;       return response;
 0380 62D000            mov REG[0xd0],>__r0
 0383 5201              mov A,[X+1]
 0385 5300              mov [__r1],A
 0387 5200              mov A,[X+0]
 0389 5300              mov [__r0],A
 038B                   .dbline -2
 038B           L47:
 038B 38FE              add SP,-2
 038D 20                pop X
 038E                   .dbline 0 ; func end
 038E 7F                ret
 038F                   .dbsym l response 0 I
 038F                   .dbsym l module_id -5 I
 038F                   .dbend
 038F                   .dbfunc e sayHello _sayHello fV
 038F           _sayHello::
 038F                   .dbline -1
 038F                   .dbline 302
 038F           ; }
 038F           ; 
 038F           ; // This function transmits a hello message.
 038F           ; void sayHello(void)
 038F           ; {
 038F                   .dbline 303
 038F           ;       configToggle(TX_MODE);                          // Toggle into TX mode.
 038F 5000              mov A,0
 0391 08                push A
 0392 08                push A
 0393 9639              xcall _configToggle
 0395 38FE              add SP,-2
 0397                   .dbline 306
 0397           ;                       
 0397           ;       // Transmit a hello.
 0397           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0397 10                push X
 0398 50FC              mov A,-4
 039A 7C0000            xcall _TRANSMIT_PutChar
 039D 20                pop X
 039E                   .dbline 307
 039E           ;       TRANSMIT_PutChar(START_TRANSMIT);
 039E 10                push X
 039F 50FC              mov A,-4
 03A1 7C0000            xcall _TRANSMIT_PutChar
 03A4 20                pop X
 03A5                   .dbline 308
 03A5           ;       TRANSMIT_PutChar(MASTER_ID);
 03A5 10                push X
 03A6 5000              mov A,0
 03A8 7C0000            xcall _TRANSMIT_PutChar
 03AB 20                pop X
 03AC                   .dbline 309
 03AC           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 03AC 10                push X
 03AD 50FB              mov A,-5
 03AF 7C0000            xcall _TRANSMIT_PutChar
 03B2 20                pop X
 03B3                   .dbline 310
 03B3           ;       TRANSMIT_PutChar(HELLO_BYTE);
 03B3 10                push X
 03B4 50C8              mov A,-56
 03B6 7C0000            xcall _TRANSMIT_PutChar
 03B9 20                pop X
 03BA                   .dbline 311
 03BA           ;       TRANSMIT_PutChar(END_TRANSMIT);
 03BA 10                push X
 03BB 50FD              mov A,-3
 03BD 7C0000            xcall _TRANSMIT_PutChar
 03C0 20                pop X
 03C1                   .dbline 312
 03C1           ;       TRANSMIT_PutChar(END_TRANSMIT);
 03C1 10                push X
 03C2 50FD              mov A,-3
 03C4 7C0000            xcall _TRANSMIT_PutChar
 03C7 20                pop X
 03C8           L68:
 03C8                   .dbline 315
 03C8           ;       
 03C8           ;       // Wait for the transmission to finish.
 03C8           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 03C8           L69:
 03C8                   .dbline 315
 03C8 10                push X
 03C9 7C0000            xcall _TRANSMIT_bReadTxStatus
 03CC 62D000            mov REG[0xd0],>__r0
 03CF 20                pop X
 03D0 5300              mov [__r0],A
 03D2 470020            tst [__r0],32
 03D5 AFF2              jz L68
 03D7                   .dbline 317
 03D7           ;       
 03D7           ;       xmitWait();
 03D7 7C0C26            xcall _xmitWait
 03DA                   .dbline 319
 03DA           ;       
 03DA           ;       configToggle(RX_MODE);                          // Listen for the response.
 03DA 5000              mov A,0
 03DC 08                push A
 03DD 5001              mov A,1
 03DF 08                push A
 03E0 95EC              xcall _configToggle
 03E2 38FE              add SP,-2
 03E4                   .dbline -2
 03E4           L67:
 03E4                   .dbline 0 ; func end
 03E4 7F                ret
 03E5                   .dbend
 03E5                   .dbfunc e validTransmission _validTransmission fI
 03E5           ; valid_transmit -> X+0
 03E5           _validTransmission::
 03E5                   .dbline -1
 03E5 10                push X
 03E6 4F                mov X,SP
 03E7 3802              add SP,2
 03E9                   .dbline 324
 03E9           ; }
 03E9           ; 
 03E9           ; // This function returns whether or not a valid transmission has been received.
 03E9           ; int validTransmission(void)
 03E9           ; {
 03E9                   .dbline 325
 03E9           ;       int valid_transmit = 0;
 03E9 560100            mov [X+1],0
 03EC 560000            mov [X+0],0
 03EF                   .dbline 327
 03EF           ;       
 03EF           ;       if(RECEIVE_cGetChar() == START_TRANSMIT)
 03EF 10                push X
 03F0 7C0000            xcall _RECEIVE_cGetChar
 03F3 62D000            mov REG[0xd0],>__r0
 03F6 20                pop X
 03F7 39FC              cmp A,-4
 03F9 B02F              jnz L72
 03FB                   .dbline 328
 03FB           ;       {
 03FB                   .dbline 329
 03FB           ;               COMMAND_SOURCE = RECEIVE_cGetChar();
 03FB 10                push X
 03FC 7C0000            xcall _RECEIVE_cGetChar
 03FF 20                pop X
 0400 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0403 5300              mov [_COMMAND_SOURCE],A
 0405                   .dbline 330
 0405           ;               COMMAND_DESTINATION = RECEIVE_cGetChar();
 0405 10                push X
 0406 7C0000            xcall _RECEIVE_cGetChar
 0409 20                pop X
 040A 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 040D 5300              mov [_COMMAND_DESTINATION],A
 040F                   .dbline 331
 040F           ;               COMMAND_TYPE = RECEIVE_cGetChar();
 040F 10                push X
 0410 7C0000            xcall _RECEIVE_cGetChar
 0413 20                pop X
 0414 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0417 5300              mov [_COMMAND_TYPE],A
 0419                   .dbline 332
 0419           ;               PARAM1 = RECEIVE_cGetChar();
 0419 10                push X
 041A 7C0000            xcall _RECEIVE_cGetChar
 041D 20                pop X
 041E 62D000            mov REG[0xd0],>_PARAM1
 0421 5300              mov [_PARAM1],A
 0423                   .dbline 334
 0423           ;               
 0423           ;               valid_transmit = 1;
 0423 560101            mov [X+1],1
 0426 560000            mov [X+0],0
 0429                   .dbline 335
 0429           ;       }
 0429           L72:
 0429                   .dbline 337
 0429           ;       
 0429           ;       return valid_transmit;
 0429 62D000            mov REG[0xd0],>__r0
 042C 5201              mov A,[X+1]
 042E 5300              mov [__r1],A
 0430 5200              mov A,[X+0]
 0432 5300              mov [__r0],A
 0434                   .dbline -2
 0434           L71:
 0434 38FE              add SP,-2
 0436 20                pop X
 0437                   .dbline 0 ; func end
 0437 7F                ret
 0438                   .dbsym l valid_transmit 0 I
 0438                   .dbend
 0438                   .dbfunc e decodeTransmission _decodeTransmission fV
 0438           ;       tempByte -> X+7
 0438           ;          angle -> X+5
 0438           ;             ID -> X+4
 0438           ;          total -> X+2
 0438           ;          param -> X+0
 0438           _decodeTransmission::
 0438                   .dbline -1
 0438 10                push X
 0439 4F                mov X,SP
 043A 3808              add SP,8
 043C                   .dbline 342
 043C           ; }
 043C           ; 
 043C           ; // This function decodes the transmission and takes the correct action.
 043C           ; void decodeTransmission(void)
 043C           ; {
 043C                   .dbline 347
 043C           ;       char* param;
 043C           ;       char ID;
 043C           ;       char tempByte;
 043C           ;       char angle[2];
 043C           ;       int total = 0;
 043C 560300            mov [X+3],0
 043F 560200            mov [X+2],0
 0442                   .dbline 349
 0442           ;       
 0442           ;       if(param = COMP_SERIAL_szGetParam())
 0442 10                push X
 0443 7C0000            xcall _COMP_SERIAL_szGetParam
 0446 62D000            mov REG[0xd0],>__r0
 0449 5300              mov [__r0],A
 044B 5A00              mov [__r1],X
 044D 20                pop X
 044E 5100              mov A,[__r1]
 0450 5401              mov [X+1],A
 0452 5100              mov A,[__r0]
 0454 5400              mov [X+0],A
 0456 3C0000            cmp [__r0],0
 0459 B006              jnz X15
 045B 3C0000            cmp [__r1],0
 045E A413              jz L75
 0460           X15:
 0460                   .dbline 350
 0460           ;       {
 0460                   .dbline 351
 0460           ;               if((param[0] == 'n') || (param[0] == 'N'))
 0460 62D000            mov REG[0xd0],>__r0
 0463 5201              mov A,[X+1]
 0465 5300              mov [__r1],A
 0467 5200              mov A,[X+0]
 0469 60D4              mov REG[0xd4],A
 046B 3E00              mvi A,[__r1]
 046D 5300              mov [__r1],A
 046F 550000            mov [__r0],0
 0472 3C0000            cmp [__r0],0
 0475 B005              jnz X16
 0477 396E              cmp A,110
 0479 A00E              jz L79
 047B           X16:
 047B 62D000            mov REG[0xd0],>__r0
 047E 3C0000            cmp [__r0],0
 0481 B03A              jnz L77
 0483 3C004E            cmp [__r1],78
 0486 B035              jnz L77
 0488           X17:
 0488           L79:
 0488                   .dbline 352
 0488           ;               {
 0488                   .dbline 353
 0488           ;                       COMP_SERIAL_CmdReset();
 0488 10                push X
 0489 7C0000            xcall _COMP_SERIAL_CmdReset
 048C 20                pop X
 048D                   .dbline 354
 048D           ;                       itoa(param,NUM_MODULES,10);
 048D 5000              mov A,0
 048F 08                push A
 0490 500A              mov A,10
 0492 08                push A
 0493 62D000            mov REG[0xd0],>_NUM_MODULES
 0496 5100              mov A,[_NUM_MODULES]
 0498 08                push A
 0499 5101              mov A,[_NUM_MODULES+1]
 049B 08                push A
 049C 5200              mov A,[X+0]
 049E 08                push A
 049F 5201              mov A,[X+1]
 04A1 08                push A
 04A2 7C0000            xcall _itoa
 04A5 38FA              add SP,-6
 04A7                   .dbline 355
 04A7           ;                       COMP_SERIAL_PutString(param);
 04A7 10                push X
 04A8 5200              mov A,[X+0]
 04AA 08                push A
 04AB 5201              mov A,[X+1]
 04AD 5C                mov X,A
 04AE 18                pop A
 04AF 7C0000            xcall _COMP_SERIAL_PutString
 04B2 20                pop X
 04B3                   .dbline 356
 04B3           ;                       COMP_SERIAL_PutChar('\n');
 04B3 10                push X
 04B4 500A              mov A,10
 04B6 7C0000            xcall _COMP_SERIAL_PutChar
 04B9 20                pop X
 04BA                   .dbline 357
 04BA           ;               }
 04BA 83B7              xjmp L78
 04BC           L77:
 04BC                   .dbline 358
 04BC           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 04BC 62D000            mov REG[0xd0],>__r0
 04BF 5201              mov A,[X+1]
 04C1 5300              mov [__r1],A
 04C3 5200              mov A,[X+0]
 04C5 60D4              mov REG[0xd4],A
 04C7 3E00              mvi A,[__r1]
 04C9 5300              mov [__r1],A
 04CB 550000            mov [__r0],0
 04CE 3C0000            cmp [__r0],0
 04D1 B005              jnz X18
 04D3 3977              cmp A,119
 04D5 A00E              jz L82
 04D7           X18:
 04D7 62D000            mov REG[0xd0],>__r0
 04DA 3C0000            cmp [__r0],0
 04DD B16B              jnz L80
 04DF 3C0057            cmp [__r1],87
 04E2 B166              jnz L80
 04E4           X19:
 04E4           L82:
 04E4                   .dbline 359
 04E4           ;               {
 04E4                   .dbline 360
 04E4           ;                       if(param = COMP_SERIAL_szGetParam())
 04E4 10                push X
 04E5 7C0000            xcall _COMP_SERIAL_szGetParam
 04E8 62D000            mov REG[0xd0],>__r0
 04EB 5300              mov [__r0],A
 04ED 5A00              mov [__r1],X
 04EF 20                pop X
 04F0 5100              mov A,[__r1]
 04F2 5401              mov [X+1],A
 04F4 5100              mov A,[__r0]
 04F6 5400              mov [X+0],A
 04F8 3C0000            cmp [__r0],0
 04FB B006              jnz X20
 04FD 3C0000            cmp [__r1],0
 0500 A371              jz L81
 0502           X20:
 0502                   .dbline 361
 0502           ;                       {
 0502                   .dbline 362
 0502           ;                               ID = atoi(param);
 0502 5200              mov A,[X+0]
 0504 08                push A
 0505 5201              mov A,[X+1]
 0507 08                push A
 0508 7C0000            xcall _atoi
 050B 38FE              add SP,-2
 050D 62D000            mov REG[0xd0],>__r0
 0510 5100              mov A,[__r1]
 0512 5404              mov [X+4],A
 0514                   .dbline 363
 0514           ;                               if(param = COMP_SERIAL_szGetParam())
 0514 10                push X
 0515 7C0000            xcall _COMP_SERIAL_szGetParam
 0518 62D000            mov REG[0xd0],>__r0
 051B 5300              mov [__r0],A
 051D 5A00              mov [__r1],X
 051F 20                pop X
 0520 5100              mov A,[__r1]
 0522 5401              mov [X+1],A
 0524 5100              mov A,[__r0]
 0526 5400              mov [X+0],A
 0528 3C0000            cmp [__r0],0
 052B B006              jnz X21
 052D 3C0000            cmp [__r1],0
 0530 A341              jz L81
 0532           X21:
 0532                   .dbline 364
 0532           ;                               {
 0532                   .dbline 365
 0532           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 0532 62D000            mov REG[0xd0],>__r0
 0535 5201              mov A,[X+1]
 0537 5300              mov [__r1],A
 0539 5200              mov A,[X+0]
 053B 60D4              mov REG[0xd4],A
 053D 3E00              mvi A,[__r1]
 053F 5300              mov [__r1],A
 0541 550000            mov [__r0],0
 0544 3C0000            cmp [__r0],0
 0547 B005              jnz X22
 0549 3961              cmp A,97
 054B A00E              jz L89
 054D           X22:
 054D 62D000            mov REG[0xd0],>__r0
 0550 3C0000            cmp [__r0],0
 0553 B089              jnz L87
 0555 3C0041            cmp [__r1],65
 0558 B084              jnz L87
 055A           X23:
 055A           L89:
 055A                   .dbline 366
 055A           ;                                       {
 055A                   .dbline 367
 055A           ;                                               if(param = COMP_SERIAL_szGetParam())
 055A 10                push X
 055B 7C0000            xcall _COMP_SERIAL_szGetParam
 055E 62D000            mov REG[0xd0],>__r0
 0561 5300              mov [__r0],A
 0563 5A00              mov [__r1],X
 0565 20                pop X
 0566 5100              mov A,[__r1]
 0568 5401              mov [X+1],A
 056A 5100              mov A,[__r0]
 056C 5400              mov [X+0],A
 056E 3C0000            cmp [__r0],0
 0571 B006              jnz X24
 0573 3C0000            cmp [__r1],0
 0576 A2FB              jz L81
 0578           X24:
 0578                   .dbline 368
 0578           ;                                               {
 0578                   .dbline 369
 0578           ;                                                       COMP_SERIAL_CmdReset();
 0578 10                push X
 0579 7C0000            xcall _COMP_SERIAL_CmdReset
 057C 20                pop X
 057D                   .dbline 370
 057D           ;                                                       total = atoi(param);
 057D 5200              mov A,[X+0]
 057F 08                push A
 0580 5201              mov A,[X+1]
 0582 08                push A
 0583 7C0000            xcall _atoi
 0586 38FE              add SP,-2
 0588 62D000            mov REG[0xd0],>__r0
 058B 5100              mov A,[__r1]
 058D 5403              mov [X+3],A
 058F 5100              mov A,[__r0]
 0591 5402              mov [X+2],A
 0593                   .dbline 371
 0593           ;                                                       angle[0] = total%256;
 0593 5001              mov A,1
 0595 08                push A
 0596 5000              mov A,0
 0598 08                push A
 0599 5202              mov A,[X+2]
 059B 08                push A
 059C 5203              mov A,[X+3]
 059E 08                push A
 059F 7C0000            xcall __divmod_16X16_16
 05A2 38FE              add SP,-2
 05A4 18                pop A
 05A5 5300              mov [__r1],A
 05A7 18                pop A
 05A8 5100              mov A,[__r1]
 05AA 5405              mov [X+5],A
 05AC                   .dbline 372
 05AC           ;                                                       angle[1] = total/256;
 05AC 5001              mov A,1
 05AE 08                push A
 05AF 5000              mov A,0
 05B1 08                push A
 05B2 5202              mov A,[X+2]
 05B4 08                push A
 05B5 5203              mov A,[X+3]
 05B7 08                push A
 05B8 7C0000            xcall __divmod_16X16_16
 05BB 18                pop A
 05BC 5300              mov [__r1],A
 05BE 18                pop A
 05BF 38FE              add SP,-2
 05C1 5100              mov A,[__r1]
 05C3 5406              mov [X+6],A
 05C5                   .dbline 373
 05C5           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 05C5 5206              mov A,[X+6]
 05C7 08                push A
 05C8 5205              mov A,[X+5]
 05CA 08                push A
 05CB 501E              mov A,30
 05CD 08                push A
 05CE 5003              mov A,3
 05D0 08                push A
 05D1 5005              mov A,5
 05D3 08                push A
 05D4 5204              mov A,[X+4]
 05D6 08                push A
 05D7 9353              xcall _longServoInstruction
 05D9 38FA              add SP,-6
 05DB                   .dbline 374
 05DB           ;                                               }
 05DB                   .dbline 375
 05DB           ;                                       }
 05DB 8296              xjmp L81
 05DD           L87:
 05DD                   .dbline 376
 05DD           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 05DD 62D000            mov REG[0xd0],>__r0
 05E0 5201              mov A,[X+1]
 05E2 5300              mov [__r1],A
 05E4 5200              mov A,[X+0]
 05E6 60D4              mov REG[0xd4],A
 05E8 3E00              mvi A,[__r1]
 05EA 5300              mov [__r1],A
 05EC 550000            mov [__r0],0
 05EF 3C0000            cmp [__r0],0
 05F2 B005              jnz X25
 05F4 3970              cmp A,112
 05F6 A00E              jz L96
 05F8           X25:
 05F8 62D000            mov REG[0xd0],>__r0
 05FB 3C0000            cmp [__r0],0
 05FE B273              jnz L81
 0600 3C0050            cmp [__r1],80
 0603 B26E              jnz L81
 0605           X26:
 0605           L96:
 0605                   .dbline 377
 0605           ;                                       {
 0605                   .dbline 378
 0605           ;                                               if(param = COMP_SERIAL_szGetParam())
 0605 10                push X
 0606 7C0000            xcall _COMP_SERIAL_szGetParam
 0609 62D000            mov REG[0xd0],>__r0
 060C 5300              mov [__r0],A
 060E 5A00              mov [__r1],X
 0610 20                pop X
 0611 5100              mov A,[__r1]
 0613 5401              mov [X+1],A
 0615 5100              mov A,[__r0]
 0617 5400              mov [X+0],A
 0619 3C0000            cmp [__r0],0
 061C B006              jnz X27
 061E 3C0000            cmp [__r1],0
 0621 A250              jz L81
 0623           X27:
 0623                   .dbline 379
 0623           ;                                               {
 0623                   .dbline 380
 0623           ;                                                       COMP_SERIAL_CmdReset();
 0623 10                push X
 0624 7C0000            xcall _COMP_SERIAL_CmdReset
 0627 20                pop X
 0628                   .dbline 381
 0628           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 0628 5200              mov A,[X+0]
 062A 08                push A
 062B 5201              mov A,[X+1]
 062D 08                push A
 062E 7C0000            xcall _atoi
 0631 62D000            mov REG[0xd0],>__r0
 0634 5100              mov A,[__r1]
 0636 08                push A
 0637 5018              mov A,24
 0639 08                push A
 063A 5003              mov A,3
 063C 08                push A
 063D 5004              mov A,4
 063F 08                push A
 0640 5204              mov A,[X+4]
 0642 08                push A
 0643 9253              xcall _servoInstruction
 0645 38F9              add SP,-7
 0647                   .dbline 382
 0647           ;                                               }
 0647                   .dbline 383
 0647           ;                                       }
 0647                   .dbline 384
 0647           ;                               }
 0647                   .dbline 385
 0647           ;                       }
 0647                   .dbline 386
 0647           ;               }
 0647 822A              xjmp L81
 0649           L80:
 0649                   .dbline 387
 0649           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 0649 62D000            mov REG[0xd0],>__r0
 064C 5201              mov A,[X+1]
 064E 5300              mov [__r1],A
 0650 5200              mov A,[X+0]
 0652 60D4              mov REG[0xd4],A
 0654 3E00              mvi A,[__r1]
 0656 5300              mov [__r1],A
 0658 550000            mov [__r0],0
 065B 3C0000            cmp [__r0],0
 065E B005              jnz X28
 0660 3972              cmp A,114
 0662 A00E              jz L101
 0664           X28:
 0664 62D000            mov REG[0xd0],>__r0
 0667 3C0000            cmp [__r0],0
 066A B207              jnz L99
 066C 3C0052            cmp [__r1],82
 066F B202              jnz L99
 0671           X29:
 0671           L101:
 0671                   .dbline 388
 0671           ;               {                       
 0671                   .dbline 389
 0671           ;                       if(param = COMP_SERIAL_szGetParam())
 0671 10                push X
 0672 7C0000            xcall _COMP_SERIAL_szGetParam
 0675 62D000            mov REG[0xd0],>__r0
 0678 5300              mov [__r0],A
 067A 5A00              mov [__r1],X
 067C 20                pop X
 067D 5100              mov A,[__r1]
 067F 5401              mov [X+1],A
 0681 5100              mov A,[__r0]
 0683 5400              mov [X+0],A
 0685 3C0000            cmp [__r0],0
 0688 B006              jnz X30
 068A 3C0000            cmp [__r1],0
 068D A1E4              jz L102
 068F           X30:
 068F                   .dbline 390
 068F           ;                       {
 068F                   .dbline 391
 068F           ;                               ID = atoi(param);
 068F 5200              mov A,[X+0]
 0691 08                push A
 0692 5201              mov A,[X+1]
 0694 08                push A
 0695 7C0000            xcall _atoi
 0698 38FE              add SP,-2
 069A 62D000            mov REG[0xd0],>__r0
 069D 5100              mov A,[__r1]
 069F 5404              mov [X+4],A
 06A1                   .dbline 392
 06A1           ;                               if(param = COMP_SERIAL_szGetParam())
 06A1 10                push X
 06A2 7C0000            xcall _COMP_SERIAL_szGetParam
 06A5 62D000            mov REG[0xd0],>__r0
 06A8 5300              mov [__r0],A
 06AA 5A00              mov [__r1],X
 06AC 20                pop X
 06AD 5100              mov A,[__r1]
 06AF 5401              mov [X+1],A
 06B1 5100              mov A,[__r0]
 06B3 5400              mov [X+0],A
 06B5 3C0000            cmp [__r0],0
 06B8 B006              jnz X31
 06BA 3C0000            cmp [__r1],0
 06BD A1B4              jz L104
 06BF           X31:
 06BF                   .dbline 393
 06BF           ;                               {
 06BF                   .dbline 394
 06BF           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 06BF 62D000            mov REG[0xd0],>__r0
 06C2 5201              mov A,[X+1]
 06C4 5300              mov [__r1],A
 06C6 5200              mov A,[X+0]
 06C8 60D4              mov REG[0xd4],A
 06CA 3E00              mvi A,[__r1]
 06CC 5300              mov [__r1],A
 06CE 550000            mov [__r0],0
 06D1 3C0000            cmp [__r0],0
 06D4 B005              jnz X32
 06D6 3961              cmp A,97
 06D8 A00E              jz L108
 06DA           X32:
 06DA 62D000            mov REG[0xd0],>__r0
 06DD 3C0000            cmp [__r0],0
 06E0 B0CC              jnz L106
 06E2 3C0041            cmp [__r1],65
 06E5 B0C7              jnz L106
 06E7           X33:
 06E7           L108:
 06E7                   .dbline 395
 06E7           ;                                       {
 06E7                   .dbline 396
 06E7           ;                                               COMP_SERIAL_CmdReset();
 06E7 10                push X
 06E8 7C0000            xcall _COMP_SERIAL_CmdReset
 06EB 20                pop X
 06EC                   .dbline 397
 06EC           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 06EC 5002              mov A,2
 06EE 08                push A
 06EF 5024              mov A,36
 06F1 08                push A
 06F2 5002              mov A,2
 06F4 08                push A
 06F5 5004              mov A,4
 06F7 08                push A
 06F8 5204              mov A,[X+4]
 06FA 08                push A
 06FB 919B              xcall _servoInstruction
 06FD                   .dbline 398
 06FD           ;                                               configToggle(RX_MODE);
 06FD 5000              mov A,0
 06FF 08                push A
 0700 5001              mov A,1
 0702 08                push A
 0703 92C9              xcall _configToggle
 0705 38F9              add SP,-7
 0707 8094              xjmp L110
 0709           L109:
 0709                   .dbline 402
 0709           ;                                                       
 0709           ;                                               // Loop until we read a response or time out.
 0709           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0709           ;                                               {
 0709                   .dbline 403
 0709           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 0709 10                push X
 070A 7C0000            xcall _RECEIVE_cReadChar
 070D 62D000            mov REG[0xd0],>__r0
 0710 20                pop X
 0711 39FF              cmp A,-1
 0713 B088              jnz L112
 0715                   .dbline 404
 0715           ;                                                       {
 0715                   .dbline 405
 0715           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 0715 10                push X
 0716 7C0000            xcall _RECEIVE_cGetChar
 0719 62D000            mov REG[0xd0],>__r0
 071C 20                pop X
 071D 39FF              cmp A,-1
 071F B07C              jnz L114
 0721                   .dbline 406
 0721           ;                                                               {
 0721                   .dbline 407
 0721           ;                                                                       if(RECEIVE_cGetChar() == ID)
 0721 10                push X
 0722 7C0000            xcall _RECEIVE_cGetChar
 0725 62D000            mov REG[0xd0],>__r0
 0728 20                pop X
 0729 3B04              cmp A,[X+4]
 072B B070              jnz L116
 072D                   .dbline 408
 072D           ;                                                                       {
 072D                   .dbline 409
 072D           ;                                                                               if(RECEIVE_cGetChar() == 4)
 072D 10                push X
 072E 7C0000            xcall _RECEIVE_cGetChar
 0731 62D000            mov REG[0xd0],>__r0
 0734 20                pop X
 0735 3904              cmp A,4
 0737 B064              jnz L118
 0739                   .dbline 410
 0739           ;                                                                               {
 0739                   .dbline 411
 0739           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 0739 10                push X
 073A 7C0000            xcall _RECEIVE_cGetChar
 073D 62D000            mov REG[0xd0],>__r0
 0740 20                pop X
 0741 3900              cmp A,0
 0743 B058              jnz L120
 0745                   .dbline 412
 0745           ;                                                                                       {
 0745                   .dbline 413
 0745           ;                                                                                               angle[0] = RECEIVE_cGetChar();
 0745 10                push X
 0746 7C0000            xcall _RECEIVE_cGetChar
 0749 62D000            mov REG[0xd0],>__r0
 074C 20                pop X
 074D 5405              mov [X+5],A
 074F                   .dbline 414
 074F           ;                                                                                               angle[1] = RECEIVE_cGetChar();
 074F 10                push X
 0750 7C0000            xcall _RECEIVE_cGetChar
 0753 62D000            mov REG[0xd0],>__r0
 0756 20                pop X
 0757 5406              mov [X+6],A
 0759                   .dbline 416
 0759           ;                                                                                               
 0759           ;                                                                                               configToggle(PC_MODE);
 0759 5000              mov A,0
 075B 08                push A
 075C 5002              mov A,2
 075E 08                push A
 075F 926D              xcall _configToggle
 0761                   .dbline 418
 0761           ;                                                                                               
 0761           ;                                                                                               total = ((angle[1])*256) + angle[0];
 0761 5205              mov A,[X+5]
 0763 5403              mov [X+3],A
 0765 5206              mov A,[X+6]
 0767 5402              mov [X+2],A
 0769                   .dbline 419
 0769           ;                                                                                               itoa(param,total,10);
 0769 5000              mov A,0
 076B 08                push A
 076C 500A              mov A,10
 076E 08                push A
 076F 5202              mov A,[X+2]
 0771 08                push A
 0772 5203              mov A,[X+3]
 0774 08                push A
 0775 5200              mov A,[X+0]
 0777 08                push A
 0778 5201              mov A,[X+1]
 077A 08                push A
 077B 7C0000            xcall _itoa
 077E 38F8              add SP,-8
 0780                   .dbline 420
 0780           ;                                                                                               COMP_SERIAL_PutString(param);
 0780 10                push X
 0781 5200              mov A,[X+0]
 0783 08                push A
 0784 5201              mov A,[X+1]
 0786 5C                mov X,A
 0787 18                pop A
 0788 7C0000            xcall _COMP_SERIAL_PutString
 078B 20                pop X
 078C                   .dbline 421
 078C           ;                                                                                               COMP_SERIAL_PutChar('\n');
 078C 10                push X
 078D 500A              mov A,10
 078F 7C0000            xcall _COMP_SERIAL_PutChar
 0792 20                pop X
 0793                   .dbline 423
 0793           ; 
 0793           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 0793 62D000            mov REG[0xd0],>_TIMEOUT
 0796 550105            mov [_TIMEOUT+1],5
 0799 550000            mov [_TIMEOUT],0
 079C                   .dbline 424
 079C           ;                                                                                       }
 079C           L120:
 079C                   .dbline 425
 079C           ;                                                                               }
 079C           L118:
 079C                   .dbline 426
 079C           ;                                                                       }
 079C           L116:
 079C                   .dbline 427
 079C           ;                                                               }
 079C           L114:
 079C                   .dbline 428
 079C           ;                                                       }
 079C           L112:
 079C                   .dbline 429
 079C           ;                                               }
 079C           L110:
 079C                   .dbline 401
 079C 62D000            mov REG[0xd0],>_TIMEOUT
 079F 5101              mov A,[_TIMEOUT+1]
 07A1 1105              sub A,5
 07A3 5100              mov A,[_TIMEOUT]
 07A5 3180              xor A,-128
 07A7 1980              sbb A,(0 ^ 0x80)
 07A9 CF5F              jc L109
 07AB           X34:
 07AB                   .dbline 430
 07AB           ;                                       }
 07AB 80C6              xjmp L107
 07AD           L106:
 07AD                   .dbline 431
 07AD           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 07AD 62D000            mov REG[0xd0],>__r0
 07B0 5201              mov A,[X+1]
 07B2 5300              mov [__r1],A
 07B4 5200              mov A,[X+0]
 07B6 60D4              mov REG[0xd4],A
 07B8 3E00              mvi A,[__r1]
 07BA 5300              mov [__r1],A
 07BC 550000            mov [__r0],0
 07BF 3C0000            cmp [__r0],0
 07C2 B005              jnz X35
 07C4 3970              cmp A,112
 07C6 A00E              jz L126
 07C8           X35:
 07C8 62D000            mov REG[0xd0],>__r0
 07CB 3C0000            cmp [__r0],0
 07CE B0A3              jnz L124
 07D0 3C0050            cmp [__r1],80
 07D3 B09E              jnz L124
 07D5           X36:
 07D5           L126:
 07D5                   .dbline 432
 07D5           ;                                       {
 07D5                   .dbline 433
 07D5           ;                                               COMP_SERIAL_CmdReset();
 07D5 10                push X
 07D6 7C0000            xcall _COMP_SERIAL_CmdReset
 07D9 20                pop X
 07DA                   .dbline 434
 07DA           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 07DA 5001              mov A,1
 07DC 08                push A
 07DD 5018              mov A,24
 07DF 08                push A
 07E0 5002              mov A,2
 07E2 08                push A
 07E3 5004              mov A,4
 07E5 08                push A
 07E6 5204              mov A,[X+4]
 07E8 08                push A
 07E9 90AD              xcall _servoInstruction
 07EB                   .dbline 435
 07EB           ;                                               configToggle(RX_MODE);
 07EB 5000              mov A,0
 07ED 08                push A
 07EE 5001              mov A,1
 07F0 08                push A
 07F1 91DB              xcall _configToggle
 07F3 38F9              add SP,-7
 07F5 806D              xjmp L128
 07F7           L127:
 07F7                   .dbline 439
 07F7           ;                                                       
 07F7           ;                                               // Loop until we read a response or time out.
 07F7           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 07F7           ;                                               {
 07F7                   .dbline 440
 07F7           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 07F7 10                push X
 07F8 7C0000            xcall _RECEIVE_cReadChar
 07FB 62D000            mov REG[0xd0],>__r0
 07FE 20                pop X
 07FF 39FF              cmp A,-1
 0801 B061              jnz L130
 0803                   .dbline 441
 0803           ;                                                       {
 0803                   .dbline 442
 0803           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 0803 10                push X
 0804 7C0000            xcall _RECEIVE_cGetChar
 0807 62D000            mov REG[0xd0],>__r0
 080A 20                pop X
 080B 39FF              cmp A,-1
 080D B055              jnz L132
 080F                   .dbline 443
 080F           ;                                                               {
 080F                   .dbline 444
 080F           ;                                                                       if(RECEIVE_cGetChar() == ID)
 080F 10                push X
 0810 7C0000            xcall _RECEIVE_cGetChar
 0813 62D000            mov REG[0xd0],>__r0
 0816 20                pop X
 0817 3B04              cmp A,[X+4]
 0819 B049              jnz L134
 081B                   .dbline 445
 081B           ;                                                                       {
 081B                   .dbline 446
 081B           ;                                                                               if(RECEIVE_cGetChar() == 3)
 081B 10                push X
 081C 7C0000            xcall _RECEIVE_cGetChar
 081F 62D000            mov REG[0xd0],>__r0
 0822 20                pop X
 0823 3903              cmp A,3
 0825 B03D              jnz L136
 0827                   .dbline 447
 0827           ;                                                                               {
 0827                   .dbline 448
 0827           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 0827 10                push X
 0828 7C0000            xcall _RECEIVE_cGetChar
 082B 62D000            mov REG[0xd0],>__r0
 082E 20                pop X
 082F 3900              cmp A,0
 0831 B031              jnz L138
 0833                   .dbline 449
 0833           ;                                                                                       {
 0833                   .dbline 450
 0833           ;                                                                                               tempByte = RECEIVE_cGetChar();
 0833 10                push X
 0834 7C0000            xcall _RECEIVE_cGetChar
 0837 62D000            mov REG[0xd0],>__r0
 083A 20                pop X
 083B 5407              mov [X+7],A
 083D                   .dbline 452
 083D           ;                                                                                               
 083D           ;                                                                                               configToggle(PC_MODE);
 083D 5000              mov A,0
 083F 08                push A
 0840 5002              mov A,2
 0842 08                push A
 0843 9189              xcall _configToggle
 0845 38FE              add SP,-2
 0847                   .dbline 455
 0847           ;                                                                                               
 0847           ;                                                                                               // Convert tempByte to an ascii value and send.
 0847           ;                                                                                               COMP_SERIAL_PutChar(tempByte + 48);
 0847 62D000            mov REG[0xd0],>__r0
 084A 5207              mov A,[X+7]
 084C 0130              add A,48
 084E 10                push X
 084F 7C0000            xcall _COMP_SERIAL_PutChar
 0852 20                pop X
 0853                   .dbline 456
 0853           ;                                                                                               COMP_SERIAL_PutChar('\n');
 0853 10                push X
 0854 500A              mov A,10
 0856 7C0000            xcall _COMP_SERIAL_PutChar
 0859 20                pop X
 085A                   .dbline 458
 085A           ; 
 085A           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 085A 62D000            mov REG[0xd0],>_TIMEOUT
 085D 550105            mov [_TIMEOUT+1],5
 0860 550000            mov [_TIMEOUT],0
 0863                   .dbline 459
 0863           ;                                                                                       }
 0863           L138:
 0863                   .dbline 460
 0863           ;                                                                               }
 0863           L136:
 0863                   .dbline 461
 0863           ;                                                                       }
 0863           L134:
 0863                   .dbline 462
 0863           ;                                                               }
 0863           L132:
 0863                   .dbline 463
 0863           ;                                                       }
 0863           L130:
 0863                   .dbline 464
 0863           ;                                               }
 0863           L128:
 0863                   .dbline 438
 0863 62D000            mov REG[0xd0],>_TIMEOUT
 0866 5101              mov A,[_TIMEOUT+1]
 0868 1105              sub A,5
 086A 5100              mov A,[_TIMEOUT]
 086C 3180              xor A,-128
 086E 1980              sbb A,(0 ^ 0x80)
 0870 CF86              jc L127
 0872           X37:
 0872                   .dbline 465
 0872           ;                                       }
 0872           L124:
 0872           L107:
 0872                   .dbline 466
 0872           ;                               }
 0872           L104:
 0872                   .dbline 467
 0872           ;                       }
 0872           L102:
 0872                   .dbline 468
 0872           ;               }
 0872           L99:
 0872           L81:
 0872           L78:
 0872                   .dbline 469
 0872           ;       }
 0872           L75:
 0872                   .dbline 471
 0872           ;       
 0872           ;       if(STATE != PC_MODE)
 0872 62D000            mov REG[0xd0],>_STATE
 0875 3C0000            cmp [_STATE],0
 0878 B006              jnz X38
 087A 3C0102            cmp [_STATE+1],2
 087D A00D              jz L140
 087F           X38:
 087F                   .dbline 472
 087F           ;       {
 087F                   .dbline 473
 087F           ;               configToggle(PC_MODE);
 087F 5000              mov A,0
 0881 08                push A
 0882 5002              mov A,2
 0884 08                push A
 0885 9147              xcall _configToggle
 0887 38FE              add SP,-2
 0889                   .dbline 474
 0889           ;       }
 0889 800A              xjmp L141
 088B           L140:
 088B                   .dbline 476
 088B           ;       else
 088B           ;       {
 088B                   .dbline 477
 088B           ;               TIMEOUT = 0;
 088B 62D000            mov REG[0xd0],>_TIMEOUT
 088E 550100            mov [_TIMEOUT+1],0
 0891 550000            mov [_TIMEOUT],0
 0894                   .dbline 478
 0894           ;       }
 0894           L141:
 0894                   .dbline -2
 0894           L74:
 0894 38F8              add SP,-8
 0896 20                pop X
 0897                   .dbline 0 ; func end
 0897 7F                ret
 0898                   .dbsym l tempByte 7 c
 0898                   .dbsym l angle 5 A[2:2]c
 0898                   .dbsym l ID 4 c
 0898                   .dbsym l total 2 I
 0898                   .dbsym l param 0 pc
 0898                   .dbend
 0898                   .dbfunc e servoInstruction _servoInstruction fV
 0898           ;          total -> X+1
 0898           ;       checksum -> X+0
 0898           ;          value -> X-8
 0898           ;        address -> X-7
 0898           ;    instruction -> X-6
 0898           ;         length -> X-5
 0898           ;             id -> X-4
 0898           _servoInstruction::
 0898                   .dbline -1
 0898 10                push X
 0899 4F                mov X,SP
 089A 3803              add SP,3
 089C                   .dbline 484
 089C           ; }
 089C           ; 
 089C           ; // This function receives a destination, command length, instruction type, address, and value.
 089C           ; // With these parameters, the function sends a packet to the communication bus.
 089C           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 089C           ; {
 089C                   .dbline 488
 089C           ;       char checksum;
 089C           ;       int total;
 089C           ;       
 089C           ;       total = id + length + instruction + address + value;
 089C 62D000            mov REG[0xd0],>__r0
 089F 52FB              mov A,[X-5]
 08A1 5300              mov [__r1],A
 08A3 550000            mov [__r0],0
 08A6 52FC              mov A,[X-4]
 08A8 0200              add A,[__r1]
 08AA 5300              mov [__r1],A
 08AC 5000              mov A,0
 08AE 0A00              adc A,[__r0]
 08B0 5300              mov [__r0],A
 08B2 52FA              mov A,[X-6]
 08B4 0400              add [__r1],A
 08B6 0E0000            adc [__r0],0
 08B9 52F9              mov A,[X-7]
 08BB 0400              add [__r1],A
 08BD 0E0000            adc [__r0],0
 08C0 52F8              mov A,[X-8]
 08C2 5300              mov [__r3],A
 08C4 550000            mov [__r2],0
 08C7 5100              mov A,[__r1]
 08C9 0200              add A,[__r3]
 08CB 5402              mov [X+2],A
 08CD 5100              mov A,[__r0]
 08CF 0A00              adc A,[__r2]
 08D1 5401              mov [X+1],A
 08D3                   .dbline 491
 08D3           ;       
 08D3           ;       // Calculate the checksum value for our servo communication.
 08D3           ;       checksum = 255-(total%256);
 08D3 5001              mov A,1
 08D5 08                push A
 08D6 5000              mov A,0
 08D8 08                push A
 08D9 5201              mov A,[X+1]
 08DB 08                push A
 08DC 5202              mov A,[X+2]
 08DE 08                push A
 08DF 7C0000            xcall __divmod_16X16_16
 08E2 38FE              add SP,-2
 08E4 18                pop A
 08E5 5300              mov [__r1],A
 08E7 18                pop A
 08E8 50FF              mov A,-1
 08EA 1200              sub A,[__r1]
 08EC 5400              mov [X+0],A
 08EE                   .dbline 494
 08EE           ;       
 08EE           ;       // Talk to the servo.
 08EE           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 08EE 10                push X
 08EF 50FF              mov A,-1
 08F1 7C0000            xcall _TX_REPEATER_PutChar
 08F4 20                pop X
 08F5                   .dbline 495
 08F5           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 08F5 10                push X
 08F6 50FF              mov A,-1
 08F8 7C0000            xcall _TX_REPEATER_PutChar
 08FB 20                pop X
 08FC                   .dbline 496
 08FC           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 08FC 10                push X
 08FD 52FC              mov A,[X-4]
 08FF 7C0000            xcall _TX_REPEATER_PutChar
 0902 20                pop X
 0903                   .dbline 497
 0903           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0903 10                push X
 0904 52FB              mov A,[X-5]
 0906 7C0000            xcall _TX_REPEATER_PutChar
 0909 20                pop X
 090A                   .dbline 498
 090A           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 090A 10                push X
 090B 52FA              mov A,[X-6]
 090D 7C0000            xcall _TX_REPEATER_PutChar
 0910 20                pop X
 0911                   .dbline 499
 0911           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0911 10                push X
 0912 52F9              mov A,[X-7]
 0914 7C0000            xcall _TX_REPEATER_PutChar
 0917 20                pop X
 0918                   .dbline 500
 0918           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 0918 10                push X
 0919 52F8              mov A,[X-8]
 091B 7C0000            xcall _TX_REPEATER_PutChar
 091E 20                pop X
 091F                   .dbline 501
 091F           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 091F 10                push X
 0920 5200              mov A,[X+0]
 0922 7C0000            xcall _TX_REPEATER_PutChar
 0925 20                pop X
 0926                   .dbline 507
 0926           ;       
 0926           ;       // Wait for the transmission to finish.
 0926           ;       //while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0926           ;       
 0926           ;       // Make completely sure we're done.
 0926           ;       xmitWait();
 0926 92FE              xcall _xmitWait
 0928                   .dbline -2
 0928           L142:
 0928 38FD              add SP,-3
 092A 20                pop X
 092B                   .dbline 0 ; func end
 092B 7F                ret
 092C                   .dbsym l total 1 I
 092C                   .dbsym l checksum 0 c
 092C                   .dbsym l value -8 c
 092C                   .dbsym l address -7 c
 092C                   .dbsym l instruction -6 c
 092C                   .dbsym l length -5 c
 092C                   .dbsym l id -4 c
 092C                   .dbend
 092C                   .dbfunc e longServoInstruction _longServoInstruction fV
 092C           ;          total -> X+1
 092C           ;       checksum -> X+0
 092C           ;         value2 -> X-9
 092C           ;         value1 -> X-8
 092C           ;        address -> X-7
 092C           ;    instruction -> X-6
 092C           ;         length -> X-5
 092C           ;             id -> X-4
 092C           _longServoInstruction::
 092C                   .dbline -1
 092C 10                push X
 092D 4F                mov X,SP
 092E 3803              add SP,3
 0930                   .dbline 512
 0930           ; }
 0930           ; 
 0930           ; // This function receives a destination, command length, instruction type, address, and two values.
 0930           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0930           ; {
 0930                   .dbline 516
 0930           ;       char checksum;
 0930           ;       int total;
 0930           ;       
 0930           ;       total = id + length + instruction + address + value1 + value2;
 0930 62D000            mov REG[0xd0],>__r0
 0933 52FB              mov A,[X-5]
 0935 5300              mov [__r1],A
 0937 550000            mov [__r0],0
 093A 52FC              mov A,[X-4]
 093C 0200              add A,[__r1]
 093E 5300              mov [__r1],A
 0940 5000              mov A,0
 0942 0A00              adc A,[__r0]
 0944 5300              mov [__r0],A
 0946 52FA              mov A,[X-6]
 0948 0400              add [__r1],A
 094A 0E0000            adc [__r0],0
 094D 52F9              mov A,[X-7]
 094F 0400              add [__r1],A
 0951 0E0000            adc [__r0],0
 0954 52F8              mov A,[X-8]
 0956 0400              add [__r1],A
 0958 0E0000            adc [__r0],0
 095B 52F7              mov A,[X-9]
 095D 5300              mov [__r3],A
 095F 550000            mov [__r2],0
 0962 5100              mov A,[__r1]
 0964 0200              add A,[__r3]
 0966 5402              mov [X+2],A
 0968 5100              mov A,[__r0]
 096A 0A00              adc A,[__r2]
 096C 5401              mov [X+1],A
 096E                   .dbline 519
 096E           ;       
 096E           ;       // Calculate the checksum value for our servo communication.
 096E           ;       checksum = 255-(total%256);
 096E 5001              mov A,1
 0970 08                push A
 0971 5000              mov A,0
 0973 08                push A
 0974 5201              mov A,[X+1]
 0976 08                push A
 0977 5202              mov A,[X+2]
 0979 08                push A
 097A 7C0000            xcall __divmod_16X16_16
 097D 38FE              add SP,-2
 097F 18                pop A
 0980 5300              mov [__r1],A
 0982 18                pop A
 0983 50FF              mov A,-1
 0985 1200              sub A,[__r1]
 0987 5400              mov [X+0],A
 0989                   .dbline 522
 0989           ;       
 0989           ;       // Talk to the servo.
 0989           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0989 10                push X
 098A 50FF              mov A,-1
 098C 7C0000            xcall _TX_REPEATER_PutChar
 098F 20                pop X
 0990                   .dbline 523
 0990           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0990 10                push X
 0991 50FF              mov A,-1
 0993 7C0000            xcall _TX_REPEATER_PutChar
 0996 20                pop X
 0997                   .dbline 524
 0997           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0997 10                push X
 0998 52FC              mov A,[X-4]
 099A 7C0000            xcall _TX_REPEATER_PutChar
 099D 20                pop X
 099E                   .dbline 525
 099E           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 099E 10                push X
 099F 52FB              mov A,[X-5]
 09A1 7C0000            xcall _TX_REPEATER_PutChar
 09A4 20                pop X
 09A5                   .dbline 526
 09A5           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 09A5 10                push X
 09A6 52FA              mov A,[X-6]
 09A8 7C0000            xcall _TX_REPEATER_PutChar
 09AB 20                pop X
 09AC                   .dbline 527
 09AC           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 09AC 10                push X
 09AD 52F9              mov A,[X-7]
 09AF 7C0000            xcall _TX_REPEATER_PutChar
 09B2 20                pop X
 09B3                   .dbline 528
 09B3           ;       TX_REPEATER_PutChar(value1);            // The first value to write.
 09B3 10                push X
 09B4 52F8              mov A,[X-8]
 09B6 7C0000            xcall _TX_REPEATER_PutChar
 09B9 20                pop X
 09BA                   .dbline 529
 09BA           ;       TX_REPEATER_PutChar(value2);            // The first value to write.
 09BA 10                push X
 09BB 52F7              mov A,[X-9]
 09BD 7C0000            xcall _TX_REPEATER_PutChar
 09C0 20                pop X
 09C1                   .dbline 530
 09C1           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 09C1 10                push X
 09C2 5200              mov A,[X+0]
 09C4 7C0000            xcall _TX_REPEATER_PutChar
 09C7 20                pop X
 09C8                   .dbline 536
 09C8           ;       
 09C8           ;       // Wait for the transmission to finish.
 09C8           ;       //while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 09C8           ;       
 09C8           ;       // Make completely sure we're done.
 09C8           ;       xmitWait();
 09C8 925C              xcall _xmitWait
 09CA                   .dbline -2
 09CA           L143:
 09CA 38FD              add SP,-3
 09CC 20                pop X
 09CD                   .dbline 0 ; func end
 09CD 7F                ret
 09CE                   .dbsym l total 1 I
 09CE                   .dbsym l checksum 0 c
 09CE                   .dbsym l value2 -9 c
 09CE                   .dbsym l value1 -8 c
 09CE                   .dbsym l address -7 c
 09CE                   .dbsym l instruction -6 c
 09CE                   .dbsym l length -5 c
 09CE                   .dbsym l id -4 c
 09CE                   .dbend
 09CE                   .dbfunc e configToggle _configToggle fV
 09CE           ;           mode -> X-5
 09CE           _configToggle::
 09CE                   .dbline -1
 09CE 10                push X
 09CF 4F                mov X,SP
 09D0                   .dbline 542
 09D0           ; }
 09D0           ; 
 09D0           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 09D0           ; // half duplex UART serial communication line.
 09D0           ; void configToggle(int mode)
 09D0           ; {
 09D0                   .dbline 544
 09D0           ;       // Disconnect from the global bus and leave the pin high.
 09D0           ;       PRT0DR |= 0b10000000;
 09D0 430080            or REG[0],-128
 09D3                   .dbline 545
 09D3           ;       PRT0GS &= 0b01111111;
 09D3 41027F            and REG[0x2],127
 09D6                   .dbline 549
 09D6           ; 
 09D6           ;       // Unload the configuration of the current state.
 09D6           ;       // If there is no state, blindly wipe all configurations.
 09D6           ;       if(STATE)
 09D6 62D000            mov REG[0xd0],>_STATE
 09D9 3C0000            cmp [_STATE],0
 09DC B006              jnz X39
 09DE 3C0100            cmp [_STATE+1],0
 09E1 A010              jz L145
 09E3           X39:
 09E3                   .dbline 550
 09E3           ;       {
 09E3                   .dbline 551
 09E3           ;               unloadConfig(STATE);
 09E3 62D000            mov REG[0xd0],>_STATE
 09E6 5100              mov A,[_STATE]
 09E8 08                push A
 09E9 5101              mov A,[_STATE+1]
 09EB 08                push A
 09EC 90D9              xcall _unloadConfig
 09EE 38FE              add SP,-2
 09F0                   .dbline 552
 09F0           ;       }
 09F0 8003              xjmp L146
 09F2           L145:
 09F2                   .dbline 554
 09F2           ;       else
 09F2           ;       {
 09F2                   .dbline 555
 09F2           ;               unloadAllConfigs();
 09F2 90C9              xcall _unloadAllConfigs
 09F4                   .dbline 556
 09F4           ;       }
 09F4           L146:
 09F4                   .dbline 558
 09F4           ;       
 09F4           ;       if(mode == PC_MODE)
 09F4 3DFB00            cmp [X-5],0
 09F7 B032              jnz L147
 09F9 3DFC02            cmp [X-4],2
 09FC B02D              jnz L147
 09FE           X40:
 09FE                   .dbline 559
 09FE           ;       {
 09FE                   .dbline 560
 09FE           ;               LoadConfig_pc_listener();
 09FE 7C0000            xcall _LoadConfig_pc_listener
 0A01                   .dbline 563
 0A01           ;               
 0A01           ;               //COMP_SERIAL_CmdReset();                                               // Initializes the RX buffer
 0A01           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 0A01 10                push X
 0A02 5001              mov A,1
 0A04 7C0000            xcall _COMP_SERIAL_IntCntl
 0A07 20                pop X
 0A08                   .dbline 564
 0A08           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 0A08 10                push X
 0A09 5000              mov A,0
 0A0B 7C0000            xcall _COMP_SERIAL_Start
 0A0E 20                pop X
 0A0F                   .dbline 566
 0A0F           ;               
 0A0F           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0A0F 10                push X
 0A10 5000              mov A,0
 0A12 7C0000            xcall _TX_REPEATER_Start
 0A15 20                pop X
 0A16                   .dbline 568
 0A16           ;               
 0A16           ;               TIMEOUT = 0;
 0A16 62D000            mov REG[0xd0],>_TIMEOUT
 0A19 550100            mov [_TIMEOUT+1],0
 0A1C 550000            mov [_TIMEOUT],0
 0A1F                   .dbline 569
 0A1F           ;               STATE = PC_MODE;
 0A1F 62D000            mov REG[0xd0],>_STATE
 0A22 550102            mov [_STATE+1],2
 0A25 550000            mov [_STATE],0
 0A28                   .dbline 570
 0A28           ;       }
 0A28 807A              xjmp L148
 0A2A           L147:
 0A2A                   .dbline 571
 0A2A           ;       else if(mode == RX_MODE)
 0A2A 3DFB00            cmp [X-5],0
 0A2D B02C              jnz L149
 0A2F 3DFC01            cmp [X-4],1
 0A32 B027              jnz L149
 0A34           X41:
 0A34                   .dbline 572
 0A34           ;       {
 0A34                   .dbline 573
 0A34           ;               LoadConfig_receiver_config();
 0A34 7C0000            xcall _LoadConfig_receiver_config
 0A37                   .dbline 578
 0A37           ;               
 0A37           ;               // Clear the buffer.
 0A37           ;               //RECEIVE_CmdReset();
 0A37           ;               // Start the receiver.
 0A37           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0A37 10                push X
 0A38 5000              mov A,0
 0A3A 7C0000            xcall _RECEIVE_Start
 0A3D 20                pop X
 0A3E                   .dbline 581
 0A3E           ;               
 0A3E           ;               // Start response timeout timer and enable its interrupt routine.
 0A3E           ;               TIMEOUT = 0;
 0A3E 62D000            mov REG[0xd0],>_TIMEOUT
 0A41 550100            mov [_TIMEOUT+1],0
 0A44 550000            mov [_TIMEOUT],0
 0A47                   .dbline 582
 0A47           ;               RX_TIMEOUT_EnableInt();
 0A47 10                push X
 0A48 7C0000            xcall _RX_TIMEOUT_EnableInt
 0A4B                   .dbline 583
 0A4B           ;               RX_TIMEOUT_Start();
 0A4B 7C0000            xcall _RX_TIMEOUT_Start
 0A4E 20                pop X
 0A4F                   .dbline 585
 0A4F           ;               
 0A4F           ;               STATE = RX_MODE;
 0A4F 62D000            mov REG[0xd0],>_STATE
 0A52 550101            mov [_STATE+1],1
 0A55 550000            mov [_STATE],0
 0A58                   .dbline 586
 0A58           ;       }
 0A58 804A              xjmp L150
 0A5A           L149:
 0A5A                   .dbline 587
 0A5A           ;       else if(mode == TX_MODE)
 0A5A 3DFB00            cmp [X-5],0
 0A5D B045              jnz L151
 0A5F 3DFC00            cmp [X-4],0
 0A62 B040              jnz L151
 0A64           X42:
 0A64                   .dbline 588
 0A64           ;       {
 0A64                   .dbline 589
 0A64           ;               LoadConfig_transmitter_config();
 0A64 7C0000            xcall _LoadConfig_transmitter_config
 0A67                   .dbline 591
 0A67           ;               // Start the transmitter.
 0A67           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 0A67 10                push X
 0A68 5000              mov A,0
 0A6A 7C0000            xcall _TRANSMIT_Start
 0A6D 20                pop X
 0A6E                   .dbline 593
 0A6E           ;               
 0A6E           ;               TIMEOUT = 0;
 0A6E 62D000            mov REG[0xd0],>_TIMEOUT
 0A71 550100            mov [_TIMEOUT+1],0
 0A74 550000            mov [_TIMEOUT],0
 0A77                   .dbline 594
 0A77           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0A77 10                push X
 0A78 7C0000            xcall _TX_TIMEOUT_EnableInt
 0A7B                   .dbline 595
 0A7B           ;               TX_TIMEOUT_Start();             // Start the timer.
 0A7B 7C0000            xcall _TX_TIMEOUT_Start
 0A7E 20                pop X
 0A7F           L153:
 0A7F                   .dbline 598
 0A7F           ;               
 0A7F           ;               while(!TIMEOUT)
 0A7F           ;               {
 0A7F                   .dbline 601
 0A7F           ;                       // Do nothing while we wait for one timeout period.
 0A7F           ;                       // This is to allow everyone to get in the right configuration.
 0A7F           ;               }
 0A7F           L154:
 0A7F                   .dbline 597
 0A7F 62D000            mov REG[0xd0],>_TIMEOUT
 0A82 3C0000            cmp [_TIMEOUT],0
 0A85 B006              jnz X43
 0A87 3C0100            cmp [_TIMEOUT+1],0
 0A8A AFF4              jz L153
 0A8C           X43:
 0A8C                   .dbline 603
 0A8C           ;               
 0A8C           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 0A8C 10                push X
 0A8D 7C0000            xcall _TX_TIMEOUT_Stop
 0A90 20                pop X
 0A91                   .dbline 604
 0A91           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0A91 62D000            mov REG[0xd0],>_TIMEOUT
 0A94 550100            mov [_TIMEOUT+1],0
 0A97 550000            mov [_TIMEOUT],0
 0A9A                   .dbline 606
 0A9A           ;               
 0A9A           ;               STATE = TX_MODE;
 0A9A 62D000            mov REG[0xd0],>_STATE
 0A9D 550100            mov [_STATE+1],0
 0AA0 550000            mov [_STATE],0
 0AA3                   .dbline 607
 0AA3           ;       }
 0AA3           L151:
 0AA3           L150:
 0AA3           L148:
 0AA3                   .dbline 612
 0AA3           ;       
 0AA3           ;       // Make sure to keep the LED on (active low).
 0AA3           ;       //PRT2DR &= 0b11111110;
 0AA3           ;       
 0AA3           ;       if(STATE == TX_MODE)
 0AA3 62D000            mov REG[0xd0],>_STATE
 0AA6 3C0000            cmp [_STATE],0
 0AA9 B00B              jnz L156
 0AAB 3C0100            cmp [_STATE+1],0
 0AAE B006              jnz L156
 0AB0           X44:
 0AB0                   .dbline 613
 0AB0           ;       {
 0AB0                   .dbline 614
 0AB0           ;               PRT1DR |= 0b00000001;
 0AB0 430401            or REG[0x4],1
 0AB3                   .dbline 615
 0AB3           ;       }
 0AB3 8004              xjmp L157
 0AB5           L156:
 0AB5                   .dbline 617
 0AB5           ;       else
 0AB5           ;       {
 0AB5                   .dbline 618
 0AB5           ;               PRT1DR &= 0b11111110;
 0AB5 4104FE            and REG[0x4],-2
 0AB8                   .dbline 620
 0AB8           ;               
 0AB8           ;       }
 0AB8           L157:
 0AB8                   .dbline 623
 0AB8           ;       
 0AB8           ;       // Reconnect to the global bus.
 0AB8           ;       PRT0GS |= 0b10000000;
 0AB8 430280            or REG[0x2],-128
 0ABB                   .dbline -2
 0ABB           L144:
 0ABB 20                pop X
 0ABC                   .dbline 0 ; func end
 0ABC 7F                ret
 0ABD                   .dbsym l mode -5 I
 0ABD                   .dbend
 0ABD                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0ABD           _unloadAllConfigs::
 0ABD                   .dbline -1
 0ABD                   .dbline 629
 0ABD           ; }
 0ABD           ; 
 0ABD           ; // This function blindly unloads all user configurations. This will be called once,
 0ABD           ; // when the system initially has no known state.
 0ABD           ; void unloadAllConfigs(void)
 0ABD           ; {
 0ABD                   .dbline 630
 0ABD           ;       UnloadConfig_pc_listener();
 0ABD 7C0000            xcall _UnloadConfig_pc_listener
 0AC0                   .dbline 631
 0AC0           ;       UnloadConfig_receiver_config();
 0AC0 7C0000            xcall _UnloadConfig_receiver_config
 0AC3                   .dbline 632
 0AC3           ;       UnloadConfig_transmitter_config();
 0AC3 7C0000            xcall _UnloadConfig_transmitter_config
 0AC6                   .dbline -2
 0AC6           L158:
 0AC6                   .dbline 0 ; func end
 0AC6 7F                ret
 0AC7                   .dbend
 0AC7                   .dbfunc e unloadConfig _unloadConfig fV
 0AC7           ;     config_num -> X-5
 0AC7           _unloadConfig::
 0AC7                   .dbline -1
 0AC7 10                push X
 0AC8 4F                mov X,SP
 0AC9                   .dbline 638
 0AC9           ; }
 0AC9           ; 
 0AC9           ; // This function unloads the configuration corresponding to the config number passed to it.
 0AC9           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0AC9           ; void unloadConfig(int config_num)
 0AC9           ; {
 0AC9                   .dbline 639
 0AC9           ;       if(config_num == PC_MODE)
 0AC9 3DFB00            cmp [X-5],0
 0ACC B00B              jnz L160
 0ACE 3DFC02            cmp [X-4],2
 0AD1 B006              jnz L160
 0AD3           X45:
 0AD3                   .dbline 640
 0AD3           ;       {
 0AD3                   .dbline 641
 0AD3           ;               UnloadConfig_pc_listener();
 0AD3 7C0000            xcall _UnloadConfig_pc_listener
 0AD6                   .dbline 642
 0AD6           ;       }
 0AD6 801D              xjmp L161
 0AD8           L160:
 0AD8                   .dbline 643
 0AD8           ;       else if(config_num == RX_MODE)
 0AD8 3DFB00            cmp [X-5],0
 0ADB B00B              jnz L162
 0ADD 3DFC01            cmp [X-4],1
 0AE0 B006              jnz L162
 0AE2           X46:
 0AE2                   .dbline 644
 0AE2           ;       {
 0AE2                   .dbline 645
 0AE2           ;               UnloadConfig_receiver_config();
 0AE2 7C0000            xcall _UnloadConfig_receiver_config
 0AE5                   .dbline 646
 0AE5           ;       }
 0AE5 800E              xjmp L163
 0AE7           L162:
 0AE7                   .dbline 647
 0AE7           ;       else if(config_num == TX_MODE)
 0AE7 3DFB00            cmp [X-5],0
 0AEA B009              jnz L164
 0AEC 3DFC00            cmp [X-4],0
 0AEF B004              jnz L164
 0AF1           X47:
 0AF1                   .dbline 648
 0AF1           ;       {
 0AF1                   .dbline 649
 0AF1           ;               UnloadConfig_transmitter_config();
 0AF1 7C0000            xcall _UnloadConfig_transmitter_config
 0AF4                   .dbline 650
 0AF4           ;       }
 0AF4           L164:
 0AF4           L163:
 0AF4           L161:
 0AF4                   .dbline -2
 0AF4           L159:
 0AF4 20                pop X
 0AF5                   .dbline 0 ; func end
 0AF5 7F                ret
 0AF6                   .dbsym l config_num -5 I
 0AF6                   .dbend
 0AF6                   .dbfunc e initializeSlaves _initializeSlaves fV
 0AF6           ;   num_timeouts -> X+0
 0AF6           _initializeSlaves::
 0AF6                   .dbline -1
 0AF6 10                push X
 0AF7 4F                mov X,SP
 0AF8 3802              add SP,2
 0AFA                   .dbline 654
 0AFA           ; }
 0AFA           ; 
 0AFA           ; void initializeSlaves(void)
 0AFA           ; {
 0AFA                   .dbline 655
 0AFA           ;       int num_timeouts = 0;
 0AFA 560100            mov [X+1],0
 0AFD 560000            mov [X+0],0
 0B00                   .dbline 657
 0B00           ;       
 0B00           ;       sayHello();
 0B00 988D              xcall _sayHello
 0B02 8109              xjmp L168
 0B04           L167:
 0B04                   .dbline 662
 0B04           ;       
 0B04           ;       // This loop continuously probes and listens at intervals
 0B04           ;       // set by the RX_TIMEOUT_DURATION variable.
 0B04           ;       while(num_timeouts < MAX_TIMEOUTS)
 0B04           ;       {                                       
 0B04                   .dbline 663
 0B04           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0B04 10                push X
 0B05 7C0000            xcall _RECEIVE_cReadChar
 0B08 62D000            mov REG[0xd0],>__r0
 0B0B 20                pop X
 0B0C 39FC              cmp A,-4
 0B0E B0D7              jnz L170
 0B10                   .dbline 664
 0B10           ;               {       
 0B10                   .dbline 665
 0B10           ;                       if(validTransmission())
 0B10 98D3              xcall _validTransmission
 0B12 62D000            mov REG[0xd0],>__r0
 0B15 3C0000            cmp [__r0],0
 0B18 B006              jnz X48
 0B1A 3C0000            cmp [__r1],0
 0B1D A0EE              jz L171
 0B1F           X48:
 0B1F                   .dbline 666
 0B1F           ;                       {
 0B1F                   .dbline 667
 0B1F           ;                               if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0B1F 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0B22 3C00C8            cmp [_COMMAND_TYPE],-56
 0B25 B0E6              jnz L171
 0B27                   .dbline 668
 0B27           ;                               {
 0B27                   .dbline 670
 0B27           ;                                       // If this is for me, assign them an ID.
 0B27           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 0B27 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0B2A 3C0000            cmp [_COMMAND_DESTINATION],0
 0B2D B0DE              jnz L171
 0B2F                   .dbline 671
 0B2F           ;                                       {
 0B2F                   .dbline 672
 0B2F           ;                                               NUM_MODULES++;                  // Increment the number of modules connected.
 0B2F 62D000            mov REG[0xd0],>_NUM_MODULES
 0B32 7601              inc [_NUM_MODULES+1]
 0B34 0E0000            adc [_NUM_MODULES],0
 0B37                   .dbline 673
 0B37           ;                                               num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0B37 560100            mov [X+1],0
 0B3A 560000            mov [X+0],0
 0B3D                   .dbline 675
 0B3D           ;                       
 0B3D           ;                                               if(!assignID(NUM_MODULES))
 0B3D 5100              mov A,[_NUM_MODULES]
 0B3F 08                push A
 0B40 5101              mov A,[_NUM_MODULES+1]
 0B42 08                push A
 0B43 7C015C            xcall _assignID
 0B46 38FE              add SP,-2
 0B48 62D000            mov REG[0xd0],>__r0
 0B4B 3C0000            cmp [__r0],0
 0B4E B0BD              jnz L171
 0B50 3C0000            cmp [__r1],0
 0B53 B0B8              jnz L171
 0B55           X49:
 0B55                   .dbline 676
 0B55           ;                                               {
 0B55                   .dbline 680
 0B55           ;                                                       // If the module did not respond that the ID was assigned,
 0B55           ;                                                       // make an effort to ping it in case that transmission was lost
 0B55           ;                                                       // before ultimately deciding that the module didn't configure.
 0B55           ;                                                       if(!pingModule(NUM_MODULES))
 0B55 62D000            mov REG[0xd0],>_NUM_MODULES
 0B58 5100              mov A,[_NUM_MODULES]
 0B5A 08                push A
 0B5B 5101              mov A,[_NUM_MODULES+1]
 0B5D 08                push A
 0B5E 7C0061            xcall _pingModule
 0B61 38FE              add SP,-2
 0B63 62D000            mov REG[0xd0],>__r0
 0B66 3C0000            cmp [__r0],0
 0B69 B0A2              jnz L171
 0B6B 3C0000            cmp [__r1],0
 0B6E B09D              jnz L171
 0B70           X50:
 0B70                   .dbline 681
 0B70           ;                                                       {
 0B70                   .dbline 682
 0B70           ;                                                               if(!pingModule(NUM_MODULES))
 0B70 62D000            mov REG[0xd0],>_NUM_MODULES
 0B73 5100              mov A,[_NUM_MODULES]
 0B75 08                push A
 0B76 5101              mov A,[_NUM_MODULES+1]
 0B78 08                push A
 0B79 7C0061            xcall _pingModule
 0B7C 38FE              add SP,-2
 0B7E 62D000            mov REG[0xd0],>__r0
 0B81 3C0000            cmp [__r0],0
 0B84 B087              jnz L171
 0B86 3C0000            cmp [__r1],0
 0B89 B082              jnz L171
 0B8B           X51:
 0B8B                   .dbline 683
 0B8B           ;                                                               {
 0B8B                   .dbline 684
 0B8B           ;                                                                       if(!pingModule(NUM_MODULES))
 0B8B 62D000            mov REG[0xd0],>_NUM_MODULES
 0B8E 5100              mov A,[_NUM_MODULES]
 0B90 08                push A
 0B91 5101              mov A,[_NUM_MODULES+1]
 0B93 08                push A
 0B94 7C0061            xcall _pingModule
 0B97 38FE              add SP,-2
 0B99 62D000            mov REG[0xd0],>__r0
 0B9C 3C0000            cmp [__r0],0
 0B9F B06C              jnz L171
 0BA1 3C0000            cmp [__r1],0
 0BA4 B067              jnz L171
 0BA6           X52:
 0BA6                   .dbline 685
 0BA6           ;                                                                       {
 0BA6                   .dbline 686
 0BA6           ;                                                                               if(!pingModule(NUM_MODULES))
 0BA6 62D000            mov REG[0xd0],>_NUM_MODULES
 0BA9 5100              mov A,[_NUM_MODULES]
 0BAB 08                push A
 0BAC 5101              mov A,[_NUM_MODULES+1]
 0BAE 08                push A
 0BAF 7C0061            xcall _pingModule
 0BB2 38FE              add SP,-2
 0BB4 62D000            mov REG[0xd0],>__r0
 0BB7 3C0000            cmp [__r0],0
 0BBA B051              jnz L171
 0BBC 3C0000            cmp [__r1],0
 0BBF B04C              jnz L171
 0BC1           X53:
 0BC1                   .dbline 687
 0BC1           ;                                                                               {
 0BC1                   .dbline 688
 0BC1           ;                                                                                       if(!pingModule(NUM_MODULES))
 0BC1 62D000            mov REG[0xd0],>_NUM_MODULES
 0BC4 5100              mov A,[_NUM_MODULES]
 0BC6 08                push A
 0BC7 5101              mov A,[_NUM_MODULES+1]
 0BC9 08                push A
 0BCA 7C0061            xcall _pingModule
 0BCD 38FE              add SP,-2
 0BCF 62D000            mov REG[0xd0],>__r0
 0BD2 3C0000            cmp [__r0],0
 0BD5 B036              jnz L171
 0BD7 3C0000            cmp [__r1],0
 0BDA B031              jnz L171
 0BDC           X54:
 0BDC                   .dbline 689
 0BDC           ;                                                                                       {
 0BDC                   .dbline 690
 0BDC           ;                                                                                               NUM_MODULES--;
 0BDC 62D000            mov REG[0xd0],>_NUM_MODULES
 0BDF 7A01              dec [_NUM_MODULES+1]
 0BE1 1E0000            sbb [_NUM_MODULES],0
 0BE4                   .dbline 691
 0BE4           ;                                                                                       }
 0BE4                   .dbline 692
 0BE4           ;                                                                               }
 0BE4                   .dbline 693
 0BE4           ;                                                                       }
 0BE4                   .dbline 694
 0BE4           ;                                                               }
 0BE4                   .dbline 695
 0BE4           ;                                                       }
 0BE4                   .dbline 696
 0BE4           ;                                               }
 0BE4                   .dbline 697
 0BE4           ;                                       }
 0BE4                   .dbline 698
 0BE4           ;                               }
 0BE4                   .dbline 699
 0BE4           ;                       }
 0BE4                   .dbline 700
 0BE4           ;               }
 0BE4 8027              xjmp L171
 0BE6           L170:
 0BE6                   .dbline 701
 0BE6           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 0BE6 62D000            mov REG[0xd0],>_TIMEOUT
 0BE9 5101              mov A,[_TIMEOUT+1]
 0BEB 1105              sub A,5
 0BED 5100              mov A,[_TIMEOUT]
 0BEF 3180              xor A,-128
 0BF1 1980              sbb A,(0 ^ 0x80)
 0BF3 C018              jc L190
 0BF5           X55:
 0BF5                   .dbline 702
 0BF5           ;               {       
 0BF5                   .dbline 703
 0BF5           ;                       num_timeouts++;
 0BF5 7701              inc [X+1]
 0BF7 0F0000            adc [X+0],0
 0BFA                   .dbline 706
 0BFA           ;                       
 0BFA           ;                       // If we are not maxed out on modules, look for more.
 0BFA           ;                       if(NUM_MODULES < MAX_MODULES)
 0BFA 62D000            mov REG[0xd0],>_NUM_MODULES
 0BFD 5101              mov A,[_NUM_MODULES+1]
 0BFF 11FA              sub A,-6
 0C01 5100              mov A,[_NUM_MODULES]
 0C03 3180              xor A,-128
 0C05 1980              sbb A,(0 ^ 0x80)
 0C07 D004              jnc L192
 0C09           X56:
 0C09                   .dbline 707
 0C09           ;                       {
 0C09                   .dbline 708
 0C09           ;                               sayHello();
 0C09 7C038F            xcall _sayHello
 0C0C                   .dbline 709
 0C0C           ;                       }
 0C0C           L192:
 0C0C                   .dbline 710
 0C0C           ;               }
 0C0C           L190:
 0C0C           L171:
 0C0C                   .dbline 711
 0C0C           ;       }
 0C0C           L168:
 0C0C                   .dbline 661
 0C0C 5201              mov A,[X+1]
 0C0E 110A              sub A,10
 0C10 5200              mov A,[X+0]
 0C12 3180              xor A,-128
 0C14 1980              sbb A,(0 ^ 0x80)
 0C16 CEED              jc L167
 0C18           X57:
 0C18                   .dbline 714
 0C18           ;       
 0C18           ;       // Switch back to PC mode.
 0C18           ;       configToggle(PC_MODE);
 0C18 5000              mov A,0
 0C1A 08                push A
 0C1B 5002              mov A,2
 0C1D 08                push A
 0C1E 9DAE              xcall _configToggle
 0C20 38FE              add SP,-2
 0C22                   .dbline -2
 0C22           L166:
 0C22 38FE              add SP,-2
 0C24 20                pop X
 0C25                   .dbline 0 ; func end
 0C25 7F                ret
 0C26                   .dbsym l num_timeouts 0 I
 0C26                   .dbend
 0C26                   .dbfunc e xmitWait _xmitWait fV
 0C26           ;              i -> X+0
 0C26           _xmitWait::
 0C26                   .dbline -1
 0C26 10                push X
 0C27 4F                mov X,SP
 0C28 3802              add SP,2
 0C2A                   .dbline 718
 0C2A           ; }
 0C2A           ; 
 0C2A           ; void xmitWait(void)
 0C2A           ; {
 0C2A                   .dbline 721
 0C2A           ;       int i;
 0C2A           ;       
 0C2A           ;       for(i = 0; i < 25; i++)
 0C2A 560100            mov [X+1],0
 0C2D 560000            mov [X+0],0
 0C30           L195:
 0C30                   .dbline 722
 0C30           ;       {
 0C30                   .dbline 724
 0C30           ;               // Sit here and spin for about 50 microseconds.
 0C30           ;       }
 0C30           L196:
 0C30                   .dbline 721
 0C30 7701              inc [X+1]
 0C32 0F0000            adc [X+0],0
 0C35                   .dbline 721
 0C35 5201              mov A,[X+1]
 0C37 1119              sub A,25
 0C39 5200              mov A,[X+0]
 0C3B 3180              xor A,-128
 0C3D 1980              sbb A,(0 ^ 0x80)
 0C3F CFF0              jc L195
 0C41           X58:
 0C41                   .dbline -2
 0C41           L194:
 0C41 38FE              add SP,-2
 0C43 20                pop X
 0C44                   .dbline 0 ; func end
 0C44 7F                ret
 0C45                   .dbsym l i 0 I
 0C45                   .dbend
 0C45                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0C45           _TX_TIMEOUT_ISR::
 0C45                   .dbline -1
 0C45 71C0              or F,-64
 0C47 08                push A
 0C48 5DD0              mov A,REG[0xd0]
 0C4A 08                push A
 0C4B                   .dbline 728
 0C4B           ; }
 0C4B           ; 
 0C4B           ; void TX_TIMEOUT_ISR(void)
 0C4B           ; {     
 0C4B                   .dbline 729
 0C4B           ;       TIMEOUT++;
 0C4B 62D000            mov REG[0xd0],>_TIMEOUT
 0C4E 7601              inc [_TIMEOUT+1]
 0C50 0E0000            adc [_TIMEOUT],0
 0C53                   .dbline 731
 0C53           ;       
 0C53           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0C53 62DAFD            mov REG[0xda],-3
 0C56                   .dbline -2
 0C56           L199:
 0C56 18                pop A
 0C57 60D0              mov REG[208],A
 0C59 18                pop A
 0C5A                   .dbline 0 ; func end
 0C5A 7E                reti
 0C5B                   .dbend
 0C5B                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0C5B           _RX_TIMEOUT_ISR::
 0C5B                   .dbline -1
 0C5B 71C0              or F,-64
 0C5D 08                push A
 0C5E 5DD0              mov A,REG[0xd0]
 0C60 08                push A
 0C61                   .dbline 735
 0C61           ; }
 0C61           ; 
 0C61           ; void RX_TIMEOUT_ISR(void)
 0C61           ; {     
 0C61                   .dbline 736
 0C61           ;       TIMEOUT++;
 0C61 62D000            mov REG[0xd0],>_TIMEOUT
 0C64 7601              inc [_TIMEOUT+1]
 0C66 0E0000            adc [_TIMEOUT],0
 0C69                   .dbline 738
 0C69           ;       
 0C69           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0C69 62DAFD            mov REG[0xda],-3
 0C6C                   .dbline -2
 0C6C           L200:
 0C6C 18                pop A
 0C6D 60D0              mov REG[208],A
 0C6F 18                pop A
 0C70                   .dbline 0 ; func end
 0C70 7E                reti
 0C71                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _PARAM2::
 0000 00                .byte 0
 0001                   .dbsym e PARAM2 _PARAM2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _PARAM1::
 0000 00                .byte 0
 0001                   .dbsym e PARAM1 _PARAM1 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area lit(rom, con, rel)
 0000           L46:
 0000 4D6F64756C65732100        .byte 'M,'o,'d,'u,'l,'e,'s,33,0
