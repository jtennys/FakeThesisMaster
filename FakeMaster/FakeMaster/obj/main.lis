 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ;          angle -> X+4
 0000           ;  softwareReset -> X+2
 0000           ;      tempValue -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3808              add SP,8
 0004                   .dbline 103
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>              // part specific constants and macros
 0004           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0004           ; #include "psocdynamic.h"
 0004           ; #include <stdlib.h>
 0004           ; #include <string.h>
 0004           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0004           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0004           ; 
 0004           ; // These defines are used as parameters of the configToggle function.
 0004           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0004           ; #define               PC_MODE                                         (2)
 0004           ; #define               RX_MODE                                         (1)
 0004           ; #define               TX_MODE                                         (0)
 0004           ; 
 0004           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0004           ; #define               PORT_1                                          ('1')
 0004           ; #define               PORT_2                                          ('2')
 0004           ; #define               PORT_3                                          ('3')
 0004           ; #define               PORT_4                                          ('4')
 0004           ; 
 0004           ; // These defines are used as transmission indicators.
 0004           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0004           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0004           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0004           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0004           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0004           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0004           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0004           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0004           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0004           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0004           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0004           ; 
 0004           ; // These defines are used to fill in the instruction we are using on the servo.
 0004           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0004           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0004           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0004           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0004           ; 
 0004           ; // These defines are used for transmission timing.
 0004           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0004           ; 
 0004           ; // These defines are used for the initial probing stage. This module first waits until it hears
 0004           ; // a byte on the bus. Once this happens, this module waits until there is a BUS_CLEAR_TIME
 0004           ; // period of no communication before attempting to probe for modules and assign ID numbers.
 0004           ; // MAX_TIMEOUTS is the number of failed attempts allowed to find an unconfigured module after
 0004           ; // the first module is found. After all of this, this module goes into a PC listening mode.
 0004           ; #define               BUS_CLEAR_TIME                          (100)   // Min time after a byte to assume bus is clear at boot.
 0004           ; #define               BOOT_TIMEOUT                            (300)   // If nothing is heard by this time, we start the init anyway.
 0004           ; #define               MAX_TIMEOUTS                            (10)    // Number of timeouts allowed before hello mode exit.
 0004           ; 
 0004           ; // This is the maximum number of allowable modules per branch out from the master
 0004           ; #define               MAX_MODULES                                     (250)
 0004           ; 
 0004           ; #define               SERVO_START                                     (255)
 0004           ; 
 0004           ; // This function receives a mode identifier as a parameter and toggles the
 0004           ; // system configuration between receive and transmit modes for half duplex UART.
 0004           ; void configToggle(int mode);
 0004           ; 
 0004           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0004           ; int pingModule(int module_id);
 0004           ; 
 0004           ; // This function assigns an ID to a module.
 0004           ; int assignID(int assigned_ID);
 0004           ; 
 0004           ; int validTransmission(void);
 0004           ; 
 0004           ; void decodeTransmission(void);
 0004           ; 
 0004           ; void busListen(void);
 0004           ; 
 0004           ; void sayHello(void);
 0004           ; 
 0004           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0004           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0004           ; 
 0004           ; int clearConfig(int module_id);
 0004           ; // This function checks the current mode and unloads the configuration for that mode.
 0004           ; void unloadAllConfigs(void);
 0004           ; // This function unloads the configuration corresponding to the number passed to it.
 0004           ; void unloadConfig(int config_num);
 0004           ; // Initialization function for the slave module controllers.
 0004           ; void initializeSlaves(void);
 0004           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0004           ; void xmitWait(void);
 0004           ; 
 0004           ; // This flag is set if there is a timeout.
 0004           ; int TIMEOUT;
 0004           ; 
 0004           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0004           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0004           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0004           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0004           ; char PARAM[10];                               // Stores a parameters that accompanies the command (if any).
 0004           ; int STATE;                                    // Stores the current configuration state of the system.
 0004           ; 
 0004           ; void main()
 0004           ; {     
 0004                   .dbline 104
 0004           ;       int tempValue = 0;
 0004 560100            mov [X+1],0
 0007 560000            mov [X+0],0
 000A                   .dbline 105
 000A           ;       int softwareReset = 0;
 000A 560300            mov [X+3],0
 000D 560200            mov [X+2],0
 0010                   .dbline 106
 0010           ;       float angle = 0;
 0010 560400            mov [X+4],0
 0013 560500            mov [X+5],0
 0016 560600            mov [X+6],0
 0019 560700            mov [X+7],0
 001C                   .dbline 108
 001C           ;       
 001C           ;       NUM_MODULES = 0;
 001C 62D000            mov REG[0xd0],>_NUM_MODULES
 001F 550100            mov [_NUM_MODULES+1],0
 0022 550000            mov [_NUM_MODULES],0
 0025                   .dbline 110
 0025           ;       
 0025           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 0025 7101                      or  F, 01h
 0027           
 0027                   .dbline 111
 0027           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); //activate GPIO ISR
 0027 43E020            or REG[0xe0],32
 002A                   .dbline 117
 002A           ;       
 002A           ;       // Sit and wait for the worst case setup time to occur.
 002A           ;       // while(TIMEOUT < BOOT_TIMEOUT) { }
 002A           ;               
 002A           ;       // Initialize all of the slave modules.
 002A           ;       initializeSlaves();
 002A 7C0C95            xcall _initializeSlaves
 002D 800F              xjmp L3
 002F           L2:
 002F                   .dbline 120
 002F           ;       
 002F           ;       while(1)
 002F           ;       {       
 002F                   .dbline 121
 002F           ;               if(COMP_SERIAL_bCmdCheck())
 002F 10                push X
 0030 7C0000            xcall _COMP_SERIAL_bCmdCheck
 0033 62D000            mov REG[0xd0],>__r0
 0036 20                pop X
 0037 3900              cmp A,0
 0039 A003              jz L5
 003B                   .dbline 122
 003B           ;               {
 003B                   .dbline 123
 003B           ;                       decodeTransmission();
 003B 942F              xcall _decodeTransmission
 003D                   .dbline 124
 003D           ;               }
 003D           L5:
 003D                   .dbline 125
 003D           ;       }
 003D           L3:
 003D                   .dbline 119
 003D 8FF1              xjmp L2
 003F           X0:
 003F                   .dbline -2
 003F           L1:
 003F 38F8              add SP,-8
 0041 20                pop X
 0042                   .dbline 0 ; func end
 0042 8FFF              jmp .
 0044                   .dbsym l angle 4 D
 0044                   .dbsym l softwareReset 2 I
 0044                   .dbsym l tempValue 0 I
 0044                   .dbend
 0044                   .dbfunc e pingModule _pingModule fI
 0044           ;       response -> X+0
 0044           ;      module_id -> X-5
 0044           _pingModule::
 0044                   .dbline -1
 0044 10                push X
 0045 4F                mov X,SP
 0046 3802              add SP,2
 0048                   .dbline 129
 0048           ; }
 0048           ; 
 0048           ; int pingModule(int module_id)
 0048           ; {
 0048                   .dbline 130
 0048           ;       int response = 0;
 0048 560100            mov [X+1],0
 004B 560000            mov [X+0],0
 004E                   .dbline 132
 004E           ;       
 004E           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 004E 5000              mov A,0
 0050 08                push A
 0051 08                push A
 0052 7C0B13            xcall _configToggle
 0055 38FE              add SP,-2
 0057                   .dbline 135
 0057           ;                       
 0057           ;       // Transmit a hello.
 0057           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0057 10                push X
 0058 50FC              mov A,-4
 005A 7C0000            xcall _TRANSMIT_PutChar
 005D 20                pop X
 005E                   .dbline 136
 005E           ;       TRANSMIT_PutChar(START_TRANSMIT);
 005E 10                push X
 005F 50FC              mov A,-4
 0061 7C0000            xcall _TRANSMIT_PutChar
 0064 20                pop X
 0065                   .dbline 137
 0065           ;       TRANSMIT_PutChar(MASTER_ID);
 0065 10                push X
 0066 5000              mov A,0
 0068 7C0000            xcall _TRANSMIT_PutChar
 006B 20                pop X
 006C                   .dbline 138
 006C           ;       TRANSMIT_PutChar(module_id);
 006C 62D000            mov REG[0xd0],>__r0
 006F 52FC              mov A,[X-4]
 0071 10                push X
 0072 7C0000            xcall _TRANSMIT_PutChar
 0075 20                pop X
 0076                   .dbline 139
 0076           ;       TRANSMIT_PutChar(PING);
 0076 10                push X
 0077 50CB              mov A,-53
 0079 7C0000            xcall _TRANSMIT_PutChar
 007C 20                pop X
 007D                   .dbline 140
 007D           ;       TRANSMIT_PutChar(END_TRANSMIT);
 007D 10                push X
 007E 50FD              mov A,-3
 0080 7C0000            xcall _TRANSMIT_PutChar
 0083 20                pop X
 0084                   .dbline 141
 0084           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0084 10                push X
 0085 50FD              mov A,-3
 0087 7C0000            xcall _TRANSMIT_PutChar
 008A 20                pop X
 008B           L8:
 008B                   .dbline 144
 008B           ;       
 008B           ;       // Wait for the transmission to finish.
 008B           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 008B           L9:
 008B                   .dbline 144
 008B 10                push X
 008C 7C0000            xcall _TRANSMIT_bReadTxStatus
 008F 62D000            mov REG[0xd0],>__r0
 0092 20                pop X
 0093 5300              mov [__r0],A
 0095 470020            tst [__r0],32
 0098 AFF2              jz L8
 009A                   .dbline 146
 009A           ;       
 009A           ;       xmitWait();
 009A 7C0DCA            xcall _xmitWait
 009D                   .dbline 148
 009D           ;       
 009D           ;       configToggle(RX_MODE);  // Listen for the response.
 009D 5000              mov A,0
 009F 08                push A
 00A0 5001              mov A,1
 00A2 08                push A
 00A3 7C0B13            xcall _configToggle
 00A6 38FE              add SP,-2
 00A8                   .dbline 150
 00A8           ;       
 00A8           ;       RX_TIMEOUT_Stop();
 00A8 10                push X
 00A9 7C0000            xcall _RX_TIMEOUT_Stop
 00AC 20                pop X
 00AD                   .dbline 151
 00AD           ;       TIMEOUT = 0;
 00AD 62D000            mov REG[0xd0],>_TIMEOUT
 00B0 550100            mov [_TIMEOUT+1],0
 00B3 550000            mov [_TIMEOUT],0
 00B6                   .dbline 152
 00B6           ;       RX_TIMEOUT_Start();
 00B6 10                push X
 00B7 7C0000            xcall _RX_TIMEOUT_Start
 00BA 20                pop X
 00BB 803C              xjmp L12
 00BD           L11:
 00BD                   .dbline 155
 00BD           ;       
 00BD           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 00BD           ;       {
 00BD                   .dbline 156
 00BD           ;               if(validTransmission())
 00BD 92B9              xcall _validTransmission
 00BF 62D000            mov REG[0xd0],>__r0
 00C2 3C0000            cmp [__r0],0
 00C5 B006              jnz X1
 00C7 3C0000            cmp [__r1],0
 00CA A02D              jz L14
 00CC           X1:
 00CC                   .dbline 157
 00CC           ;               {
 00CC                   .dbline 158
 00CC           ;                       if(COMMAND_TYPE == PING)        // This is the response we are looking for.
 00CC 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00CF 3C00CB            cmp [_COMMAND_TYPE],-53
 00D2 B025              jnz L16
 00D4                   .dbline 159
 00D4           ;                       {
 00D4                   .dbline 161
 00D4           ;                               // If this is for me, check who it was from.
 00D4           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 00D4 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00D7 3C0000            cmp [_COMMAND_DESTINATION],0
 00DA B01D              jnz L18
 00DC                   .dbline 162
 00DC           ;                               {
 00DC                   .dbline 163
 00DC           ;                                       if(COMMAND_SOURCE == module_id)
 00DC 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 00DF 5100              mov A,[_COMMAND_SOURCE]
 00E1 62D000            mov REG[0xd0],>__r0
 00E4 5300              mov [__r1],A
 00E6 5000              mov A,0
 00E8 3BFB              cmp A,[X-5]
 00EA B00D              jnz L20
 00EC 5100              mov A,[__r1]
 00EE 3BFC              cmp A,[X-4]
 00F0 B007              jnz L20
 00F2           X2:
 00F2                   .dbline 164
 00F2           ;                                       {
 00F2                   .dbline 165
 00F2           ;                                               response = 1;
 00F2 560101            mov [X+1],1
 00F5 560000            mov [X+0],0
 00F8                   .dbline 166
 00F8           ;                                       }
 00F8           L20:
 00F8                   .dbline 167
 00F8           ;                               }
 00F8           L18:
 00F8                   .dbline 168
 00F8           ;                       }
 00F8           L16:
 00F8                   .dbline 169
 00F8           ;               }
 00F8           L14:
 00F8                   .dbline 170
 00F8           ;       }
 00F8           L12:
 00F8                   .dbline 154
 00F8 62D000            mov REG[0xd0],>_TIMEOUT
 00FB 5101              mov A,[_TIMEOUT+1]
 00FD 1105              sub A,5
 00FF 5100              mov A,[_TIMEOUT]
 0101 3180              xor A,-128
 0103 1980              sbb A,(0 ^ 0x80)
 0105 D00B              jnc L22
 0107           X3:
 0107 3D0000            cmp [X+0],0
 010A B006              jnz X4
 010C 3D0100            cmp [X+1],0
 010F AFAD              jz L11
 0111           X4:
 0111           L22:
 0111                   .dbline 172
 0111           ;       
 0111           ;       RX_TIMEOUT_Stop();
 0111 10                push X
 0112 7C0000            xcall _RX_TIMEOUT_Stop
 0115 20                pop X
 0116                   .dbline 173
 0116           ;       TIMEOUT = 0;
 0116 62D000            mov REG[0xd0],>_TIMEOUT
 0119 550100            mov [_TIMEOUT+1],0
 011C 550000            mov [_TIMEOUT],0
 011F                   .dbline 174
 011F           ;       RX_TIMEOUT_Start();
 011F 10                push X
 0120 7C0000            xcall _RX_TIMEOUT_Start
 0123 20                pop X
 0124                   .dbline 176
 0124           ;       
 0124           ;       return response;
 0124 62D000            mov REG[0xd0],>__r0
 0127 5201              mov A,[X+1]
 0129 5300              mov [__r1],A
 012B 5200              mov A,[X+0]
 012D 5300              mov [__r0],A
 012F                   .dbline -2
 012F           L7:
 012F 38FE              add SP,-2
 0131 20                pop X
 0132                   .dbline 0 ; func end
 0132 7F                ret
 0133                   .dbsym l response 0 I
 0133                   .dbsym l module_id -5 I
 0133                   .dbend
 0133                   .dbfunc e assignID _assignID fI
 0133           ;        success -> X+0
 0133           ;    assigned_ID -> X-5
 0133           _assignID::
 0133                   .dbline -1
 0133 10                push X
 0134 4F                mov X,SP
 0135 3802              add SP,2
 0137                   .dbline 180
 0137           ; }
 0137           ; 
 0137           ; int assignID(int assigned_ID)
 0137           ; {
 0137                   .dbline 181
 0137           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 0137 560100            mov [X+1],0
 013A 560000            mov [X+0],0
 013D                   .dbline 183
 013D           ;       
 013D           ;       configToggle(TX_MODE);  // Switch to TX mode.
 013D 5000              mov A,0
 013F 08                push A
 0140 08                push A
 0141 7C0B13            xcall _configToggle
 0144 38FE              add SP,-2
 0146                   .dbline 186
 0146           ; 
 0146           ;       // Transmit the assignment.
 0146           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0146 10                push X
 0147 50FC              mov A,-4
 0149 7C0000            xcall _TRANSMIT_PutChar
 014C 20                pop X
 014D                   .dbline 187
 014D           ;       TRANSMIT_PutChar(START_TRANSMIT);
 014D 10                push X
 014E 50FC              mov A,-4
 0150 7C0000            xcall _TRANSMIT_PutChar
 0153 20                pop X
 0154                   .dbline 188
 0154           ;       TRANSMIT_PutChar(MASTER_ID);
 0154 10                push X
 0155 5000              mov A,0
 0157 7C0000            xcall _TRANSMIT_PutChar
 015A 20                pop X
 015B                   .dbline 189
 015B           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 015B 10                push X
 015C 50FB              mov A,-5
 015E 7C0000            xcall _TRANSMIT_PutChar
 0161 20                pop X
 0162                   .dbline 190
 0162           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 0162 10                push X
 0163 50C9              mov A,-55
 0165 7C0000            xcall _TRANSMIT_PutChar
 0168 20                pop X
 0169                   .dbline 191
 0169           ;       TRANSMIT_PutChar(assigned_ID);
 0169 62D000            mov REG[0xd0],>__r0
 016C 52FC              mov A,[X-4]
 016E 10                push X
 016F 7C0000            xcall _TRANSMIT_PutChar
 0172 20                pop X
 0173                   .dbline 192
 0173           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0173 10                push X
 0174 50FD              mov A,-3
 0176 7C0000            xcall _TRANSMIT_PutChar
 0179 20                pop X
 017A                   .dbline 193
 017A           ;       TRANSMIT_PutChar(END_TRANSMIT);
 017A 10                push X
 017B 50FD              mov A,-3
 017D 7C0000            xcall _TRANSMIT_PutChar
 0180 20                pop X
 0181           L24:
 0181                   .dbline 196
 0181           ;       
 0181           ;       // Wait for the transmission to finish.
 0181           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0181           L25:
 0181                   .dbline 196
 0181 10                push X
 0182 7C0000            xcall _TRANSMIT_bReadTxStatus
 0185 62D000            mov REG[0xd0],>__r0
 0188 20                pop X
 0189 5300              mov [__r0],A
 018B 470020            tst [__r0],32
 018E AFF2              jz L24
 0190                   .dbline 198
 0190           ;       
 0190           ;       xmitWait();
 0190 7C0DCA            xcall _xmitWait
 0193                   .dbline 200
 0193           ;       
 0193           ;       configToggle(RX_MODE);  // Switch back to receive mode.
 0193 5000              mov A,0
 0195 08                push A
 0196 5001              mov A,1
 0198 08                push A
 0199 7C0B13            xcall _configToggle
 019C 38FE              add SP,-2
 019E                   .dbline 202
 019E           ;       
 019E           ;       RX_TIMEOUT_Stop();
 019E 10                push X
 019F 7C0000            xcall _RX_TIMEOUT_Stop
 01A2 20                pop X
 01A3                   .dbline 203
 01A3           ;       TIMEOUT = 0;
 01A3 62D000            mov REG[0xd0],>_TIMEOUT
 01A6 550100            mov [_TIMEOUT+1],0
 01A9 550000            mov [_TIMEOUT],0
 01AC                   .dbline 204
 01AC           ;       RX_TIMEOUT_Start();
 01AC 10                push X
 01AD 7C0000            xcall _RX_TIMEOUT_Start
 01B0 20                pop X
 01B1 803C              xjmp L28
 01B3           L27:
 01B3                   .dbline 207
 01B3           ;       
 01B3           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!success))
 01B3           ;       {
 01B3                   .dbline 208
 01B3           ;               if(validTransmission())
 01B3 91C3              xcall _validTransmission
 01B5 62D000            mov REG[0xd0],>__r0
 01B8 3C0000            cmp [__r0],0
 01BB B006              jnz X5
 01BD 3C0000            cmp [__r1],0
 01C0 A02D              jz L30
 01C2           X5:
 01C2                   .dbline 209
 01C2           ;               {
 01C2                   .dbline 210
 01C2           ;                       if(COMMAND_TYPE == ID_ASSIGN_OK)        // This is the response we are looking for.
 01C2 62D000            mov REG[0xd0],>_COMMAND_TYPE
 01C5 3C00CA            cmp [_COMMAND_TYPE],-54
 01C8 B025              jnz L32
 01CA                   .dbline 211
 01CA           ;                       {
 01CA                   .dbline 213
 01CA           ;                               // If this is for me, check who it was from.
 01CA           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 01CA 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 01CD 3C0000            cmp [_COMMAND_DESTINATION],0
 01D0 B01D              jnz L34
 01D2                   .dbline 214
 01D2           ;                               {
 01D2                   .dbline 215
 01D2           ;                                       if(COMMAND_SOURCE == assigned_ID)
 01D2 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 01D5 5100              mov A,[_COMMAND_SOURCE]
 01D7 62D000            mov REG[0xd0],>__r0
 01DA 5300              mov [__r1],A
 01DC 5000              mov A,0
 01DE 3BFB              cmp A,[X-5]
 01E0 B00D              jnz L36
 01E2 5100              mov A,[__r1]
 01E4 3BFC              cmp A,[X-4]
 01E6 B007              jnz L36
 01E8           X6:
 01E8                   .dbline 216
 01E8           ;                                       {
 01E8                   .dbline 217
 01E8           ;                                               success = 1;
 01E8 560101            mov [X+1],1
 01EB 560000            mov [X+0],0
 01EE                   .dbline 218
 01EE           ;                                       }
 01EE           L36:
 01EE                   .dbline 219
 01EE           ;                               }
 01EE           L34:
 01EE                   .dbline 220
 01EE           ;                       }
 01EE           L32:
 01EE                   .dbline 221
 01EE           ;               }
 01EE           L30:
 01EE                   .dbline 222
 01EE           ;       }
 01EE           L28:
 01EE                   .dbline 206
 01EE 62D000            mov REG[0xd0],>_TIMEOUT
 01F1 5101              mov A,[_TIMEOUT+1]
 01F3 1105              sub A,5
 01F5 5100              mov A,[_TIMEOUT]
 01F7 3180              xor A,-128
 01F9 1980              sbb A,(0 ^ 0x80)
 01FB D00B              jnc L38
 01FD           X7:
 01FD 3D0000            cmp [X+0],0
 0200 B006              jnz X8
 0202 3D0100            cmp [X+1],0
 0205 AFAD              jz L27
 0207           X8:
 0207           L38:
 0207                   .dbline 230
 0207           ;       
 0207           ; //    LCD_1_Start();
 0207           ; //    LCD_1_Position(0,0);
 0207           ; //    LCD_1_PrHexInt(NUM_MODULES);
 0207           ; //    LCD_1_Position(0,5);
 0207           ; //    LCD_1_PrCString("Modules!");
 0207           ;       
 0207           ;       RX_TIMEOUT_Stop();
 0207 10                push X
 0208 7C0000            xcall _RX_TIMEOUT_Stop
 020B 20                pop X
 020C                   .dbline 231
 020C           ;       TIMEOUT = 0;
 020C 62D000            mov REG[0xd0],>_TIMEOUT
 020F 550100            mov [_TIMEOUT+1],0
 0212 550000            mov [_TIMEOUT],0
 0215                   .dbline 232
 0215           ;       RX_TIMEOUT_Start();
 0215 10                push X
 0216 7C0000            xcall _RX_TIMEOUT_Start
 0219 20                pop X
 021A                   .dbline 234
 021A           ;       
 021A           ;       return success;
 021A 62D000            mov REG[0xd0],>__r0
 021D 5201              mov A,[X+1]
 021F 5300              mov [__r1],A
 0221 5200              mov A,[X+0]
 0223 5300              mov [__r0],A
 0225                   .dbline -2
 0225           L23:
 0225 38FE              add SP,-2
 0227 20                pop X
 0228                   .dbline 0 ; func end
 0228 7F                ret
 0229                   .dbsym l success 0 I
 0229                   .dbsym l assigned_ID -5 I
 0229                   .dbend
 0229                   .dbfunc e clearConfig _clearConfig fI
 0229           ;       response -> X+0
 0229           ;      module_id -> X-5
 0229           _clearConfig::
 0229                   .dbline -1
 0229 10                push X
 022A 4F                mov X,SP
 022B 3802              add SP,2
 022D                   .dbline 238
 022D           ; }
 022D           ; 
 022D           ; int clearConfig(int module_id)
 022D           ; {
 022D                   .dbline 239
 022D           ;       int response = 0;
 022D 560100            mov [X+1],0
 0230 560000            mov [X+0],0
 0233                   .dbline 241
 0233           ;       
 0233           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0233 5000              mov A,0
 0235 08                push A
 0236 08                push A
 0237 7C0B13            xcall _configToggle
 023A 38FE              add SP,-2
 023C                   .dbline 244
 023C           ;                       
 023C           ;       // Transmit a hello.
 023C           ;       TRANSMIT_PutChar(START_TRANSMIT);
 023C 10                push X
 023D 50FC              mov A,-4
 023F 7C0000            xcall _TRANSMIT_PutChar
 0242 20                pop X
 0243                   .dbline 245
 0243           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0243 10                push X
 0244 50FC              mov A,-4
 0246 7C0000            xcall _TRANSMIT_PutChar
 0249 20                pop X
 024A                   .dbline 246
 024A           ;       TRANSMIT_PutChar(MASTER_ID);
 024A 10                push X
 024B 5000              mov A,0
 024D 7C0000            xcall _TRANSMIT_PutChar
 0250 20                pop X
 0251                   .dbline 247
 0251           ;       TRANSMIT_PutChar(module_id);
 0251 62D000            mov REG[0xd0],>__r0
 0254 52FC              mov A,[X-4]
 0256 10                push X
 0257 7C0000            xcall _TRANSMIT_PutChar
 025A 20                pop X
 025B                   .dbline 248
 025B           ;       TRANSMIT_PutChar(CLEAR_CONFIG);
 025B 10                push X
 025C 50CC              mov A,-52
 025E 7C0000            xcall _TRANSMIT_PutChar
 0261 20                pop X
 0262                   .dbline 249
 0262           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0262 10                push X
 0263 50FD              mov A,-3
 0265 7C0000            xcall _TRANSMIT_PutChar
 0268 20                pop X
 0269                   .dbline 250
 0269           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0269 10                push X
 026A 50FD              mov A,-3
 026C 7C0000            xcall _TRANSMIT_PutChar
 026F 20                pop X
 0270           L40:
 0270                   .dbline 253
 0270           ;       
 0270           ;       // Wait for the transmission to finish.
 0270           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 0270           L41:
 0270                   .dbline 253
 0270 10                push X
 0271 7C0000            xcall _TRANSMIT_bReadTxStatus
 0274 62D000            mov REG[0xd0],>__r0
 0277 20                pop X
 0278 5300              mov [__r0],A
 027A 470020            tst [__r0],32
 027D AFF2              jz L40
 027F                   .dbline 255
 027F           ;       
 027F           ;       xmitWait();
 027F 7C0DCA            xcall _xmitWait
 0282                   .dbline 257
 0282           ;       
 0282           ;       configToggle(RX_MODE);  // Listen for the response.
 0282 5000              mov A,0
 0284 08                push A
 0285 5001              mov A,1
 0287 08                push A
 0288 7C0B13            xcall _configToggle
 028B 38FE              add SP,-2
 028D                   .dbline 259
 028D           ;       
 028D           ;       if(module_id != BROADCAST)
 028D 3DFB00            cmp [X-5],0
 0290 B006              jnz X9
 0292 3DFCFE            cmp [X-4],-2
 0295 A07D              jz L43
 0297           X9:
 0297                   .dbline 260
 0297           ;       {
 0297                   .dbline 261
 0297           ;               RX_TIMEOUT_Stop();
 0297 10                push X
 0298 7C0000            xcall _RX_TIMEOUT_Stop
 029B 20                pop X
 029C                   .dbline 262
 029C           ;               TIMEOUT = 0;
 029C 62D000            mov REG[0xd0],>_TIMEOUT
 029F 550100            mov [_TIMEOUT+1],0
 02A2 550000            mov [_TIMEOUT],0
 02A5                   .dbline 263
 02A5           ;               RX_TIMEOUT_Start();
 02A5 10                push X
 02A6 7C0000            xcall _RX_TIMEOUT_Start
 02A9 20                pop X
 02AA 803C              xjmp L46
 02AC           L45:
 02AC                   .dbline 266
 02AC           ;               
 02AC           ;               while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 02AC           ;               {
 02AC                   .dbline 267
 02AC           ;                       if(validTransmission())
 02AC 90CA              xcall _validTransmission
 02AE 62D000            mov REG[0xd0],>__r0
 02B1 3C0000            cmp [__r0],0
 02B4 B006              jnz X10
 02B6 3C0000            cmp [__r1],0
 02B9 A02D              jz L48
 02BB           X10:
 02BB                   .dbline 268
 02BB           ;                       {
 02BB                   .dbline 269
 02BB           ;                               if(COMMAND_TYPE == CONFIG_CLEARED)      // This is the response we are looking for.
 02BB 62D000            mov REG[0xd0],>_COMMAND_TYPE
 02BE 3C00CD            cmp [_COMMAND_TYPE],-51
 02C1 B025              jnz L50
 02C3                   .dbline 270
 02C3           ;                               {
 02C3                   .dbline 272
 02C3           ;                                       // If this is for me, check who it was from.
 02C3           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 02C3 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 02C6 3C0000            cmp [_COMMAND_DESTINATION],0
 02C9 B01D              jnz L52
 02CB                   .dbline 273
 02CB           ;                                       {
 02CB                   .dbline 274
 02CB           ;                                               if(COMMAND_SOURCE == module_id)
 02CB 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 02CE 5100              mov A,[_COMMAND_SOURCE]
 02D0 62D000            mov REG[0xd0],>__r0
 02D3 5300              mov [__r1],A
 02D5 5000              mov A,0
 02D7 3BFB              cmp A,[X-5]
 02D9 B00D              jnz L54
 02DB 5100              mov A,[__r1]
 02DD 3BFC              cmp A,[X-4]
 02DF B007              jnz L54
 02E1           X11:
 02E1                   .dbline 275
 02E1           ;                                               {
 02E1                   .dbline 276
 02E1           ;                                                       response = 1;
 02E1 560101            mov [X+1],1
 02E4 560000            mov [X+0],0
 02E7                   .dbline 277
 02E7           ;                                               }
 02E7           L54:
 02E7                   .dbline 278
 02E7           ;                                       }
 02E7           L52:
 02E7                   .dbline 279
 02E7           ;                               }
 02E7           L50:
 02E7                   .dbline 280
 02E7           ;                       }
 02E7           L48:
 02E7                   .dbline 281
 02E7           ;               }
 02E7           L46:
 02E7                   .dbline 265
 02E7 62D000            mov REG[0xd0],>_TIMEOUT
 02EA 5101              mov A,[_TIMEOUT+1]
 02EC 1105              sub A,5
 02EE 5100              mov A,[_TIMEOUT]
 02F0 3180              xor A,-128
 02F2 1980              sbb A,(0 ^ 0x80)
 02F4 D00B              jnc L56
 02F6           X12:
 02F6 3D0000            cmp [X+0],0
 02F9 B006              jnz X13
 02FB 3D0100            cmp [X+1],0
 02FE AFAD              jz L45
 0300           X13:
 0300           L56:
 0300                   .dbline 283
 0300           ;               
 0300           ;               RX_TIMEOUT_Stop();
 0300 10                push X
 0301 7C0000            xcall _RX_TIMEOUT_Stop
 0304 20                pop X
 0305                   .dbline 284
 0305           ;               TIMEOUT = 0;
 0305 62D000            mov REG[0xd0],>_TIMEOUT
 0308 550100            mov [_TIMEOUT+1],0
 030B 550000            mov [_TIMEOUT],0
 030E                   .dbline 285
 030E           ;               RX_TIMEOUT_Start();
 030E 10                push X
 030F 7C0000            xcall _RX_TIMEOUT_Start
 0312 20                pop X
 0313                   .dbline 286
 0313           ;       }
 0313           L43:
 0313                   .dbline 288
 0313           ;       
 0313           ;       return response;
 0313 62D000            mov REG[0xd0],>__r0
 0316 5201              mov A,[X+1]
 0318 5300              mov [__r1],A
 031A 5200              mov A,[X+0]
 031C 5300              mov [__r0],A
 031E                   .dbline -2
 031E           L39:
 031E 38FE              add SP,-2
 0320 20                pop X
 0321                   .dbline 0 ; func end
 0321 7F                ret
 0322                   .dbsym l response 0 I
 0322                   .dbsym l module_id -5 I
 0322                   .dbend
 0322                   .dbfunc e sayHello _sayHello fV
 0322           _sayHello::
 0322                   .dbline -1
 0322                   .dbline 293
 0322           ; }
 0322           ; 
 0322           ; // This function transmits a hello message.
 0322           ; void sayHello(void)
 0322           ; {
 0322                   .dbline 294
 0322           ;       configToggle(TX_MODE);                          // Toggle into TX mode.
 0322 5000              mov A,0
 0324 08                push A
 0325 08                push A
 0326 97EB              xcall _configToggle
 0328 38FE              add SP,-2
 032A                   .dbline 297
 032A           ;                       
 032A           ;       // Transmit a hello.
 032A           ;       TRANSMIT_PutChar(START_TRANSMIT);
 032A 10                push X
 032B 50FC              mov A,-4
 032D 7C0000            xcall _TRANSMIT_PutChar
 0330 20                pop X
 0331                   .dbline 298
 0331           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0331 10                push X
 0332 50FC              mov A,-4
 0334 7C0000            xcall _TRANSMIT_PutChar
 0337 20                pop X
 0338                   .dbline 299
 0338           ;       TRANSMIT_PutChar(MASTER_ID);
 0338 10                push X
 0339 5000              mov A,0
 033B 7C0000            xcall _TRANSMIT_PutChar
 033E 20                pop X
 033F                   .dbline 300
 033F           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 033F 10                push X
 0340 50FB              mov A,-5
 0342 7C0000            xcall _TRANSMIT_PutChar
 0345 20                pop X
 0346                   .dbline 301
 0346           ;       TRANSMIT_PutChar(HELLO_BYTE);
 0346 10                push X
 0347 50C8              mov A,-56
 0349 7C0000            xcall _TRANSMIT_PutChar
 034C 20                pop X
 034D                   .dbline 302
 034D           ;       TRANSMIT_PutChar(END_TRANSMIT);
 034D 10                push X
 034E 50FD              mov A,-3
 0350 7C0000            xcall _TRANSMIT_PutChar
 0353 20                pop X
 0354                   .dbline 303
 0354           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0354 10                push X
 0355 50FD              mov A,-3
 0357 7C0000            xcall _TRANSMIT_PutChar
 035A 20                pop X
 035B           L58:
 035B                   .dbline 306
 035B           ;       
 035B           ;       // Wait for the transmission to finish.
 035B           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 035B           L59:
 035B                   .dbline 306
 035B 10                push X
 035C 7C0000            xcall _TRANSMIT_bReadTxStatus
 035F 62D000            mov REG[0xd0],>__r0
 0362 20                pop X
 0363 5300              mov [__r0],A
 0365 470020            tst [__r0],32
 0368 AFF2              jz L58
 036A                   .dbline 308
 036A           ;       
 036A           ;       xmitWait();
 036A 7C0DCA            xcall _xmitWait
 036D                   .dbline 310
 036D           ;       
 036D           ;       configToggle(RX_MODE);                          // Listen for the response.
 036D 5000              mov A,0
 036F 08                push A
 0370 5001              mov A,1
 0372 08                push A
 0373 979E              xcall _configToggle
 0375 38FE              add SP,-2
 0377                   .dbline -2
 0377           L57:
 0377                   .dbline 0 ; func end
 0377 7F                ret
 0378                   .dbend
 0378                   .dbfunc e validTransmission _validTransmission fI
 0378           ; valid_transmit -> X+3
 0378           ;              i -> X+1
 0378           ;       tempByte -> X+0
 0378           _validTransmission::
 0378                   .dbline -1
 0378 10                push X
 0379 4F                mov X,SP
 037A 3805              add SP,5
 037C                   .dbline 315
 037C           ; }
 037C           ; 
 037C           ; // This function returns whether or not a valid transmission has been received.
 037C           ; int validTransmission(void)
 037C           ; {
 037C                   .dbline 316
 037C           ;       int valid_transmit = 0;
 037C 560400            mov [X+4],0
 037F 560300            mov [X+3],0
 0382                   .dbline 317
 0382           ;       int i = 0;
 0382 560200            mov [X+2],0
 0385 560100            mov [X+1],0
 0388                   .dbline 318
 0388           ;       char tempByte = 0;
 0388 560000            mov [X+0],0
 038B 80C2              xjmp L63
 038D           L62:
 038D                   .dbline 321
 038D           ;       
 038D           ;       while(TIMEOUT < RX_TIMEOUT_DURATION)
 038D           ;       {
 038D                   .dbline 322
 038D           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 038D 10                push X
 038E 7C0000            xcall _RECEIVE_cReadChar
 0391 62D000            mov REG[0xd0],>__r0
 0394 20                pop X
 0395 39FC              cmp A,-4
 0397 B0B6              jnz L65
 0399                   .dbline 323
 0399           ;               {
 0399 80A5              xjmp L68
 039B           L67:
 039B                   .dbline 325
 039B           ;                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 039B           ;                       {
 039B                   .dbline 326
 039B           ;                               if(RECEIVE_cReadChar() == START_TRANSMIT)
 039B 10                push X
 039C 7C0000            xcall _RECEIVE_cReadChar
 039F 62D000            mov REG[0xd0],>__r0
 03A2 20                pop X
 03A3 39FC              cmp A,-4
 03A5 B099              jnz L70
 03A7                   .dbline 327
 03A7           ;                               {
 03A7 8088              xjmp L73
 03A9           L72:
 03A9                   .dbline 329
 03A9           ;                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 03A9           ;                                       {
 03A9                   .dbline 330
 03A9           ;                                               if(tempByte = RECEIVE_cReadChar())
 03A9 10                push X
 03AA 7C0000            xcall _RECEIVE_cReadChar
 03AD 20                pop X
 03AE 5400              mov [X+0],A
 03B0 3900              cmp A,0
 03B2 A07D              jz L75
 03B4                   .dbline 331
 03B4           ;                                               {
 03B4                   .dbline 332
 03B4           ;                                                       COMMAND_SOURCE = tempByte;
 03B4 5200              mov A,[X+0]
 03B6 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 03B9 5300              mov [_COMMAND_SOURCE],A
 03BB 8065              xjmp L78
 03BD           L77:
 03BD                   .dbline 335
 03BD           ;                                                       
 03BD           ;                                                       while(TIMEOUT < RX_TIMEOUT_DURATION)
 03BD           ;                                                       {
 03BD                   .dbline 336
 03BD           ;                                                               if(tempByte = RECEIVE_cReadChar())
 03BD 10                push X
 03BE 7C0000            xcall _RECEIVE_cReadChar
 03C1 62D000            mov REG[0xd0],>__r0
 03C4 20                pop X
 03C5 5400              mov [X+0],A
 03C7 3900              cmp A,0
 03C9 A057              jz L80
 03CB                   .dbline 337
 03CB           ;                                                               {
 03CB                   .dbline 338
 03CB           ;                                                                       if(tempByte >= HELLO_BYTE)
 03CB 3D00C8            cmp [X+0],-56
 03CE C052              jc L82
 03D0           X14:
 03D0                   .dbline 339
 03D0           ;                                                                       {
 03D0                   .dbline 340
 03D0           ;                                                                               COMMAND_TYPE = tempByte;
 03D0 5200              mov A,[X+0]
 03D2 62D000            mov REG[0xd0],>_COMMAND_TYPE
 03D5 5300              mov [_COMMAND_TYPE],A
 03D7 803A              xjmp L85
 03D9           L84:
 03D9                   .dbline 343
 03D9           ;                                                                               
 03D9           ;                                                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 03D9           ;                                                                               {
 03D9                   .dbline 344
 03D9           ;                                                                                       if(tempByte = RECEIVE_cReadChar())
 03D9 10                push X
 03DA 7C0000            xcall _RECEIVE_cReadChar
 03DD 62D000            mov REG[0xd0],>__r0
 03E0 20                pop X
 03E1 5400              mov [X+0],A
 03E3 3900              cmp A,0
 03E5 A02C              jz L87
 03E7                   .dbline 345
 03E7           ;                                                                                       {
 03E7                   .dbline 346
 03E7           ;                                                                                               if(tempByte != END_TRANSMIT)
 03E7 3D00FD            cmp [X+0],-3
 03EA A018              jz L89
 03EC                   .dbline 347
 03EC           ;                                                                                               {
 03EC                   .dbline 348
 03EC           ;                                                                                                       PARAM[i] = tempByte;
 03EC 5202              mov A,[X+2]
 03EE 0100              add A,<_PARAM
 03F0 5300              mov [__r1],A
 03F2 5201              mov A,[X+1]
 03F4 0900              adc A,>_PARAM
 03F6 60D5              mov REG[0xd5],A
 03F8 5200              mov A,[X+0]
 03FA 3F00              mvi [__r1],A
 03FC                   .dbline 349
 03FC           ;                                                                                                       i++;
 03FC 7702              inc [X+2]
 03FE 0F0100            adc [X+1],0
 0401                   .dbline 350
 0401           ;                                                                                               }
 0401 8010              xjmp L90
 0403           L89:
 0403                   .dbline 352
 0403           ;                                                                                               else
 0403           ;                                                                                               {
 0403                   .dbline 353
 0403           ;                                                                                                       valid_transmit = 1;
 0403 560401            mov [X+4],1
 0406 560300            mov [X+3],0
 0409                   .dbline 354
 0409           ;                                                                                                       TIMEOUT = RX_TIMEOUT_DURATION;
 0409 62D000            mov REG[0xd0],>_TIMEOUT
 040C 550105            mov [_TIMEOUT+1],5
 040F 550000            mov [_TIMEOUT],0
 0412                   .dbline 355
 0412           ;                                                                                               }
 0412           L90:
 0412                   .dbline 356
 0412           ;                                                                                       }
 0412           L87:
 0412                   .dbline 357
 0412           ;                                                                               }
 0412           L85:
 0412                   .dbline 342
 0412 62D000            mov REG[0xd0],>_TIMEOUT
 0415 5101              mov A,[_TIMEOUT+1]
 0417 1105              sub A,5
 0419 5100              mov A,[_TIMEOUT]
 041B 3180              xor A,-128
 041D 1980              sbb A,(0 ^ 0x80)
 041F CFB9              jc L84
 0421           X15:
 0421                   .dbline 358
 0421           ;                                                                       }
 0421           L82:
 0421                   .dbline 359
 0421           ;                                                               }
 0421           L80:
 0421                   .dbline 360
 0421           ;                                                       }
 0421           L78:
 0421                   .dbline 334
 0421 62D000            mov REG[0xd0],>_TIMEOUT
 0424 5101              mov A,[_TIMEOUT+1]
 0426 1105              sub A,5
 0428 5100              mov A,[_TIMEOUT]
 042A 3180              xor A,-128
 042C 1980              sbb A,(0 ^ 0x80)
 042E CF8E              jc L77
 0430           X16:
 0430                   .dbline 361
 0430           ;                                               }
 0430           L75:
 0430                   .dbline 362
 0430           ;                                       }
 0430           L73:
 0430                   .dbline 328
 0430 62D000            mov REG[0xd0],>_TIMEOUT
 0433 5101              mov A,[_TIMEOUT+1]
 0435 1105              sub A,5
 0437 5100              mov A,[_TIMEOUT]
 0439 3180              xor A,-128
 043B 1980              sbb A,(0 ^ 0x80)
 043D CF6B              jc L72
 043F           X17:
 043F                   .dbline 363
 043F           ;                               }
 043F           L70:
 043F                   .dbline 364
 043F           ;                       }
 043F           L68:
 043F                   .dbline 324
 043F 62D000            mov REG[0xd0],>_TIMEOUT
 0442 5101              mov A,[_TIMEOUT+1]
 0444 1105              sub A,5
 0446 5100              mov A,[_TIMEOUT]
 0448 3180              xor A,-128
 044A 1980              sbb A,(0 ^ 0x80)
 044C CF4E              jc L67
 044E           X18:
 044E                   .dbline 365
 044E           ;               }
 044E           L65:
 044E                   .dbline 366
 044E           ;       }
 044E           L63:
 044E                   .dbline 320
 044E 62D000            mov REG[0xd0],>_TIMEOUT
 0451 5101              mov A,[_TIMEOUT+1]
 0453 1105              sub A,5
 0455 5100              mov A,[_TIMEOUT]
 0457 3180              xor A,-128
 0459 1980              sbb A,(0 ^ 0x80)
 045B CF31              jc L62
 045D           X19:
 045D                   .dbline 368
 045D           ;       
 045D           ;       return valid_transmit;
 045D 62D000            mov REG[0xd0],>__r0
 0460 5204              mov A,[X+4]
 0462 5300              mov [__r1],A
 0464 5203              mov A,[X+3]
 0466 5300              mov [__r0],A
 0468                   .dbline -2
 0468           L61:
 0468 38FB              add SP,-5
 046A 20                pop X
 046B                   .dbline 0 ; func end
 046B 7F                ret
 046C                   .dbsym l valid_transmit 3 I
 046C                   .dbsym l i 1 I
 046C                   .dbsym l tempByte 0 c
 046C                   .dbend
 046C                   .dbfunc e decodeTransmission _decodeTransmission fV
 046C           ;       tempByte -> X+7
 046C           ;          angle -> X+5
 046C           ;             ID -> X+4
 046C           ;          total -> X+2
 046C           ;          param -> X+0
 046C           _decodeTransmission::
 046C                   .dbline -1
 046C 10                push X
 046D 4F                mov X,SP
 046E 3808              add SP,8
 0470                   .dbline 373
 0470           ; }
 0470           ; 
 0470           ; // This function decodes the transmission and takes the correct action.
 0470           ; void decodeTransmission(void)
 0470           ; {
 0470                   .dbline 378
 0470           ;       char* param;
 0470           ;       char ID;
 0470           ;       char tempByte;
 0470           ;       char angle[2];
 0470           ;       int total = 0;
 0470 560300            mov [X+3],0
 0473 560200            mov [X+2],0
 0476                   .dbline 380
 0476           ;       
 0476           ;       if(param = COMP_SERIAL_szGetParam())
 0476 10                push X
 0477 7C0000            xcall _COMP_SERIAL_szGetParam
 047A 62D000            mov REG[0xd0],>__r0
 047D 5300              mov [__r0],A
 047F 5A00              mov [__r1],X
 0481 20                pop X
 0482 5100              mov A,[__r1]
 0484 5401              mov [X+1],A
 0486 5100              mov A,[__r0]
 0488 5400              mov [X+0],A
 048A 3C0000            cmp [__r0],0
 048D B006              jnz X20
 048F 3C0000            cmp [__r1],0
 0492 A506              jz L92
 0494           X20:
 0494                   .dbline 381
 0494           ;       {
 0494                   .dbline 382
 0494           ;               if((param[0] == 'n') || (param[0] == 'N'))
 0494 62D000            mov REG[0xd0],>__r0
 0497 5201              mov A,[X+1]
 0499 5300              mov [__r1],A
 049B 5200              mov A,[X+0]
 049D 60D4              mov REG[0xd4],A
 049F 3E00              mvi A,[__r1]
 04A1 5300              mov [__r1],A
 04A3 550000            mov [__r0],0
 04A6 3C0000            cmp [__r0],0
 04A9 B005              jnz X21
 04AB 396E              cmp A,110
 04AD A00E              jz L96
 04AF           X21:
 04AF 62D000            mov REG[0xd0],>__r0
 04B2 3C0000            cmp [__r0],0
 04B5 B03A              jnz L94
 04B7 3C004E            cmp [__r1],78
 04BA B035              jnz L94
 04BC           X22:
 04BC           L96:
 04BC                   .dbline 383
 04BC           ;               {
 04BC                   .dbline 384
 04BC           ;                       COMP_SERIAL_CmdReset();
 04BC 10                push X
 04BD 7C0000            xcall _COMP_SERIAL_CmdReset
 04C0 20                pop X
 04C1                   .dbline 385
 04C1           ;                       itoa(param,NUM_MODULES,10);
 04C1 5000              mov A,0
 04C3 08                push A
 04C4 500A              mov A,10
 04C6 08                push A
 04C7 62D000            mov REG[0xd0],>_NUM_MODULES
 04CA 5100              mov A,[_NUM_MODULES]
 04CC 08                push A
 04CD 5101              mov A,[_NUM_MODULES+1]
 04CF 08                push A
 04D0 5200              mov A,[X+0]
 04D2 08                push A
 04D3 5201              mov A,[X+1]
 04D5 08                push A
 04D6 7C0000            xcall _itoa
 04D9 38FA              add SP,-6
 04DB                   .dbline 386
 04DB           ;                       COMP_SERIAL_PutString(param);
 04DB 10                push X
 04DC 5200              mov A,[X+0]
 04DE 08                push A
 04DF 5201              mov A,[X+1]
 04E1 5C                mov X,A
 04E2 18                pop A
 04E3 7C0000            xcall _COMP_SERIAL_PutString
 04E6 20                pop X
 04E7                   .dbline 387
 04E7           ;                       COMP_SERIAL_PutChar('\n');
 04E7 10                push X
 04E8 500A              mov A,10
 04EA 7C0000            xcall _COMP_SERIAL_PutChar
 04ED 20                pop X
 04EE                   .dbline 388
 04EE           ;               }
 04EE 84AA              xjmp L95
 04F0           L94:
 04F0                   .dbline 389
 04F0           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 04F0 62D000            mov REG[0xd0],>__r0
 04F3 5201              mov A,[X+1]
 04F5 5300              mov [__r1],A
 04F7 5200              mov A,[X+0]
 04F9 60D4              mov REG[0xd4],A
 04FB 3E00              mvi A,[__r1]
 04FD 5300              mov [__r1],A
 04FF 550000            mov [__r0],0
 0502 3C0000            cmp [__r0],0
 0505 B005              jnz X23
 0507 3977              cmp A,119
 0509 A00E              jz L99
 050B           X23:
 050B 62D000            mov REG[0xd0],>__r0
 050E 3C0000            cmp [__r0],0
 0511 B16B              jnz L97
 0513 3C0057            cmp [__r1],87
 0516 B166              jnz L97
 0518           X24:
 0518           L99:
 0518                   .dbline 390
 0518           ;               {
 0518                   .dbline 391
 0518           ;                       if(param = COMP_SERIAL_szGetParam())
 0518 10                push X
 0519 7C0000            xcall _COMP_SERIAL_szGetParam
 051C 62D000            mov REG[0xd0],>__r0
 051F 5300              mov [__r0],A
 0521 5A00              mov [__r1],X
 0523 20                pop X
 0524 5100              mov A,[__r1]
 0526 5401              mov [X+1],A
 0528 5100              mov A,[__r0]
 052A 5400              mov [X+0],A
 052C 3C0000            cmp [__r0],0
 052F B006              jnz X25
 0531 3C0000            cmp [__r1],0
 0534 A464              jz L98
 0536           X25:
 0536                   .dbline 392
 0536           ;                       {
 0536                   .dbline 393
 0536           ;                               ID = atoi(param);
 0536 5200              mov A,[X+0]
 0538 08                push A
 0539 5201              mov A,[X+1]
 053B 08                push A
 053C 7C0000            xcall _atoi
 053F 38FE              add SP,-2
 0541 62D000            mov REG[0xd0],>__r0
 0544 5100              mov A,[__r1]
 0546 5404              mov [X+4],A
 0548                   .dbline 394
 0548           ;                               if(param = COMP_SERIAL_szGetParam())
 0548 10                push X
 0549 7C0000            xcall _COMP_SERIAL_szGetParam
 054C 62D000            mov REG[0xd0],>__r0
 054F 5300              mov [__r0],A
 0551 5A00              mov [__r1],X
 0553 20                pop X
 0554 5100              mov A,[__r1]
 0556 5401              mov [X+1],A
 0558 5100              mov A,[__r0]
 055A 5400              mov [X+0],A
 055C 3C0000            cmp [__r0],0
 055F B006              jnz X26
 0561 3C0000            cmp [__r1],0
 0564 A434              jz L98
 0566           X26:
 0566                   .dbline 395
 0566           ;                               {
 0566                   .dbline 396
 0566           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 0566 62D000            mov REG[0xd0],>__r0
 0569 5201              mov A,[X+1]
 056B 5300              mov [__r1],A
 056D 5200              mov A,[X+0]
 056F 60D4              mov REG[0xd4],A
 0571 3E00              mvi A,[__r1]
 0573 5300              mov [__r1],A
 0575 550000            mov [__r0],0
 0578 3C0000            cmp [__r0],0
 057B B005              jnz X27
 057D 3961              cmp A,97
 057F A00E              jz L106
 0581           X27:
 0581 62D000            mov REG[0xd0],>__r0
 0584 3C0000            cmp [__r0],0
 0587 B089              jnz L104
 0589 3C0041            cmp [__r1],65
 058C B084              jnz L104
 058E           X28:
 058E           L106:
 058E                   .dbline 397
 058E           ;                                       {
 058E                   .dbline 398
 058E           ;                                               if(param = COMP_SERIAL_szGetParam())
 058E 10                push X
 058F 7C0000            xcall _COMP_SERIAL_szGetParam
 0592 62D000            mov REG[0xd0],>__r0
 0595 5300              mov [__r0],A
 0597 5A00              mov [__r1],X
 0599 20                pop X
 059A 5100              mov A,[__r1]
 059C 5401              mov [X+1],A
 059E 5100              mov A,[__r0]
 05A0 5400              mov [X+0],A
 05A2 3C0000            cmp [__r0],0
 05A5 B006              jnz X29
 05A7 3C0000            cmp [__r1],0
 05AA A3EE              jz L98
 05AC           X29:
 05AC                   .dbline 399
 05AC           ;                                               {
 05AC                   .dbline 400
 05AC           ;                                                       COMP_SERIAL_CmdReset();
 05AC 10                push X
 05AD 7C0000            xcall _COMP_SERIAL_CmdReset
 05B0 20                pop X
 05B1                   .dbline 401
 05B1           ;                                                       total = atoi(param);
 05B1 5200              mov A,[X+0]
 05B3 08                push A
 05B4 5201              mov A,[X+1]
 05B6 08                push A
 05B7 7C0000            xcall _atoi
 05BA 38FE              add SP,-2
 05BC 62D000            mov REG[0xd0],>__r0
 05BF 5100              mov A,[__r1]
 05C1 5403              mov [X+3],A
 05C3 5100              mov A,[__r0]
 05C5 5402              mov [X+2],A
 05C7                   .dbline 402
 05C7           ;                                                       angle[0] = total%256;
 05C7 5001              mov A,1
 05C9 08                push A
 05CA 5000              mov A,0
 05CC 08                push A
 05CD 5202              mov A,[X+2]
 05CF 08                push A
 05D0 5203              mov A,[X+3]
 05D2 08                push A
 05D3 7C0000            xcall __divmod_16X16_16
 05D6 38FE              add SP,-2
 05D8 18                pop A
 05D9 5300              mov [__r1],A
 05DB 18                pop A
 05DC 5100              mov A,[__r1]
 05DE 5405              mov [X+5],A
 05E0                   .dbline 403
 05E0           ;                                                       angle[1] = total/256;
 05E0 5001              mov A,1
 05E2 08                push A
 05E3 5000              mov A,0
 05E5 08                push A
 05E6 5202              mov A,[X+2]
 05E8 08                push A
 05E9 5203              mov A,[X+3]
 05EB 08                push A
 05EC 7C0000            xcall __divmod_16X16_16
 05EF 18                pop A
 05F0 5300              mov [__r1],A
 05F2 18                pop A
 05F3 38FE              add SP,-2
 05F5 5100              mov A,[__r1]
 05F7 5406              mov [X+6],A
 05F9                   .dbline 404
 05F9           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 05F9 5206              mov A,[X+6]
 05FB 08                push A
 05FC 5205              mov A,[X+5]
 05FE 08                push A
 05FF 501E              mov A,30
 0601 08                push A
 0602 5003              mov A,3
 0604 08                push A
 0605 5005              mov A,5
 0607 08                push A
 0608 5204              mov A,[X+4]
 060A 08                push A
 060B 9455              xcall _longServoInstruction
 060D 38FA              add SP,-6
 060F                   .dbline 405
 060F           ;                                               }
 060F                   .dbline 406
 060F           ;                                       }
 060F 8389              xjmp L98
 0611           L104:
 0611                   .dbline 407
 0611           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 0611 62D000            mov REG[0xd0],>__r0
 0614 5201              mov A,[X+1]
 0616 5300              mov [__r1],A
 0618 5200              mov A,[X+0]
 061A 60D4              mov REG[0xd4],A
 061C 3E00              mvi A,[__r1]
 061E 5300              mov [__r1],A
 0620 550000            mov [__r0],0
 0623 3C0000            cmp [__r0],0
 0626 B005              jnz X30
 0628 3970              cmp A,112
 062A A00E              jz L113
 062C           X30:
 062C 62D000            mov REG[0xd0],>__r0
 062F 3C0000            cmp [__r0],0
 0632 B366              jnz L98
 0634 3C0050            cmp [__r1],80
 0637 B361              jnz L98
 0639           X31:
 0639           L113:
 0639                   .dbline 408
 0639           ;                                       {
 0639                   .dbline 409
 0639           ;                                               if(param = COMP_SERIAL_szGetParam())
 0639 10                push X
 063A 7C0000            xcall _COMP_SERIAL_szGetParam
 063D 62D000            mov REG[0xd0],>__r0
 0640 5300              mov [__r0],A
 0642 5A00              mov [__r1],X
 0644 20                pop X
 0645 5100              mov A,[__r1]
 0647 5401              mov [X+1],A
 0649 5100              mov A,[__r0]
 064B 5400              mov [X+0],A
 064D 3C0000            cmp [__r0],0
 0650 B006              jnz X32
 0652 3C0000            cmp [__r1],0
 0655 A343              jz L98
 0657           X32:
 0657                   .dbline 410
 0657           ;                                               {
 0657                   .dbline 411
 0657           ;                                                       COMP_SERIAL_CmdReset();
 0657 10                push X
 0658 7C0000            xcall _COMP_SERIAL_CmdReset
 065B 20                pop X
 065C                   .dbline 412
 065C           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 065C 5200              mov A,[X+0]
 065E 08                push A
 065F 5201              mov A,[X+1]
 0661 08                push A
 0662 7C0000            xcall _atoi
 0665 62D000            mov REG[0xd0],>__r0
 0668 5100              mov A,[__r1]
 066A 08                push A
 066B 5018              mov A,24
 066D 08                push A
 066E 5003              mov A,3
 0670 08                push A
 0671 5004              mov A,4
 0673 08                push A
 0674 5204              mov A,[X+4]
 0676 08                push A
 0677 9346              xcall _servoInstruction
 0679 38F9              add SP,-7
 067B                   .dbline 413
 067B           ;                                               }
 067B                   .dbline 414
 067B           ;                                       }
 067B                   .dbline 415
 067B           ;                               }
 067B                   .dbline 416
 067B           ;                       }
 067B                   .dbline 417
 067B           ;               }
 067B 831D              xjmp L98
 067D           L97:
 067D                   .dbline 418
 067D           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 067D 62D000            mov REG[0xd0],>__r0
 0680 5201              mov A,[X+1]
 0682 5300              mov [__r1],A
 0684 5200              mov A,[X+0]
 0686 60D4              mov REG[0xd4],A
 0688 3E00              mvi A,[__r1]
 068A 5300              mov [__r1],A
 068C 550000            mov [__r0],0
 068F 3C0000            cmp [__r0],0
 0692 B005              jnz X33
 0694 3972              cmp A,114
 0696 A00E              jz L118
 0698           X33:
 0698 62D000            mov REG[0xd0],>__r0
 069B 3C0000            cmp [__r0],0
 069E B2FA              jnz L116
 06A0 3C0052            cmp [__r1],82
 06A3 B2F5              jnz L116
 06A5           X34:
 06A5           L118:
 06A5                   .dbline 419
 06A5           ;               {                       
 06A5                   .dbline 420
 06A5           ;                       if(param = COMP_SERIAL_szGetParam())
 06A5 10                push X
 06A6 7C0000            xcall _COMP_SERIAL_szGetParam
 06A9 62D000            mov REG[0xd0],>__r0
 06AC 5300              mov [__r0],A
 06AE 5A00              mov [__r1],X
 06B0 20                pop X
 06B1 5100              mov A,[__r1]
 06B3 5401              mov [X+1],A
 06B5 5100              mov A,[__r0]
 06B7 5400              mov [X+0],A
 06B9 3C0000            cmp [__r0],0
 06BC B006              jnz X35
 06BE 3C0000            cmp [__r1],0
 06C1 A2D7              jz L119
 06C3           X35:
 06C3                   .dbline 421
 06C3           ;                       {
 06C3                   .dbline 422
 06C3           ;                               ID = atoi(param);
 06C3 5200              mov A,[X+0]
 06C5 08                push A
 06C6 5201              mov A,[X+1]
 06C8 08                push A
 06C9 7C0000            xcall _atoi
 06CC 38FE              add SP,-2
 06CE 62D000            mov REG[0xd0],>__r0
 06D1 5100              mov A,[__r1]
 06D3 5404              mov [X+4],A
 06D5                   .dbline 423
 06D5           ;                               if(param = COMP_SERIAL_szGetParam())
 06D5 10                push X
 06D6 7C0000            xcall _COMP_SERIAL_szGetParam
 06D9 62D000            mov REG[0xd0],>__r0
 06DC 5300              mov [__r0],A
 06DE 5A00              mov [__r1],X
 06E0 20                pop X
 06E1 5100              mov A,[__r1]
 06E3 5401              mov [X+1],A
 06E5 5100              mov A,[__r0]
 06E7 5400              mov [X+0],A
 06E9 3C0000            cmp [__r0],0
 06EC B006              jnz X36
 06EE 3C0000            cmp [__r1],0
 06F1 A2A7              jz L121
 06F3           X36:
 06F3                   .dbline 424
 06F3           ;                               {
 06F3                   .dbline 425
 06F3           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 06F3 62D000            mov REG[0xd0],>__r0
 06F6 5201              mov A,[X+1]
 06F8 5300              mov [__r1],A
 06FA 5200              mov A,[X+0]
 06FC 60D4              mov REG[0xd4],A
 06FE 3E00              mvi A,[__r1]
 0700 5300              mov [__r1],A
 0702 550000            mov [__r0],0
 0705 3C0000            cmp [__r0],0
 0708 B005              jnz X37
 070A 3961              cmp A,97
 070C A00E              jz L125
 070E           X37:
 070E 62D000            mov REG[0xd0],>__r0
 0711 3C0000            cmp [__r0],0
 0714 B0CC              jnz L123
 0716 3C0041            cmp [__r1],65
 0719 B0C7              jnz L123
 071B           X38:
 071B           L125:
 071B                   .dbline 426
 071B           ;                                       {
 071B                   .dbline 427
 071B           ;                                               COMP_SERIAL_CmdReset();
 071B 10                push X
 071C 7C0000            xcall _COMP_SERIAL_CmdReset
 071F 20                pop X
 0720                   .dbline 428
 0720           ;                                               servoInstruction(ID,4,READ_SERVO,36,2);
 0720 5002              mov A,2
 0722 08                push A
 0723 5024              mov A,36
 0725 08                push A
 0726 5002              mov A,2
 0728 08                push A
 0729 5004              mov A,4
 072B 08                push A
 072C 5204              mov A,[X+4]
 072E 08                push A
 072F 928E              xcall _servoInstruction
 0731                   .dbline 429
 0731           ;                                               configToggle(RX_MODE);
 0731 5000              mov A,0
 0733 08                push A
 0734 5001              mov A,1
 0736 08                push A
 0737 93DA              xcall _configToggle
 0739 38F9              add SP,-7
 073B 8094              xjmp L127
 073D           L126:
 073D                   .dbline 433
 073D           ;                                                       
 073D           ;                                               // Loop until we read a response or time out.
 073D           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 073D           ;                                               {
 073D                   .dbline 434
 073D           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 073D 10                push X
 073E 7C0000            xcall _RECEIVE_cReadChar
 0741 62D000            mov REG[0xd0],>__r0
 0744 20                pop X
 0745 39FF              cmp A,-1
 0747 B088              jnz L129
 0749                   .dbline 435
 0749           ;                                                       {
 0749                   .dbline 436
 0749           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 0749 10                push X
 074A 7C0000            xcall _RECEIVE_cGetChar
 074D 62D000            mov REG[0xd0],>__r0
 0750 20                pop X
 0751 39FF              cmp A,-1
 0753 B07C              jnz L131
 0755                   .dbline 437
 0755           ;                                                               {
 0755                   .dbline 438
 0755           ;                                                                       if(RECEIVE_cGetChar() == ID)
 0755 10                push X
 0756 7C0000            xcall _RECEIVE_cGetChar
 0759 62D000            mov REG[0xd0],>__r0
 075C 20                pop X
 075D 3B04              cmp A,[X+4]
 075F B070              jnz L133
 0761                   .dbline 439
 0761           ;                                                                       {
 0761                   .dbline 440
 0761           ;                                                                               if(RECEIVE_cGetChar() == 4)
 0761 10                push X
 0762 7C0000            xcall _RECEIVE_cGetChar
 0765 62D000            mov REG[0xd0],>__r0
 0768 20                pop X
 0769 3904              cmp A,4
 076B B064              jnz L135
 076D                   .dbline 441
 076D           ;                                                                               {
 076D                   .dbline 442
 076D           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 076D 10                push X
 076E 7C0000            xcall _RECEIVE_cGetChar
 0771 62D000            mov REG[0xd0],>__r0
 0774 20                pop X
 0775 3900              cmp A,0
 0777 B058              jnz L137
 0779                   .dbline 443
 0779           ;                                                                                       {
 0779                   .dbline 444
 0779           ;                                                                                               angle[0] = RECEIVE_cGetChar();
 0779 10                push X
 077A 7C0000            xcall _RECEIVE_cGetChar
 077D 62D000            mov REG[0xd0],>__r0
 0780 20                pop X
 0781 5405              mov [X+5],A
 0783                   .dbline 445
 0783           ;                                                                                               angle[1] = RECEIVE_cGetChar();
 0783 10                push X
 0784 7C0000            xcall _RECEIVE_cGetChar
 0787 62D000            mov REG[0xd0],>__r0
 078A 20                pop X
 078B 5406              mov [X+6],A
 078D                   .dbline 447
 078D           ;                                                                                               
 078D           ;                                                                                               configToggle(PC_MODE);
 078D 5000              mov A,0
 078F 08                push A
 0790 5002              mov A,2
 0792 08                push A
 0793 937E              xcall _configToggle
 0795                   .dbline 449
 0795           ;                                                                                               
 0795           ;                                                                                               total = ((angle[1])*256) + angle[0];
 0795 5205              mov A,[X+5]
 0797 5403              mov [X+3],A
 0799 5206              mov A,[X+6]
 079B 5402              mov [X+2],A
 079D                   .dbline 450
 079D           ;                                                                                               itoa(param,total,10);
 079D 5000              mov A,0
 079F 08                push A
 07A0 500A              mov A,10
 07A2 08                push A
 07A3 5202              mov A,[X+2]
 07A5 08                push A
 07A6 5203              mov A,[X+3]
 07A8 08                push A
 07A9 5200              mov A,[X+0]
 07AB 08                push A
 07AC 5201              mov A,[X+1]
 07AE 08                push A
 07AF 7C0000            xcall _itoa
 07B2 38F8              add SP,-8
 07B4                   .dbline 451
 07B4           ;                                                                                               COMP_SERIAL_PutString(param);
 07B4 10                push X
 07B5 5200              mov A,[X+0]
 07B7 08                push A
 07B8 5201              mov A,[X+1]
 07BA 5C                mov X,A
 07BB 18                pop A
 07BC 7C0000            xcall _COMP_SERIAL_PutString
 07BF 20                pop X
 07C0                   .dbline 452
 07C0           ;                                                                                               COMP_SERIAL_PutChar('\n');
 07C0 10                push X
 07C1 500A              mov A,10
 07C3 7C0000            xcall _COMP_SERIAL_PutChar
 07C6 20                pop X
 07C7                   .dbline 454
 07C7           ; 
 07C7           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 07C7 62D000            mov REG[0xd0],>_TIMEOUT
 07CA 550105            mov [_TIMEOUT+1],5
 07CD 550000            mov [_TIMEOUT],0
 07D0                   .dbline 455
 07D0           ;                                                                                       }
 07D0           L137:
 07D0                   .dbline 456
 07D0           ;                                                                               }
 07D0           L135:
 07D0                   .dbline 457
 07D0           ;                                                                       }
 07D0           L133:
 07D0                   .dbline 458
 07D0           ;                                                               }
 07D0           L131:
 07D0                   .dbline 459
 07D0           ;                                                       }
 07D0           L129:
 07D0                   .dbline 460
 07D0           ;                                               }
 07D0           L127:
 07D0                   .dbline 432
 07D0 62D000            mov REG[0xd0],>_TIMEOUT
 07D3 5101              mov A,[_TIMEOUT+1]
 07D5 1105              sub A,5
 07D7 5100              mov A,[_TIMEOUT]
 07D9 3180              xor A,-128
 07DB 1980              sbb A,(0 ^ 0x80)
 07DD CF5F              jc L126
 07DF           X39:
 07DF                   .dbline 461
 07DF           ;                                       }
 07DF 81B9              xjmp L124
 07E1           L123:
 07E1                   .dbline 462
 07E1           ;                                       else if ((param[0] == 'p') || (param[0] == 'P'))
 07E1 62D000            mov REG[0xd0],>__r0
 07E4 5201              mov A,[X+1]
 07E6 5300              mov [__r1],A
 07E8 5200              mov A,[X+0]
 07EA 60D4              mov REG[0xd4],A
 07EC 3E00              mvi A,[__r1]
 07EE 5300              mov [__r1],A
 07F0 550000            mov [__r0],0
 07F3 3C0000            cmp [__r0],0
 07F6 B005              jnz X40
 07F8 3970              cmp A,112
 07FA A00E              jz L143
 07FC           X40:
 07FC 62D000            mov REG[0xd0],>__r0
 07FF 3C0000            cmp [__r0],0
 0802 B0A5              jnz L141
 0804 3C0050            cmp [__r1],80
 0807 B0A0              jnz L141
 0809           X41:
 0809           L143:
 0809                   .dbline 463
 0809           ;                                       {
 0809                   .dbline 464
 0809           ;                                               COMP_SERIAL_CmdReset();
 0809 10                push X
 080A 7C0000            xcall _COMP_SERIAL_CmdReset
 080D 20                pop X
 080E                   .dbline 465
 080E           ;                                               servoInstruction(ID,4,READ_SERVO,24,1);
 080E 5001              mov A,1
 0810 08                push A
 0811 5018              mov A,24
 0813 08                push A
 0814 5002              mov A,2
 0816 08                push A
 0817 5004              mov A,4
 0819 08                push A
 081A 5204              mov A,[X+4]
 081C 08                push A
 081D 91A0              xcall _servoInstruction
 081F                   .dbline 466
 081F           ;                                               configToggle(RX_MODE);
 081F 5000              mov A,0
 0821 08                push A
 0822 5001              mov A,1
 0824 08                push A
 0825 92EC              xcall _configToggle
 0827 38F9              add SP,-7
 0829 806D              xjmp L145
 082B           L144:
 082B                   .dbline 470
 082B           ;                                                       
 082B           ;                                               // Loop until we read a response or time out.
 082B           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 082B           ;                                               {
 082B                   .dbline 471
 082B           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 082B 10                push X
 082C 7C0000            xcall _RECEIVE_cReadChar
 082F 62D000            mov REG[0xd0],>__r0
 0832 20                pop X
 0833 39FF              cmp A,-1
 0835 B061              jnz L147
 0837                   .dbline 472
 0837           ;                                                       {
 0837                   .dbline 473
 0837           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 0837 10                push X
 0838 7C0000            xcall _RECEIVE_cGetChar
 083B 62D000            mov REG[0xd0],>__r0
 083E 20                pop X
 083F 39FF              cmp A,-1
 0841 B055              jnz L149
 0843                   .dbline 474
 0843           ;                                                               {
 0843                   .dbline 475
 0843           ;                                                                       if(RECEIVE_cGetChar() == ID)
 0843 10                push X
 0844 7C0000            xcall _RECEIVE_cGetChar
 0847 62D000            mov REG[0xd0],>__r0
 084A 20                pop X
 084B 3B04              cmp A,[X+4]
 084D B049              jnz L151
 084F                   .dbline 476
 084F           ;                                                                       {
 084F                   .dbline 477
 084F           ;                                                                               if(RECEIVE_cGetChar() == 3)
 084F 10                push X
 0850 7C0000            xcall _RECEIVE_cGetChar
 0853 62D000            mov REG[0xd0],>__r0
 0856 20                pop X
 0857 3903              cmp A,3
 0859 B03D              jnz L153
 085B                   .dbline 478
 085B           ;                                                                               {
 085B                   .dbline 479
 085B           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 085B 10                push X
 085C 7C0000            xcall _RECEIVE_cGetChar
 085F 62D000            mov REG[0xd0],>__r0
 0862 20                pop X
 0863 3900              cmp A,0
 0865 B031              jnz L155
 0867                   .dbline 480
 0867           ;                                                                                       {
 0867                   .dbline 481
 0867           ;                                                                                               tempByte = RECEIVE_cGetChar();
 0867 10                push X
 0868 7C0000            xcall _RECEIVE_cGetChar
 086B 62D000            mov REG[0xd0],>__r0
 086E 20                pop X
 086F 5407              mov [X+7],A
 0871                   .dbline 483
 0871           ;                                                                                               
 0871           ;                                                                                               configToggle(PC_MODE);
 0871 5000              mov A,0
 0873 08                push A
 0874 5002              mov A,2
 0876 08                push A
 0877 929A              xcall _configToggle
 0879 38FE              add SP,-2
 087B                   .dbline 486
 087B           ;                                                                                               
 087B           ;                                                                                               // Convert tempByte to an ascii value and send.
 087B           ;                                                                                               COMP_SERIAL_PutChar(tempByte + 48);
 087B 62D000            mov REG[0xd0],>__r0
 087E 5207              mov A,[X+7]
 0880 0130              add A,48
 0882 10                push X
 0883 7C0000            xcall _COMP_SERIAL_PutChar
 0886 20                pop X
 0887                   .dbline 487
 0887           ;                                                                                               COMP_SERIAL_PutChar('\n');
 0887 10                push X
 0888 500A              mov A,10
 088A 7C0000            xcall _COMP_SERIAL_PutChar
 088D 20                pop X
 088E                   .dbline 489
 088E           ; 
 088E           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 088E 62D000            mov REG[0xd0],>_TIMEOUT
 0891 550105            mov [_TIMEOUT+1],5
 0894 550000            mov [_TIMEOUT],0
 0897                   .dbline 490
 0897           ;                                                                                       }
 0897           L155:
 0897                   .dbline 491
 0897           ;                                                                               }
 0897           L153:
 0897                   .dbline 492
 0897           ;                                                                       }
 0897           L151:
 0897                   .dbline 493
 0897           ;                                                               }
 0897           L149:
 0897                   .dbline 494
 0897           ;                                                       }
 0897           L147:
 0897                   .dbline 495
 0897           ;                                               }
 0897           L145:
 0897                   .dbline 469
 0897 62D000            mov REG[0xd0],>_TIMEOUT
 089A 5101              mov A,[_TIMEOUT+1]
 089C 1105              sub A,5
 089E 5100              mov A,[_TIMEOUT]
 08A0 3180              xor A,-128
 08A2 1980              sbb A,(0 ^ 0x80)
 08A4 CF86              jc L144
 08A6           X42:
 08A6                   .dbline 496
 08A6           ;                                       }
 08A6 80F2              xjmp L142
 08A8           L141:
 08A8                   .dbline 497
 08A8           ;                                       else if ((param[0] == 't') || (param[0] == 'T'))
 08A8 62D000            mov REG[0xd0],>__r0
 08AB 5201              mov A,[X+1]
 08AD 5300              mov [__r1],A
 08AF 5200              mov A,[X+0]
 08B1 60D4              mov REG[0xd4],A
 08B3 3E00              mvi A,[__r1]
 08B5 5300              mov [__r1],A
 08B7 550000            mov [__r0],0
 08BA 3C0000            cmp [__r0],0
 08BD B005              jnz X43
 08BF 3974              cmp A,116
 08C1 A00E              jz L159
 08C3           X43:
 08C3 62D000            mov REG[0xd0],>__r0
 08C6 3C0000            cmp [__r0],0
 08C9 B068              jnz L157
 08CB 3C0054            cmp [__r1],84
 08CE B063              jnz L157
 08D0           X44:
 08D0           L159:
 08D0                   .dbline 498
 08D0           ;                                       {
 08D0                   .dbline 499
 08D0           ;                                               COMP_SERIAL_CmdReset();
 08D0 10                push X
 08D1 7C0000            xcall _COMP_SERIAL_CmdReset
 08D4 20                pop X
 08D5                   .dbline 500
 08D5           ;                                               if(pingModule(ID))
 08D5 62D000            mov REG[0xd0],>__r0
 08D8 5204              mov A,[X+4]
 08DA 5300              mov [__r1],A
 08DC 5000              mov A,0
 08DE 08                push A
 08DF 5100              mov A,[__r1]
 08E1 08                push A
 08E2 7C0044            xcall _pingModule
 08E5 38FE              add SP,-2
 08E7 62D000            mov REG[0xd0],>__r0
 08EA 3C0000            cmp [__r0],0
 08ED B006              jnz X45
 08EF 3C0000            cmp [__r1],0
 08F2 A0A6              jz L158
 08F4           X45:
 08F4                   .dbline 501
 08F4           ;                                               {
 08F4                   .dbline 502
 08F4           ;                                                       configToggle(PC_MODE);
 08F4 5000              mov A,0
 08F6 08                push A
 08F7 5002              mov A,2
 08F9 08                push A
 08FA 9217              xcall _configToggle
 08FC                   .dbline 504
 08FC           ;                                                                                               
 08FC           ;                                                       total = PARAM[0];
 08FC 62D000            mov REG[0xd0],>_PARAM
 08FF 5100              mov A,[_PARAM]
 0901 5403              mov [X+3],A
 0903 560200            mov [X+2],0
 0906                   .dbline 505
 0906           ;                                                       itoa(param,total,10);
 0906 5000              mov A,0
 0908 08                push A
 0909 500A              mov A,10
 090B 08                push A
 090C 5202              mov A,[X+2]
 090E 08                push A
 090F 5203              mov A,[X+3]
 0911 08                push A
 0912 5200              mov A,[X+0]
 0914 08                push A
 0915 5201              mov A,[X+1]
 0917 08                push A
 0918 7C0000            xcall _itoa
 091B 38F8              add SP,-8
 091D                   .dbline 506
 091D           ;                                                       COMP_SERIAL_PutString(param);
 091D 10                push X
 091E 5200              mov A,[X+0]
 0920 08                push A
 0921 5201              mov A,[X+1]
 0923 5C                mov X,A
 0924 18                pop A
 0925 7C0000            xcall _COMP_SERIAL_PutString
 0928 20                pop X
 0929                   .dbline 507
 0929           ;                                                       COMP_SERIAL_PutChar('\n');
 0929 10                push X
 092A 500A              mov A,10
 092C 7C0000            xcall _COMP_SERIAL_PutChar
 092F 20                pop X
 0930                   .dbline 508
 0930           ;                                               }
 0930                   .dbline 509
 0930           ;                                       }
 0930 8068              xjmp L158
 0932           L157:
 0932                   .dbline 510
 0932           ;                                       else if ((param[0] == 'c') || (param[0] == 'C'))
 0932 62D000            mov REG[0xd0],>__r0
 0935 5201              mov A,[X+1]
 0937 5300              mov [__r1],A
 0939 5200              mov A,[X+0]
 093B 60D4              mov REG[0xd4],A
 093D 3E00              mvi A,[__r1]
 093F 5300              mov [__r1],A
 0941 550000            mov [__r0],0
 0944 3C0000            cmp [__r0],0
 0947 B005              jnz X46
 0949 3963              cmp A,99
 094B A00E              jz L164
 094D           X46:
 094D 62D000            mov REG[0xd0],>__r0
 0950 3C0000            cmp [__r0],0
 0953 B045              jnz L162
 0955 3C0043            cmp [__r1],67
 0958 B040              jnz L162
 095A           X47:
 095A           L164:
 095A                   .dbline 511
 095A           ;                                       {
 095A                   .dbline 512
 095A           ;                                               COMP_SERIAL_CmdReset();
 095A 10                push X
 095B 7C0000            xcall _COMP_SERIAL_CmdReset
 095E 20                pop X
 095F                   .dbline 513
 095F           ;                                               if(pingModule(ID))
 095F 62D000            mov REG[0xd0],>__r0
 0962 5204              mov A,[X+4]
 0964 5300              mov [__r1],A
 0966 5000              mov A,0
 0968 08                push A
 0969 5100              mov A,[__r1]
 096B 08                push A
 096C 7C0044            xcall _pingModule
 096F 38FE              add SP,-2
 0971 62D000            mov REG[0xd0],>__r0
 0974 3C0000            cmp [__r0],0
 0977 B006              jnz X48
 0979 3C0000            cmp [__r1],0
 097C A01C              jz L165
 097E           X48:
 097E                   .dbline 514
 097E           ;                                               {       
 097E                   .dbline 515
 097E           ;                                                       configToggle(PC_MODE);
 097E 5000              mov A,0
 0980 08                push A
 0981 5002              mov A,2
 0983 08                push A
 0984 918D              xcall _configToggle
 0986 38FE              add SP,-2
 0988                   .dbline 517
 0988           ;                                                                                               
 0988           ;                                                       COMP_SERIAL_PutChar(PARAM[1]);
 0988 10                push X
 0989 62D000            mov REG[0xd0],>_PARAM
 098C 5101              mov A,[_PARAM+1]
 098E 7C0000            xcall _COMP_SERIAL_PutChar
 0991 20                pop X
 0992                   .dbline 518
 0992           ;                                                       COMP_SERIAL_PutChar('\n');
 0992 10                push X
 0993 500A              mov A,10
 0995 7C0000            xcall _COMP_SERIAL_PutChar
 0998 20                pop X
 0999                   .dbline 519
 0999           ;                                               }
 0999           L165:
 0999                   .dbline 520
 0999           ;                                       }
 0999           L162:
 0999           L158:
 0999           L142:
 0999           L124:
 0999                   .dbline 521
 0999           ;                               }
 0999           L121:
 0999                   .dbline 522
 0999           ;                       }
 0999           L119:
 0999                   .dbline 523
 0999           ;               }
 0999           L116:
 0999           L98:
 0999           L95:
 0999                   .dbline 524
 0999           ;       }
 0999           L92:
 0999                   .dbline 526
 0999           ;       
 0999           ;       if(STATE != PC_MODE)
 0999 62D000            mov REG[0xd0],>_STATE
 099C 3C0000            cmp [_STATE],0
 099F B006              jnz X49
 09A1 3C0102            cmp [_STATE+1],2
 09A4 A00D              jz L168
 09A6           X49:
 09A6                   .dbline 527
 09A6           ;       {
 09A6                   .dbline 528
 09A6           ;               configToggle(PC_MODE);
 09A6 5000              mov A,0
 09A8 08                push A
 09A9 5002              mov A,2
 09AB 08                push A
 09AC 9165              xcall _configToggle
 09AE 38FE              add SP,-2
 09B0                   .dbline 529
 09B0           ;       }
 09B0 800A              xjmp L169
 09B2           L168:
 09B2                   .dbline 531
 09B2           ;       else
 09B2           ;       {
 09B2                   .dbline 532
 09B2           ;               TIMEOUT = 0;
 09B2 62D000            mov REG[0xd0],>_TIMEOUT
 09B5 550100            mov [_TIMEOUT+1],0
 09B8 550000            mov [_TIMEOUT],0
 09BB                   .dbline 533
 09BB           ;       }
 09BB           L169:
 09BB                   .dbline -2
 09BB           L91:
 09BB 38F8              add SP,-8
 09BD 20                pop X
 09BE                   .dbline 0 ; func end
 09BE 7F                ret
 09BF                   .dbsym l tempByte 7 c
 09BF                   .dbsym l angle 5 A[2:2]c
 09BF                   .dbsym l ID 4 c
 09BF                   .dbsym l total 2 I
 09BF                   .dbsym l param 0 pc
 09BF                   .dbend
 09BF                   .dbfunc e servoInstruction _servoInstruction fV
 09BF           ;          total -> X+1
 09BF           ;       checksum -> X+0
 09BF           ;          value -> X-8
 09BF           ;        address -> X-7
 09BF           ;    instruction -> X-6
 09BF           ;         length -> X-5
 09BF           ;             id -> X-4
 09BF           _servoInstruction::
 09BF                   .dbline -1
 09BF 10                push X
 09C0 4F                mov X,SP
 09C1 3803              add SP,3
 09C3                   .dbline 539
 09C3           ; }
 09C3           ; 
 09C3           ; // This function receives a destination, command length, instruction type, address, and value.
 09C3           ; // With these parameters, the function sends a packet to the communication bus.
 09C3           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 09C3           ; {
 09C3                   .dbline 543
 09C3           ;       char checksum;
 09C3           ;       int total;
 09C3           ;       
 09C3           ;       total = id + length + instruction + address + value;
 09C3 62D000            mov REG[0xd0],>__r0
 09C6 52FB              mov A,[X-5]
 09C8 5300              mov [__r1],A
 09CA 550000            mov [__r0],0
 09CD 52FC              mov A,[X-4]
 09CF 0200              add A,[__r1]
 09D1 5300              mov [__r1],A
 09D3 5000              mov A,0
 09D5 0A00              adc A,[__r0]
 09D7 5300              mov [__r0],A
 09D9 52FA              mov A,[X-6]
 09DB 0400              add [__r1],A
 09DD 0E0000            adc [__r0],0
 09E0 52F9              mov A,[X-7]
 09E2 0400              add [__r1],A
 09E4 0E0000            adc [__r0],0
 09E7 52F8              mov A,[X-8]
 09E9 5300              mov [__r3],A
 09EB 550000            mov [__r2],0
 09EE 5100              mov A,[__r1]
 09F0 0200              add A,[__r3]
 09F2 5402              mov [X+2],A
 09F4 5100              mov A,[__r0]
 09F6 0A00              adc A,[__r2]
 09F8 5401              mov [X+1],A
 09FA                   .dbline 546
 09FA           ;       
 09FA           ;       // Calculate the checksum value for our servo communication.
 09FA           ;       checksum = 255-(total%256);
 09FA 5001              mov A,1
 09FC 08                push A
 09FD 5000              mov A,0
 09FF 08                push A
 0A00 5201              mov A,[X+1]
 0A02 08                push A
 0A03 5202              mov A,[X+2]
 0A05 08                push A
 0A06 7C0000            xcall __divmod_16X16_16
 0A09 38FE              add SP,-2
 0A0B 18                pop A
 0A0C 5300              mov [__r1],A
 0A0E 18                pop A
 0A0F 50FF              mov A,-1
 0A11 1200              sub A,[__r1]
 0A13 5400              mov [X+0],A
 0A15                   .dbline 549
 0A15           ;       
 0A15           ;       // Talk to the servo.
 0A15           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0A15 10                push X
 0A16 50FF              mov A,-1
 0A18 7C0000            xcall _TX_REPEATER_PutChar
 0A1B 20                pop X
 0A1C                   .dbline 550
 0A1C           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0A1C 10                push X
 0A1D 50FF              mov A,-1
 0A1F 7C0000            xcall _TX_REPEATER_PutChar
 0A22 20                pop X
 0A23                   .dbline 551
 0A23           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0A23 10                push X
 0A24 52FC              mov A,[X-4]
 0A26 7C0000            xcall _TX_REPEATER_PutChar
 0A29 20                pop X
 0A2A                   .dbline 552
 0A2A           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0A2A 10                push X
 0A2B 52FB              mov A,[X-5]
 0A2D 7C0000            xcall _TX_REPEATER_PutChar
 0A30 20                pop X
 0A31                   .dbline 553
 0A31           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0A31 10                push X
 0A32 52FA              mov A,[X-6]
 0A34 7C0000            xcall _TX_REPEATER_PutChar
 0A37 20                pop X
 0A38                   .dbline 554
 0A38           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0A38 10                push X
 0A39 52F9              mov A,[X-7]
 0A3B 7C0000            xcall _TX_REPEATER_PutChar
 0A3E 20                pop X
 0A3F                   .dbline 555
 0A3F           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 0A3F 10                push X
 0A40 52F8              mov A,[X-8]
 0A42 7C0000            xcall _TX_REPEATER_PutChar
 0A45 20                pop X
 0A46                   .dbline 556
 0A46           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0A46 10                push X
 0A47 5200              mov A,[X+0]
 0A49 7C0000            xcall _TX_REPEATER_PutChar
 0A4C 20                pop X
 0A4D           L171:
 0A4D                   .dbline 559
 0A4D           ;       
 0A4D           ;       // Wait for the transmission to finish.
 0A4D           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0A4D           L172:
 0A4D                   .dbline 559
 0A4D 10                push X
 0A4E 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0A51 62D000            mov REG[0xd0],>__r0
 0A54 20                pop X
 0A55 5300              mov [__r0],A
 0A57 470020            tst [__r0],32
 0A5A AFF2              jz L171
 0A5C                   .dbline 562
 0A5C           ;       
 0A5C           ;       // Make completely sure we're done.
 0A5C           ;       xmitWait();
 0A5C 936C              xcall _xmitWait
 0A5E                   .dbline -2
 0A5E           L170:
 0A5E 38FD              add SP,-3
 0A60 20                pop X
 0A61                   .dbline 0 ; func end
 0A61 7F                ret
 0A62                   .dbsym l total 1 I
 0A62                   .dbsym l checksum 0 c
 0A62                   .dbsym l value -8 c
 0A62                   .dbsym l address -7 c
 0A62                   .dbsym l instruction -6 c
 0A62                   .dbsym l length -5 c
 0A62                   .dbsym l id -4 c
 0A62                   .dbend
 0A62                   .dbfunc e longServoInstruction _longServoInstruction fV
 0A62           ;          total -> X+1
 0A62           ;       checksum -> X+0
 0A62           ;         value2 -> X-9
 0A62           ;         value1 -> X-8
 0A62           ;        address -> X-7
 0A62           ;    instruction -> X-6
 0A62           ;         length -> X-5
 0A62           ;             id -> X-4
 0A62           _longServoInstruction::
 0A62                   .dbline -1
 0A62 10                push X
 0A63 4F                mov X,SP
 0A64 3803              add SP,3
 0A66                   .dbline 567
 0A66           ; }
 0A66           ; 
 0A66           ; // This function receives a destination, command length, instruction type, address, and two values.
 0A66           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0A66           ; {
 0A66                   .dbline 571
 0A66           ;       char checksum;
 0A66           ;       int total;
 0A66           ;       
 0A66           ;       total = id + length + instruction + address + value1 + value2;
 0A66 62D000            mov REG[0xd0],>__r0
 0A69 52FB              mov A,[X-5]
 0A6B 5300              mov [__r1],A
 0A6D 550000            mov [__r0],0
 0A70 52FC              mov A,[X-4]
 0A72 0200              add A,[__r1]
 0A74 5300              mov [__r1],A
 0A76 5000              mov A,0
 0A78 0A00              adc A,[__r0]
 0A7A 5300              mov [__r0],A
 0A7C 52FA              mov A,[X-6]
 0A7E 0400              add [__r1],A
 0A80 0E0000            adc [__r0],0
 0A83 52F9              mov A,[X-7]
 0A85 0400              add [__r1],A
 0A87 0E0000            adc [__r0],0
 0A8A 52F8              mov A,[X-8]
 0A8C 0400              add [__r1],A
 0A8E 0E0000            adc [__r0],0
 0A91 52F7              mov A,[X-9]
 0A93 5300              mov [__r3],A
 0A95 550000            mov [__r2],0
 0A98 5100              mov A,[__r1]
 0A9A 0200              add A,[__r3]
 0A9C 5402              mov [X+2],A
 0A9E 5100              mov A,[__r0]
 0AA0 0A00              adc A,[__r2]
 0AA2 5401              mov [X+1],A
 0AA4                   .dbline 574
 0AA4           ;       
 0AA4           ;       // Calculate the checksum value for our servo communication.
 0AA4           ;       checksum = 255-(total%256);
 0AA4 5001              mov A,1
 0AA6 08                push A
 0AA7 5000              mov A,0
 0AA9 08                push A
 0AAA 5201              mov A,[X+1]
 0AAC 08                push A
 0AAD 5202              mov A,[X+2]
 0AAF 08                push A
 0AB0 7C0000            xcall __divmod_16X16_16
 0AB3 38FE              add SP,-2
 0AB5 18                pop A
 0AB6 5300              mov [__r1],A
 0AB8 18                pop A
 0AB9 50FF              mov A,-1
 0ABB 1200              sub A,[__r1]
 0ABD 5400              mov [X+0],A
 0ABF                   .dbline 577
 0ABF           ;       
 0ABF           ;       // Talk to the servo.
 0ABF           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0ABF 10                push X
 0AC0 50FF              mov A,-1
 0AC2 7C0000            xcall _TX_REPEATER_PutChar
 0AC5 20                pop X
 0AC6                   .dbline 578
 0AC6           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0AC6 10                push X
 0AC7 50FF              mov A,-1
 0AC9 7C0000            xcall _TX_REPEATER_PutChar
 0ACC 20                pop X
 0ACD                   .dbline 579
 0ACD           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0ACD 10                push X
 0ACE 52FC              mov A,[X-4]
 0AD0 7C0000            xcall _TX_REPEATER_PutChar
 0AD3 20                pop X
 0AD4                   .dbline 580
 0AD4           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0AD4 10                push X
 0AD5 52FB              mov A,[X-5]
 0AD7 7C0000            xcall _TX_REPEATER_PutChar
 0ADA 20                pop X
 0ADB                   .dbline 581
 0ADB           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0ADB 10                push X
 0ADC 52FA              mov A,[X-6]
 0ADE 7C0000            xcall _TX_REPEATER_PutChar
 0AE1 20                pop X
 0AE2                   .dbline 582
 0AE2           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0AE2 10                push X
 0AE3 52F9              mov A,[X-7]
 0AE5 7C0000            xcall _TX_REPEATER_PutChar
 0AE8 20                pop X
 0AE9                   .dbline 583
 0AE9           ;       TX_REPEATER_PutChar(value1);            // The first value to write.
 0AE9 10                push X
 0AEA 52F8              mov A,[X-8]
 0AEC 7C0000            xcall _TX_REPEATER_PutChar
 0AEF 20                pop X
 0AF0                   .dbline 584
 0AF0           ;       TX_REPEATER_PutChar(value2);            // The first value to write.
 0AF0 10                push X
 0AF1 52F7              mov A,[X-9]
 0AF3 7C0000            xcall _TX_REPEATER_PutChar
 0AF6 20                pop X
 0AF7                   .dbline 585
 0AF7           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0AF7 10                push X
 0AF8 5200              mov A,[X+0]
 0AFA 7C0000            xcall _TX_REPEATER_PutChar
 0AFD 20                pop X
 0AFE           L175:
 0AFE                   .dbline 588
 0AFE           ;       
 0AFE           ;       // Wait for the transmission to finish.
 0AFE           ;       while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0AFE           L176:
 0AFE                   .dbline 588
 0AFE 10                push X
 0AFF 7C0000            xcall _TX_REPEATER_bReadTxStatus
 0B02 62D000            mov REG[0xd0],>__r0
 0B05 20                pop X
 0B06 5300              mov [__r0],A
 0B08 470020            tst [__r0],32
 0B0B AFF2              jz L175
 0B0D                   .dbline 591
 0B0D           ;       
 0B0D           ;       // Make completely sure we're done.
 0B0D           ;       xmitWait();
 0B0D 92BB              xcall _xmitWait
 0B0F                   .dbline -2
 0B0F           L174:
 0B0F 38FD              add SP,-3
 0B11 20                pop X
 0B12                   .dbline 0 ; func end
 0B12 7F                ret
 0B13                   .dbsym l total 1 I
 0B13                   .dbsym l checksum 0 c
 0B13                   .dbsym l value2 -9 c
 0B13                   .dbsym l value1 -8 c
 0B13                   .dbsym l address -7 c
 0B13                   .dbsym l instruction -6 c
 0B13                   .dbsym l length -5 c
 0B13                   .dbsym l id -4 c
 0B13                   .dbend
 0B13                   .dbfunc e configToggle _configToggle fV
 0B13           ;           mode -> X-5
 0B13           _configToggle::
 0B13                   .dbline -1
 0B13 10                push X
 0B14 4F                mov X,SP
 0B15                   .dbline 597
 0B15           ; }
 0B15           ; 
 0B15           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0B15           ; // half duplex UART serial communication line.
 0B15           ; void configToggle(int mode)
 0B15           ; {
 0B15                   .dbline 599
 0B15           ;       // Disconnect from the global bus and leave the pin high.
 0B15           ;       PRT0DR |= 0b10000000;
 0B15 430080            or REG[0],-128
 0B18                   .dbline 600
 0B18           ;       PRT0GS &= 0b01111111;
 0B18 41027F            and REG[0x2],127
 0B1B                   .dbline 604
 0B1B           ; 
 0B1B           ;       // Unload the configuration of the current state.
 0B1B           ;       // If there is no state, blindly wipe all configurations.
 0B1B           ;       if(STATE)
 0B1B 62D000            mov REG[0xd0],>_STATE
 0B1E 3C0000            cmp [_STATE],0
 0B21 B006              jnz X50
 0B23 3C0100            cmp [_STATE+1],0
 0B26 A010              jz L179
 0B28           X50:
 0B28                   .dbline 605
 0B28           ;       {
 0B28                   .dbline 606
 0B28           ;               unloadConfig(STATE);
 0B28 62D000            mov REG[0xd0],>_STATE
 0B2B 5100              mov A,[_STATE]
 0B2D 08                push A
 0B2E 5101              mov A,[_STATE+1]
 0B30 08                push A
 0B31 90D9              xcall _unloadConfig
 0B33 38FE              add SP,-2
 0B35                   .dbline 607
 0B35           ;       }
 0B35 8003              xjmp L180
 0B37           L179:
 0B37                   .dbline 609
 0B37           ;       else
 0B37           ;       {
 0B37                   .dbline 610
 0B37           ;               unloadAllConfigs();
 0B37 90C9              xcall _unloadAllConfigs
 0B39                   .dbline 611
 0B39           ;       }
 0B39           L180:
 0B39                   .dbline 613
 0B39           ;       
 0B39           ;       if(mode == PC_MODE)
 0B39 3DFB00            cmp [X-5],0
 0B3C B032              jnz L181
 0B3E 3DFC02            cmp [X-4],2
 0B41 B02D              jnz L181
 0B43           X51:
 0B43                   .dbline 614
 0B43           ;       {
 0B43                   .dbline 615
 0B43           ;               LoadConfig_pc_listener();
 0B43 7C0000            xcall _LoadConfig_pc_listener
 0B46                   .dbline 618
 0B46           ;               
 0B46           ;               //COMP_SERIAL_CmdReset();                                               // Initializes the RX buffer
 0B46           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 0B46 10                push X
 0B47 5001              mov A,1
 0B49 7C0000            xcall _COMP_SERIAL_IntCntl
 0B4C 20                pop X
 0B4D                   .dbline 619
 0B4D           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 0B4D 10                push X
 0B4E 5000              mov A,0
 0B50 7C0000            xcall _COMP_SERIAL_Start
 0B53 20                pop X
 0B54                   .dbline 621
 0B54           ;               
 0B54           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0B54 10                push X
 0B55 5000              mov A,0
 0B57 7C0000            xcall _TX_REPEATER_Start
 0B5A 20                pop X
 0B5B                   .dbline 623
 0B5B           ;               
 0B5B           ;               TIMEOUT = 0;
 0B5B 62D000            mov REG[0xd0],>_TIMEOUT
 0B5E 550100            mov [_TIMEOUT+1],0
 0B61 550000            mov [_TIMEOUT],0
 0B64                   .dbline 624
 0B64           ;               STATE = PC_MODE;
 0B64 62D000            mov REG[0xd0],>_STATE
 0B67 550102            mov [_STATE+1],2
 0B6A 550000            mov [_STATE],0
 0B6D                   .dbline 625
 0B6D           ;       }
 0B6D 807A              xjmp L182
 0B6F           L181:
 0B6F                   .dbline 626
 0B6F           ;       else if(mode == RX_MODE)
 0B6F 3DFB00            cmp [X-5],0
 0B72 B02C              jnz L183
 0B74 3DFC01            cmp [X-4],1
 0B77 B027              jnz L183
 0B79           X52:
 0B79                   .dbline 627
 0B79           ;       {
 0B79                   .dbline 628
 0B79           ;               LoadConfig_receiver_config();
 0B79 7C0000            xcall _LoadConfig_receiver_config
 0B7C                   .dbline 633
 0B7C           ;               
 0B7C           ;               // Clear the buffer.
 0B7C           ;               //RECEIVE_CmdReset();
 0B7C           ;               // Start the receiver.
 0B7C           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0B7C 10                push X
 0B7D 5000              mov A,0
 0B7F 7C0000            xcall _RECEIVE_Start
 0B82 20                pop X
 0B83                   .dbline 636
 0B83           ;               
 0B83           ;               // Start response timeout timer and enable its interrupt routine.
 0B83           ;               TIMEOUT = 0;
 0B83 62D000            mov REG[0xd0],>_TIMEOUT
 0B86 550100            mov [_TIMEOUT+1],0
 0B89 550000            mov [_TIMEOUT],0
 0B8C                   .dbline 637
 0B8C           ;               RX_TIMEOUT_EnableInt();
 0B8C 10                push X
 0B8D 7C0000            xcall _RX_TIMEOUT_EnableInt
 0B90                   .dbline 638
 0B90           ;               RX_TIMEOUT_Start();
 0B90 7C0000            xcall _RX_TIMEOUT_Start
 0B93 20                pop X
 0B94                   .dbline 640
 0B94           ;               
 0B94           ;               STATE = RX_MODE;
 0B94 62D000            mov REG[0xd0],>_STATE
 0B97 550101            mov [_STATE+1],1
 0B9A 550000            mov [_STATE],0
 0B9D                   .dbline 641
 0B9D           ;       }
 0B9D 804A              xjmp L184
 0B9F           L183:
 0B9F                   .dbline 642
 0B9F           ;       else if(mode == TX_MODE)
 0B9F 3DFB00            cmp [X-5],0
 0BA2 B045              jnz L185
 0BA4 3DFC00            cmp [X-4],0
 0BA7 B040              jnz L185
 0BA9           X53:
 0BA9                   .dbline 643
 0BA9           ;       {
 0BA9                   .dbline 644
 0BA9           ;               LoadConfig_transmitter_config();
 0BA9 7C0000            xcall _LoadConfig_transmitter_config
 0BAC                   .dbline 646
 0BAC           ;               // Start the transmitter.
 0BAC           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 0BAC 10                push X
 0BAD 5000              mov A,0
 0BAF 7C0000            xcall _TRANSMIT_Start
 0BB2 20                pop X
 0BB3                   .dbline 648
 0BB3           ;               
 0BB3           ;               TIMEOUT = 0;
 0BB3 62D000            mov REG[0xd0],>_TIMEOUT
 0BB6 550100            mov [_TIMEOUT+1],0
 0BB9 550000            mov [_TIMEOUT],0
 0BBC                   .dbline 649
 0BBC           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0BBC 10                push X
 0BBD 7C0000            xcall _TX_TIMEOUT_EnableInt
 0BC0                   .dbline 650
 0BC0           ;               TX_TIMEOUT_Start();             // Start the timer.
 0BC0 7C0000            xcall _TX_TIMEOUT_Start
 0BC3 20                pop X
 0BC4           L187:
 0BC4                   .dbline 653
 0BC4           ;               
 0BC4           ;               while(!TIMEOUT)
 0BC4           ;               {
 0BC4                   .dbline 656
 0BC4           ;                       // Do nothing while we wait for one timeout period.
 0BC4           ;                       // This is to allow everyone to get in the right configuration.
 0BC4           ;               }
 0BC4           L188:
 0BC4                   .dbline 652
 0BC4 62D000            mov REG[0xd0],>_TIMEOUT
 0BC7 3C0000            cmp [_TIMEOUT],0
 0BCA B006              jnz X54
 0BCC 3C0100            cmp [_TIMEOUT+1],0
 0BCF AFF4              jz L187
 0BD1           X54:
 0BD1                   .dbline 658
 0BD1           ;               
 0BD1           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 0BD1 10                push X
 0BD2 7C0000            xcall _TX_TIMEOUT_Stop
 0BD5 20                pop X
 0BD6                   .dbline 659
 0BD6           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0BD6 62D000            mov REG[0xd0],>_TIMEOUT
 0BD9 550100            mov [_TIMEOUT+1],0
 0BDC 550000            mov [_TIMEOUT],0
 0BDF                   .dbline 661
 0BDF           ;               
 0BDF           ;               STATE = TX_MODE;
 0BDF 62D000            mov REG[0xd0],>_STATE
 0BE2 550100            mov [_STATE+1],0
 0BE5 550000            mov [_STATE],0
 0BE8                   .dbline 662
 0BE8           ;       }
 0BE8           L185:
 0BE8           L184:
 0BE8           L182:
 0BE8                   .dbline 667
 0BE8           ;       
 0BE8           ;       // Make sure to keep the LED on (active low).
 0BE8           ;       //PRT2DR &= 0b11111110;
 0BE8           ;       
 0BE8           ;       if(STATE == TX_MODE)
 0BE8 62D000            mov REG[0xd0],>_STATE
 0BEB 3C0000            cmp [_STATE],0
 0BEE B00B              jnz L190
 0BF0 3C0100            cmp [_STATE+1],0
 0BF3 B006              jnz L190
 0BF5           X55:
 0BF5                   .dbline 668
 0BF5           ;       {
 0BF5                   .dbline 669
 0BF5           ;               PRT1DR |= 0b00000001;
 0BF5 430401            or REG[0x4],1
 0BF8                   .dbline 670
 0BF8           ;       }
 0BF8 8004              xjmp L191
 0BFA           L190:
 0BFA                   .dbline 672
 0BFA           ;       else
 0BFA           ;       {
 0BFA                   .dbline 673
 0BFA           ;               PRT1DR &= 0b11111110;
 0BFA 4104FE            and REG[0x4],-2
 0BFD                   .dbline 675
 0BFD           ;               
 0BFD           ;       }
 0BFD           L191:
 0BFD                   .dbline 678
 0BFD           ;       
 0BFD           ;       // Reconnect to the global bus.
 0BFD           ;       PRT0GS |= 0b10000000;
 0BFD 430280            or REG[0x2],-128
 0C00                   .dbline -2
 0C00           L178:
 0C00 20                pop X
 0C01                   .dbline 0 ; func end
 0C01 7F                ret
 0C02                   .dbsym l mode -5 I
 0C02                   .dbend
 0C02                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 0C02           _unloadAllConfigs::
 0C02                   .dbline -1
 0C02                   .dbline 684
 0C02           ; }
 0C02           ; 
 0C02           ; // This function blindly unloads all user configurations. This will be called once,
 0C02           ; // when the system initially has no known state.
 0C02           ; void unloadAllConfigs(void)
 0C02           ; {
 0C02                   .dbline 685
 0C02           ;       UnloadConfig_pc_listener();
 0C02 7C0000            xcall _UnloadConfig_pc_listener
 0C05                   .dbline 686
 0C05           ;       UnloadConfig_receiver_config();
 0C05 7C0000            xcall _UnloadConfig_receiver_config
 0C08                   .dbline 687
 0C08           ;       UnloadConfig_transmitter_config();
 0C08 7C0000            xcall _UnloadConfig_transmitter_config
 0C0B                   .dbline -2
 0C0B           L192:
 0C0B                   .dbline 0 ; func end
 0C0B 7F                ret
 0C0C                   .dbend
 0C0C                   .dbfunc e unloadConfig _unloadConfig fV
 0C0C           ;     config_num -> X-5
 0C0C           _unloadConfig::
 0C0C                   .dbline -1
 0C0C 10                push X
 0C0D 4F                mov X,SP
 0C0E                   .dbline 693
 0C0E           ; }
 0C0E           ; 
 0C0E           ; // This function unloads the configuration corresponding to the config number passed to it.
 0C0E           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0C0E           ; void unloadConfig(int config_num)
 0C0E           ; {
 0C0E                   .dbline 694
 0C0E           ;       if(config_num == PC_MODE)
 0C0E 3DFB00            cmp [X-5],0
 0C11 B00B              jnz L194
 0C13 3DFC02            cmp [X-4],2
 0C16 B006              jnz L194
 0C18           X56:
 0C18                   .dbline 695
 0C18           ;       {
 0C18                   .dbline 696
 0C18           ;               UnloadConfig_pc_listener();
 0C18 7C0000            xcall _UnloadConfig_pc_listener
 0C1B                   .dbline 697
 0C1B           ;       }
 0C1B 801D              xjmp L195
 0C1D           L194:
 0C1D                   .dbline 698
 0C1D           ;       else if(config_num == RX_MODE)
 0C1D 3DFB00            cmp [X-5],0
 0C20 B00B              jnz L196
 0C22 3DFC01            cmp [X-4],1
 0C25 B006              jnz L196
 0C27           X57:
 0C27                   .dbline 699
 0C27           ;       {
 0C27                   .dbline 700
 0C27           ;               UnloadConfig_receiver_config();
 0C27 7C0000            xcall _UnloadConfig_receiver_config
 0C2A                   .dbline 701
 0C2A           ;       }
 0C2A 800E              xjmp L197
 0C2C           L196:
 0C2C                   .dbline 702
 0C2C           ;       else if(config_num == TX_MODE)
 0C2C 3DFB00            cmp [X-5],0
 0C2F B009              jnz L198
 0C31 3DFC00            cmp [X-4],0
 0C34 B004              jnz L198
 0C36           X58:
 0C36                   .dbline 703
 0C36           ;       {
 0C36                   .dbline 704
 0C36           ;               UnloadConfig_transmitter_config();
 0C36 7C0000            xcall _UnloadConfig_transmitter_config
 0C39                   .dbline 705
 0C39           ;       }
 0C39           L198:
 0C39           L197:
 0C39           L195:
 0C39                   .dbline -2
 0C39           L193:
 0C39 20                pop X
 0C3A                   .dbline 0 ; func end
 0C3A 7F                ret
 0C3B                   .dbsym l config_num -5 I
 0C3B                   .dbend
 0C3B                   .dbfunc e busListen _busListen fV
 0C3B           _busListen::
 0C3B                   .dbline -1
 0C3B                   .dbline 709
 0C3B           ; }
 0C3B           ; 
 0C3B           ; void busListen(void)
 0C3B           ; {
 0C3B                   .dbline 710
 0C3B           ;       configToggle(RX_MODE);
 0C3B 5000              mov A,0
 0C3D 08                push A
 0C3E 5001              mov A,1
 0C40 08                push A
 0C41 9ED0              xcall _configToggle
 0C43 38FE              add SP,-2
 0C45 8013              xjmp L202
 0C47           L201:
 0C47                   .dbline 714
 0C47           ; 
 0C47           ;       // Wait for the first byte.
 0C47           ;       while(TIMEOUT < BOOT_TIMEOUT)
 0C47           ;       {
 0C47                   .dbline 715
 0C47           ;               if(RECEIVE_cGetChar())
 0C47 10                push X
 0C48 7C0000            xcall _RECEIVE_cGetChar
 0C4B 20                pop X
 0C4C 3900              cmp A,0
 0C4E A00A              jz L204
 0C50                   .dbline 716
 0C50           ;               {
 0C50                   .dbline 717
 0C50           ;                       TIMEOUT = BOOT_TIMEOUT;
 0C50 62D000            mov REG[0xd0],>_TIMEOUT
 0C53 55012C            mov [_TIMEOUT+1],44
 0C56 550001            mov [_TIMEOUT],1
 0C59                   .dbline 718
 0C59           ;               }
 0C59           L204:
 0C59                   .dbline 719
 0C59           ;       }
 0C59           L202:
 0C59                   .dbline 713
 0C59 62D000            mov REG[0xd0],>_TIMEOUT
 0C5C 5101              mov A,[_TIMEOUT+1]
 0C5E 112C              sub A,44
 0C60 5100              mov A,[_TIMEOUT]
 0C62 3180              xor A,-128
 0C64 1981              sbb A,(1 ^ 0x80)
 0C66 CFE0              jc L201
 0C68           X59:
 0C68                   .dbline 722
 0C68           ;       
 0C68           ;       // Clear the timeout flag.
 0C68           ;       TIMEOUT = 0;
 0C68 62D000            mov REG[0xd0],>_TIMEOUT
 0C6B 550100            mov [_TIMEOUT+1],0
 0C6E 550000            mov [_TIMEOUT],0
 0C71 8013              xjmp L207
 0C73           L206:
 0C73                   .dbline 726
 0C73           ;       
 0C73           ;       // Wait for BUS_CLEAR_TIME to pass without hearing a byte.
 0C73           ;       while(TIMEOUT < BUS_CLEAR_TIME)
 0C73           ;       {                                       
 0C73                   .dbline 727
 0C73           ;               if(RECEIVE_cReadChar())
 0C73 10                push X
 0C74 7C0000            xcall _RECEIVE_cReadChar
 0C77 20                pop X
 0C78 3900              cmp A,0
 0C7A A00A              jz L209
 0C7C                   .dbline 728
 0C7C           ;               {
 0C7C                   .dbline 729
 0C7C           ;                       TIMEOUT = 0;    
 0C7C 62D000            mov REG[0xd0],>_TIMEOUT
 0C7F 550100            mov [_TIMEOUT+1],0
 0C82 550000            mov [_TIMEOUT],0
 0C85                   .dbline 730
 0C85           ;               }
 0C85           L209:
 0C85                   .dbline 731
 0C85           ;       }
 0C85           L207:
 0C85                   .dbline 725
 0C85 62D000            mov REG[0xd0],>_TIMEOUT
 0C88 5101              mov A,[_TIMEOUT+1]
 0C8A 1164              sub A,100
 0C8C 5100              mov A,[_TIMEOUT]
 0C8E 3180              xor A,-128
 0C90 1980              sbb A,(0 ^ 0x80)
 0C92 CFE0              jc L206
 0C94           X60:
 0C94                   .dbline -2
 0C94           L200:
 0C94                   .dbline 0 ; func end
 0C94 7F                ret
 0C95                   .dbend
 0C95                   .dbfunc e initializeSlaves _initializeSlaves fV
 0C95           ;   num_timeouts -> X+0
 0C95           _initializeSlaves::
 0C95                   .dbline -1
 0C95 10                push X
 0C96 4F                mov X,SP
 0C97 3802              add SP,2
 0C99                   .dbline 735
 0C99           ; }
 0C99           ; 
 0C99           ; void initializeSlaves(void)
 0C99           ; {
 0C99                   .dbline 736
 0C99           ;       int num_timeouts = 0;
 0C99 560100            mov [X+1],0
 0C9C 560000            mov [X+0],0
 0C9F                   .dbline 739
 0C9F           ;       
 0C9F           ;       // Block and wait for the bus to be clear.
 0C9F           ;       busListen();
 0C9F 9F9A              xcall _busListen
 0CA1                   .dbline 741
 0CA1           ;       
 0CA1           ;       sayHello();
 0CA1 7C0322            xcall _sayHello
 0CA4 810B              xjmp L213
 0CA6           L212:
 0CA6                   .dbline 746
 0CA6           ;       
 0CA6           ;       // This loop continuously probes and listens at intervals
 0CA6           ;       // set by the RX_TIMEOUT_DURATION variable.
 0CA6           ;       while(num_timeouts < MAX_TIMEOUTS)
 0CA6           ;       {                                       
 0CA6                   .dbline 747
 0CA6           ;               if(validTransmission())
 0CA6 7C0378            xcall _validTransmission
 0CA9 62D000            mov REG[0xd0],>__r0
 0CAC 3C0000            cmp [__r0],0
 0CAF B006              jnz X61
 0CB1 3C0000            cmp [__r1],0
 0CB4 A0C8              jz L215
 0CB6           X61:
 0CB6                   .dbline 748
 0CB6           ;               {
 0CB6                   .dbline 749
 0CB6           ;                       if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0CB6 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0CB9 3C00C8            cmp [_COMMAND_TYPE],-56
 0CBC B0F3              jnz L216
 0CBE                   .dbline 750
 0CBE           ;                       {
 0CBE                   .dbline 752
 0CBE           ;                               // If this is for me, assign them an ID.
 0CBE           ;                               if(COMMAND_DESTINATION == MASTER_ID)
 0CBE 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0CC1 3C0000            cmp [_COMMAND_DESTINATION],0
 0CC4 B0EB              jnz L216
 0CC6                   .dbline 753
 0CC6           ;                               {
 0CC6                   .dbline 754
 0CC6           ;                                       NUM_MODULES++;                  // Increment the number of modules connected.
 0CC6 62D000            mov REG[0xd0],>_NUM_MODULES
 0CC9 7601              inc [_NUM_MODULES+1]
 0CCB 0E0000            adc [_NUM_MODULES],0
 0CCE                   .dbline 755
 0CCE           ;                                       num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0CCE 560100            mov [X+1],0
 0CD1 560000            mov [X+0],0
 0CD4                   .dbline 757
 0CD4           ;               
 0CD4           ;                                       if(!assignID(NUM_MODULES))
 0CD4 5100              mov A,[_NUM_MODULES]
 0CD6 08                push A
 0CD7 5101              mov A,[_NUM_MODULES+1]
 0CD9 08                push A
 0CDA 7C0133            xcall _assignID
 0CDD 38FE              add SP,-2
 0CDF 62D000            mov REG[0xd0],>__r0
 0CE2 3C0000            cmp [__r0],0
 0CE5 B0CA              jnz L216
 0CE7 3C0000            cmp [__r1],0
 0CEA B0C5              jnz L216
 0CEC           X62:
 0CEC                   .dbline 758
 0CEC           ;                                       {
 0CEC                   .dbline 762
 0CEC           ;                                               // If the module did not respond that the ID was assigned,
 0CEC           ;                                               // make an effort to ping it in case that transmission was lost
 0CEC           ;                                               // before ultimately deciding that the module didn't configure.
 0CEC           ;                                               if(!pingModule(NUM_MODULES))
 0CEC 62D000            mov REG[0xd0],>_NUM_MODULES
 0CEF 5100              mov A,[_NUM_MODULES]
 0CF1 08                push A
 0CF2 5101              mov A,[_NUM_MODULES+1]
 0CF4 08                push A
 0CF5 7C0044            xcall _pingModule
 0CF8 38FE              add SP,-2
 0CFA 62D000            mov REG[0xd0],>__r0
 0CFD 3C0000            cmp [__r0],0
 0D00 B0AF              jnz L216
 0D02 3C0000            cmp [__r1],0
 0D05 B0AA              jnz L216
 0D07           X63:
 0D07                   .dbline 763
 0D07           ;                                               {
 0D07                   .dbline 764
 0D07           ;                                                       if(!pingModule(NUM_MODULES))
 0D07 62D000            mov REG[0xd0],>_NUM_MODULES
 0D0A 5100              mov A,[_NUM_MODULES]
 0D0C 08                push A
 0D0D 5101              mov A,[_NUM_MODULES+1]
 0D0F 08                push A
 0D10 7C0044            xcall _pingModule
 0D13 38FE              add SP,-2
 0D15 62D000            mov REG[0xd0],>__r0
 0D18 3C0000            cmp [__r0],0
 0D1B B094              jnz L216
 0D1D 3C0000            cmp [__r1],0
 0D20 B08F              jnz L216
 0D22           X64:
 0D22                   .dbline 765
 0D22           ;                                                       {
 0D22                   .dbline 766
 0D22           ;                                                               if(!pingModule(NUM_MODULES))
 0D22 62D000            mov REG[0xd0],>_NUM_MODULES
 0D25 5100              mov A,[_NUM_MODULES]
 0D27 08                push A
 0D28 5101              mov A,[_NUM_MODULES+1]
 0D2A 08                push A
 0D2B 7C0044            xcall _pingModule
 0D2E 38FE              add SP,-2
 0D30 62D000            mov REG[0xd0],>__r0
 0D33 3C0000            cmp [__r0],0
 0D36 B079              jnz L216
 0D38 3C0000            cmp [__r1],0
 0D3B B074              jnz L216
 0D3D           X65:
 0D3D                   .dbline 767
 0D3D           ;                                                               {
 0D3D                   .dbline 768
 0D3D           ;                                                                       if(!pingModule(NUM_MODULES))
 0D3D 62D000            mov REG[0xd0],>_NUM_MODULES
 0D40 5100              mov A,[_NUM_MODULES]
 0D42 08                push A
 0D43 5101              mov A,[_NUM_MODULES+1]
 0D45 08                push A
 0D46 7C0044            xcall _pingModule
 0D49 38FE              add SP,-2
 0D4B 62D000            mov REG[0xd0],>__r0
 0D4E 3C0000            cmp [__r0],0
 0D51 B05E              jnz L216
 0D53 3C0000            cmp [__r1],0
 0D56 B059              jnz L216
 0D58           X66:
 0D58                   .dbline 769
 0D58           ;                                                                       {
 0D58                   .dbline 770
 0D58           ;                                                                               if(!pingModule(NUM_MODULES))
 0D58 62D000            mov REG[0xd0],>_NUM_MODULES
 0D5B 5100              mov A,[_NUM_MODULES]
 0D5D 08                push A
 0D5E 5101              mov A,[_NUM_MODULES+1]
 0D60 08                push A
 0D61 7C0044            xcall _pingModule
 0D64 38FE              add SP,-2
 0D66 62D000            mov REG[0xd0],>__r0
 0D69 3C0000            cmp [__r0],0
 0D6C B043              jnz L216
 0D6E 3C0000            cmp [__r1],0
 0D71 B03E              jnz L216
 0D73           X67:
 0D73                   .dbline 771
 0D73           ;                                                                               {
 0D73                   .dbline 772
 0D73           ;                                                                                       NUM_MODULES--;
 0D73 62D000            mov REG[0xd0],>_NUM_MODULES
 0D76 7A01              dec [_NUM_MODULES+1]
 0D78 1E0000            sbb [_NUM_MODULES],0
 0D7B                   .dbline 773
 0D7B           ;                                                                               }
 0D7B                   .dbline 774
 0D7B           ;                                                                       }
 0D7B                   .dbline 775
 0D7B           ;                                                               }
 0D7B                   .dbline 776
 0D7B           ;                                                       }
 0D7B                   .dbline 777
 0D7B           ;                                               }
 0D7B                   .dbline 778
 0D7B           ;                                       }
 0D7B                   .dbline 779
 0D7B           ;                               }
 0D7B                   .dbline 780
 0D7B           ;                       }
 0D7B                   .dbline 781
 0D7B           ;               }
 0D7B 8034              xjmp L216
 0D7D           L215:
 0D7D                   .dbline 782
 0D7D           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 0D7D 62D000            mov REG[0xd0],>_TIMEOUT
 0D80 5101              mov A,[_TIMEOUT+1]
 0D82 1105              sub A,5
 0D84 5100              mov A,[_TIMEOUT]
 0D86 3180              xor A,-128
 0D88 1980              sbb A,(0 ^ 0x80)
 0D8A C025              jc L233
 0D8C           X68:
 0D8C                   .dbline 783
 0D8C           ;               {       
 0D8C                   .dbline 785
 0D8C           ;                       // Only count timeouts if we've found at least one module.
 0D8C           ;                       if(NUM_MODULES)
 0D8C 62D000            mov REG[0xd0],>_NUM_MODULES
 0D8F 3C0000            cmp [_NUM_MODULES],0
 0D92 B006              jnz X69
 0D94 3C0100            cmp [_NUM_MODULES+1],0
 0D97 A006              jz L235
 0D99           X69:
 0D99                   .dbline 786
 0D99           ;                       {
 0D99                   .dbline 787
 0D99           ;                               num_timeouts++;
 0D99 7701              inc [X+1]
 0D9B 0F0000            adc [X+0],0
 0D9E                   .dbline 788
 0D9E           ;                       }
 0D9E           L235:
 0D9E                   .dbline 791
 0D9E           ;                       
 0D9E           ;                       // If we are not maxed out on modules, look for more.
 0D9E           ;                       if(NUM_MODULES < MAX_MODULES)
 0D9E 62D000            mov REG[0xd0],>_NUM_MODULES
 0DA1 5101              mov A,[_NUM_MODULES+1]
 0DA3 11FA              sub A,-6
 0DA5 5100              mov A,[_NUM_MODULES]
 0DA7 3180              xor A,-128
 0DA9 1980              sbb A,(0 ^ 0x80)
 0DAB D004              jnc L237
 0DAD           X70:
 0DAD                   .dbline 792
 0DAD           ;                       {
 0DAD                   .dbline 793
 0DAD           ;                               sayHello();
 0DAD 7C0322            xcall _sayHello
 0DB0                   .dbline 794
 0DB0           ;                       }
 0DB0           L237:
 0DB0                   .dbline 795
 0DB0           ;               }
 0DB0           L233:
 0DB0           L216:
 0DB0                   .dbline 796
 0DB0           ;       }
 0DB0           L213:
 0DB0                   .dbline 745
 0DB0 5201              mov A,[X+1]
 0DB2 110A              sub A,10
 0DB4 5200              mov A,[X+0]
 0DB6 3180              xor A,-128
 0DB8 1980              sbb A,(0 ^ 0x80)
 0DBA CEEB              jc L212
 0DBC           X71:
 0DBC                   .dbline 799
 0DBC           ;       
 0DBC           ;       // Switch back to PC mode.
 0DBC           ;       configToggle(PC_MODE);
 0DBC 5000              mov A,0
 0DBE 08                push A
 0DBF 5002              mov A,2
 0DC1 08                push A
 0DC2 9D4F              xcall _configToggle
 0DC4 38FE              add SP,-2
 0DC6                   .dbline -2
 0DC6           L211:
 0DC6 38FE              add SP,-2
 0DC8 20                pop X
 0DC9                   .dbline 0 ; func end
 0DC9 7F                ret
 0DCA                   .dbsym l num_timeouts 0 I
 0DCA                   .dbend
 0DCA                   .dbfunc e xmitWait _xmitWait fV
 0DCA           ;              i -> X+0
 0DCA           _xmitWait::
 0DCA                   .dbline -1
 0DCA 10                push X
 0DCB 4F                mov X,SP
 0DCC 3802              add SP,2
 0DCE                   .dbline 803
 0DCE           ; }
 0DCE           ; 
 0DCE           ; void xmitWait(void)
 0DCE           ; {
 0DCE                   .dbline 806
 0DCE           ;       int i;
 0DCE           ;       
 0DCE           ;       for(i = 0; i < 25; i++)
 0DCE 560100            mov [X+1],0
 0DD1 560000            mov [X+0],0
 0DD4           L240:
 0DD4                   .dbline 807
 0DD4           ;       {
 0DD4                   .dbline 809
 0DD4           ;               // Sit here and spin for about 50 microseconds.
 0DD4           ;       }
 0DD4           L241:
 0DD4                   .dbline 806
 0DD4 7701              inc [X+1]
 0DD6 0F0000            adc [X+0],0
 0DD9                   .dbline 806
 0DD9 5201              mov A,[X+1]
 0DDB 1119              sub A,25
 0DDD 5200              mov A,[X+0]
 0DDF 3180              xor A,-128
 0DE1 1980              sbb A,(0 ^ 0x80)
 0DE3 CFF0              jc L240
 0DE5           X72:
 0DE5                   .dbline -2
 0DE5           L239:
 0DE5 38FE              add SP,-2
 0DE7 20                pop X
 0DE8                   .dbline 0 ; func end
 0DE8 7F                ret
 0DE9                   .dbsym l i 0 I
 0DE9                   .dbend
 0DE9                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0DE9           _TX_TIMEOUT_ISR::
 0DE9                   .dbline -1
 0DE9 71C0              or F,-64
 0DEB 08                push A
 0DEC 5DD0              mov A,REG[0xd0]
 0DEE 08                push A
 0DEF                   .dbline 813
 0DEF           ; }
 0DEF           ; 
 0DEF           ; void TX_TIMEOUT_ISR(void)
 0DEF           ; {     
 0DEF                   .dbline 814
 0DEF           ;       TIMEOUT++;
 0DEF 62D000            mov REG[0xd0],>_TIMEOUT
 0DF2 7601              inc [_TIMEOUT+1]
 0DF4 0E0000            adc [_TIMEOUT],0
 0DF7                   .dbline 816
 0DF7           ;       
 0DF7           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0DF7 62DAFD            mov REG[0xda],-3
 0DFA                   .dbline -2
 0DFA           L244:
 0DFA 18                pop A
 0DFB 60D0              mov REG[208],A
 0DFD 18                pop A
 0DFE                   .dbline 0 ; func end
 0DFE 7E                reti
 0DFF                   .dbend
 0DFF                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0DFF           _RX_TIMEOUT_ISR::
 0DFF                   .dbline -1
 0DFF 71C0              or F,-64
 0E01 08                push A
 0E02 5DD0              mov A,REG[0xd0]
 0E04 08                push A
 0E05                   .dbline 820
 0E05           ; }
 0E05           ; 
 0E05           ; void RX_TIMEOUT_ISR(void)
 0E05           ; {     
 0E05                   .dbline 821
 0E05           ;       TIMEOUT++;
 0E05 62D000            mov REG[0xd0],>_TIMEOUT
 0E08 7601              inc [_TIMEOUT+1]
 0E0A 0E0000            adc [_TIMEOUT],0
 0E0D                   .dbline 823
 0E0D           ;       
 0E0D           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0E0D 62DAFD            mov REG[0xda],-3
 0E10                   .dbline -2
 0E10           L245:
 0E10 18                pop A
 0E11 60D0              mov REG[208],A
 0E13 18                pop A
 0E14                   .dbline 0 ; func end
 0E14 7E                reti
 0E15                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _PARAM::
 0000 00000000000000000000      .byte 0,0,0,0,0,0,0,0,0,0
 000A                   .dbsym e PARAM _PARAM A[10:10]c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
