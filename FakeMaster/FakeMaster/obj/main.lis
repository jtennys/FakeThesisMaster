 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ;          angle -> X+4
 0000           ;  softwareReset -> X+2
 0000           ;      tempValue -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3808              add SP,8
 0004                   .dbline 98
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>              // part specific constants and macros
 0004           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0004           ; #include "psocdynamic.h"
 0004           ; #include <stdlib.h>
 0004           ; #include <string.h>
 0004           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0004           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0004           ; 
 0004           ; // These defines are used as parameters of the configToggle function.
 0004           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0004           ; #define               PC_MODE                                         (2)
 0004           ; #define               RX_MODE                                         (1)
 0004           ; #define               TX_MODE                                         (0)
 0004           ; 
 0004           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0004           ; #define               PORT_1                                          ('A')
 0004           ; #define               PORT_2                                          ('B')
 0004           ; #define               PORT_3                                          ('C')
 0004           ; #define               PORT_4                                          ('D')
 0004           ; 
 0004           ; // These defines are used as transmission indicators.
 0004           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0004           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0004           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0004           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0004           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0004           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0004           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0004           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0004           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0004           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0004           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0004           ; 
 0004           ; // These defines are used to fill in the instruction we are using on the servo.
 0004           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0004           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0004           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0004           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0004           ; 
 0004           ; // These defines are used for transmission timing.
 0004           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0004           ; 
 0004           ; // These defines are used for the initial probing stage, where receive waits are longer to make
 0004           ; // sure of transmission failure or success.
 0004           ; #define               BOOT_TIMEOUT                            (200)   // This is boot wait time in 1 ms units.
 0004           ; #define               MAX_TIMEOUTS                            (10)    // Number of timeouts allowed before hello mode exit.
 0004           ; 
 0004           ; // This is the maximum number of allowable modules per branch out from the master
 0004           ; #define               MAX_MODULES                                     (250)
 0004           ; 
 0004           ; #define               SERVO_START                                     (255)
 0004           ; 
 0004           ; // This function receives a mode identifier as a parameter and toggles the
 0004           ; // system configuration between receive and transmit modes for half duplex UART.
 0004           ; void configToggle(int mode);
 0004           ; 
 0004           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0004           ; int pingModule(int module_id);
 0004           ; 
 0004           ; // This function assigns an ID to a module.
 0004           ; int assignID(int assigned_ID);
 0004           ; 
 0004           ; int validTransmission(void);
 0004           ; 
 0004           ; void decodeTransmission(void);
 0004           ; 
 0004           ; void sayHello(void);
 0004           ; 
 0004           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0004           ; 
 0004           ; int clearConfig(int module_id);
 0004           ; // This function checks the current mode and unloads the configuration for that mode.
 0004           ; void unloadAllConfigs(void);
 0004           ; // This function unloads the configuration corresponding to the number passed to it.
 0004           ; void unloadConfig(int config_num);
 0004           ; // Initialization function for the slave module controllers.
 0004           ; void initializeSlaves(void);
 0004           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0004           ; void xmitWait(void);
 0004           ; 
 0004           ; // This flag is set if there is a timeout.
 0004           ; int TIMEOUT;
 0004           ; 
 0004           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0004           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0004           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0004           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0004           ; char PARAM1;                          // Stores a parameter that accompanies the command (if any).
 0004           ; char PARAM2;                          // Stores a parameter that accompanies the command (if any).
 0004           ; 
 0004           ; int STATE;                                    // Stores the current configuration state of the system.
 0004           ; 
 0004           ; void main()
 0004           ; {     
 0004                   .dbline 99
 0004           ;       int tempValue = 0;
 0004 560100            mov [X+1],0
 0007 560000            mov [X+0],0
 000A                   .dbline 100
 000A           ;       int softwareReset = 0;
 000A 560300            mov [X+3],0
 000D 560200            mov [X+2],0
 0010                   .dbline 101
 0010           ;       float angle = 0;
 0010 560400            mov [X+4],0
 0013 560500            mov [X+5],0
 0016 560600            mov [X+6],0
 0019 560700            mov [X+7],0
 001C                   .dbline 103
 001C           ;       
 001C           ;       NUM_MODULES = 0;
 001C 62D000            mov REG[0xd0],>_NUM_MODULES
 001F 550100            mov [_NUM_MODULES+1],0
 0022 550000            mov [_NUM_MODULES],0
 0025                   .dbline 105
 0025           ;       
 0025           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 0025 7101                      or  F, 01h
 0027           
 0027                   .dbline 106
 0027           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); //activate GPIO ISR
 0027 43E020            or REG[0xe0],32
 002A                   .dbline 108
 002A           ;       
 002A           ;       unloadAllConfigs();
 002A 9771              xcall _unloadAllConfigs
 002C                   .dbline 110
 002C           ; 
 002C           ;       configToggle(RX_MODE);
 002C 5000              mov A,0
 002E 08                push A
 002F 5001              mov A,1
 0031 08                push A
 0032 967A              xcall _configToggle
 0034 38FE              add SP,-2
 0036           L2:
 0036                   .dbline 113
 0036           ;               
 0036           ;       // Sit and wait for the worst case setup time to occur.
 0036           ;       while(TIMEOUT < BOOT_TIMEOUT) { }
 0036                   .dbline 113
 0036           L3:
 0036                   .dbline 113
 0036 62D000            mov REG[0xd0],>_TIMEOUT
 0039 5101              mov A,[_TIMEOUT+1]
 003B 11C8              sub A,-56
 003D 5100              mov A,[_TIMEOUT]
 003F 3180              xor A,-128
 0041 1980              sbb A,(0 ^ 0x80)
 0043 CFF2              jc L2
 0045           X1:
 0045                   .dbline 116
 0045           ;               
 0045           ;       // Initialize all of the slave modules.
 0045           ;       initializeSlaves();
 0045 978F              xcall _initializeSlaves
 0047 800F              xjmp L6
 0049           L5:
 0049                   .dbline 119
 0049           ;       
 0049           ;       while(1)
 0049           ;       {       
 0049                   .dbline 120
 0049           ;               if(COMP_SERIAL_bCmdCheck())
 0049 10                push X
 004A 7C0000            xcall _COMP_SERIAL_bCmdCheck
 004D 62D000            mov REG[0xd0],>__r0
 0050 20                pop X
 0051 3900              cmp A,0
 0053 A003              jz L8
 0055                   .dbline 121
 0055           ;               {
 0055                   .dbline 122
 0055           ;                       decodeTransmission();
 0055 93D7              xcall _decodeTransmission
 0057                   .dbline 123
 0057           ;               }
 0057           L8:
 0057                   .dbline 124
 0057           ;       }
 0057           L6:
 0057                   .dbline 118
 0057 8FF1              xjmp L5
 0059           X0:
 0059                   .dbline -2
 0059           L1:
 0059 38F8              add SP,-8
 005B 20                pop X
 005C                   .dbline 0 ; func end
 005C 8FFF              jmp .
 005E                   .dbsym l angle 4 D
 005E                   .dbsym l softwareReset 2 I
 005E                   .dbsym l tempValue 0 I
 005E                   .dbend
 005E                   .dbfunc e pingModule _pingModule fI
 005E           ;       response -> X+0
 005E           ;      module_id -> X-5
 005E           _pingModule::
 005E                   .dbline -1
 005E 10                push X
 005F 4F                mov X,SP
 0060 3802              add SP,2
 0062                   .dbline 128
 0062           ; }
 0062           ; 
 0062           ; int pingModule(int module_id)
 0062           ; {
 0062                   .dbline 129
 0062           ;       int response = 0;
 0062 560100            mov [X+1],0
 0065 560000            mov [X+0],0
 0068                   .dbline 131
 0068           ;       
 0068           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0068 5000              mov A,0
 006A 08                push A
 006B 08                push A
 006C 9640              xcall _configToggle
 006E 38FE              add SP,-2
 0070                   .dbline 134
 0070           ;                       
 0070           ;       // Transmit a hello.
 0070           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0070 10                push X
 0071 50FC              mov A,-4
 0073 7C0000            xcall _TRANSMIT_PutChar
 0076 20                pop X
 0077                   .dbline 135
 0077           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0077 10                push X
 0078 50FC              mov A,-4
 007A 7C0000            xcall _TRANSMIT_PutChar
 007D 20                pop X
 007E                   .dbline 136
 007E           ;       TRANSMIT_PutChar(MASTER_ID);
 007E 10                push X
 007F 5000              mov A,0
 0081 7C0000            xcall _TRANSMIT_PutChar
 0084 20                pop X
 0085                   .dbline 137
 0085           ;       TRANSMIT_PutChar(module_id);
 0085 62D000            mov REG[0xd0],>__r0
 0088 52FC              mov A,[X-4]
 008A 10                push X
 008B 7C0000            xcall _TRANSMIT_PutChar
 008E 20                pop X
 008F                   .dbline 138
 008F           ;       TRANSMIT_PutChar(PING);
 008F 10                push X
 0090 50CB              mov A,-53
 0092 7C0000            xcall _TRANSMIT_PutChar
 0095 20                pop X
 0096                   .dbline 139
 0096           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0096 10                push X
 0097 50FD              mov A,-3
 0099 7C0000            xcall _TRANSMIT_PutChar
 009C 20                pop X
 009D                   .dbline 140
 009D           ;       TRANSMIT_PutChar(END_TRANSMIT);
 009D 10                push X
 009E 50FD              mov A,-3
 00A0 7C0000            xcall _TRANSMIT_PutChar
 00A3 20                pop X
 00A4           L11:
 00A4                   .dbline 143
 00A4           ;       
 00A4           ;       // Wait for the transmission to finish.
 00A4           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 00A4           L12:
 00A4                   .dbline 143
 00A4 10                push X
 00A5 7C0000            xcall _TRANSMIT_bReadTxStatus
 00A8 62D000            mov REG[0xd0],>__r0
 00AB 20                pop X
 00AC 5300              mov [__r0],A
 00AE 470020            tst [__r0],32
 00B1 AFF2              jz L11
 00B3                   .dbline 145
 00B3           ;       
 00B3           ;       xmitWait();
 00B3 7C0902            xcall _xmitWait
 00B6                   .dbline 147
 00B6           ;       
 00B6           ;       configToggle(RX_MODE);  // Listen for the response.
 00B6 5000              mov A,0
 00B8 08                push A
 00B9 5001              mov A,1
 00BB 08                push A
 00BC 95F0              xcall _configToggle
 00BE 38FE              add SP,-2
 00C0                   .dbline 149
 00C0           ;       
 00C0           ;       RX_TIMEOUT_Stop();
 00C0 10                push X
 00C1 7C0000            xcall _RX_TIMEOUT_Stop
 00C4 20                pop X
 00C5                   .dbline 150
 00C5           ;       TIMEOUT = 0;
 00C5 62D000            mov REG[0xd0],>_TIMEOUT
 00C8 550100            mov [_TIMEOUT+1],0
 00CB 550000            mov [_TIMEOUT],0
 00CE                   .dbline 151
 00CE           ;       RX_TIMEOUT_Start();
 00CE 10                push X
 00CF 7C0000            xcall _RX_TIMEOUT_Start
 00D2 20                pop X
 00D3 8048              xjmp L15
 00D5           L14:
 00D5                   .dbline 154
 00D5           ;       
 00D5           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 00D5           ;       {
 00D5                   .dbline 155
 00D5           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 00D5 10                push X
 00D6 7C0000            xcall _RECEIVE_cReadChar
 00D9 62D000            mov REG[0xd0],>__r0
 00DC 20                pop X
 00DD 39FC              cmp A,-4
 00DF B03C              jnz L17
 00E1                   .dbline 156
 00E1           ;               {       
 00E1                   .dbline 157
 00E1           ;                       if(validTransmission())
 00E1 92F8              xcall _validTransmission
 00E3 62D000            mov REG[0xd0],>__r0
 00E6 3C0000            cmp [__r0],0
 00E9 B006              jnz X2
 00EB 3C0000            cmp [__r1],0
 00EE A02D              jz L19
 00F0           X2:
 00F0                   .dbline 158
 00F0           ;                       {
 00F0                   .dbline 159
 00F0           ;                               if(COMMAND_TYPE == PING)        // This is the response we are looking for.
 00F0 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00F3 3C00CB            cmp [_COMMAND_TYPE],-53
 00F6 B025              jnz L21
 00F8                   .dbline 160
 00F8           ;                               {
 00F8                   .dbline 162
 00F8           ;                                       // If this is for me, check who it was from.
 00F8           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 00F8 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 00FB 3C0000            cmp [_COMMAND_DESTINATION],0
 00FE B01D              jnz L23
 0100                   .dbline 163
 0100           ;                                       {
 0100                   .dbline 164
 0100           ;                                               if(COMMAND_SOURCE == module_id)
 0100 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0103 5100              mov A,[_COMMAND_SOURCE]
 0105 62D000            mov REG[0xd0],>__r0
 0108 5300              mov [__r1],A
 010A 5000              mov A,0
 010C 3BFB              cmp A,[X-5]
 010E B00D              jnz L25
 0110 5100              mov A,[__r1]
 0112 3BFC              cmp A,[X-4]
 0114 B007              jnz L25
 0116           X3:
 0116                   .dbline 165
 0116           ;                                               {
 0116                   .dbline 166
 0116           ;                                                       response = 1;
 0116 560101            mov [X+1],1
 0119 560000            mov [X+0],0
 011C                   .dbline 167
 011C           ;                                               }
 011C           L25:
 011C                   .dbline 168
 011C           ;                                       }
 011C           L23:
 011C                   .dbline 169
 011C           ;                               }
 011C           L21:
 011C                   .dbline 170
 011C           ;                       }
 011C           L19:
 011C                   .dbline 171
 011C           ;               }
 011C           L17:
 011C                   .dbline 172
 011C           ;       }
 011C           L15:
 011C                   .dbline 153
 011C 62D000            mov REG[0xd0],>_TIMEOUT
 011F 5101              mov A,[_TIMEOUT+1]
 0121 1105              sub A,5
 0123 5100              mov A,[_TIMEOUT]
 0125 3180              xor A,-128
 0127 1980              sbb A,(0 ^ 0x80)
 0129 D00B              jnc L27
 012B           X4:
 012B 3D0000            cmp [X+0],0
 012E B006              jnz X5
 0130 3D0100            cmp [X+1],0
 0133 AFA1              jz L14
 0135           X5:
 0135           L27:
 0135                   .dbline 174
 0135           ;       
 0135           ;       RX_TIMEOUT_Stop();
 0135 10                push X
 0136 7C0000            xcall _RX_TIMEOUT_Stop
 0139 20                pop X
 013A                   .dbline 175
 013A           ;       TIMEOUT = 0;
 013A 62D000            mov REG[0xd0],>_TIMEOUT
 013D 550100            mov [_TIMEOUT+1],0
 0140 550000            mov [_TIMEOUT],0
 0143                   .dbline 176
 0143           ;       RX_TIMEOUT_Start();
 0143 10                push X
 0144 7C0000            xcall _RX_TIMEOUT_Start
 0147 20                pop X
 0148                   .dbline 178
 0148           ;       
 0148           ;       return response;
 0148 62D000            mov REG[0xd0],>__r0
 014B 5201              mov A,[X+1]
 014D 5300              mov [__r1],A
 014F 5200              mov A,[X+0]
 0151 5300              mov [__r0],A
 0153                   .dbline -2
 0153           L10:
 0153 38FE              add SP,-2
 0155 20                pop X
 0156                   .dbline 0 ; func end
 0156 7F                ret
 0157                   .dbsym l response 0 I
 0157                   .dbsym l module_id -5 I
 0157                   .dbend
 0157                   .dbfunc e assignID _assignID fI
 0157           ;        success -> X+0
 0157           ;    assigned_ID -> X-5
 0157           _assignID::
 0157                   .dbline -1
 0157 10                push X
 0158 4F                mov X,SP
 0159 3802              add SP,2
 015B                   .dbline 182
 015B           ; }
 015B           ; 
 015B           ; int assignID(int assigned_ID)
 015B           ; {
 015B                   .dbline 183
 015B           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 015B 560100            mov [X+1],0
 015E 560000            mov [X+0],0
 0161                   .dbline 185
 0161           ;       
 0161           ;       configToggle(TX_MODE);  // Switch to TX mode.
 0161 5000              mov A,0
 0163 08                push A
 0164 08                push A
 0165 9547              xcall _configToggle
 0167 38FE              add SP,-2
 0169                   .dbline 188
 0169           ; 
 0169           ;       // Transmit the assignment.
 0169           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0169 10                push X
 016A 50FC              mov A,-4
 016C 7C0000            xcall _TRANSMIT_PutChar
 016F 20                pop X
 0170                   .dbline 189
 0170           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0170 10                push X
 0171 50FC              mov A,-4
 0173 7C0000            xcall _TRANSMIT_PutChar
 0176 20                pop X
 0177                   .dbline 190
 0177           ;       TRANSMIT_PutChar(MASTER_ID);
 0177 10                push X
 0178 5000              mov A,0
 017A 7C0000            xcall _TRANSMIT_PutChar
 017D 20                pop X
 017E                   .dbline 191
 017E           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 017E 10                push X
 017F 50FB              mov A,-5
 0181 7C0000            xcall _TRANSMIT_PutChar
 0184 20                pop X
 0185                   .dbline 192
 0185           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 0185 10                push X
 0186 50C9              mov A,-55
 0188 7C0000            xcall _TRANSMIT_PutChar
 018B 20                pop X
 018C                   .dbline 193
 018C           ;       TRANSMIT_PutChar(assigned_ID);
 018C 62D000            mov REG[0xd0],>__r0
 018F 52FC              mov A,[X-4]
 0191 10                push X
 0192 7C0000            xcall _TRANSMIT_PutChar
 0195 20                pop X
 0196                   .dbline 194
 0196           ;       TRANSMIT_PutChar(END_TRANSMIT);
 0196 10                push X
 0197 50FD              mov A,-3
 0199 7C0000            xcall _TRANSMIT_PutChar
 019C 20                pop X
 019D                   .dbline 195
 019D           ;       TRANSMIT_PutChar(END_TRANSMIT);
 019D 10                push X
 019E 50FD              mov A,-3
 01A0 7C0000            xcall _TRANSMIT_PutChar
 01A3 20                pop X
 01A4           L29:
 01A4                   .dbline 198
 01A4           ;       
 01A4           ;       // Wait for the transmission to finish.
 01A4           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 01A4           L30:
 01A4                   .dbline 198
 01A4 10                push X
 01A5 7C0000            xcall _TRANSMIT_bReadTxStatus
 01A8 62D000            mov REG[0xd0],>__r0
 01AB 20                pop X
 01AC 5300              mov [__r0],A
 01AE 470020            tst [__r0],32
 01B1 AFF2              jz L29
 01B3                   .dbline 200
 01B3           ;       
 01B3           ;       xmitWait();
 01B3 974D              xcall _xmitWait
 01B5                   .dbline 202
 01B5           ;       
 01B5           ;       configToggle(RX_MODE);  // Switch back to receive mode.
 01B5 5000              mov A,0
 01B7 08                push A
 01B8 5001              mov A,1
 01BA 08                push A
 01BB 94F1              xcall _configToggle
 01BD 38FE              add SP,-2
 01BF                   .dbline 204
 01BF           ;       
 01BF           ;       RX_TIMEOUT_Stop();
 01BF 10                push X
 01C0 7C0000            xcall _RX_TIMEOUT_Stop
 01C3 20                pop X
 01C4                   .dbline 205
 01C4           ;       TIMEOUT = 0;
 01C4 62D000            mov REG[0xd0],>_TIMEOUT
 01C7 550100            mov [_TIMEOUT+1],0
 01CA 550000            mov [_TIMEOUT],0
 01CD                   .dbline 206
 01CD           ;       RX_TIMEOUT_Start();
 01CD 10                push X
 01CE 7C0000            xcall _RX_TIMEOUT_Start
 01D1 20                pop X
 01D2 8048              xjmp L33
 01D4           L32:
 01D4                   .dbline 209
 01D4           ;       
 01D4           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!success))
 01D4           ;       {
 01D4                   .dbline 210
 01D4           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 01D4 10                push X
 01D5 7C0000            xcall _RECEIVE_cReadChar
 01D8 62D000            mov REG[0xd0],>__r0
 01DB 20                pop X
 01DC 39FC              cmp A,-4
 01DE B03C              jnz L35
 01E0                   .dbline 211
 01E0           ;               {       
 01E0                   .dbline 212
 01E0           ;                       if(validTransmission())
 01E0 91F9              xcall _validTransmission
 01E2 62D000            mov REG[0xd0],>__r0
 01E5 3C0000            cmp [__r0],0
 01E8 B006              jnz X6
 01EA 3C0000            cmp [__r1],0
 01ED A02D              jz L37
 01EF           X6:
 01EF                   .dbline 213
 01EF           ;                       {
 01EF                   .dbline 214
 01EF           ;                               if(COMMAND_TYPE == ID_ASSIGN_OK)        // This is the response we are looking for.
 01EF 62D000            mov REG[0xd0],>_COMMAND_TYPE
 01F2 3C00CA            cmp [_COMMAND_TYPE],-54
 01F5 B025              jnz L39
 01F7                   .dbline 215
 01F7           ;                               {
 01F7                   .dbline 217
 01F7           ;                                       // If this is for me, check who it was from.
 01F7           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 01F7 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 01FA 3C0000            cmp [_COMMAND_DESTINATION],0
 01FD B01D              jnz L41
 01FF                   .dbline 218
 01FF           ;                                       {
 01FF                   .dbline 219
 01FF           ;                                               if(COMMAND_SOURCE == assigned_ID)
 01FF 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0202 5100              mov A,[_COMMAND_SOURCE]
 0204 62D000            mov REG[0xd0],>__r0
 0207 5300              mov [__r1],A
 0209 5000              mov A,0
 020B 3BFB              cmp A,[X-5]
 020D B00D              jnz L43
 020F 5100              mov A,[__r1]
 0211 3BFC              cmp A,[X-4]
 0213 B007              jnz L43
 0215           X7:
 0215                   .dbline 220
 0215           ;                                               {
 0215                   .dbline 221
 0215           ;                                                       success = 1;
 0215 560101            mov [X+1],1
 0218 560000            mov [X+0],0
 021B                   .dbline 222
 021B           ;                                               }
 021B           L43:
 021B                   .dbline 223
 021B           ;                                       }
 021B           L41:
 021B                   .dbline 224
 021B           ;                               }
 021B           L39:
 021B                   .dbline 225
 021B           ;                       }
 021B           L37:
 021B                   .dbline 226
 021B           ;               }
 021B           L35:
 021B                   .dbline 227
 021B           ;       }
 021B           L33:
 021B                   .dbline 208
 021B 62D000            mov REG[0xd0],>_TIMEOUT
 021E 5101              mov A,[_TIMEOUT+1]
 0220 1105              sub A,5
 0222 5100              mov A,[_TIMEOUT]
 0224 3180              xor A,-128
 0226 1980              sbb A,(0 ^ 0x80)
 0228 D00B              jnc L45
 022A           X8:
 022A 3D0000            cmp [X+0],0
 022D B006              jnz X9
 022F 3D0100            cmp [X+1],0
 0232 AFA1              jz L32
 0234           X9:
 0234           L45:
 0234                   .dbline 229
 0234           ;       
 0234           ;       LCD_1_Start();
 0234 10                push X
 0235 7C0000            xcall _LCD_1_Start
 0238 20                pop X
 0239                   .dbline 230
 0239           ;       LCD_1_Position(0,0);
 0239 10                push X
 023A 5000              mov A,0
 023C 5C                mov X,A
 023D 7C0000            xcall _LCD_1_Position
 0240 20                pop X
 0241                   .dbline 231
 0241           ;       LCD_1_PrHexInt(NUM_MODULES);
 0241 10                push X
 0242 62D000            mov REG[0xd0],>_NUM_MODULES
 0245 5100              mov A,[_NUM_MODULES]
 0247 08                push A
 0248 5101              mov A,[_NUM_MODULES+1]
 024A 20                pop X
 024B 7C0000            xcall _LCD_1_PrHexInt
 024E 20                pop X
 024F                   .dbline 232
 024F           ;       LCD_1_Position(0,5);
 024F 10                push X
 0250 5705              mov X,5
 0252 5000              mov A,0
 0254 7C0000            xcall _LCD_1_Position
 0257 20                pop X
 0258                   .dbline 233
 0258           ;       LCD_1_PrCString("Modules!");
 0258 10                push X
 0259 5000              mov A,>L46
 025B 08                push A
 025C 5000              mov A,<L46
 025E 5C                mov X,A
 025F 18                pop A
 0260 7C0000            xcall _LCD_1_PrCString
 0263                   .dbline 235
 0263           ;       
 0263           ;       RX_TIMEOUT_Stop();
 0263 7C0000            xcall _RX_TIMEOUT_Stop
 0266 20                pop X
 0267                   .dbline 236
 0267           ;       TIMEOUT = 0;
 0267 62D000            mov REG[0xd0],>_TIMEOUT
 026A 550100            mov [_TIMEOUT+1],0
 026D 550000            mov [_TIMEOUT],0
 0270                   .dbline 237
 0270           ;       RX_TIMEOUT_Start();
 0270 10                push X
 0271 7C0000            xcall _RX_TIMEOUT_Start
 0274 20                pop X
 0275                   .dbline 239
 0275           ;       
 0275           ;       return success;
 0275 62D000            mov REG[0xd0],>__r0
 0278 5201              mov A,[X+1]
 027A 5300              mov [__r1],A
 027C 5200              mov A,[X+0]
 027E 5300              mov [__r0],A
 0280                   .dbline -2
 0280           L28:
 0280 38FE              add SP,-2
 0282 20                pop X
 0283                   .dbline 0 ; func end
 0283 7F                ret
 0284                   .dbsym l success 0 I
 0284                   .dbsym l assigned_ID -5 I
 0284                   .dbend
 0284                   .dbfunc e clearConfig _clearConfig fI
 0284           ;       response -> X+0
 0284           ;      module_id -> X-5
 0284           _clearConfig::
 0284                   .dbline -1
 0284 10                push X
 0285 4F                mov X,SP
 0286 3802              add SP,2
 0288                   .dbline 243
 0288           ; }
 0288           ; 
 0288           ; int clearConfig(int module_id)
 0288           ; {
 0288                   .dbline 244
 0288           ;       int response = 0;
 0288 560100            mov [X+1],0
 028B 560000            mov [X+0],0
 028E                   .dbline 246
 028E           ;       
 028E           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 028E 5000              mov A,0
 0290 08                push A
 0291 08                push A
 0292 941A              xcall _configToggle
 0294 38FE              add SP,-2
 0296                   .dbline 249
 0296           ;                       
 0296           ;       // Transmit a hello.
 0296           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0296 10                push X
 0297 50FC              mov A,-4
 0299 7C0000            xcall _TRANSMIT_PutChar
 029C 20                pop X
 029D                   .dbline 250
 029D           ;       TRANSMIT_PutChar(START_TRANSMIT);
 029D 10                push X
 029E 50FC              mov A,-4
 02A0 7C0000            xcall _TRANSMIT_PutChar
 02A3 20                pop X
 02A4                   .dbline 251
 02A4           ;       TRANSMIT_PutChar(MASTER_ID);
 02A4 10                push X
 02A5 5000              mov A,0
 02A7 7C0000            xcall _TRANSMIT_PutChar
 02AA 20                pop X
 02AB                   .dbline 252
 02AB           ;       TRANSMIT_PutChar(module_id);
 02AB 62D000            mov REG[0xd0],>__r0
 02AE 52FC              mov A,[X-4]
 02B0 10                push X
 02B1 7C0000            xcall _TRANSMIT_PutChar
 02B4 20                pop X
 02B5                   .dbline 253
 02B5           ;       TRANSMIT_PutChar(CLEAR_CONFIG);
 02B5 10                push X
 02B6 50CC              mov A,-52
 02B8 7C0000            xcall _TRANSMIT_PutChar
 02BB 20                pop X
 02BC                   .dbline 254
 02BC           ;       TRANSMIT_PutChar(END_TRANSMIT);
 02BC 10                push X
 02BD 50FD              mov A,-3
 02BF 7C0000            xcall _TRANSMIT_PutChar
 02C2 20                pop X
 02C3                   .dbline 255
 02C3           ;       TRANSMIT_PutChar(END_TRANSMIT);
 02C3 10                push X
 02C4 50FD              mov A,-3
 02C6 7C0000            xcall _TRANSMIT_PutChar
 02C9 20                pop X
 02CA           L48:
 02CA                   .dbline 258
 02CA           ;       
 02CA           ;       // Wait for the transmission to finish.
 02CA           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 02CA           L49:
 02CA                   .dbline 258
 02CA 10                push X
 02CB 7C0000            xcall _TRANSMIT_bReadTxStatus
 02CE 62D000            mov REG[0xd0],>__r0
 02D1 20                pop X
 02D2 5300              mov [__r0],A
 02D4 470020            tst [__r0],32
 02D7 AFF2              jz L48
 02D9                   .dbline 260
 02D9           ;       
 02D9           ;       xmitWait();
 02D9 9627              xcall _xmitWait
 02DB                   .dbline 262
 02DB           ;       
 02DB           ;       configToggle(RX_MODE);  // Listen for the response.
 02DB 5000              mov A,0
 02DD 08                push A
 02DE 5001              mov A,1
 02E0 08                push A
 02E1 93CB              xcall _configToggle
 02E3 38FE              add SP,-2
 02E5                   .dbline 264
 02E5           ;       
 02E5           ;       if(module_id != BROADCAST)
 02E5 3DFB00            cmp [X-5],0
 02E8 B006              jnz X10
 02EA 3DFCFE            cmp [X-4],-2
 02ED A089              jz L51
 02EF           X10:
 02EF                   .dbline 265
 02EF           ;       {
 02EF                   .dbline 266
 02EF           ;               RX_TIMEOUT_Stop();
 02EF 10                push X
 02F0 7C0000            xcall _RX_TIMEOUT_Stop
 02F3 20                pop X
 02F4                   .dbline 267
 02F4           ;               TIMEOUT = 0;
 02F4 62D000            mov REG[0xd0],>_TIMEOUT
 02F7 550100            mov [_TIMEOUT+1],0
 02FA 550000            mov [_TIMEOUT],0
 02FD                   .dbline 268
 02FD           ;               RX_TIMEOUT_Start();
 02FD 10                push X
 02FE 7C0000            xcall _RX_TIMEOUT_Start
 0301 20                pop X
 0302 8048              xjmp L54
 0304           L53:
 0304                   .dbline 271
 0304           ;               
 0304           ;               while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 0304           ;               {
 0304                   .dbline 272
 0304           ;                       if(RECEIVE_cReadChar() == START_TRANSMIT)
 0304 10                push X
 0305 7C0000            xcall _RECEIVE_cReadChar
 0308 62D000            mov REG[0xd0],>__r0
 030B 20                pop X
 030C 39FC              cmp A,-4
 030E B03C              jnz L56
 0310                   .dbline 273
 0310           ;                       {       
 0310                   .dbline 274
 0310           ;                               if(validTransmission())
 0310 90C9              xcall _validTransmission
 0312 62D000            mov REG[0xd0],>__r0
 0315 3C0000            cmp [__r0],0
 0318 B006              jnz X11
 031A 3C0000            cmp [__r1],0
 031D A02D              jz L58
 031F           X11:
 031F                   .dbline 275
 031F           ;                               {
 031F                   .dbline 276
 031F           ;                                       if(COMMAND_TYPE == CONFIG_CLEARED)      // This is the response we are looking for.
 031F 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0322 3C00CD            cmp [_COMMAND_TYPE],-51
 0325 B025              jnz L60
 0327                   .dbline 277
 0327           ;                                       {
 0327                   .dbline 279
 0327           ;                                               // If this is for me, check who it was from.
 0327           ;                                               if(COMMAND_DESTINATION == MASTER_ID)
 0327 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 032A 3C0000            cmp [_COMMAND_DESTINATION],0
 032D B01D              jnz L62
 032F                   .dbline 280
 032F           ;                                               {
 032F                   .dbline 281
 032F           ;                                                       if(COMMAND_SOURCE == module_id)
 032F 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0332 5100              mov A,[_COMMAND_SOURCE]
 0334 62D000            mov REG[0xd0],>__r0
 0337 5300              mov [__r1],A
 0339 5000              mov A,0
 033B 3BFB              cmp A,[X-5]
 033D B00D              jnz L64
 033F 5100              mov A,[__r1]
 0341 3BFC              cmp A,[X-4]
 0343 B007              jnz L64
 0345           X12:
 0345                   .dbline 282
 0345           ;                                                       {
 0345                   .dbline 283
 0345           ;                                                               response = 1;
 0345 560101            mov [X+1],1
 0348 560000            mov [X+0],0
 034B                   .dbline 284
 034B           ;                                                       }
 034B           L64:
 034B                   .dbline 285
 034B           ;                                               }
 034B           L62:
 034B                   .dbline 286
 034B           ;                                       }
 034B           L60:
 034B                   .dbline 287
 034B           ;                               }
 034B           L58:
 034B                   .dbline 288
 034B           ;                       }
 034B           L56:
 034B                   .dbline 289
 034B           ;               }
 034B           L54:
 034B                   .dbline 270
 034B 62D000            mov REG[0xd0],>_TIMEOUT
 034E 5101              mov A,[_TIMEOUT+1]
 0350 1105              sub A,5
 0352 5100              mov A,[_TIMEOUT]
 0354 3180              xor A,-128
 0356 1980              sbb A,(0 ^ 0x80)
 0358 D00B              jnc L66
 035A           X13:
 035A 3D0000            cmp [X+0],0
 035D B006              jnz X14
 035F 3D0100            cmp [X+1],0
 0362 AFA1              jz L53
 0364           X14:
 0364           L66:
 0364                   .dbline 291
 0364           ;               
 0364           ;               RX_TIMEOUT_Stop();
 0364 10                push X
 0365 7C0000            xcall _RX_TIMEOUT_Stop
 0368 20                pop X
 0369                   .dbline 292
 0369           ;               TIMEOUT = 0;
 0369 62D000            mov REG[0xd0],>_TIMEOUT
 036C 550100            mov [_TIMEOUT+1],0
 036F 550000            mov [_TIMEOUT],0
 0372                   .dbline 293
 0372           ;               RX_TIMEOUT_Start();
 0372 10                push X
 0373 7C0000            xcall _RX_TIMEOUT_Start
 0376 20                pop X
 0377                   .dbline 294
 0377           ;       }
 0377           L51:
 0377                   .dbline 296
 0377           ;       
 0377           ;       return response;
 0377 62D000            mov REG[0xd0],>__r0
 037A 5201              mov A,[X+1]
 037C 5300              mov [__r1],A
 037E 5200              mov A,[X+0]
 0380 5300              mov [__r0],A
 0382                   .dbline -2
 0382           L47:
 0382 38FE              add SP,-2
 0384 20                pop X
 0385                   .dbline 0 ; func end
 0385 7F                ret
 0386                   .dbsym l response 0 I
 0386                   .dbsym l module_id -5 I
 0386                   .dbend
 0386                   .dbfunc e sayHello _sayHello fV
 0386           _sayHello::
 0386                   .dbline -1
 0386                   .dbline 301
 0386           ; }
 0386           ; 
 0386           ; // This function transmits a hello message.
 0386           ; void sayHello(void)
 0386           ; {
 0386                   .dbline 302
 0386           ;       configToggle(TX_MODE);                          // Toggle into TX mode.
 0386 5000              mov A,0
 0388 08                push A
 0389 08                push A
 038A 9322              xcall _configToggle
 038C 38FE              add SP,-2
 038E                   .dbline 305
 038E           ;                       
 038E           ;       // Transmit a hello.
 038E           ;       TRANSMIT_PutChar(START_TRANSMIT);
 038E 10                push X
 038F 50FC              mov A,-4
 0391 7C0000            xcall _TRANSMIT_PutChar
 0394 20                pop X
 0395                   .dbline 306
 0395           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0395 10                push X
 0396 50FC              mov A,-4
 0398 7C0000            xcall _TRANSMIT_PutChar
 039B 20                pop X
 039C                   .dbline 307
 039C           ;       TRANSMIT_PutChar(MASTER_ID);
 039C 10                push X
 039D 5000              mov A,0
 039F 7C0000            xcall _TRANSMIT_PutChar
 03A2 20                pop X
 03A3                   .dbline 308
 03A3           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 03A3 10                push X
 03A4 50FB              mov A,-5
 03A6 7C0000            xcall _TRANSMIT_PutChar
 03A9 20                pop X
 03AA                   .dbline 309
 03AA           ;       TRANSMIT_PutChar(HELLO_BYTE);
 03AA 10                push X
 03AB 50C8              mov A,-56
 03AD 7C0000            xcall _TRANSMIT_PutChar
 03B0 20                pop X
 03B1                   .dbline 310
 03B1           ;       TRANSMIT_PutChar(END_TRANSMIT);
 03B1 10                push X
 03B2 50FD              mov A,-3
 03B4 7C0000            xcall _TRANSMIT_PutChar
 03B7 20                pop X
 03B8                   .dbline 311
 03B8           ;       TRANSMIT_PutChar(END_TRANSMIT);
 03B8 10                push X
 03B9 50FD              mov A,-3
 03BB 7C0000            xcall _TRANSMIT_PutChar
 03BE 20                pop X
 03BF           L68:
 03BF                   .dbline 314
 03BF           ;       
 03BF           ;       // Wait for the transmission to finish.
 03BF           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 03BF           L69:
 03BF                   .dbline 314
 03BF 10                push X
 03C0 7C0000            xcall _TRANSMIT_bReadTxStatus
 03C3 62D000            mov REG[0xd0],>__r0
 03C6 20                pop X
 03C7 5300              mov [__r0],A
 03C9 470020            tst [__r0],32
 03CC AFF2              jz L68
 03CE                   .dbline 316
 03CE           ;       
 03CE           ;       xmitWait();
 03CE 9532              xcall _xmitWait
 03D0                   .dbline 318
 03D0           ;       
 03D0           ;       configToggle(RX_MODE);                          // Listen for the response.
 03D0 5000              mov A,0
 03D2 08                push A
 03D3 5001              mov A,1
 03D5 08                push A
 03D6 92D6              xcall _configToggle
 03D8 38FE              add SP,-2
 03DA                   .dbline -2
 03DA           L67:
 03DA                   .dbline 0 ; func end
 03DA 7F                ret
 03DB                   .dbend
 03DB                   .dbfunc e validTransmission _validTransmission fI
 03DB           ; valid_transmit -> X+0
 03DB           _validTransmission::
 03DB                   .dbline -1
 03DB 10                push X
 03DC 4F                mov X,SP
 03DD 3802              add SP,2
 03DF                   .dbline 323
 03DF           ; }
 03DF           ; 
 03DF           ; // This function returns whether or not a valid transmission has been received.
 03DF           ; int validTransmission(void)
 03DF           ; {
 03DF                   .dbline 324
 03DF           ;       int valid_transmit = 0;
 03DF 560100            mov [X+1],0
 03E2 560000            mov [X+0],0
 03E5                   .dbline 326
 03E5           ;       
 03E5           ;       if(RECEIVE_cGetChar() == START_TRANSMIT)
 03E5 10                push X
 03E6 7C0000            xcall _RECEIVE_cGetChar
 03E9 62D000            mov REG[0xd0],>__r0
 03EC 20                pop X
 03ED 39FC              cmp A,-4
 03EF B02F              jnz L72
 03F1                   .dbline 327
 03F1           ;       {
 03F1                   .dbline 328
 03F1           ;               COMMAND_SOURCE = RECEIVE_cGetChar();
 03F1 10                push X
 03F2 7C0000            xcall _RECEIVE_cGetChar
 03F5 20                pop X
 03F6 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 03F9 5300              mov [_COMMAND_SOURCE],A
 03FB                   .dbline 329
 03FB           ;               COMMAND_DESTINATION = RECEIVE_cGetChar();
 03FB 10                push X
 03FC 7C0000            xcall _RECEIVE_cGetChar
 03FF 20                pop X
 0400 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0403 5300              mov [_COMMAND_DESTINATION],A
 0405                   .dbline 330
 0405           ;               COMMAND_TYPE = RECEIVE_cGetChar();
 0405 10                push X
 0406 7C0000            xcall _RECEIVE_cGetChar
 0409 20                pop X
 040A 62D000            mov REG[0xd0],>_COMMAND_TYPE
 040D 5300              mov [_COMMAND_TYPE],A
 040F                   .dbline 331
 040F           ;               PARAM1 = RECEIVE_cGetChar();
 040F 10                push X
 0410 7C0000            xcall _RECEIVE_cGetChar
 0413 20                pop X
 0414 62D000            mov REG[0xd0],>_PARAM1
 0417 5300              mov [_PARAM1],A
 0419                   .dbline 333
 0419           ;               
 0419           ;               valid_transmit = 1;
 0419 560101            mov [X+1],1
 041C 560000            mov [X+0],0
 041F                   .dbline 334
 041F           ;       }
 041F           L72:
 041F                   .dbline 336
 041F           ;       
 041F           ;       return valid_transmit;
 041F 62D000            mov REG[0xd0],>__r0
 0422 5201              mov A,[X+1]
 0424 5300              mov [__r1],A
 0426 5200              mov A,[X+0]
 0428 5300              mov [__r0],A
 042A                   .dbline -2
 042A           L71:
 042A 38FE              add SP,-2
 042C 20                pop X
 042D                   .dbline 0 ; func end
 042D 7F                ret
 042E                   .dbsym l valid_transmit 0 I
 042E                   .dbend
 042E                   .dbfunc e decodeTransmission _decodeTransmission fV
 042E           ;       tempByte -> X+7
 042E           ;          angle -> X+5
 042E           ;             ID -> X+4
 042E           ;          total -> X+2
 042E           ;          param -> X+0
 042E           _decodeTransmission::
 042E                   .dbline -1
 042E 10                push X
 042F 4F                mov X,SP
 0430 3808              add SP,8
 0432                   .dbline 341
 0432           ; }
 0432           ; 
 0432           ; // This function decodes the transmission and takes the correct action.
 0432           ; void decodeTransmission(void)
 0432           ; {
 0432                   .dbline 346
 0432           ;       char* param;
 0432           ;       char ID;
 0432           ;       char tempByte;
 0432           ;       char angle[2];
 0432           ;       int total = 0;
 0432 560300            mov [X+3],0
 0435 560200            mov [X+2],0
 0438                   .dbline 348
 0438           ;       
 0438           ;       if(param = COMP_SERIAL_szGetParam())
 0438 10                push X
 0439 7C0000            xcall _COMP_SERIAL_szGetParam
 043C 62D000            mov REG[0xd0],>__r0
 043F 5300              mov [__r0],A
 0441 5A00              mov [__r1],X
 0443 20                pop X
 0444 5100              mov A,[__r1]
 0446 5401              mov [X+1],A
 0448 5100              mov A,[__r0]
 044A 5400              mov [X+0],A
 044C 3C0000            cmp [__r0],0
 044F B006              jnz X15
 0451 3C0000            cmp [__r1],0
 0454 A1AB              jz L75
 0456           X15:
 0456                   .dbline 349
 0456           ;       {
 0456                   .dbline 350
 0456           ;               if((param[0] == 'w') || (param[0] == 'W'))
 0456 62D000            mov REG[0xd0],>__r0
 0459 5201              mov A,[X+1]
 045B 5300              mov [__r1],A
 045D 5200              mov A,[X+0]
 045F 60D4              mov REG[0xd4],A
 0461 3E00              mvi A,[__r1]
 0463 5300              mov [__r1],A
 0465 550000            mov [__r0],0
 0468 3C0000            cmp [__r0],0
 046B B005              jnz X16
 046D 3977              cmp A,119
 046F A00E              jz L79
 0471           X16:
 0471 62D000            mov REG[0xd0],>__r0
 0474 3C0000            cmp [__r0],0
 0477 B026              jnz L77
 0479 3C0057            cmp [__r1],87
 047C B021              jnz L77
 047E           X17:
 047E           L79:
 047E                   .dbline 351
 047E           ;               {
 047E                   .dbline 352
 047E           ;                       if(param = COMP_SERIAL_szGetParam())
 047E 10                push X
 047F 7C0000            xcall _COMP_SERIAL_szGetParam
 0482 62D000            mov REG[0xd0],>__r0
 0485 5300              mov [__r0],A
 0487 5A00              mov [__r1],X
 0489 20                pop X
 048A 5100              mov A,[__r1]
 048C 5401              mov [X+1],A
 048E 5100              mov A,[__r0]
 0490 5400              mov [X+0],A
 0492 3C0000            cmp [__r0],0
 0495 B006              jnz X18
 0497 3C0000            cmp [__r1],0
 049A A165              jz L78
 049C           X18:
 049C                   .dbline 353
 049C           ;                       {
 049C                   .dbline 355
 049C           ;                               
 049C           ;                       }
 049C                   .dbline 356
 049C           ;               }
 049C 8163              xjmp L78
 049E           L77:
 049E                   .dbline 357
 049E           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 049E 62D000            mov REG[0xd0],>__r0
 04A1 5201              mov A,[X+1]
 04A3 5300              mov [__r1],A
 04A5 5200              mov A,[X+0]
 04A7 60D4              mov REG[0xd4],A
 04A9 3E00              mvi A,[__r1]
 04AB 5300              mov [__r1],A
 04AD 550000            mov [__r0],0
 04B0 3C0000            cmp [__r0],0
 04B3 B005              jnz X19
 04B5 3972              cmp A,114
 04B7 A00E              jz L84
 04B9           X19:
 04B9 62D000            mov REG[0xd0],>__r0
 04BC 3C0000            cmp [__r0],0
 04BF B140              jnz L82
 04C1 3C0052            cmp [__r1],82
 04C4 B13B              jnz L82
 04C6           X20:
 04C6           L84:
 04C6                   .dbline 358
 04C6           ;               {                       
 04C6                   .dbline 359
 04C6           ;                       if(param = COMP_SERIAL_szGetParam())
 04C6 10                push X
 04C7 7C0000            xcall _COMP_SERIAL_szGetParam
 04CA 62D000            mov REG[0xd0],>__r0
 04CD 5300              mov [__r0],A
 04CF 5A00              mov [__r1],X
 04D1 20                pop X
 04D2 5100              mov A,[__r1]
 04D4 5401              mov [X+1],A
 04D6 5100              mov A,[__r0]
 04D8 5400              mov [X+0],A
 04DA 3C0000            cmp [__r0],0
 04DD B006              jnz X21
 04DF 3C0000            cmp [__r1],0
 04E2 A11D              jz L85
 04E4           X21:
 04E4                   .dbline 360
 04E4           ;                       {
 04E4                   .dbline 361
 04E4           ;                               ID = atoi(param);
 04E4 5200              mov A,[X+0]
 04E6 08                push A
 04E7 5201              mov A,[X+1]
 04E9 08                push A
 04EA 7C0000            xcall _atoi
 04ED 38FE              add SP,-2
 04EF 62D000            mov REG[0xd0],>__r0
 04F2 5100              mov A,[__r1]
 04F4 5404              mov [X+4],A
 04F6                   .dbline 362
 04F6           ;                               if(param = COMP_SERIAL_szGetParam())
 04F6 10                push X
 04F7 7C0000            xcall _COMP_SERIAL_szGetParam
 04FA 62D000            mov REG[0xd0],>__r0
 04FD 5300              mov [__r0],A
 04FF 5A00              mov [__r1],X
 0501 20                pop X
 0502 5100              mov A,[__r1]
 0504 5401              mov [X+1],A
 0506 5100              mov A,[__r0]
 0508 5400              mov [X+0],A
 050A 3C0000            cmp [__r0],0
 050D B006              jnz X22
 050F 3C0000            cmp [__r1],0
 0512 A0ED              jz L87
 0514           X22:
 0514                   .dbline 363
 0514           ;                               {
 0514                   .dbline 364
 0514           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 0514 62D000            mov REG[0xd0],>__r0
 0517 5201              mov A,[X+1]
 0519 5300              mov [__r1],A
 051B 5200              mov A,[X+0]
 051D 60D4              mov REG[0xd4],A
 051F 3E00              mvi A,[__r1]
 0521 5300              mov [__r1],A
 0523 550000            mov [__r0],0
 0526 3C0000            cmp [__r0],0
 0529 B005              jnz X23
 052B 3961              cmp A,97
 052D A00E              jz L91
 052F           X23:
 052F 62D000            mov REG[0xd0],>__r0
 0532 3C0000            cmp [__r0],0
 0535 B0CA              jnz L89
 0537 3C0041            cmp [__r1],65
 053A B0C5              jnz L89
 053C           X24:
 053C           L91:
 053C                   .dbline 365
 053C           ;                                       {
 053C                   .dbline 366
 053C           ;                                               COMP_SERIAL_CmdReset();
 053C 10                push X
 053D 7C0000            xcall _COMP_SERIAL_CmdReset
 0540 20                pop X
 0541                   .dbline 367
 0541           ;                                               servoInstruction(ID,4,2,36,2);
 0541 5002              mov A,2
 0543 08                push A
 0544 5024              mov A,36
 0546 08                push A
 0547 5002              mov A,2
 0549 08                push A
 054A 5004              mov A,4
 054C 08                push A
 054D 5204              mov A,[X+4]
 054F 08                push A
 0550 90D4              xcall _servoInstruction
 0552                   .dbline 368
 0552           ;                                               configToggle(RX_MODE);
 0552 5000              mov A,0
 0554 08                push A
 0555 5001              mov A,1
 0557 08                push A
 0558 9154              xcall _configToggle
 055A 38F9              add SP,-7
 055C 8094              xjmp L93
 055E           L92:
 055E                   .dbline 372
 055E           ;                                                       
 055E           ;                                               // Loop until we read a response or time out.
 055E           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 055E           ;                                               {
 055E                   .dbline 373
 055E           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 055E 10                push X
 055F 7C0000            xcall _RECEIVE_cReadChar
 0562 62D000            mov REG[0xd0],>__r0
 0565 20                pop X
 0566 39FF              cmp A,-1
 0568 B088              jnz L95
 056A                   .dbline 374
 056A           ;                                                       {
 056A                   .dbline 375
 056A           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 056A 10                push X
 056B 7C0000            xcall _RECEIVE_cGetChar
 056E 62D000            mov REG[0xd0],>__r0
 0571 20                pop X
 0572 39FF              cmp A,-1
 0574 B07C              jnz L97
 0576                   .dbline 376
 0576           ;                                                               {
 0576                   .dbline 377
 0576           ;                                                                       if(RECEIVE_cGetChar() == ID)
 0576 10                push X
 0577 7C0000            xcall _RECEIVE_cGetChar
 057A 62D000            mov REG[0xd0],>__r0
 057D 20                pop X
 057E 3B04              cmp A,[X+4]
 0580 B070              jnz L99
 0582                   .dbline 378
 0582           ;                                                                       {
 0582                   .dbline 379
 0582           ;                                                                               if(RECEIVE_cGetChar() == 4)
 0582 10                push X
 0583 7C0000            xcall _RECEIVE_cGetChar
 0586 62D000            mov REG[0xd0],>__r0
 0589 20                pop X
 058A 3904              cmp A,4
 058C B064              jnz L101
 058E                   .dbline 380
 058E           ;                                                                               {
 058E                   .dbline 381
 058E           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 058E 10                push X
 058F 7C0000            xcall _RECEIVE_cGetChar
 0592 62D000            mov REG[0xd0],>__r0
 0595 20                pop X
 0596 3900              cmp A,0
 0598 B058              jnz L103
 059A                   .dbline 382
 059A           ;                                                                                       {
 059A                   .dbline 383
 059A           ;                                                                                               angle[0] = RECEIVE_cGetChar();
 059A 10                push X
 059B 7C0000            xcall _RECEIVE_cGetChar
 059E 62D000            mov REG[0xd0],>__r0
 05A1 20                pop X
 05A2 5405              mov [X+5],A
 05A4                   .dbline 384
 05A4           ;                                                                                               angle[1] = RECEIVE_cGetChar();
 05A4 10                push X
 05A5 7C0000            xcall _RECEIVE_cGetChar
 05A8 62D000            mov REG[0xd0],>__r0
 05AB 20                pop X
 05AC 5406              mov [X+6],A
 05AE                   .dbline 386
 05AE           ;                                                                                               
 05AE           ;                                                                                               configToggle(PC_MODE);
 05AE 5000              mov A,0
 05B0 08                push A
 05B1 5002              mov A,2
 05B3 08                push A
 05B4 90F8              xcall _configToggle
 05B6                   .dbline 388
 05B6           ;                                                                                               
 05B6           ;                                                                                               total = ((angle[1])*256) + angle[0];
 05B6 5205              mov A,[X+5]
 05B8 5403              mov [X+3],A
 05BA 5206              mov A,[X+6]
 05BC 5402              mov [X+2],A
 05BE                   .dbline 389
 05BE           ;                                                                                               itoa(param,total,10);
 05BE 5000              mov A,0
 05C0 08                push A
 05C1 500A              mov A,10
 05C3 08                push A
 05C4 5202              mov A,[X+2]
 05C6 08                push A
 05C7 5203              mov A,[X+3]
 05C9 08                push A
 05CA 5200              mov A,[X+0]
 05CC 08                push A
 05CD 5201              mov A,[X+1]
 05CF 08                push A
 05D0 7C0000            xcall _itoa
 05D3 38F8              add SP,-8
 05D5                   .dbline 390
 05D5           ;                                                                                               COMP_SERIAL_PutString(param);
 05D5 10                push X
 05D6 5200              mov A,[X+0]
 05D8 08                push A
 05D9 5201              mov A,[X+1]
 05DB 5C                mov X,A
 05DC 18                pop A
 05DD 7C0000            xcall _COMP_SERIAL_PutString
 05E0 20                pop X
 05E1                   .dbline 391
 05E1           ;                                                                                               COMP_SERIAL_PutChar('\n');
 05E1 10                push X
 05E2 500A              mov A,10
 05E4 7C0000            xcall _COMP_SERIAL_PutChar
 05E7 20                pop X
 05E8                   .dbline 393
 05E8           ; 
 05E8           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 05E8 62D000            mov REG[0xd0],>_TIMEOUT
 05EB 550105            mov [_TIMEOUT+1],5
 05EE 550000            mov [_TIMEOUT],0
 05F1                   .dbline 394
 05F1           ;                                                                                       }
 05F1           L103:
 05F1                   .dbline 395
 05F1           ;                                                                               }
 05F1           L101:
 05F1                   .dbline 396
 05F1           ;                                                                       }
 05F1           L99:
 05F1                   .dbline 397
 05F1           ;                                                               }
 05F1           L97:
 05F1                   .dbline 398
 05F1           ;                                                       }
 05F1           L95:
 05F1                   .dbline 399
 05F1           ;                                               }
 05F1           L93:
 05F1                   .dbline 371
 05F1 62D000            mov REG[0xd0],>_TIMEOUT
 05F4 5101              mov A,[_TIMEOUT+1]
 05F6 1105              sub A,5
 05F8 5100              mov A,[_TIMEOUT]
 05FA 3180              xor A,-128
 05FC 1980              sbb A,(0 ^ 0x80)
 05FE CF5F              jc L92
 0600           X25:
 0600                   .dbline 400
 0600           ;                                       }
 0600           L89:
 0600                   .dbline 401
 0600           ;                               }
 0600           L87:
 0600                   .dbline 402
 0600           ;                       }
 0600           L85:
 0600                   .dbline 403
 0600           ;               }
 0600           L82:
 0600           L78:
 0600                   .dbline 404
 0600           ;       }
 0600           L75:
 0600                   .dbline 406
 0600           ;       
 0600           ;       if(STATE != PC_MODE)
 0600 62D000            mov REG[0xd0],>_STATE
 0603 3C0000            cmp [_STATE],0
 0606 B006              jnz X26
 0608 3C0102            cmp [_STATE+1],2
 060B A00D              jz L107
 060D           X26:
 060D                   .dbline 407
 060D           ;       {
 060D                   .dbline 408
 060D           ;               configToggle(PC_MODE);
 060D 5000              mov A,0
 060F 08                push A
 0610 5002              mov A,2
 0612 08                push A
 0613 9099              xcall _configToggle
 0615 38FE              add SP,-2
 0617                   .dbline 409
 0617           ;       }
 0617 800A              xjmp L108
 0619           L107:
 0619                   .dbline 411
 0619           ;       else
 0619           ;       {
 0619                   .dbline 412
 0619           ;               TIMEOUT = 0;
 0619 62D000            mov REG[0xd0],>_TIMEOUT
 061C 550100            mov [_TIMEOUT+1],0
 061F 550000            mov [_TIMEOUT],0
 0622                   .dbline 413
 0622           ;       }
 0622           L108:
 0622                   .dbline -2
 0622           L74:
 0622 38F8              add SP,-8
 0624 20                pop X
 0625                   .dbline 0 ; func end
 0625 7F                ret
 0626                   .dbsym l tempByte 7 c
 0626                   .dbsym l angle 5 A[2:2]c
 0626                   .dbsym l ID 4 c
 0626                   .dbsym l total 2 I
 0626                   .dbsym l param 0 pc
 0626                   .dbend
 0626                   .dbfunc e servoInstruction _servoInstruction fV
 0626           ;       checksum -> X+0
 0626           ;          value -> X-8
 0626           ;        address -> X-7
 0626           ;    instruction -> X-6
 0626           ;         length -> X-5
 0626           ;             id -> X-4
 0626           _servoInstruction::
 0626                   .dbline -1
 0626 10                push X
 0627 4F                mov X,SP
 0628 3801              add SP,1
 062A                   .dbline 419
 062A           ; }
 062A           ; 
 062A           ; // This function receives a destination, command length, instruction type, address, and value.
 062A           ; // With these parameters, the function sends a packet to the communication bus.
 062A           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 062A           ; {
 062A                   .dbline 423
 062A           ;       char checksum;
 062A           ;       
 062A           ;       // Calculate the checksum value for our servo communication.
 062A           ;       checksum = 255-((id + length + instruction + address + value)%256);
 062A 62D000            mov REG[0xd0],>__r0
 062D 52FB              mov A,[X-5]
 062F 5300              mov [__r1],A
 0631 550000            mov [__r0],0
 0634 52FC              mov A,[X-4]
 0636 0200              add A,[__r1]
 0638 5300              mov [__r1],A
 063A 5000              mov A,0
 063C 0A00              adc A,[__r0]
 063E 5300              mov [__r0],A
 0640 52FA              mov A,[X-6]
 0642 0400              add [__r1],A
 0644 0E0000            adc [__r0],0
 0647 52F9              mov A,[X-7]
 0649 0400              add [__r1],A
 064B 0E0000            adc [__r0],0
 064E 52F8              mov A,[X-8]
 0650 0400              add [__r1],A
 0652 0E0000            adc [__r0],0
 0655 5001              mov A,1
 0657 08                push A
 0658 5000              mov A,0
 065A 08                push A
 065B 5100              mov A,[__r0]
 065D 08                push A
 065E 5100              mov A,[__r1]
 0660 08                push A
 0661 7C0000            xcall __divmod_16X16_16
 0664 38FE              add SP,-2
 0666 18                pop A
 0667 5300              mov [__r1],A
 0669 18                pop A
 066A 50FF              mov A,-1
 066C 1200              sub A,[__r1]
 066E 5400              mov [X+0],A
 0670                   .dbline 426
 0670           ;       
 0670           ;       // Talk to the servo.
 0670           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0670 10                push X
 0671 50FF              mov A,-1
 0673 7C0000            xcall _TX_REPEATER_PutChar
 0676 20                pop X
 0677                   .dbline 427
 0677           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 0677 10                push X
 0678 50FF              mov A,-1
 067A 7C0000            xcall _TX_REPEATER_PutChar
 067D 20                pop X
 067E                   .dbline 428
 067E           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 067E 10                push X
 067F 52FC              mov A,[X-4]
 0681 7C0000            xcall _TX_REPEATER_PutChar
 0684 20                pop X
 0685                   .dbline 429
 0685           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 0685 10                push X
 0686 52FB              mov A,[X-5]
 0688 7C0000            xcall _TX_REPEATER_PutChar
 068B 20                pop X
 068C                   .dbline 430
 068C           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 068C 10                push X
 068D 52FA              mov A,[X-6]
 068F 7C0000            xcall _TX_REPEATER_PutChar
 0692 20                pop X
 0693                   .dbline 431
 0693           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 0693 10                push X
 0694 52F9              mov A,[X-7]
 0696 7C0000            xcall _TX_REPEATER_PutChar
 0699 20                pop X
 069A                   .dbline 432
 069A           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 069A 10                push X
 069B 52F8              mov A,[X-8]
 069D 7C0000            xcall _TX_REPEATER_PutChar
 06A0 20                pop X
 06A1                   .dbline 433
 06A1           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 06A1 10                push X
 06A2 5200              mov A,[X+0]
 06A4 7C0000            xcall _TX_REPEATER_PutChar
 06A7 20                pop X
 06A8                   .dbline 439
 06A8           ;       
 06A8           ;       // Wait for the transmission to finish.
 06A8           ;       //while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 06A8           ;       
 06A8           ;       // Make completely sure we're done.
 06A8           ;       xmitWait();
 06A8 9258              xcall _xmitWait
 06AA                   .dbline -2
 06AA           L109:
 06AA 38FF              add SP,-1
 06AC 20                pop X
 06AD                   .dbline 0 ; func end
 06AD 7F                ret
 06AE                   .dbsym l checksum 0 c
 06AE                   .dbsym l value -8 c
 06AE                   .dbsym l address -7 c
 06AE                   .dbsym l instruction -6 c
 06AE                   .dbsym l length -5 c
 06AE                   .dbsym l id -4 c
 06AE                   .dbend
 06AE                   .dbfunc e configToggle _configToggle fV
 06AE           ;           mode -> X-5
 06AE           _configToggle::
 06AE                   .dbline -1
 06AE 10                push X
 06AF 4F                mov X,SP
 06B0                   .dbline 445
 06B0           ; }
 06B0           ; 
 06B0           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 06B0           ; // half duplex UART serial communication line.
 06B0           ; void configToggle(int mode)
 06B0           ; {
 06B0                   .dbline 447
 06B0           ;       // Disconnect from the global bus and leave the pin high.
 06B0           ;       PRT0DR |= 0b10000000;
 06B0 430080            or REG[0],-128
 06B3                   .dbline 448
 06B3           ;       PRT0GS &= 0b01111111;
 06B3 41027F            and REG[0x2],127
 06B6                   .dbline 452
 06B6           ; 
 06B6           ;       // Unload the configuration of the current state.
 06B6           ;       // If there is no state, blindly wipe all configurations.
 06B6           ;       if(STATE)
 06B6 62D000            mov REG[0xd0],>_STATE
 06B9 3C0000            cmp [_STATE],0
 06BC B006              jnz X27
 06BE 3C0100            cmp [_STATE+1],0
 06C1 A010              jz L111
 06C3           X27:
 06C3                   .dbline 453
 06C3           ;       {
 06C3                   .dbline 454
 06C3           ;               unloadConfig(STATE);
 06C3 62D000            mov REG[0xd0],>_STATE
 06C6 5100              mov A,[_STATE]
 06C8 08                push A
 06C9 5101              mov A,[_STATE+1]
 06CB 08                push A
 06CC 90D9              xcall _unloadConfig
 06CE 38FE              add SP,-2
 06D0                   .dbline 455
 06D0           ;       }
 06D0 8003              xjmp L112
 06D2           L111:
 06D2                   .dbline 457
 06D2           ;       else
 06D2           ;       {
 06D2                   .dbline 458
 06D2           ;               unloadAllConfigs();
 06D2 90C9              xcall _unloadAllConfigs
 06D4                   .dbline 459
 06D4           ;       }
 06D4           L112:
 06D4                   .dbline 461
 06D4           ;       
 06D4           ;       if(mode == PC_MODE)
 06D4 3DFB00            cmp [X-5],0
 06D7 B032              jnz L113
 06D9 3DFC02            cmp [X-4],2
 06DC B02D              jnz L113
 06DE           X28:
 06DE                   .dbline 462
 06DE           ;       {
 06DE                   .dbline 463
 06DE           ;               LoadConfig_pc_listener();
 06DE 7C0000            xcall _LoadConfig_pc_listener
 06E1                   .dbline 466
 06E1           ;               
 06E1           ;               //COMP_SERIAL_CmdReset();                                               // Initializes the RX buffer
 06E1           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 06E1 10                push X
 06E2 5001              mov A,1
 06E4 7C0000            xcall _COMP_SERIAL_IntCntl
 06E7 20                pop X
 06E8                   .dbline 467
 06E8           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 06E8 10                push X
 06E9 5000              mov A,0
 06EB 7C0000            xcall _COMP_SERIAL_Start
 06EE 20                pop X
 06EF                   .dbline 469
 06EF           ;               
 06EF           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 06EF 10                push X
 06F0 5000              mov A,0
 06F2 7C0000            xcall _TX_REPEATER_Start
 06F5 20                pop X
 06F6                   .dbline 471
 06F6           ;               
 06F6           ;               TIMEOUT = 0;
 06F6 62D000            mov REG[0xd0],>_TIMEOUT
 06F9 550100            mov [_TIMEOUT+1],0
 06FC 550000            mov [_TIMEOUT],0
 06FF                   .dbline 472
 06FF           ;               STATE = PC_MODE;
 06FF 62D000            mov REG[0xd0],>_STATE
 0702 550102            mov [_STATE+1],2
 0705 550000            mov [_STATE],0
 0708                   .dbline 473
 0708           ;       }
 0708 807A              xjmp L114
 070A           L113:
 070A                   .dbline 474
 070A           ;       else if(mode == RX_MODE)
 070A 3DFB00            cmp [X-5],0
 070D B02C              jnz L115
 070F 3DFC01            cmp [X-4],1
 0712 B027              jnz L115
 0714           X29:
 0714                   .dbline 475
 0714           ;       {
 0714                   .dbline 476
 0714           ;               LoadConfig_receiver_config();
 0714 7C0000            xcall _LoadConfig_receiver_config
 0717                   .dbline 481
 0717           ;               
 0717           ;               // Clear the buffer.
 0717           ;               //RECEIVE_CmdReset();
 0717           ;               // Start the receiver.
 0717           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0717 10                push X
 0718 5000              mov A,0
 071A 7C0000            xcall _RECEIVE_Start
 071D 20                pop X
 071E                   .dbline 484
 071E           ;               
 071E           ;               // Start response timeout timer and enable its interrupt routine.
 071E           ;               TIMEOUT = 0;
 071E 62D000            mov REG[0xd0],>_TIMEOUT
 0721 550100            mov [_TIMEOUT+1],0
 0724 550000            mov [_TIMEOUT],0
 0727                   .dbline 485
 0727           ;               RX_TIMEOUT_EnableInt();
 0727 10                push X
 0728 7C0000            xcall _RX_TIMEOUT_EnableInt
 072B                   .dbline 486
 072B           ;               RX_TIMEOUT_Start();
 072B 7C0000            xcall _RX_TIMEOUT_Start
 072E 20                pop X
 072F                   .dbline 488
 072F           ;               
 072F           ;               STATE = RX_MODE;
 072F 62D000            mov REG[0xd0],>_STATE
 0732 550101            mov [_STATE+1],1
 0735 550000            mov [_STATE],0
 0738                   .dbline 489
 0738           ;       }
 0738 804A              xjmp L116
 073A           L115:
 073A                   .dbline 490
 073A           ;       else if(mode == TX_MODE)
 073A 3DFB00            cmp [X-5],0
 073D B045              jnz L117
 073F 3DFC00            cmp [X-4],0
 0742 B040              jnz L117
 0744           X30:
 0744                   .dbline 491
 0744           ;       {
 0744                   .dbline 492
 0744           ;               LoadConfig_transmitter_config();
 0744 7C0000            xcall _LoadConfig_transmitter_config
 0747                   .dbline 494
 0747           ;               // Start the transmitter.
 0747           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 0747 10                push X
 0748 5000              mov A,0
 074A 7C0000            xcall _TRANSMIT_Start
 074D 20                pop X
 074E                   .dbline 496
 074E           ;               
 074E           ;               TIMEOUT = 0;
 074E 62D000            mov REG[0xd0],>_TIMEOUT
 0751 550100            mov [_TIMEOUT+1],0
 0754 550000            mov [_TIMEOUT],0
 0757                   .dbline 497
 0757           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 0757 10                push X
 0758 7C0000            xcall _TX_TIMEOUT_EnableInt
 075B                   .dbline 498
 075B           ;               TX_TIMEOUT_Start();             // Start the timer.
 075B 7C0000            xcall _TX_TIMEOUT_Start
 075E 20                pop X
 075F           L119:
 075F                   .dbline 501
 075F           ;               
 075F           ;               while(!TIMEOUT)
 075F           ;               {
 075F                   .dbline 504
 075F           ;                       // Do nothing while we wait for one timeout period.
 075F           ;                       // This is to allow everyone to get in the right configuration.
 075F           ;               }
 075F           L120:
 075F                   .dbline 500
 075F 62D000            mov REG[0xd0],>_TIMEOUT
 0762 3C0000            cmp [_TIMEOUT],0
 0765 B006              jnz X31
 0767 3C0100            cmp [_TIMEOUT+1],0
 076A AFF4              jz L119
 076C           X31:
 076C                   .dbline 506
 076C           ;               
 076C           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 076C 10                push X
 076D 7C0000            xcall _TX_TIMEOUT_Stop
 0770 20                pop X
 0771                   .dbline 507
 0771           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 0771 62D000            mov REG[0xd0],>_TIMEOUT
 0774 550100            mov [_TIMEOUT+1],0
 0777 550000            mov [_TIMEOUT],0
 077A                   .dbline 509
 077A           ;               
 077A           ;               STATE = TX_MODE;
 077A 62D000            mov REG[0xd0],>_STATE
 077D 550100            mov [_STATE+1],0
 0780 550000            mov [_STATE],0
 0783                   .dbline 510
 0783           ;       }
 0783           L117:
 0783           L116:
 0783           L114:
 0783                   .dbline 515
 0783           ;       
 0783           ;       // Make sure to keep the LED on (active low).
 0783           ;       //PRT2DR &= 0b11111110;
 0783           ;       
 0783           ;       if(STATE == TX_MODE)
 0783 62D000            mov REG[0xd0],>_STATE
 0786 3C0000            cmp [_STATE],0
 0789 B00B              jnz L122
 078B 3C0100            cmp [_STATE+1],0
 078E B006              jnz L122
 0790           X32:
 0790                   .dbline 516
 0790           ;       {
 0790                   .dbline 517
 0790           ;               PRT1DR |= 0b00000001;
 0790 430401            or REG[0x4],1
 0793                   .dbline 518
 0793           ;       }
 0793 8004              xjmp L123
 0795           L122:
 0795                   .dbline 520
 0795           ;       else
 0795           ;       {
 0795                   .dbline 521
 0795           ;               PRT1DR &= 0b11111110;
 0795 4104FE            and REG[0x4],-2
 0798                   .dbline 523
 0798           ;               
 0798           ;       }
 0798           L123:
 0798                   .dbline 526
 0798           ;       
 0798           ;       // Reconnect to the global bus.
 0798           ;       PRT0GS |= 0b10000000;
 0798 430280            or REG[0x2],-128
 079B                   .dbline -2
 079B           L110:
 079B 20                pop X
 079C                   .dbline 0 ; func end
 079C 7F                ret
 079D                   .dbsym l mode -5 I
 079D                   .dbend
 079D                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 079D           _unloadAllConfigs::
 079D                   .dbline -1
 079D                   .dbline 532
 079D           ; }
 079D           ; 
 079D           ; // This function blindly unloads all user configurations. This will be called once,
 079D           ; // when the system initially has no known state.
 079D           ; void unloadAllConfigs(void)
 079D           ; {
 079D                   .dbline 533
 079D           ;       UnloadConfig_pc_listener();
 079D 7C0000            xcall _UnloadConfig_pc_listener
 07A0                   .dbline 534
 07A0           ;       UnloadConfig_receiver_config();
 07A0 7C0000            xcall _UnloadConfig_receiver_config
 07A3                   .dbline 535
 07A3           ;       UnloadConfig_transmitter_config();
 07A3 7C0000            xcall _UnloadConfig_transmitter_config
 07A6                   .dbline -2
 07A6           L124:
 07A6                   .dbline 0 ; func end
 07A6 7F                ret
 07A7                   .dbend
 07A7                   .dbfunc e unloadConfig _unloadConfig fV
 07A7           ;     config_num -> X-5
 07A7           _unloadConfig::
 07A7                   .dbline -1
 07A7 10                push X
 07A8 4F                mov X,SP
 07A9                   .dbline 541
 07A9           ; }
 07A9           ; 
 07A9           ; // This function unloads the configuration corresponding to the config number passed to it.
 07A9           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 07A9           ; void unloadConfig(int config_num)
 07A9           ; {
 07A9                   .dbline 542
 07A9           ;       if(config_num == PC_MODE)
 07A9 3DFB00            cmp [X-5],0
 07AC B00B              jnz L126
 07AE 3DFC02            cmp [X-4],2
 07B1 B006              jnz L126
 07B3           X33:
 07B3                   .dbline 543
 07B3           ;       {
 07B3                   .dbline 544
 07B3           ;               UnloadConfig_pc_listener();
 07B3 7C0000            xcall _UnloadConfig_pc_listener
 07B6                   .dbline 545
 07B6           ;       }
 07B6 801D              xjmp L127
 07B8           L126:
 07B8                   .dbline 546
 07B8           ;       else if(config_num == RX_MODE)
 07B8 3DFB00            cmp [X-5],0
 07BB B00B              jnz L128
 07BD 3DFC01            cmp [X-4],1
 07C0 B006              jnz L128
 07C2           X34:
 07C2                   .dbline 547
 07C2           ;       {
 07C2                   .dbline 548
 07C2           ;               UnloadConfig_receiver_config();
 07C2 7C0000            xcall _UnloadConfig_receiver_config
 07C5                   .dbline 549
 07C5           ;       }
 07C5 800E              xjmp L129
 07C7           L128:
 07C7                   .dbline 550
 07C7           ;       else if(config_num == TX_MODE)
 07C7 3DFB00            cmp [X-5],0
 07CA B009              jnz L130
 07CC 3DFC00            cmp [X-4],0
 07CF B004              jnz L130
 07D1           X35:
 07D1                   .dbline 551
 07D1           ;       {
 07D1                   .dbline 552
 07D1           ;               UnloadConfig_transmitter_config();
 07D1 7C0000            xcall _UnloadConfig_transmitter_config
 07D4                   .dbline 553
 07D4           ;       }
 07D4           L130:
 07D4           L129:
 07D4           L127:
 07D4                   .dbline -2
 07D4           L125:
 07D4 20                pop X
 07D5                   .dbline 0 ; func end
 07D5 7F                ret
 07D6                   .dbsym l config_num -5 I
 07D6                   .dbend
 07D6                   .dbfunc e initializeSlaves _initializeSlaves fV
 07D6           ;   num_timeouts -> X+0
 07D6           _initializeSlaves::
 07D6                   .dbline -1
 07D6 10                push X
 07D7 4F                mov X,SP
 07D8 3802              add SP,2
 07DA                   .dbline 557
 07DA           ; }
 07DA           ; 
 07DA           ; void initializeSlaves(void)
 07DA           ; {
 07DA                   .dbline 558
 07DA           ;       int num_timeouts = 0;
 07DA 560100            mov [X+1],0
 07DD 560000            mov [X+0],0
 07E0                   .dbline 560
 07E0           ;       
 07E0           ;       sayHello();
 07E0 9BA4              xcall _sayHello
 07E2 8105              xjmp L134
 07E4           L133:
 07E4                   .dbline 565
 07E4           ;       
 07E4           ;       // This loop continuously probes and listens at intervals
 07E4           ;       // set by the RX_TIMEOUT_DURATION variable.
 07E4           ;       while(num_timeouts < MAX_TIMEOUTS)
 07E4           ;       {                                       
 07E4                   .dbline 566
 07E4           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 07E4 10                push X
 07E5 7C0000            xcall _RECEIVE_cReadChar
 07E8 62D000            mov REG[0xd0],>__r0
 07EB 20                pop X
 07EC 39FC              cmp A,-4
 07EE B0D4              jnz L136
 07F0                   .dbline 567
 07F0           ;               {       
 07F0                   .dbline 568
 07F0           ;                       if(validTransmission())
 07F0 9BE9              xcall _validTransmission
 07F2 62D000            mov REG[0xd0],>__r0
 07F5 3C0000            cmp [__r0],0
 07F8 B006              jnz X36
 07FA 3C0000            cmp [__r1],0
 07FD A0EA              jz L137
 07FF           X36:
 07FF                   .dbline 569
 07FF           ;                       {
 07FF                   .dbline 570
 07FF           ;                               if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 07FF 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0802 3C00C8            cmp [_COMMAND_TYPE],-56
 0805 B0E2              jnz L137
 0807                   .dbline 571
 0807           ;                               {
 0807                   .dbline 573
 0807           ;                                       // If this is for me, assign them an ID.
 0807           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 0807 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 080A 3C0000            cmp [_COMMAND_DESTINATION],0
 080D B0DA              jnz L137
 080F                   .dbline 574
 080F           ;                                       {
 080F                   .dbline 575
 080F           ;                                               NUM_MODULES++;                  // Increment the number of modules connected.
 080F 62D000            mov REG[0xd0],>_NUM_MODULES
 0812 7601              inc [_NUM_MODULES+1]
 0814 0E0000            adc [_NUM_MODULES],0
 0817                   .dbline 576
 0817           ;                                               num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0817 560100            mov [X+1],0
 081A 560000            mov [X+0],0
 081D                   .dbline 578
 081D           ;                       
 081D           ;                                               if(!assignID(NUM_MODULES))
 081D 5100              mov A,[_NUM_MODULES]
 081F 08                push A
 0820 5101              mov A,[_NUM_MODULES+1]
 0822 08                push A
 0823 9932              xcall _assignID
 0825 38FE              add SP,-2
 0827 62D000            mov REG[0xd0],>__r0
 082A 3C0000            cmp [__r0],0
 082D B0BA              jnz L137
 082F 3C0000            cmp [__r1],0
 0832 B0B5              jnz L137
 0834           X37:
 0834                   .dbline 579
 0834           ;                                               {
 0834                   .dbline 583
 0834           ;                                                       // If the module did not respond that the ID was assigned,
 0834           ;                                                       // make an effort to ping it in case that transmission was lost
 0834           ;                                                       // before ultimately deciding that the module didn't configure.
 0834           ;                                                       if(!pingModule(NUM_MODULES))
 0834 62D000            mov REG[0xd0],>_NUM_MODULES
 0837 5100              mov A,[_NUM_MODULES]
 0839 08                push A
 083A 5101              mov A,[_NUM_MODULES+1]
 083C 08                push A
 083D 981F              xcall _pingModule
 083F 38FE              add SP,-2
 0841 62D000            mov REG[0xd0],>__r0
 0844 3C0000            cmp [__r0],0
 0847 B0A0              jnz L137
 0849 3C0000            cmp [__r1],0
 084C B09B              jnz L137
 084E           X38:
 084E                   .dbline 584
 084E           ;                                                       {
 084E                   .dbline 585
 084E           ;                                                               if(!pingModule(NUM_MODULES))
 084E 62D000            mov REG[0xd0],>_NUM_MODULES
 0851 5100              mov A,[_NUM_MODULES]
 0853 08                push A
 0854 5101              mov A,[_NUM_MODULES+1]
 0856 08                push A
 0857 9805              xcall _pingModule
 0859 38FE              add SP,-2
 085B 62D000            mov REG[0xd0],>__r0
 085E 3C0000            cmp [__r0],0
 0861 B086              jnz L137
 0863 3C0000            cmp [__r1],0
 0866 B081              jnz L137
 0868           X39:
 0868                   .dbline 586
 0868           ;                                                               {
 0868                   .dbline 587
 0868           ;                                                                       if(!pingModule(NUM_MODULES))
 0868 62D000            mov REG[0xd0],>_NUM_MODULES
 086B 5100              mov A,[_NUM_MODULES]
 086D 08                push A
 086E 5101              mov A,[_NUM_MODULES+1]
 0870 08                push A
 0871 7C005E            xcall _pingModule
 0874 38FE              add SP,-2
 0876 62D000            mov REG[0xd0],>__r0
 0879 3C0000            cmp [__r0],0
 087C B06B              jnz L137
 087E 3C0000            cmp [__r1],0
 0881 B066              jnz L137
 0883           X40:
 0883                   .dbline 588
 0883           ;                                                                       {
 0883                   .dbline 589
 0883           ;                                                                               if(!pingModule(NUM_MODULES))
 0883 62D000            mov REG[0xd0],>_NUM_MODULES
 0886 5100              mov A,[_NUM_MODULES]
 0888 08                push A
 0889 5101              mov A,[_NUM_MODULES+1]
 088B 08                push A
 088C 7C005E            xcall _pingModule
 088F 38FE              add SP,-2
 0891 62D000            mov REG[0xd0],>__r0
 0894 3C0000            cmp [__r0],0
 0897 B050              jnz L137
 0899 3C0000            cmp [__r1],0
 089C B04B              jnz L137
 089E           X41:
 089E                   .dbline 590
 089E           ;                                                                               {
 089E                   .dbline 591
 089E           ;                                                                                       if(!pingModule(NUM_MODULES))
 089E 62D000            mov REG[0xd0],>_NUM_MODULES
 08A1 5100              mov A,[_NUM_MODULES]
 08A3 08                push A
 08A4 5101              mov A,[_NUM_MODULES+1]
 08A6 08                push A
 08A7 7C005E            xcall _pingModule
 08AA 38FE              add SP,-2
 08AC 62D000            mov REG[0xd0],>__r0
 08AF 3C0000            cmp [__r0],0
 08B2 B035              jnz L137
 08B4 3C0000            cmp [__r1],0
 08B7 B030              jnz L137
 08B9           X42:
 08B9                   .dbline 592
 08B9           ;                                                                                       {
 08B9                   .dbline 593
 08B9           ;                                                                                               NUM_MODULES--;
 08B9 62D000            mov REG[0xd0],>_NUM_MODULES
 08BC 7A01              dec [_NUM_MODULES+1]
 08BE 1E0000            sbb [_NUM_MODULES],0
 08C1                   .dbline 594
 08C1           ;                                                                                       }
 08C1                   .dbline 595
 08C1           ;                                                                               }
 08C1                   .dbline 596
 08C1           ;                                                                       }
 08C1                   .dbline 597
 08C1           ;                                                               }
 08C1                   .dbline 598
 08C1           ;                                                       }
 08C1                   .dbline 599
 08C1           ;                                               }
 08C1                   .dbline 600
 08C1           ;                                       }
 08C1                   .dbline 601
 08C1           ;                               }
 08C1                   .dbline 602
 08C1           ;                       }
 08C1                   .dbline 603
 08C1           ;               }
 08C1 8026              xjmp L137
 08C3           L136:
 08C3                   .dbline 604
 08C3           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 08C3 62D000            mov REG[0xd0],>_TIMEOUT
 08C6 5101              mov A,[_TIMEOUT+1]
 08C8 1105              sub A,5
 08CA 5100              mov A,[_TIMEOUT]
 08CC 3180              xor A,-128
 08CE 1980              sbb A,(0 ^ 0x80)
 08D0 C017              jc L156
 08D2           X43:
 08D2                   .dbline 605
 08D2           ;               {       
 08D2                   .dbline 606
 08D2           ;                       num_timeouts++;
 08D2 7701              inc [X+1]
 08D4 0F0000            adc [X+0],0
 08D7                   .dbline 609
 08D7           ;                       
 08D7           ;                       // If we are not maxed out on modules, look for more.
 08D7           ;                       if(NUM_MODULES < MAX_MODULES)
 08D7 62D000            mov REG[0xd0],>_NUM_MODULES
 08DA 5101              mov A,[_NUM_MODULES+1]
 08DC 11FA              sub A,-6
 08DE 5100              mov A,[_NUM_MODULES]
 08E0 3180              xor A,-128
 08E2 1980              sbb A,(0 ^ 0x80)
 08E4 D003              jnc L158
 08E6           X44:
 08E6                   .dbline 610
 08E6           ;                       {
 08E6                   .dbline 611
 08E6           ;                               sayHello();
 08E6 9A9E              xcall _sayHello
 08E8                   .dbline 612
 08E8           ;                       }
 08E8           L158:
 08E8                   .dbline 613
 08E8           ;               }
 08E8           L156:
 08E8           L137:
 08E8                   .dbline 614
 08E8           ;       }
 08E8           L134:
 08E8                   .dbline 564
 08E8 5201              mov A,[X+1]
 08EA 110A              sub A,10
 08EC 5200              mov A,[X+0]
 08EE 3180              xor A,-128
 08F0 1980              sbb A,(0 ^ 0x80)
 08F2 CEF1              jc L133
 08F4           X45:
 08F4                   .dbline 617
 08F4           ;       
 08F4           ;       // Switch back to PC mode.
 08F4           ;       configToggle(PC_MODE);
 08F4 5000              mov A,0
 08F6 08                push A
 08F7 5002              mov A,2
 08F9 08                push A
 08FA 9DB2              xcall _configToggle
 08FC 38FE              add SP,-2
 08FE                   .dbline -2
 08FE           L132:
 08FE 38FE              add SP,-2
 0900 20                pop X
 0901                   .dbline 0 ; func end
 0901 7F                ret
 0902                   .dbsym l num_timeouts 0 I
 0902                   .dbend
 0902                   .dbfunc e xmitWait _xmitWait fV
 0902           ;              i -> X+0
 0902           _xmitWait::
 0902                   .dbline -1
 0902 10                push X
 0903 4F                mov X,SP
 0904 3802              add SP,2
 0906                   .dbline 621
 0906           ; }
 0906           ; 
 0906           ; void xmitWait(void)
 0906           ; {
 0906                   .dbline 624
 0906           ;       int i;
 0906           ;       
 0906           ;       for(i = 0; i < 25; i++)
 0906 560100            mov [X+1],0
 0909 560000            mov [X+0],0
 090C           L161:
 090C                   .dbline 625
 090C           ;       {
 090C                   .dbline 627
 090C           ;               // Sit here and spin for about 50 microseconds.
 090C           ;       }
 090C           L162:
 090C                   .dbline 624
 090C 7701              inc [X+1]
 090E 0F0000            adc [X+0],0
 0911                   .dbline 624
 0911 5201              mov A,[X+1]
 0913 1119              sub A,25
 0915 5200              mov A,[X+0]
 0917 3180              xor A,-128
 0919 1980              sbb A,(0 ^ 0x80)
 091B CFF0              jc L161
 091D           X46:
 091D                   .dbline -2
 091D           L160:
 091D 38FE              add SP,-2
 091F 20                pop X
 0920                   .dbline 0 ; func end
 0920 7F                ret
 0921                   .dbsym l i 0 I
 0921                   .dbend
 0921                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0921           _TX_TIMEOUT_ISR::
 0921                   .dbline -1
 0921 71C0              or F,-64
 0923 08                push A
 0924 5DD0              mov A,REG[0xd0]
 0926 08                push A
 0927                   .dbline 631
 0927           ; }
 0927           ; 
 0927           ; void TX_TIMEOUT_ISR(void)
 0927           ; {     
 0927                   .dbline 632
 0927           ;       TIMEOUT++;
 0927 62D000            mov REG[0xd0],>_TIMEOUT
 092A 7601              inc [_TIMEOUT+1]
 092C 0E0000            adc [_TIMEOUT],0
 092F                   .dbline 634
 092F           ;       
 092F           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 092F 62DAFD            mov REG[0xda],-3
 0932                   .dbline -2
 0932           L165:
 0932 18                pop A
 0933 60D0              mov REG[208],A
 0935 18                pop A
 0936                   .dbline 0 ; func end
 0936 7E                reti
 0937                   .dbend
 0937                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0937           _RX_TIMEOUT_ISR::
 0937                   .dbline -1
 0937 71C0              or F,-64
 0939 08                push A
 093A 5DD0              mov A,REG[0xd0]
 093C 08                push A
 093D                   .dbline 638
 093D           ; }
 093D           ; 
 093D           ; void RX_TIMEOUT_ISR(void)
 093D           ; {     
 093D                   .dbline 639
 093D           ;       TIMEOUT++;
 093D 62D000            mov REG[0xd0],>_TIMEOUT
 0940 7601              inc [_TIMEOUT+1]
 0942 0E0000            adc [_TIMEOUT],0
 0945                   .dbline 641
 0945           ;       
 0945           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0945 62DAFD            mov REG[0xda],-3
 0948                   .dbline -2
 0948           L166:
 0948 18                pop A
 0949 60D0              mov REG[208],A
 094B 18                pop A
 094C                   .dbline 0 ; func end
 094C 7E                reti
 094D                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _PARAM2::
 0000 00                .byte 0
 0001                   .dbsym e PARAM2 _PARAM2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _PARAM1::
 0000 00                .byte 0
 0001                   .dbsym e PARAM1 _PARAM1 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area lit(rom, con, rel)
 0000           L46:
 0000 4D6F64756C65732100        .byte 'M,'o,'d,'u,'l,'e,'s,33,0
