 0000                   cpu LMM
                        .module main.c
                        .area text(rom, con, rel)
 0000                   .dbfile ./main.c
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000                   .dbfunc e main _main fV
 0000           ;          angle -> X+4
 0000           ;  softwareReset -> X+2
 0000           ;      tempValue -> X+0
 0000           _main::
 0000                   .dbline -1
 0000 10                push X
 0001 4F                mov X,SP
 0002 3808              add SP,8
 0004                   .dbline 99
 0004           ; //----------------------------------------------------------------------------
 0004           ; // C main line
 0004           ; //----------------------------------------------------------------------------
 0004           ; 
 0004           ; #include <m8c.h>              // part specific constants and macros
 0004           ; #include "PSoCAPI.h"          // PSoC API definitions for all User Modules
 0004           ; #include "psocdynamic.h"
 0004           ; #include <stdlib.h>
 0004           ; #include <string.h>
 0004           ; #pragma interrupt_handler TX_TIMEOUT_ISR
 0004           ; #pragma interrupt_handler RX_TIMEOUT_ISR
 0004           ; 
 0004           ; // These defines are used as parameters of the configToggle function.
 0004           ; // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
 0004           ; #define               PC_MODE                                         (2)
 0004           ; #define               RX_MODE                                         (1)
 0004           ; #define               TX_MODE                                         (0)
 0004           ; 
 0004           ; // These defines are used as comparisons to find what port the newest module is connected to.
 0004           ; #define               PORT_1                                          ('A')
 0004           ; #define               PORT_2                                          ('B')
 0004           ; #define               PORT_3                                          ('C')
 0004           ; #define               PORT_4                                          ('D')
 0004           ; 
 0004           ; // These defines are used as transmission indicators.
 0004           ; #define               START_TRANSMIT                          (252)   // Indicates the beginning of a transmission.
 0004           ; #define               END_TRANSMIT                            (253)   // Indicates the end of a transmission.
 0004           ; #define               HELLO_BYTE                                      (200)   // Indicates master is ready to talk.
 0004           ; #define               ID_ASSIGNMENT                           (201)   // Indicates an ID assignment from the master.
 0004           ; #define               ID_ASSIGN_OK                            (202)   // Indicates an ID assignment is acknowledged.
 0004           ; #define               PING                                            (203)   // Indicates that someone is pinging someone else.
 0004           ; #define               CLEAR_CONFIG                            (204)   // Indicates that the master is asking for a config clear.
 0004           ; #define               CONFIG_CLEARED                          (205)   // Indicates that a module has cleared its own config.
 0004           ; #define               MASTER_ID                                       (0)             // The master node's ID.
 0004           ; #define               BROADCAST                                       (254)   // The broadcast ID for talking to all nodes.
 0004           ; #define               BLANK_MODULE_ID                         (251)   // This is the ID of an unconfigured module.
 0004           ; 
 0004           ; // These defines are used to fill in the instruction we are using on the servo.
 0004           ; #define               PING_SERVO                                      (1)             // This is the instruction number for ping.
 0004           ; #define               READ_SERVO                                      (2)             // This is the instruction number for a read.
 0004           ; #define               WRITE_SERVO                                     (3)             // This is the instruction number for a write.
 0004           ; #define               RESET_SERVO                                     (6)             // This is the instruction to reset the servo EEPROM.
 0004           ; 
 0004           ; // These defines are used for transmission timing.
 0004           ; #define       RX_TIMEOUT_DURATION                     (5)             // This is receive wait time in 1 ms units.
 0004           ; 
 0004           ; // These defines are used for the initial probing stage, where receive waits are longer to make
 0004           ; // sure of transmission failure or success.
 0004           ; #define               BOOT_TIMEOUT                            (200)   // This is boot wait time in 1 ms units.
 0004           ; #define               MAX_TIMEOUTS                            (10)    // Number of timeouts allowed before hello mode exit.
 0004           ; 
 0004           ; // This is the maximum number of allowable modules per branch out from the master
 0004           ; #define               MAX_MODULES                                     (250)
 0004           ; 
 0004           ; #define               SERVO_START                                     (255)
 0004           ; 
 0004           ; // This function receives a mode identifier as a parameter and toggles the
 0004           ; // system configuration between receive and transmit modes for half duplex UART.
 0004           ; void configToggle(int mode);
 0004           ; 
 0004           ; // This function pings the index passed to it. Returns 1 on success, 0 on fail.
 0004           ; int pingModule(int module_id);
 0004           ; 
 0004           ; // This function assigns an ID to a module.
 0004           ; int assignID(int assigned_ID);
 0004           ; 
 0004           ; int validTransmission(void);
 0004           ; 
 0004           ; void decodeTransmission(void);
 0004           ; 
 0004           ; void sayHello(void);
 0004           ; 
 0004           ; void servoInstruction(char id, char length, char instruction, char address, char value);
 0004           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
 0004           ; 
 0004           ; int clearConfig(int module_id);
 0004           ; // This function checks the current mode and unloads the configuration for that mode.
 0004           ; void unloadAllConfigs(void);
 0004           ; // This function unloads the configuration corresponding to the number passed to it.
 0004           ; void unloadConfig(int config_num);
 0004           ; // Initialization function for the slave module controllers.
 0004           ; void initializeSlaves(void);
 0004           ; // Static wait time of approximately 50 microseconds for use after starting a transmission.
 0004           ; void xmitWait(void);
 0004           ; 
 0004           ; // This flag is set if there is a timeout.
 0004           ; int TIMEOUT;
 0004           ; 
 0004           ; int NUM_MODULES;                      // Stores the number of modules that have been discovered.
 0004           ; char COMMAND_SOURCE;          // Stores who the current command is from.
 0004           ; char COMMAND_DESTINATION;     // Stores who the current command is for.
 0004           ; char COMMAND_TYPE;                    // Stores the type of command that was just read.
 0004           ; char PARAM1;                          // Stores a parameter that accompanies the command (if any).
 0004           ; char PARAM2;                          // Stores a parameter that accompanies the command (if any).
 0004           ; 
 0004           ; int STATE;                                    // Stores the current configuration state of the system.
 0004           ; 
 0004           ; void main()
 0004           ; {     
 0004                   .dbline 100
 0004           ;       int tempValue = 0;
 0004 560100            mov [X+1],0
 0007 560000            mov [X+0],0
 000A                   .dbline 101
 000A           ;       int softwareReset = 0;
 000A 560300            mov [X+3],0
 000D 560200            mov [X+2],0
 0010                   .dbline 102
 0010           ;       float angle = 0;
 0010 560400            mov [X+4],0
 0013 560500            mov [X+5],0
 0016 560600            mov [X+6],0
 0019 560700            mov [X+7],0
 001C                   .dbline 104
 001C           ;       
 001C           ;       NUM_MODULES = 0;
 001C 62D000            mov REG[0xd0],>_NUM_MODULES
 001F 550100            mov [_NUM_MODULES+1],0
 0022 550000            mov [_NUM_MODULES],0
 0025                   .dbline 106
 0025           ;       
 0025           ;       M8C_EnableGInt;                 // Turn on global interrupts for the transmission timeout timer.
 0025 7101                      or  F, 01h
 0027           
 0027                   .dbline 107
 0027           ;       M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); //activate GPIO ISR
 0027 43E020            or REG[0xe0],32
 002A                   .dbline 109
 002A           ;       
 002A           ;       unloadAllConfigs();
 002A 7C09F6            xcall _unloadAllConfigs
 002D                   .dbline 111
 002D           ; 
 002D           ;       configToggle(RX_MODE);
 002D 5000              mov A,0
 002F 08                push A
 0030 5001              mov A,1
 0032 08                push A
 0033 7C0907            xcall _configToggle
 0036 38FE              add SP,-2
 0038           L2:
 0038                   .dbline 114
 0038           ;               
 0038           ;       // Sit and wait for the worst case setup time to occur.
 0038           ;       while(TIMEOUT < BOOT_TIMEOUT) { }
 0038                   .dbline 114
 0038           L3:
 0038                   .dbline 114
 0038 62D000            mov REG[0xd0],>_TIMEOUT
 003B 5101              mov A,[_TIMEOUT+1]
 003D 11C8              sub A,-56
 003F 5100              mov A,[_TIMEOUT]
 0041 3180              xor A,-128
 0043 1980              sbb A,(0 ^ 0x80)
 0045 CFF2              jc L2
 0047           X1:
 0047                   .dbline 117
 0047           ;               
 0047           ;       // Initialize all of the slave modules.
 0047           ;       initializeSlaves();
 0047 7C0A2F            xcall _initializeSlaves
 004A 800F              xjmp L6
 004C           L5:
 004C                   .dbline 120
 004C           ;       
 004C           ;       while(1)
 004C           ;       {       
 004C                   .dbline 121
 004C           ;               if(COMP_SERIAL_bCmdCheck())
 004C 10                push X
 004D 7C0000            xcall _COMP_SERIAL_bCmdCheck
 0050 62D000            mov REG[0xd0],>__r0
 0053 20                pop X
 0054 3900              cmp A,0
 0056 A003              jz L8
 0058                   .dbline 122
 0058           ;               {
 0058                   .dbline 123
 0058           ;                       decodeTransmission();
 0058 93DB              xcall _decodeTransmission
 005A                   .dbline 124
 005A           ;               }
 005A           L8:
 005A                   .dbline 125
 005A           ;       }
 005A           L6:
 005A                   .dbline 119
 005A 8FF1              xjmp L5
 005C           X0:
 005C                   .dbline -2
 005C           L1:
 005C 38F8              add SP,-8
 005E 20                pop X
 005F                   .dbline 0 ; func end
 005F 8FFF              jmp .
 0061                   .dbsym l angle 4 D
 0061                   .dbsym l softwareReset 2 I
 0061                   .dbsym l tempValue 0 I
 0061                   .dbend
 0061                   .dbfunc e pingModule _pingModule fI
 0061           ;       response -> X+0
 0061           ;      module_id -> X-5
 0061           _pingModule::
 0061                   .dbline -1
 0061 10                push X
 0062 4F                mov X,SP
 0063 3802              add SP,2
 0065                   .dbline 129
 0065           ; }
 0065           ; 
 0065           ; int pingModule(int module_id)
 0065           ; {
 0065                   .dbline 130
 0065           ;       int response = 0;
 0065 560100            mov [X+1],0
 0068 560000            mov [X+0],0
 006B                   .dbline 132
 006B           ;       
 006B           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 006B 5000              mov A,0
 006D 08                push A
 006E 08                push A
 006F 7C0907            xcall _configToggle
 0072 38FE              add SP,-2
 0074                   .dbline 135
 0074           ;                       
 0074           ;       // Transmit a hello.
 0074           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0074 10                push X
 0075 50FC              mov A,-4
 0077 7C0000            xcall _TRANSMIT_PutChar
 007A 20                pop X
 007B                   .dbline 136
 007B           ;       TRANSMIT_PutChar(START_TRANSMIT);
 007B 10                push X
 007C 50FC              mov A,-4
 007E 7C0000            xcall _TRANSMIT_PutChar
 0081 20                pop X
 0082                   .dbline 137
 0082           ;       TRANSMIT_PutChar(MASTER_ID);
 0082 10                push X
 0083 5000              mov A,0
 0085 7C0000            xcall _TRANSMIT_PutChar
 0088 20                pop X
 0089                   .dbline 138
 0089           ;       TRANSMIT_PutChar(module_id);
 0089 62D000            mov REG[0xd0],>__r0
 008C 52FC              mov A,[X-4]
 008E 10                push X
 008F 7C0000            xcall _TRANSMIT_PutChar
 0092 20                pop X
 0093                   .dbline 139
 0093           ;       TRANSMIT_PutChar(PING);
 0093 10                push X
 0094 50CB              mov A,-53
 0096 7C0000            xcall _TRANSMIT_PutChar
 0099 20                pop X
 009A                   .dbline 140
 009A           ;       TRANSMIT_PutChar(END_TRANSMIT);
 009A 10                push X
 009B 50FD              mov A,-3
 009D 7C0000            xcall _TRANSMIT_PutChar
 00A0 20                pop X
 00A1                   .dbline 141
 00A1           ;       TRANSMIT_PutChar(END_TRANSMIT);
 00A1 10                push X
 00A2 50FD              mov A,-3
 00A4 7C0000            xcall _TRANSMIT_PutChar
 00A7 20                pop X
 00A8           L11:
 00A8                   .dbline 144
 00A8           ;       
 00A8           ;       // Wait for the transmission to finish.
 00A8           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 00A8           L12:
 00A8                   .dbline 144
 00A8 10                push X
 00A9 7C0000            xcall _TRANSMIT_bReadTxStatus
 00AC 62D000            mov REG[0xd0],>__r0
 00AF 20                pop X
 00B0 5300              mov [__r0],A
 00B2 470020            tst [__r0],32
 00B5 AFF2              jz L11
 00B7                   .dbline 146
 00B7           ;       
 00B7           ;       xmitWait();
 00B7 7C0B5E            xcall _xmitWait
 00BA                   .dbline 148
 00BA           ;       
 00BA           ;       configToggle(RX_MODE);  // Listen for the response.
 00BA 5000              mov A,0
 00BC 08                push A
 00BD 5001              mov A,1
 00BF 08                push A
 00C0 7C0907            xcall _configToggle
 00C3 38FE              add SP,-2
 00C5                   .dbline 150
 00C5           ;       
 00C5           ;       RX_TIMEOUT_Stop();
 00C5 10                push X
 00C6 7C0000            xcall _RX_TIMEOUT_Stop
 00C9 20                pop X
 00CA                   .dbline 151
 00CA           ;       TIMEOUT = 0;
 00CA 62D000            mov REG[0xd0],>_TIMEOUT
 00CD 550100            mov [_TIMEOUT+1],0
 00D0 550000            mov [_TIMEOUT],0
 00D3                   .dbline 152
 00D3           ;       RX_TIMEOUT_Start();
 00D3 10                push X
 00D4 7C0000            xcall _RX_TIMEOUT_Start
 00D7 20                pop X
 00D8 8048              xjmp L15
 00DA           L14:
 00DA                   .dbline 155
 00DA           ;       
 00DA           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 00DA           ;       {
 00DA                   .dbline 156
 00DA           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 00DA 10                push X
 00DB 7C0000            xcall _RECEIVE_cReadChar
 00DE 62D000            mov REG[0xd0],>__r0
 00E1 20                pop X
 00E2 39FC              cmp A,-4
 00E4 B03C              jnz L17
 00E6                   .dbline 157
 00E6           ;               {       
 00E6                   .dbline 158
 00E6           ;                       if(validTransmission())
 00E6 92FA              xcall _validTransmission
 00E8 62D000            mov REG[0xd0],>__r0
 00EB 3C0000            cmp [__r0],0
 00EE B006              jnz X2
 00F0 3C0000            cmp [__r1],0
 00F3 A02D              jz L19
 00F5           X2:
 00F5                   .dbline 159
 00F5           ;                       {
 00F5                   .dbline 160
 00F5           ;                               if(COMMAND_TYPE == PING)        // This is the response we are looking for.
 00F5 62D000            mov REG[0xd0],>_COMMAND_TYPE
 00F8 3C00CB            cmp [_COMMAND_TYPE],-53
 00FB B025              jnz L21
 00FD                   .dbline 161
 00FD           ;                               {
 00FD                   .dbline 163
 00FD           ;                                       // If this is for me, check who it was from.
 00FD           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 00FD 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0100 3C0000            cmp [_COMMAND_DESTINATION],0
 0103 B01D              jnz L23
 0105                   .dbline 164
 0105           ;                                       {
 0105                   .dbline 165
 0105           ;                                               if(COMMAND_SOURCE == module_id)
 0105 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0108 5100              mov A,[_COMMAND_SOURCE]
 010A 62D000            mov REG[0xd0],>__r0
 010D 5300              mov [__r1],A
 010F 5000              mov A,0
 0111 3BFB              cmp A,[X-5]
 0113 B00D              jnz L25
 0115 5100              mov A,[__r1]
 0117 3BFC              cmp A,[X-4]
 0119 B007              jnz L25
 011B           X3:
 011B                   .dbline 166
 011B           ;                                               {
 011B                   .dbline 167
 011B           ;                                                       response = 1;
 011B 560101            mov [X+1],1
 011E 560000            mov [X+0],0
 0121                   .dbline 168
 0121           ;                                               }
 0121           L25:
 0121                   .dbline 169
 0121           ;                                       }
 0121           L23:
 0121                   .dbline 170
 0121           ;                               }
 0121           L21:
 0121                   .dbline 171
 0121           ;                       }
 0121           L19:
 0121                   .dbline 172
 0121           ;               }
 0121           L17:
 0121                   .dbline 173
 0121           ;       }
 0121           L15:
 0121                   .dbline 154
 0121 62D000            mov REG[0xd0],>_TIMEOUT
 0124 5101              mov A,[_TIMEOUT+1]
 0126 1105              sub A,5
 0128 5100              mov A,[_TIMEOUT]
 012A 3180              xor A,-128
 012C 1980              sbb A,(0 ^ 0x80)
 012E D00B              jnc L27
 0130           X4:
 0130 3D0000            cmp [X+0],0
 0133 B006              jnz X5
 0135 3D0100            cmp [X+1],0
 0138 AFA1              jz L14
 013A           X5:
 013A           L27:
 013A                   .dbline 175
 013A           ;       
 013A           ;       RX_TIMEOUT_Stop();
 013A 10                push X
 013B 7C0000            xcall _RX_TIMEOUT_Stop
 013E 20                pop X
 013F                   .dbline 176
 013F           ;       TIMEOUT = 0;
 013F 62D000            mov REG[0xd0],>_TIMEOUT
 0142 550100            mov [_TIMEOUT+1],0
 0145 550000            mov [_TIMEOUT],0
 0148                   .dbline 177
 0148           ;       RX_TIMEOUT_Start();
 0148 10                push X
 0149 7C0000            xcall _RX_TIMEOUT_Start
 014C 20                pop X
 014D                   .dbline 179
 014D           ;       
 014D           ;       return response;
 014D 62D000            mov REG[0xd0],>__r0
 0150 5201              mov A,[X+1]
 0152 5300              mov [__r1],A
 0154 5200              mov A,[X+0]
 0156 5300              mov [__r0],A
 0158                   .dbline -2
 0158           L10:
 0158 38FE              add SP,-2
 015A 20                pop X
 015B                   .dbline 0 ; func end
 015B 7F                ret
 015C                   .dbsym l response 0 I
 015C                   .dbsym l module_id -5 I
 015C                   .dbend
 015C                   .dbfunc e assignID _assignID fI
 015C           ;        success -> X+0
 015C           ;    assigned_ID -> X-5
 015C           _assignID::
 015C                   .dbline -1
 015C 10                push X
 015D 4F                mov X,SP
 015E 3802              add SP,2
 0160                   .dbline 183
 0160           ; }
 0160           ; 
 0160           ; int assignID(int assigned_ID)
 0160           ; {
 0160                   .dbline 184
 0160           ;       int success = 0;                // Stores 0 on fail, 1 on success.
 0160 560100            mov [X+1],0
 0163 560000            mov [X+0],0
 0166                   .dbline 186
 0166           ;       
 0166           ;       configToggle(TX_MODE);  // Switch to TX mode.
 0166 5000              mov A,0
 0168 08                push A
 0169 08                push A
 016A 979B              xcall _configToggle
 016C 38FE              add SP,-2
 016E                   .dbline 189
 016E           ; 
 016E           ;       // Transmit the assignment.
 016E           ;       TRANSMIT_PutChar(START_TRANSMIT);
 016E 10                push X
 016F 50FC              mov A,-4
 0171 7C0000            xcall _TRANSMIT_PutChar
 0174 20                pop X
 0175                   .dbline 190
 0175           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0175 10                push X
 0176 50FC              mov A,-4
 0178 7C0000            xcall _TRANSMIT_PutChar
 017B 20                pop X
 017C                   .dbline 191
 017C           ;       TRANSMIT_PutChar(MASTER_ID);
 017C 10                push X
 017D 5000              mov A,0
 017F 7C0000            xcall _TRANSMIT_PutChar
 0182 20                pop X
 0183                   .dbline 192
 0183           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 0183 10                push X
 0184 50FB              mov A,-5
 0186 7C0000            xcall _TRANSMIT_PutChar
 0189 20                pop X
 018A                   .dbline 193
 018A           ;       TRANSMIT_PutChar(ID_ASSIGNMENT);
 018A 10                push X
 018B 50C9              mov A,-55
 018D 7C0000            xcall _TRANSMIT_PutChar
 0190 20                pop X
 0191                   .dbline 194
 0191           ;       TRANSMIT_PutChar(assigned_ID);
 0191 62D000            mov REG[0xd0],>__r0
 0194 52FC              mov A,[X-4]
 0196 10                push X
 0197 7C0000            xcall _TRANSMIT_PutChar
 019A 20                pop X
 019B                   .dbline 195
 019B           ;       TRANSMIT_PutChar(END_TRANSMIT);
 019B 10                push X
 019C 50FD              mov A,-3
 019E 7C0000            xcall _TRANSMIT_PutChar
 01A1 20                pop X
 01A2                   .dbline 196
 01A2           ;       TRANSMIT_PutChar(END_TRANSMIT);
 01A2 10                push X
 01A3 50FD              mov A,-3
 01A5 7C0000            xcall _TRANSMIT_PutChar
 01A8 20                pop X
 01A9           L29:
 01A9                   .dbline 199
 01A9           ;       
 01A9           ;       // Wait for the transmission to finish.
 01A9           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 01A9           L30:
 01A9                   .dbline 199
 01A9 10                push X
 01AA 7C0000            xcall _TRANSMIT_bReadTxStatus
 01AD 62D000            mov REG[0xd0],>__r0
 01B0 20                pop X
 01B1 5300              mov [__r0],A
 01B3 470020            tst [__r0],32
 01B6 AFF2              jz L29
 01B8                   .dbline 201
 01B8           ;       
 01B8           ;       xmitWait();
 01B8 7C0B5E            xcall _xmitWait
 01BB                   .dbline 203
 01BB           ;       
 01BB           ;       configToggle(RX_MODE);  // Switch back to receive mode.
 01BB 5000              mov A,0
 01BD 08                push A
 01BE 5001              mov A,1
 01C0 08                push A
 01C1 9744              xcall _configToggle
 01C3 38FE              add SP,-2
 01C5                   .dbline 205
 01C5           ;       
 01C5           ;       RX_TIMEOUT_Stop();
 01C5 10                push X
 01C6 7C0000            xcall _RX_TIMEOUT_Stop
 01C9 20                pop X
 01CA                   .dbline 206
 01CA           ;       TIMEOUT = 0;
 01CA 62D000            mov REG[0xd0],>_TIMEOUT
 01CD 550100            mov [_TIMEOUT+1],0
 01D0 550000            mov [_TIMEOUT],0
 01D3                   .dbline 207
 01D3           ;       RX_TIMEOUT_Start();
 01D3 10                push X
 01D4 7C0000            xcall _RX_TIMEOUT_Start
 01D7 20                pop X
 01D8 8048              xjmp L33
 01DA           L32:
 01DA                   .dbline 210
 01DA           ;       
 01DA           ;       while((TIMEOUT < RX_TIMEOUT_DURATION) && (!success))
 01DA           ;       {
 01DA                   .dbline 211
 01DA           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 01DA 10                push X
 01DB 7C0000            xcall _RECEIVE_cReadChar
 01DE 62D000            mov REG[0xd0],>__r0
 01E1 20                pop X
 01E2 39FC              cmp A,-4
 01E4 B03C              jnz L35
 01E6                   .dbline 212
 01E6           ;               {       
 01E6                   .dbline 213
 01E6           ;                       if(validTransmission())
 01E6 91FA              xcall _validTransmission
 01E8 62D000            mov REG[0xd0],>__r0
 01EB 3C0000            cmp [__r0],0
 01EE B006              jnz X6
 01F0 3C0000            cmp [__r1],0
 01F3 A02D              jz L37
 01F5           X6:
 01F5                   .dbline 214
 01F5           ;                       {
 01F5                   .dbline 215
 01F5           ;                               if(COMMAND_TYPE == ID_ASSIGN_OK)        // This is the response we are looking for.
 01F5 62D000            mov REG[0xd0],>_COMMAND_TYPE
 01F8 3C00CA            cmp [_COMMAND_TYPE],-54
 01FB B025              jnz L39
 01FD                   .dbline 216
 01FD           ;                               {
 01FD                   .dbline 218
 01FD           ;                                       // If this is for me, check who it was from.
 01FD           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 01FD 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0200 3C0000            cmp [_COMMAND_DESTINATION],0
 0203 B01D              jnz L41
 0205                   .dbline 219
 0205           ;                                       {
 0205                   .dbline 220
 0205           ;                                               if(COMMAND_SOURCE == assigned_ID)
 0205 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0208 5100              mov A,[_COMMAND_SOURCE]
 020A 62D000            mov REG[0xd0],>__r0
 020D 5300              mov [__r1],A
 020F 5000              mov A,0
 0211 3BFB              cmp A,[X-5]
 0213 B00D              jnz L43
 0215 5100              mov A,[__r1]
 0217 3BFC              cmp A,[X-4]
 0219 B007              jnz L43
 021B           X7:
 021B                   .dbline 221
 021B           ;                                               {
 021B                   .dbline 222
 021B           ;                                                       success = 1;
 021B 560101            mov [X+1],1
 021E 560000            mov [X+0],0
 0221                   .dbline 223
 0221           ;                                               }
 0221           L43:
 0221                   .dbline 224
 0221           ;                                       }
 0221           L41:
 0221                   .dbline 225
 0221           ;                               }
 0221           L39:
 0221                   .dbline 226
 0221           ;                       }
 0221           L37:
 0221                   .dbline 227
 0221           ;               }
 0221           L35:
 0221                   .dbline 228
 0221           ;       }
 0221           L33:
 0221                   .dbline 209
 0221 62D000            mov REG[0xd0],>_TIMEOUT
 0224 5101              mov A,[_TIMEOUT+1]
 0226 1105              sub A,5
 0228 5100              mov A,[_TIMEOUT]
 022A 3180              xor A,-128
 022C 1980              sbb A,(0 ^ 0x80)
 022E D00B              jnc L45
 0230           X8:
 0230 3D0000            cmp [X+0],0
 0233 B006              jnz X9
 0235 3D0100            cmp [X+1],0
 0238 AFA1              jz L32
 023A           X9:
 023A           L45:
 023A                   .dbline 230
 023A           ;       
 023A           ;       LCD_1_Start();
 023A 10                push X
 023B 7C0000            xcall _LCD_1_Start
 023E 20                pop X
 023F                   .dbline 231
 023F           ;       LCD_1_Position(0,0);
 023F 10                push X
 0240 5000              mov A,0
 0242 5C                mov X,A
 0243 7C0000            xcall _LCD_1_Position
 0246 20                pop X
 0247                   .dbline 232
 0247           ;       LCD_1_PrHexInt(NUM_MODULES);
 0247 10                push X
 0248 62D000            mov REG[0xd0],>_NUM_MODULES
 024B 5100              mov A,[_NUM_MODULES]
 024D 08                push A
 024E 5101              mov A,[_NUM_MODULES+1]
 0250 20                pop X
 0251 7C0000            xcall _LCD_1_PrHexInt
 0254 20                pop X
 0255                   .dbline 233
 0255           ;       LCD_1_Position(0,5);
 0255 10                push X
 0256 5705              mov X,5
 0258 5000              mov A,0
 025A 7C0000            xcall _LCD_1_Position
 025D 20                pop X
 025E                   .dbline 234
 025E           ;       LCD_1_PrCString("Modules!");
 025E 10                push X
 025F 5000              mov A,>L46
 0261 08                push A
 0262 5000              mov A,<L46
 0264 5C                mov X,A
 0265 18                pop A
 0266 7C0000            xcall _LCD_1_PrCString
 0269                   .dbline 236
 0269           ;       
 0269           ;       RX_TIMEOUT_Stop();
 0269 7C0000            xcall _RX_TIMEOUT_Stop
 026C 20                pop X
 026D                   .dbline 237
 026D           ;       TIMEOUT = 0;
 026D 62D000            mov REG[0xd0],>_TIMEOUT
 0270 550100            mov [_TIMEOUT+1],0
 0273 550000            mov [_TIMEOUT],0
 0276                   .dbline 238
 0276           ;       RX_TIMEOUT_Start();
 0276 10                push X
 0277 7C0000            xcall _RX_TIMEOUT_Start
 027A 20                pop X
 027B                   .dbline 240
 027B           ;       
 027B           ;       return success;
 027B 62D000            mov REG[0xd0],>__r0
 027E 5201              mov A,[X+1]
 0280 5300              mov [__r1],A
 0282 5200              mov A,[X+0]
 0284 5300              mov [__r0],A
 0286                   .dbline -2
 0286           L28:
 0286 38FE              add SP,-2
 0288 20                pop X
 0289                   .dbline 0 ; func end
 0289 7F                ret
 028A                   .dbsym l success 0 I
 028A                   .dbsym l assigned_ID -5 I
 028A                   .dbend
 028A                   .dbfunc e clearConfig _clearConfig fI
 028A           ;       response -> X+0
 028A           ;      module_id -> X-5
 028A           _clearConfig::
 028A                   .dbline -1
 028A 10                push X
 028B 4F                mov X,SP
 028C 3802              add SP,2
 028E                   .dbline 244
 028E           ; }
 028E           ; 
 028E           ; int clearConfig(int module_id)
 028E           ; {
 028E                   .dbline 245
 028E           ;       int response = 0;
 028E 560100            mov [X+1],0
 0291 560000            mov [X+0],0
 0294                   .dbline 247
 0294           ;       
 0294           ;       configToggle(TX_MODE);  // Toggle into TX mode.
 0294 5000              mov A,0
 0296 08                push A
 0297 08                push A
 0298 966D              xcall _configToggle
 029A 38FE              add SP,-2
 029C                   .dbline 250
 029C           ;                       
 029C           ;       // Transmit a hello.
 029C           ;       TRANSMIT_PutChar(START_TRANSMIT);
 029C 10                push X
 029D 50FC              mov A,-4
 029F 7C0000            xcall _TRANSMIT_PutChar
 02A2 20                pop X
 02A3                   .dbline 251
 02A3           ;       TRANSMIT_PutChar(START_TRANSMIT);
 02A3 10                push X
 02A4 50FC              mov A,-4
 02A6 7C0000            xcall _TRANSMIT_PutChar
 02A9 20                pop X
 02AA                   .dbline 252
 02AA           ;       TRANSMIT_PutChar(MASTER_ID);
 02AA 10                push X
 02AB 5000              mov A,0
 02AD 7C0000            xcall _TRANSMIT_PutChar
 02B0 20                pop X
 02B1                   .dbline 253
 02B1           ;       TRANSMIT_PutChar(module_id);
 02B1 62D000            mov REG[0xd0],>__r0
 02B4 52FC              mov A,[X-4]
 02B6 10                push X
 02B7 7C0000            xcall _TRANSMIT_PutChar
 02BA 20                pop X
 02BB                   .dbline 254
 02BB           ;       TRANSMIT_PutChar(CLEAR_CONFIG);
 02BB 10                push X
 02BC 50CC              mov A,-52
 02BE 7C0000            xcall _TRANSMIT_PutChar
 02C1 20                pop X
 02C2                   .dbline 255
 02C2           ;       TRANSMIT_PutChar(END_TRANSMIT);
 02C2 10                push X
 02C3 50FD              mov A,-3
 02C5 7C0000            xcall _TRANSMIT_PutChar
 02C8 20                pop X
 02C9                   .dbline 256
 02C9           ;       TRANSMIT_PutChar(END_TRANSMIT);
 02C9 10                push X
 02CA 50FD              mov A,-3
 02CC 7C0000            xcall _TRANSMIT_PutChar
 02CF 20                pop X
 02D0           L48:
 02D0                   .dbline 259
 02D0           ;       
 02D0           ;       // Wait for the transmission to finish.
 02D0           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 02D0           L49:
 02D0                   .dbline 259
 02D0 10                push X
 02D1 7C0000            xcall _TRANSMIT_bReadTxStatus
 02D4 62D000            mov REG[0xd0],>__r0
 02D7 20                pop X
 02D8 5300              mov [__r0],A
 02DA 470020            tst [__r0],32
 02DD AFF2              jz L48
 02DF                   .dbline 261
 02DF           ;       
 02DF           ;       xmitWait();
 02DF 7C0B5E            xcall _xmitWait
 02E2                   .dbline 263
 02E2           ;       
 02E2           ;       configToggle(RX_MODE);  // Listen for the response.
 02E2 5000              mov A,0
 02E4 08                push A
 02E5 5001              mov A,1
 02E7 08                push A
 02E8 961D              xcall _configToggle
 02EA 38FE              add SP,-2
 02EC                   .dbline 265
 02EC           ;       
 02EC           ;       if(module_id != BROADCAST)
 02EC 3DFB00            cmp [X-5],0
 02EF B006              jnz X10
 02F1 3DFCFE            cmp [X-4],-2
 02F4 A089              jz L51
 02F6           X10:
 02F6                   .dbline 266
 02F6           ;       {
 02F6                   .dbline 267
 02F6           ;               RX_TIMEOUT_Stop();
 02F6 10                push X
 02F7 7C0000            xcall _RX_TIMEOUT_Stop
 02FA 20                pop X
 02FB                   .dbline 268
 02FB           ;               TIMEOUT = 0;
 02FB 62D000            mov REG[0xd0],>_TIMEOUT
 02FE 550100            mov [_TIMEOUT+1],0
 0301 550000            mov [_TIMEOUT],0
 0304                   .dbline 269
 0304           ;               RX_TIMEOUT_Start();
 0304 10                push X
 0305 7C0000            xcall _RX_TIMEOUT_Start
 0308 20                pop X
 0309 8048              xjmp L54
 030B           L53:
 030B                   .dbline 272
 030B           ;               
 030B           ;               while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
 030B           ;               {
 030B                   .dbline 273
 030B           ;                       if(RECEIVE_cReadChar() == START_TRANSMIT)
 030B 10                push X
 030C 7C0000            xcall _RECEIVE_cReadChar
 030F 62D000            mov REG[0xd0],>__r0
 0312 20                pop X
 0313 39FC              cmp A,-4
 0315 B03C              jnz L56
 0317                   .dbline 274
 0317           ;                       {       
 0317                   .dbline 275
 0317           ;                               if(validTransmission())
 0317 90C9              xcall _validTransmission
 0319 62D000            mov REG[0xd0],>__r0
 031C 3C0000            cmp [__r0],0
 031F B006              jnz X11
 0321 3C0000            cmp [__r1],0
 0324 A02D              jz L58
 0326           X11:
 0326                   .dbline 276
 0326           ;                               {
 0326                   .dbline 277
 0326           ;                                       if(COMMAND_TYPE == CONFIG_CLEARED)      // This is the response we are looking for.
 0326 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0329 3C00CD            cmp [_COMMAND_TYPE],-51
 032C B025              jnz L60
 032E                   .dbline 278
 032E           ;                                       {
 032E                   .dbline 280
 032E           ;                                               // If this is for me, check who it was from.
 032E           ;                                               if(COMMAND_DESTINATION == MASTER_ID)
 032E 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0331 3C0000            cmp [_COMMAND_DESTINATION],0
 0334 B01D              jnz L62
 0336                   .dbline 281
 0336           ;                                               {
 0336                   .dbline 282
 0336           ;                                                       if(COMMAND_SOURCE == module_id)
 0336 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0339 5100              mov A,[_COMMAND_SOURCE]
 033B 62D000            mov REG[0xd0],>__r0
 033E 5300              mov [__r1],A
 0340 5000              mov A,0
 0342 3BFB              cmp A,[X-5]
 0344 B00D              jnz L64
 0346 5100              mov A,[__r1]
 0348 3BFC              cmp A,[X-4]
 034A B007              jnz L64
 034C           X12:
 034C                   .dbline 283
 034C           ;                                                       {
 034C                   .dbline 284
 034C           ;                                                               response = 1;
 034C 560101            mov [X+1],1
 034F 560000            mov [X+0],0
 0352                   .dbline 285
 0352           ;                                                       }
 0352           L64:
 0352                   .dbline 286
 0352           ;                                               }
 0352           L62:
 0352                   .dbline 287
 0352           ;                                       }
 0352           L60:
 0352                   .dbline 288
 0352           ;                               }
 0352           L58:
 0352                   .dbline 289
 0352           ;                       }
 0352           L56:
 0352                   .dbline 290
 0352           ;               }
 0352           L54:
 0352                   .dbline 271
 0352 62D000            mov REG[0xd0],>_TIMEOUT
 0355 5101              mov A,[_TIMEOUT+1]
 0357 1105              sub A,5
 0359 5100              mov A,[_TIMEOUT]
 035B 3180              xor A,-128
 035D 1980              sbb A,(0 ^ 0x80)
 035F D00B              jnc L66
 0361           X13:
 0361 3D0000            cmp [X+0],0
 0364 B006              jnz X14
 0366 3D0100            cmp [X+1],0
 0369 AFA1              jz L53
 036B           X14:
 036B           L66:
 036B                   .dbline 292
 036B           ;               
 036B           ;               RX_TIMEOUT_Stop();
 036B 10                push X
 036C 7C0000            xcall _RX_TIMEOUT_Stop
 036F 20                pop X
 0370                   .dbline 293
 0370           ;               TIMEOUT = 0;
 0370 62D000            mov REG[0xd0],>_TIMEOUT
 0373 550100            mov [_TIMEOUT+1],0
 0376 550000            mov [_TIMEOUT],0
 0379                   .dbline 294
 0379           ;               RX_TIMEOUT_Start();
 0379 10                push X
 037A 7C0000            xcall _RX_TIMEOUT_Start
 037D 20                pop X
 037E                   .dbline 295
 037E           ;       }
 037E           L51:
 037E                   .dbline 297
 037E           ;       
 037E           ;       return response;
 037E 62D000            mov REG[0xd0],>__r0
 0381 5201              mov A,[X+1]
 0383 5300              mov [__r1],A
 0385 5200              mov A,[X+0]
 0387 5300              mov [__r0],A
 0389                   .dbline -2
 0389           L47:
 0389 38FE              add SP,-2
 038B 20                pop X
 038C                   .dbline 0 ; func end
 038C 7F                ret
 038D                   .dbsym l response 0 I
 038D                   .dbsym l module_id -5 I
 038D                   .dbend
 038D                   .dbfunc e sayHello _sayHello fV
 038D           _sayHello::
 038D                   .dbline -1
 038D                   .dbline 302
 038D           ; }
 038D           ; 
 038D           ; // This function transmits a hello message.
 038D           ; void sayHello(void)
 038D           ; {
 038D                   .dbline 303
 038D           ;       configToggle(TX_MODE);                          // Toggle into TX mode.
 038D 5000              mov A,0
 038F 08                push A
 0390 08                push A
 0391 9574              xcall _configToggle
 0393 38FE              add SP,-2
 0395                   .dbline 306
 0395           ;                       
 0395           ;       // Transmit a hello.
 0395           ;       TRANSMIT_PutChar(START_TRANSMIT);
 0395 10                push X
 0396 50FC              mov A,-4
 0398 7C0000            xcall _TRANSMIT_PutChar
 039B 20                pop X
 039C                   .dbline 307
 039C           ;       TRANSMIT_PutChar(START_TRANSMIT);
 039C 10                push X
 039D 50FC              mov A,-4
 039F 7C0000            xcall _TRANSMIT_PutChar
 03A2 20                pop X
 03A3                   .dbline 308
 03A3           ;       TRANSMIT_PutChar(MASTER_ID);
 03A3 10                push X
 03A4 5000              mov A,0
 03A6 7C0000            xcall _TRANSMIT_PutChar
 03A9 20                pop X
 03AA                   .dbline 309
 03AA           ;       TRANSMIT_PutChar(BLANK_MODULE_ID);
 03AA 10                push X
 03AB 50FB              mov A,-5
 03AD 7C0000            xcall _TRANSMIT_PutChar
 03B0 20                pop X
 03B1                   .dbline 310
 03B1           ;       TRANSMIT_PutChar(HELLO_BYTE);
 03B1 10                push X
 03B2 50C8              mov A,-56
 03B4 7C0000            xcall _TRANSMIT_PutChar
 03B7 20                pop X
 03B8                   .dbline 311
 03B8           ;       TRANSMIT_PutChar(END_TRANSMIT);
 03B8 10                push X
 03B9 50FD              mov A,-3
 03BB 7C0000            xcall _TRANSMIT_PutChar
 03BE 20                pop X
 03BF                   .dbline 312
 03BF           ;       TRANSMIT_PutChar(END_TRANSMIT);
 03BF 10                push X
 03C0 50FD              mov A,-3
 03C2 7C0000            xcall _TRANSMIT_PutChar
 03C5 20                pop X
 03C6           L68:
 03C6                   .dbline 315
 03C6           ;       
 03C6           ;       // Wait for the transmission to finish.
 03C6           ;       while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
 03C6           L69:
 03C6                   .dbline 315
 03C6 10                push X
 03C7 7C0000            xcall _TRANSMIT_bReadTxStatus
 03CA 62D000            mov REG[0xd0],>__r0
 03CD 20                pop X
 03CE 5300              mov [__r0],A
 03D0 470020            tst [__r0],32
 03D3 AFF2              jz L68
 03D5                   .dbline 317
 03D5           ;       
 03D5           ;       xmitWait();
 03D5 9787              xcall _xmitWait
 03D7                   .dbline 319
 03D7           ;       
 03D7           ;       configToggle(RX_MODE);                          // Listen for the response.
 03D7 5000              mov A,0
 03D9 08                push A
 03DA 5001              mov A,1
 03DC 08                push A
 03DD 9528              xcall _configToggle
 03DF 38FE              add SP,-2
 03E1                   .dbline -2
 03E1           L67:
 03E1                   .dbline 0 ; func end
 03E1 7F                ret
 03E2                   .dbend
 03E2                   .dbfunc e validTransmission _validTransmission fI
 03E2           ; valid_transmit -> X+0
 03E2           _validTransmission::
 03E2                   .dbline -1
 03E2 10                push X
 03E3 4F                mov X,SP
 03E4 3802              add SP,2
 03E6                   .dbline 324
 03E6           ; }
 03E6           ; 
 03E6           ; // This function returns whether or not a valid transmission has been received.
 03E6           ; int validTransmission(void)
 03E6           ; {
 03E6                   .dbline 325
 03E6           ;       int valid_transmit = 0;
 03E6 560100            mov [X+1],0
 03E9 560000            mov [X+0],0
 03EC                   .dbline 327
 03EC           ;       
 03EC           ;       if(RECEIVE_cGetChar() == START_TRANSMIT)
 03EC 10                push X
 03ED 7C0000            xcall _RECEIVE_cGetChar
 03F0 62D000            mov REG[0xd0],>__r0
 03F3 20                pop X
 03F4 39FC              cmp A,-4
 03F6 B02F              jnz L72
 03F8                   .dbline 328
 03F8           ;       {
 03F8                   .dbline 329
 03F8           ;               COMMAND_SOURCE = RECEIVE_cGetChar();
 03F8 10                push X
 03F9 7C0000            xcall _RECEIVE_cGetChar
 03FC 20                pop X
 03FD 62D000            mov REG[0xd0],>_COMMAND_SOURCE
 0400 5300              mov [_COMMAND_SOURCE],A
 0402                   .dbline 330
 0402           ;               COMMAND_DESTINATION = RECEIVE_cGetChar();
 0402 10                push X
 0403 7C0000            xcall _RECEIVE_cGetChar
 0406 20                pop X
 0407 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 040A 5300              mov [_COMMAND_DESTINATION],A
 040C                   .dbline 331
 040C           ;               COMMAND_TYPE = RECEIVE_cGetChar();
 040C 10                push X
 040D 7C0000            xcall _RECEIVE_cGetChar
 0410 20                pop X
 0411 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0414 5300              mov [_COMMAND_TYPE],A
 0416                   .dbline 332
 0416           ;               PARAM1 = RECEIVE_cGetChar();
 0416 10                push X
 0417 7C0000            xcall _RECEIVE_cGetChar
 041A 20                pop X
 041B 62D000            mov REG[0xd0],>_PARAM1
 041E 5300              mov [_PARAM1],A
 0420                   .dbline 334
 0420           ;               
 0420           ;               valid_transmit = 1;
 0420 560101            mov [X+1],1
 0423 560000            mov [X+0],0
 0426                   .dbline 335
 0426           ;       }
 0426           L72:
 0426                   .dbline 337
 0426           ;       
 0426           ;       return valid_transmit;
 0426 62D000            mov REG[0xd0],>__r0
 0429 5201              mov A,[X+1]
 042B 5300              mov [__r1],A
 042D 5200              mov A,[X+0]
 042F 5300              mov [__r0],A
 0431                   .dbline -2
 0431           L71:
 0431 38FE              add SP,-2
 0433 20                pop X
 0434                   .dbline 0 ; func end
 0434 7F                ret
 0435                   .dbsym l valid_transmit 0 I
 0435                   .dbend
 0435                   .dbfunc e decodeTransmission _decodeTransmission fV
 0435           ;       tempByte -> X+7
 0435           ;          angle -> X+5
 0435           ;             ID -> X+4
 0435           ;          total -> X+2
 0435           ;          param -> X+0
 0435           _decodeTransmission::
 0435                   .dbline -1
 0435 10                push X
 0436 4F                mov X,SP
 0437 3808              add SP,8
 0439                   .dbline 342
 0439           ; }
 0439           ; 
 0439           ; // This function decodes the transmission and takes the correct action.
 0439           ; void decodeTransmission(void)
 0439           ; {
 0439                   .dbline 347
 0439           ;       char* param;
 0439           ;       char ID;
 0439           ;       char tempByte;
 0439           ;       char angle[2];
 0439           ;       int total = 0;
 0439 560300            mov [X+3],0
 043C 560200            mov [X+2],0
 043F                   .dbline 349
 043F           ;       
 043F           ;       if(param = COMP_SERIAL_szGetParam())
 043F 10                push X
 0440 7C0000            xcall _COMP_SERIAL_szGetParam
 0443 62D000            mov REG[0xd0],>__r0
 0446 5300              mov [__r0],A
 0448 5A00              mov [__r1],X
 044A 20                pop X
 044B 5100              mov A,[__r1]
 044D 5401              mov [X+1],A
 044F 5100              mov A,[__r0]
 0451 5400              mov [X+0],A
 0453 3C0000            cmp [__r0],0
 0456 B006              jnz X15
 0458 3C0000            cmp [__r1],0
 045B A34F              jz L75
 045D           X15:
 045D                   .dbline 350
 045D           ;       {
 045D                   .dbline 351
 045D           ;               if((param[0] == 'n') || (param[0] == 'N'))
 045D 62D000            mov REG[0xd0],>__r0
 0460 5201              mov A,[X+1]
 0462 5300              mov [__r1],A
 0464 5200              mov A,[X+0]
 0466 60D4              mov REG[0xd4],A
 0468 3E00              mvi A,[__r1]
 046A 5300              mov [__r1],A
 046C 550000            mov [__r0],0
 046F 3C0000            cmp [__r0],0
 0472 B005              jnz X16
 0474 396E              cmp A,110
 0476 A00E              jz L79
 0478           X16:
 0478 62D000            mov REG[0xd0],>__r0
 047B 3C0000            cmp [__r0],0
 047E B03A              jnz L77
 0480 3C004E            cmp [__r1],78
 0483 B035              jnz L77
 0485           X17:
 0485           L79:
 0485                   .dbline 352
 0485           ;               {
 0485                   .dbline 353
 0485           ;                       COMP_SERIAL_CmdReset();
 0485 10                push X
 0486 7C0000            xcall _COMP_SERIAL_CmdReset
 0489 20                pop X
 048A                   .dbline 354
 048A           ;                       itoa(param,NUM_MODULES,10);
 048A 5000              mov A,0
 048C 08                push A
 048D 500A              mov A,10
 048F 08                push A
 0490 62D000            mov REG[0xd0],>_NUM_MODULES
 0493 5100              mov A,[_NUM_MODULES]
 0495 08                push A
 0496 5101              mov A,[_NUM_MODULES+1]
 0498 08                push A
 0499 5200              mov A,[X+0]
 049B 08                push A
 049C 5201              mov A,[X+1]
 049E 08                push A
 049F 7C0000            xcall _itoa
 04A2 38FA              add SP,-6
 04A4                   .dbline 355
 04A4           ;                       COMP_SERIAL_PutString(param);
 04A4 10                push X
 04A5 5200              mov A,[X+0]
 04A7 08                push A
 04A8 5201              mov A,[X+1]
 04AA 5C                mov X,A
 04AB 18                pop A
 04AC 7C0000            xcall _COMP_SERIAL_PutString
 04AF 20                pop X
 04B0                   .dbline 356
 04B0           ;                       COMP_SERIAL_PutChar('\n');
 04B0 10                push X
 04B1 500A              mov A,10
 04B3 7C0000            xcall _COMP_SERIAL_PutChar
 04B6 20                pop X
 04B7                   .dbline 357
 04B7           ;               }
 04B7 82F3              xjmp L78
 04B9           L77:
 04B9                   .dbline 358
 04B9           ;               else if((param[0] == 'w') || (param[0] == 'W'))
 04B9 62D000            mov REG[0xd0],>__r0
 04BC 5201              mov A,[X+1]
 04BE 5300              mov [__r1],A
 04C0 5200              mov A,[X+0]
 04C2 60D4              mov REG[0xd4],A
 04C4 3E00              mvi A,[__r1]
 04C6 5300              mov [__r1],A
 04C8 550000            mov [__r0],0
 04CB 3C0000            cmp [__r0],0
 04CE B005              jnz X18
 04D0 3977              cmp A,119
 04D2 A00E              jz L82
 04D4           X18:
 04D4 62D000            mov REG[0xd0],>__r0
 04D7 3C0000            cmp [__r0],0
 04DA B16B              jnz L80
 04DC 3C0057            cmp [__r1],87
 04DF B166              jnz L80
 04E1           X19:
 04E1           L82:
 04E1                   .dbline 359
 04E1           ;               {
 04E1                   .dbline 360
 04E1           ;                       if(param = COMP_SERIAL_szGetParam())
 04E1 10                push X
 04E2 7C0000            xcall _COMP_SERIAL_szGetParam
 04E5 62D000            mov REG[0xd0],>__r0
 04E8 5300              mov [__r0],A
 04EA 5A00              mov [__r1],X
 04EC 20                pop X
 04ED 5100              mov A,[__r1]
 04EF 5401              mov [X+1],A
 04F1 5100              mov A,[__r0]
 04F3 5400              mov [X+0],A
 04F5 3C0000            cmp [__r0],0
 04F8 B006              jnz X20
 04FA 3C0000            cmp [__r1],0
 04FD A2AD              jz L81
 04FF           X20:
 04FF                   .dbline 361
 04FF           ;                       {
 04FF                   .dbline 362
 04FF           ;                               ID = atoi(param);
 04FF 5200              mov A,[X+0]
 0501 08                push A
 0502 5201              mov A,[X+1]
 0504 08                push A
 0505 7C0000            xcall _atoi
 0508 38FE              add SP,-2
 050A 62D000            mov REG[0xd0],>__r0
 050D 5100              mov A,[__r1]
 050F 5404              mov [X+4],A
 0511                   .dbline 363
 0511           ;                               if(param = COMP_SERIAL_szGetParam())
 0511 10                push X
 0512 7C0000            xcall _COMP_SERIAL_szGetParam
 0515 62D000            mov REG[0xd0],>__r0
 0518 5300              mov [__r0],A
 051A 5A00              mov [__r1],X
 051C 20                pop X
 051D 5100              mov A,[__r1]
 051F 5401              mov [X+1],A
 0521 5100              mov A,[__r0]
 0523 5400              mov [X+0],A
 0525 3C0000            cmp [__r0],0
 0528 B006              jnz X21
 052A 3C0000            cmp [__r1],0
 052D A27D              jz L81
 052F           X21:
 052F                   .dbline 364
 052F           ;                               {
 052F                   .dbline 365
 052F           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 052F 62D000            mov REG[0xd0],>__r0
 0532 5201              mov A,[X+1]
 0534 5300              mov [__r1],A
 0536 5200              mov A,[X+0]
 0538 60D4              mov REG[0xd4],A
 053A 3E00              mvi A,[__r1]
 053C 5300              mov [__r1],A
 053E 550000            mov [__r0],0
 0541 3C0000            cmp [__r0],0
 0544 B005              jnz X22
 0546 3961              cmp A,97
 0548 A00E              jz L89
 054A           X22:
 054A 62D000            mov REG[0xd0],>__r0
 054D 3C0000            cmp [__r0],0
 0550 B089              jnz L87
 0552 3C0041            cmp [__r1],65
 0555 B084              jnz L87
 0557           X23:
 0557           L89:
 0557                   .dbline 366
 0557           ;                                       {
 0557                   .dbline 367
 0557           ;                                               if(param = COMP_SERIAL_szGetParam())
 0557 10                push X
 0558 7C0000            xcall _COMP_SERIAL_szGetParam
 055B 62D000            mov REG[0xd0],>__r0
 055E 5300              mov [__r0],A
 0560 5A00              mov [__r1],X
 0562 20                pop X
 0563 5100              mov A,[__r1]
 0565 5401              mov [X+1],A
 0567 5100              mov A,[__r0]
 0569 5400              mov [X+0],A
 056B 3C0000            cmp [__r0],0
 056E B006              jnz X24
 0570 3C0000            cmp [__r1],0
 0573 A237              jz L81
 0575           X24:
 0575                   .dbline 368
 0575           ;                                               {
 0575                   .dbline 369
 0575           ;                                                       COMP_SERIAL_CmdReset();
 0575 10                push X
 0576 7C0000            xcall _COMP_SERIAL_CmdReset
 0579 20                pop X
 057A                   .dbline 370
 057A           ;                                                       total = atoi(param);
 057A 5200              mov A,[X+0]
 057C 08                push A
 057D 5201              mov A,[X+1]
 057F 08                push A
 0580 7C0000            xcall _atoi
 0583 38FE              add SP,-2
 0585 62D000            mov REG[0xd0],>__r0
 0588 5100              mov A,[__r1]
 058A 5403              mov [X+3],A
 058C 5100              mov A,[__r0]
 058E 5402              mov [X+2],A
 0590                   .dbline 371
 0590           ;                                                       angle[0] = total%256;
 0590 5001              mov A,1
 0592 08                push A
 0593 5000              mov A,0
 0595 08                push A
 0596 5202              mov A,[X+2]
 0598 08                push A
 0599 5203              mov A,[X+3]
 059B 08                push A
 059C 7C0000            xcall __divmod_16X16_16
 059F 38FE              add SP,-2
 05A1 18                pop A
 05A2 5300              mov [__r1],A
 05A4 18                pop A
 05A5 5100              mov A,[__r1]
 05A7 5405              mov [X+5],A
 05A9                   .dbline 372
 05A9           ;                                                       angle[1] = total/256;
 05A9 5001              mov A,1
 05AB 08                push A
 05AC 5000              mov A,0
 05AE 08                push A
 05AF 5202              mov A,[X+2]
 05B1 08                push A
 05B2 5203              mov A,[X+3]
 05B4 08                push A
 05B5 7C0000            xcall __divmod_16X16_16
 05B8 18                pop A
 05B9 5300              mov [__r1],A
 05BB 18                pop A
 05BC 38FE              add SP,-2
 05BE 5100              mov A,[__r1]
 05C0 5406              mov [X+6],A
 05C2                   .dbline 373
 05C2           ;                                                       longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
 05C2 5206              mov A,[X+6]
 05C4 08                push A
 05C5 5205              mov A,[X+5]
 05C7 08                push A
 05C8 501E              mov A,30
 05CA 08                push A
 05CB 5003              mov A,3
 05CD 08                push A
 05CE 5005              mov A,5
 05D0 08                push A
 05D1 5204              mov A,[X+4]
 05D3 08                push A
 05D4 928F              xcall _longServoInstruction
 05D6 38FA              add SP,-6
 05D8                   .dbline 374
 05D8           ;                                               }
 05D8                   .dbline 375
 05D8           ;                                       }
 05D8 81D2              xjmp L81
 05DA           L87:
 05DA                   .dbline 376
 05DA           ;                                       else if((param[0] == 'p') || (param[0] == 'P'))
 05DA 62D000            mov REG[0xd0],>__r0
 05DD 5201              mov A,[X+1]
 05DF 5300              mov [__r1],A
 05E1 5200              mov A,[X+0]
 05E3 60D4              mov REG[0xd4],A
 05E5 3E00              mvi A,[__r1]
 05E7 5300              mov [__r1],A
 05E9 550000            mov [__r0],0
 05EC 3C0000            cmp [__r0],0
 05EF B005              jnz X25
 05F1 3970              cmp A,112
 05F3 A00E              jz L96
 05F5           X25:
 05F5 62D000            mov REG[0xd0],>__r0
 05F8 3C0000            cmp [__r0],0
 05FB B1AF              jnz L81
 05FD 3C0050            cmp [__r1],80
 0600 B1AA              jnz L81
 0602           X26:
 0602           L96:
 0602                   .dbline 377
 0602           ;                                       {
 0602                   .dbline 378
 0602           ;                                               if(param = COMP_SERIAL_szGetParam())
 0602 10                push X
 0603 7C0000            xcall _COMP_SERIAL_szGetParam
 0606 62D000            mov REG[0xd0],>__r0
 0609 5300              mov [__r0],A
 060B 5A00              mov [__r1],X
 060D 20                pop X
 060E 5100              mov A,[__r1]
 0610 5401              mov [X+1],A
 0612 5100              mov A,[__r0]
 0614 5400              mov [X+0],A
 0616 3C0000            cmp [__r0],0
 0619 B006              jnz X27
 061B 3C0000            cmp [__r1],0
 061E A18C              jz L81
 0620           X27:
 0620                   .dbline 379
 0620           ;                                               {
 0620                   .dbline 380
 0620           ;                                                       COMP_SERIAL_CmdReset();
 0620 10                push X
 0621 7C0000            xcall _COMP_SERIAL_CmdReset
 0624 20                pop X
 0625                   .dbline 381
 0625           ;                                                       servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
 0625 5200              mov A,[X+0]
 0627 08                push A
 0628 5201              mov A,[X+1]
 062A 08                push A
 062B 7C0000            xcall _atoi
 062E 62D000            mov REG[0xd0],>__r0
 0631 5100              mov A,[__r1]
 0633 08                push A
 0634 5018              mov A,24
 0636 08                push A
 0637 5003              mov A,3
 0639 08                push A
 063A 5004              mov A,4
 063C 08                push A
 063D 5204              mov A,[X+4]
 063F 08                push A
 0640 918F              xcall _servoInstruction
 0642 38F9              add SP,-7
 0644                   .dbline 382
 0644           ;                                               }
 0644                   .dbline 383
 0644           ;                                       }
 0644                   .dbline 384
 0644           ;                               }
 0644                   .dbline 385
 0644           ;                       }
 0644                   .dbline 386
 0644           ;               }
 0644 8166              xjmp L81
 0646           L80:
 0646                   .dbline 387
 0646           ;               else if((param[0] == 'r') || (param[0] == 'R'))
 0646 62D000            mov REG[0xd0],>__r0
 0649 5201              mov A,[X+1]
 064B 5300              mov [__r1],A
 064D 5200              mov A,[X+0]
 064F 60D4              mov REG[0xd4],A
 0651 3E00              mvi A,[__r1]
 0653 5300              mov [__r1],A
 0655 550000            mov [__r0],0
 0658 3C0000            cmp [__r0],0
 065B B005              jnz X28
 065D 3972              cmp A,114
 065F A00E              jz L101
 0661           X28:
 0661 62D000            mov REG[0xd0],>__r0
 0664 3C0000            cmp [__r0],0
 0667 B143              jnz L99
 0669 3C0052            cmp [__r1],82
 066C B13E              jnz L99
 066E           X29:
 066E           L101:
 066E                   .dbline 388
 066E           ;               {                       
 066E                   .dbline 389
 066E           ;                       if(param = COMP_SERIAL_szGetParam())
 066E 10                push X
 066F 7C0000            xcall _COMP_SERIAL_szGetParam
 0672 62D000            mov REG[0xd0],>__r0
 0675 5300              mov [__r0],A
 0677 5A00              mov [__r1],X
 0679 20                pop X
 067A 5100              mov A,[__r1]
 067C 5401              mov [X+1],A
 067E 5100              mov A,[__r0]
 0680 5400              mov [X+0],A
 0682 3C0000            cmp [__r0],0
 0685 B006              jnz X30
 0687 3C0000            cmp [__r1],0
 068A A120              jz L102
 068C           X30:
 068C                   .dbline 390
 068C           ;                       {
 068C                   .dbline 391
 068C           ;                               ID = atoi(param);
 068C 5200              mov A,[X+0]
 068E 08                push A
 068F 5201              mov A,[X+1]
 0691 08                push A
 0692 7C0000            xcall _atoi
 0695 38FE              add SP,-2
 0697 62D000            mov REG[0xd0],>__r0
 069A 5100              mov A,[__r1]
 069C 5404              mov [X+4],A
 069E                   .dbline 392
 069E           ;                               if(param = COMP_SERIAL_szGetParam())
 069E 10                push X
 069F 7C0000            xcall _COMP_SERIAL_szGetParam
 06A2 62D000            mov REG[0xd0],>__r0
 06A5 5300              mov [__r0],A
 06A7 5A00              mov [__r1],X
 06A9 20                pop X
 06AA 5100              mov A,[__r1]
 06AC 5401              mov [X+1],A
 06AE 5100              mov A,[__r0]
 06B0 5400              mov [X+0],A
 06B2 3C0000            cmp [__r0],0
 06B5 B006              jnz X31
 06B7 3C0000            cmp [__r1],0
 06BA A0F0              jz L104
 06BC           X31:
 06BC                   .dbline 393
 06BC           ;                               {
 06BC                   .dbline 394
 06BC           ;                                       if((param[0] == 'a') || (param[0] == 'A'))
 06BC 62D000            mov REG[0xd0],>__r0
 06BF 5201              mov A,[X+1]
 06C1 5300              mov [__r1],A
 06C3 5200              mov A,[X+0]
 06C5 60D4              mov REG[0xd4],A
 06C7 3E00              mvi A,[__r1]
 06C9 5300              mov [__r1],A
 06CB 550000            mov [__r0],0
 06CE 3C0000            cmp [__r0],0
 06D1 B005              jnz X32
 06D3 3961              cmp A,97
 06D5 A00E              jz L108
 06D7           X32:
 06D7 62D000            mov REG[0xd0],>__r0
 06DA 3C0000            cmp [__r0],0
 06DD B0CD              jnz L106
 06DF 3C0041            cmp [__r1],65
 06E2 B0C8              jnz L106
 06E4           X33:
 06E4           L108:
 06E4                   .dbline 395
 06E4           ;                                       {
 06E4                   .dbline 396
 06E4           ;                                               COMP_SERIAL_CmdReset();
 06E4 10                push X
 06E5 7C0000            xcall _COMP_SERIAL_CmdReset
 06E8 20                pop X
 06E9                   .dbline 397
 06E9           ;                                               tempByte = 2;
 06E9 560702            mov [X+7],2
 06EC                   .dbline 398
 06EC           ;                                               servoInstruction(ID,4,READ_SERVO,36,tempByte);
 06EC 5207              mov A,[X+7]
 06EE 08                push A
 06EF 5024              mov A,36
 06F1 08                push A
 06F2 5002              mov A,2
 06F4 08                push A
 06F5 5004              mov A,4
 06F7 08                push A
 06F8 5204              mov A,[X+4]
 06FA 08                push A
 06FB 90D4              xcall _servoInstruction
 06FD                   .dbline 399
 06FD           ;                                               configToggle(RX_MODE);
 06FD 5000              mov A,0
 06FF 08                push A
 0700 5001              mov A,1
 0702 08                push A
 0703 9202              xcall _configToggle
 0705 38F9              add SP,-7
 0707 8094              xjmp L110
 0709           L109:
 0709                   .dbline 403
 0709           ;                                                       
 0709           ;                                               // Loop until we read a response or time out.
 0709           ;                                               while(TIMEOUT < RX_TIMEOUT_DURATION)
 0709           ;                                               {
 0709                   .dbline 404
 0709           ;                                                       if(RECEIVE_cReadChar() == SERVO_START)
 0709 10                push X
 070A 7C0000            xcall _RECEIVE_cReadChar
 070D 62D000            mov REG[0xd0],>__r0
 0710 20                pop X
 0711 39FF              cmp A,-1
 0713 B088              jnz L112
 0715                   .dbline 405
 0715           ;                                                       {
 0715                   .dbline 406
 0715           ;                                                               if(RECEIVE_cGetChar() == SERVO_START)
 0715 10                push X
 0716 7C0000            xcall _RECEIVE_cGetChar
 0719 62D000            mov REG[0xd0],>__r0
 071C 20                pop X
 071D 39FF              cmp A,-1
 071F B07C              jnz L114
 0721                   .dbline 407
 0721           ;                                                               {
 0721                   .dbline 408
 0721           ;                                                                       if(RECEIVE_cGetChar() == ID)
 0721 10                push X
 0722 7C0000            xcall _RECEIVE_cGetChar
 0725 62D000            mov REG[0xd0],>__r0
 0728 20                pop X
 0729 3B04              cmp A,[X+4]
 072B B070              jnz L116
 072D                   .dbline 409
 072D           ;                                                                       {
 072D                   .dbline 410
 072D           ;                                                                               if(RECEIVE_cGetChar() == 4)
 072D 10                push X
 072E 7C0000            xcall _RECEIVE_cGetChar
 0731 62D000            mov REG[0xd0],>__r0
 0734 20                pop X
 0735 3904              cmp A,4
 0737 B064              jnz L118
 0739                   .dbline 411
 0739           ;                                                                               {
 0739                   .dbline 412
 0739           ;                                                                                       if(RECEIVE_cGetChar() == 0)
 0739 10                push X
 073A 7C0000            xcall _RECEIVE_cGetChar
 073D 62D000            mov REG[0xd0],>__r0
 0740 20                pop X
 0741 3900              cmp A,0
 0743 B058              jnz L120
 0745                   .dbline 413
 0745           ;                                                                                       {
 0745                   .dbline 414
 0745           ;                                                                                               angle[0] = RECEIVE_cGetChar();
 0745 10                push X
 0746 7C0000            xcall _RECEIVE_cGetChar
 0749 62D000            mov REG[0xd0],>__r0
 074C 20                pop X
 074D 5405              mov [X+5],A
 074F                   .dbline 415
 074F           ;                                                                                               angle[1] = RECEIVE_cGetChar();
 074F 10                push X
 0750 7C0000            xcall _RECEIVE_cGetChar
 0753 62D000            mov REG[0xd0],>__r0
 0756 20                pop X
 0757 5406              mov [X+6],A
 0759                   .dbline 417
 0759           ;                                                                                               
 0759           ;                                                                                               configToggle(PC_MODE);
 0759 5000              mov A,0
 075B 08                push A
 075C 5002              mov A,2
 075E 08                push A
 075F 91A6              xcall _configToggle
 0761                   .dbline 419
 0761           ;                                                                                               
 0761           ;                                                                                               total = ((angle[1])*256) + angle[0];
 0761 5205              mov A,[X+5]
 0763 5403              mov [X+3],A
 0765 5206              mov A,[X+6]
 0767 5402              mov [X+2],A
 0769                   .dbline 420
 0769           ;                                                                                               itoa(param,total,10);
 0769 5000              mov A,0
 076B 08                push A
 076C 500A              mov A,10
 076E 08                push A
 076F 5202              mov A,[X+2]
 0771 08                push A
 0772 5203              mov A,[X+3]
 0774 08                push A
 0775 5200              mov A,[X+0]
 0777 08                push A
 0778 5201              mov A,[X+1]
 077A 08                push A
 077B 7C0000            xcall _itoa
 077E 38F8              add SP,-8
 0780                   .dbline 421
 0780           ;                                                                                               COMP_SERIAL_PutString(param);
 0780 10                push X
 0781 5200              mov A,[X+0]
 0783 08                push A
 0784 5201              mov A,[X+1]
 0786 5C                mov X,A
 0787 18                pop A
 0788 7C0000            xcall _COMP_SERIAL_PutString
 078B 20                pop X
 078C                   .dbline 422
 078C           ;                                                                                               COMP_SERIAL_PutChar('\n');
 078C 10                push X
 078D 500A              mov A,10
 078F 7C0000            xcall _COMP_SERIAL_PutChar
 0792 20                pop X
 0793                   .dbline 424
 0793           ; 
 0793           ;                                                                                               TIMEOUT = RX_TIMEOUT_DURATION;
 0793 62D000            mov REG[0xd0],>_TIMEOUT
 0796 550105            mov [_TIMEOUT+1],5
 0799 550000            mov [_TIMEOUT],0
 079C                   .dbline 425
 079C           ;                                                                                       }
 079C           L120:
 079C                   .dbline 426
 079C           ;                                                                               }
 079C           L118:
 079C                   .dbline 427
 079C           ;                                                                       }
 079C           L116:
 079C                   .dbline 428
 079C           ;                                                               }
 079C           L114:
 079C                   .dbline 429
 079C           ;                                                       }
 079C           L112:
 079C                   .dbline 430
 079C           ;                                               }
 079C           L110:
 079C                   .dbline 402
 079C 62D000            mov REG[0xd0],>_TIMEOUT
 079F 5101              mov A,[_TIMEOUT+1]
 07A1 1105              sub A,5
 07A3 5100              mov A,[_TIMEOUT]
 07A5 3180              xor A,-128
 07A7 1980              sbb A,(0 ^ 0x80)
 07A9 CF5F              jc L109
 07AB           X34:
 07AB                   .dbline 431
 07AB           ;                                       }
 07AB           L106:
 07AB                   .dbline 432
 07AB           ;                               }
 07AB           L104:
 07AB                   .dbline 433
 07AB           ;                       }
 07AB           L102:
 07AB                   .dbline 434
 07AB           ;               }
 07AB           L99:
 07AB           L81:
 07AB           L78:
 07AB                   .dbline 435
 07AB           ;       }
 07AB           L75:
 07AB                   .dbline 437
 07AB           ;       
 07AB           ;       if(STATE != PC_MODE)
 07AB 62D000            mov REG[0xd0],>_STATE
 07AE 3C0000            cmp [_STATE],0
 07B1 B006              jnz X35
 07B3 3C0102            cmp [_STATE+1],2
 07B6 A00D              jz L124
 07B8           X35:
 07B8                   .dbline 438
 07B8           ;       {
 07B8                   .dbline 439
 07B8           ;               configToggle(PC_MODE);
 07B8 5000              mov A,0
 07BA 08                push A
 07BB 5002              mov A,2
 07BD 08                push A
 07BE 9147              xcall _configToggle
 07C0 38FE              add SP,-2
 07C2                   .dbline 440
 07C2           ;       }
 07C2 800A              xjmp L125
 07C4           L124:
 07C4                   .dbline 442
 07C4           ;       else
 07C4           ;       {
 07C4                   .dbline 443
 07C4           ;               TIMEOUT = 0;
 07C4 62D000            mov REG[0xd0],>_TIMEOUT
 07C7 550100            mov [_TIMEOUT+1],0
 07CA 550000            mov [_TIMEOUT],0
 07CD                   .dbline 444
 07CD           ;       }
 07CD           L125:
 07CD                   .dbline -2
 07CD           L74:
 07CD 38F8              add SP,-8
 07CF 20                pop X
 07D0                   .dbline 0 ; func end
 07D0 7F                ret
 07D1                   .dbsym l tempByte 7 c
 07D1                   .dbsym l angle 5 A[2:2]c
 07D1                   .dbsym l ID 4 c
 07D1                   .dbsym l total 2 I
 07D1                   .dbsym l param 0 pc
 07D1                   .dbend
 07D1                   .dbfunc e servoInstruction _servoInstruction fV
 07D1           ;          total -> X+1
 07D1           ;       checksum -> X+0
 07D1           ;          value -> X-8
 07D1           ;        address -> X-7
 07D1           ;    instruction -> X-6
 07D1           ;         length -> X-5
 07D1           ;             id -> X-4
 07D1           _servoInstruction::
 07D1                   .dbline -1
 07D1 10                push X
 07D2 4F                mov X,SP
 07D3 3803              add SP,3
 07D5                   .dbline 450
 07D5           ; }
 07D5           ; 
 07D5           ; // This function receives a destination, command length, instruction type, address, and value.
 07D5           ; // With these parameters, the function sends a packet to the communication bus.
 07D5           ; void servoInstruction(char id, char length, char instruction, char address, char value)
 07D5           ; {
 07D5                   .dbline 454
 07D5           ;       char checksum;
 07D5           ;       int total;
 07D5           ;       
 07D5           ;       total = id + length + instruction + address + value;
 07D5 62D000            mov REG[0xd0],>__r0
 07D8 52FB              mov A,[X-5]
 07DA 5300              mov [__r1],A
 07DC 550000            mov [__r0],0
 07DF 52FC              mov A,[X-4]
 07E1 0200              add A,[__r1]
 07E3 5300              mov [__r1],A
 07E5 5000              mov A,0
 07E7 0A00              adc A,[__r0]
 07E9 5300              mov [__r0],A
 07EB 52FA              mov A,[X-6]
 07ED 0400              add [__r1],A
 07EF 0E0000            adc [__r0],0
 07F2 52F9              mov A,[X-7]
 07F4 0400              add [__r1],A
 07F6 0E0000            adc [__r0],0
 07F9 52F8              mov A,[X-8]
 07FB 5300              mov [__r3],A
 07FD 550000            mov [__r2],0
 0800 5100              mov A,[__r1]
 0802 0200              add A,[__r3]
 0804 5402              mov [X+2],A
 0806 5100              mov A,[__r0]
 0808 0A00              adc A,[__r2]
 080A 5401              mov [X+1],A
 080C                   .dbline 457
 080C           ;       
 080C           ;       // Calculate the checksum value for our servo communication.
 080C           ;       checksum = 255-(total%256);
 080C 5001              mov A,1
 080E 08                push A
 080F 5000              mov A,0
 0811 08                push A
 0812 5201              mov A,[X+1]
 0814 08                push A
 0815 5202              mov A,[X+2]
 0817 08                push A
 0818 7C0000            xcall __divmod_16X16_16
 081B 38FE              add SP,-2
 081D 18                pop A
 081E 5300              mov [__r1],A
 0820 18                pop A
 0821 50FF              mov A,-1
 0823 1200              sub A,[__r1]
 0825 5400              mov [X+0],A
 0827                   .dbline 460
 0827           ;       
 0827           ;       // Talk to the servo.
 0827           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 0827 10                push X
 0828 50FF              mov A,-1
 082A 7C0000            xcall _TX_REPEATER_PutChar
 082D 20                pop X
 082E                   .dbline 461
 082E           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 082E 10                push X
 082F 50FF              mov A,-1
 0831 7C0000            xcall _TX_REPEATER_PutChar
 0834 20                pop X
 0835                   .dbline 462
 0835           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 0835 10                push X
 0836 52FC              mov A,[X-4]
 0838 7C0000            xcall _TX_REPEATER_PutChar
 083B 20                pop X
 083C                   .dbline 463
 083C           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 083C 10                push X
 083D 52FB              mov A,[X-5]
 083F 7C0000            xcall _TX_REPEATER_PutChar
 0842 20                pop X
 0843                   .dbline 464
 0843           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 0843 10                push X
 0844 52FA              mov A,[X-6]
 0846 7C0000            xcall _TX_REPEATER_PutChar
 0849 20                pop X
 084A                   .dbline 465
 084A           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 084A 10                push X
 084B 52F9              mov A,[X-7]
 084D 7C0000            xcall _TX_REPEATER_PutChar
 0850 20                pop X
 0851                   .dbline 466
 0851           ;       TX_REPEATER_PutChar(value);                     // The value to write or number of bytes to read.
 0851 10                push X
 0852 52F8              mov A,[X-8]
 0854 7C0000            xcall _TX_REPEATER_PutChar
 0857 20                pop X
 0858                   .dbline 467
 0858           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 0858 10                push X
 0859 5200              mov A,[X+0]
 085B 7C0000            xcall _TX_REPEATER_PutChar
 085E 20                pop X
 085F                   .dbline 473
 085F           ;       
 085F           ;       // Wait for the transmission to finish.
 085F           ;       //while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 085F           ;       
 085F           ;       // Make completely sure we're done.
 085F           ;       xmitWait();
 085F 92FD              xcall _xmitWait
 0861                   .dbline -2
 0861           L126:
 0861 38FD              add SP,-3
 0863 20                pop X
 0864                   .dbline 0 ; func end
 0864 7F                ret
 0865                   .dbsym l total 1 I
 0865                   .dbsym l checksum 0 c
 0865                   .dbsym l value -8 c
 0865                   .dbsym l address -7 c
 0865                   .dbsym l instruction -6 c
 0865                   .dbsym l length -5 c
 0865                   .dbsym l id -4 c
 0865                   .dbend
 0865                   .dbfunc e longServoInstruction _longServoInstruction fV
 0865           ;          total -> X+1
 0865           ;       checksum -> X+0
 0865           ;         value2 -> X-9
 0865           ;         value1 -> X-8
 0865           ;        address -> X-7
 0865           ;    instruction -> X-6
 0865           ;         length -> X-5
 0865           ;             id -> X-4
 0865           _longServoInstruction::
 0865                   .dbline -1
 0865 10                push X
 0866 4F                mov X,SP
 0867 3803              add SP,3
 0869                   .dbline 478
 0869           ; }
 0869           ; 
 0869           ; // This function receives a destination, command length, instruction type, address, and two values.
 0869           ; void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
 0869           ; {
 0869                   .dbline 482
 0869           ;       char checksum;
 0869           ;       int total;
 0869           ;       
 0869           ;       total = id + length + instruction + address + value1 + value2;
 0869 62D000            mov REG[0xd0],>__r0
 086C 52FB              mov A,[X-5]
 086E 5300              mov [__r1],A
 0870 550000            mov [__r0],0
 0873 52FC              mov A,[X-4]
 0875 0200              add A,[__r1]
 0877 5300              mov [__r1],A
 0879 5000              mov A,0
 087B 0A00              adc A,[__r0]
 087D 5300              mov [__r0],A
 087F 52FA              mov A,[X-6]
 0881 0400              add [__r1],A
 0883 0E0000            adc [__r0],0
 0886 52F9              mov A,[X-7]
 0888 0400              add [__r1],A
 088A 0E0000            adc [__r0],0
 088D 52F8              mov A,[X-8]
 088F 0400              add [__r1],A
 0891 0E0000            adc [__r0],0
 0894 52F7              mov A,[X-9]
 0896 5300              mov [__r3],A
 0898 550000            mov [__r2],0
 089B 5100              mov A,[__r1]
 089D 0200              add A,[__r3]
 089F 5402              mov [X+2],A
 08A1 5100              mov A,[__r0]
 08A3 0A00              adc A,[__r2]
 08A5 5401              mov [X+1],A
 08A7                   .dbline 485
 08A7           ;       
 08A7           ;       // Calculate the checksum value for our servo communication.
 08A7           ;       checksum = 255-(total%256);
 08A7 5001              mov A,1
 08A9 08                push A
 08AA 5000              mov A,0
 08AC 08                push A
 08AD 5201              mov A,[X+1]
 08AF 08                push A
 08B0 5202              mov A,[X+2]
 08B2 08                push A
 08B3 7C0000            xcall __divmod_16X16_16
 08B6 38FE              add SP,-2
 08B8 18                pop A
 08B9 5300              mov [__r1],A
 08BB 18                pop A
 08BC 50FF              mov A,-1
 08BE 1200              sub A,[__r1]
 08C0 5400              mov [X+0],A
 08C2                   .dbline 488
 08C2           ;       
 08C2           ;       // Talk to the servo.
 08C2           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte one
 08C2 10                push X
 08C3 50FF              mov A,-1
 08C5 7C0000            xcall _TX_REPEATER_PutChar
 08C8 20                pop X
 08C9                   .dbline 489
 08C9           ;       TX_REPEATER_PutChar(SERVO_START);       // Start byte two
 08C9 10                push X
 08CA 50FF              mov A,-1
 08CC 7C0000            xcall _TX_REPEATER_PutChar
 08CF 20                pop X
 08D0                   .dbline 490
 08D0           ;       TX_REPEATER_PutChar(id);                        // Servo ID
 08D0 10                push X
 08D1 52FC              mov A,[X-4]
 08D3 7C0000            xcall _TX_REPEATER_PutChar
 08D6 20                pop X
 08D7                   .dbline 491
 08D7           ;       TX_REPEATER_PutChar(length);            // The instruction length.
 08D7 10                push X
 08D8 52FB              mov A,[X-5]
 08DA 7C0000            xcall _TX_REPEATER_PutChar
 08DD 20                pop X
 08DE                   .dbline 492
 08DE           ;       TX_REPEATER_PutChar(instruction);       // The instruction to carry out.
 08DE 10                push X
 08DF 52FA              mov A,[X-6]
 08E1 7C0000            xcall _TX_REPEATER_PutChar
 08E4 20                pop X
 08E5                   .dbline 493
 08E5           ;       TX_REPEATER_PutChar(address);           // The address to read/write from/to.
 08E5 10                push X
 08E6 52F9              mov A,[X-7]
 08E8 7C0000            xcall _TX_REPEATER_PutChar
 08EB 20                pop X
 08EC                   .dbline 494
 08EC           ;       TX_REPEATER_PutChar(value1);            // The first value to write.
 08EC 10                push X
 08ED 52F8              mov A,[X-8]
 08EF 7C0000            xcall _TX_REPEATER_PutChar
 08F2 20                pop X
 08F3                   .dbline 495
 08F3           ;       TX_REPEATER_PutChar(value2);            // The first value to write.
 08F3 10                push X
 08F4 52F7              mov A,[X-9]
 08F6 7C0000            xcall _TX_REPEATER_PutChar
 08F9 20                pop X
 08FA                   .dbline 496
 08FA           ;       TX_REPEATER_PutChar(checksum);          // This is the checksum.
 08FA 10                push X
 08FB 5200              mov A,[X+0]
 08FD 7C0000            xcall _TX_REPEATER_PutChar
 0900 20                pop X
 0901                   .dbline 502
 0901           ;       
 0901           ;       // Wait for the transmission to finish.
 0901           ;       //while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
 0901           ;       
 0901           ;       // Make completely sure we're done.
 0901           ;       xmitWait();
 0901 925B              xcall _xmitWait
 0903                   .dbline -2
 0903           L127:
 0903 38FD              add SP,-3
 0905 20                pop X
 0906                   .dbline 0 ; func end
 0906 7F                ret
 0907                   .dbsym l total 1 I
 0907                   .dbsym l checksum 0 c
 0907                   .dbsym l value2 -9 c
 0907                   .dbsym l value1 -8 c
 0907                   .dbsym l address -7 c
 0907                   .dbsym l instruction -6 c
 0907                   .dbsym l length -5 c
 0907                   .dbsym l id -4 c
 0907                   .dbend
 0907                   .dbfunc e configToggle _configToggle fV
 0907           ;           mode -> X-5
 0907           _configToggle::
 0907                   .dbline -1
 0907 10                push X
 0908 4F                mov X,SP
 0909                   .dbline 508
 0909           ; }
 0909           ; 
 0909           ; // This function allows the program to pass an RX or TX mode flag for switching between modes on the
 0909           ; // half duplex UART serial communication line.
 0909           ; void configToggle(int mode)
 0909           ; {
 0909                   .dbline 510
 0909           ;       // Disconnect from the global bus and leave the pin high.
 0909           ;       PRT0DR |= 0b10000000;
 0909 430080            or REG[0],-128
 090C                   .dbline 511
 090C           ;       PRT0GS &= 0b01111111;
 090C 41027F            and REG[0x2],127
 090F                   .dbline 515
 090F           ; 
 090F           ;       // Unload the configuration of the current state.
 090F           ;       // If there is no state, blindly wipe all configurations.
 090F           ;       if(STATE)
 090F 62D000            mov REG[0xd0],>_STATE
 0912 3C0000            cmp [_STATE],0
 0915 B006              jnz X36
 0917 3C0100            cmp [_STATE+1],0
 091A A010              jz L129
 091C           X36:
 091C                   .dbline 516
 091C           ;       {
 091C                   .dbline 517
 091C           ;               unloadConfig(STATE);
 091C 62D000            mov REG[0xd0],>_STATE
 091F 5100              mov A,[_STATE]
 0921 08                push A
 0922 5101              mov A,[_STATE+1]
 0924 08                push A
 0925 90D9              xcall _unloadConfig
 0927 38FE              add SP,-2
 0929                   .dbline 518
 0929           ;       }
 0929 8003              xjmp L130
 092B           L129:
 092B                   .dbline 520
 092B           ;       else
 092B           ;       {
 092B                   .dbline 521
 092B           ;               unloadAllConfigs();
 092B 90C9              xcall _unloadAllConfigs
 092D                   .dbline 522
 092D           ;       }
 092D           L130:
 092D                   .dbline 524
 092D           ;       
 092D           ;       if(mode == PC_MODE)
 092D 3DFB00            cmp [X-5],0
 0930 B032              jnz L131
 0932 3DFC02            cmp [X-4],2
 0935 B02D              jnz L131
 0937           X37:
 0937                   .dbline 525
 0937           ;       {
 0937                   .dbline 526
 0937           ;               LoadConfig_pc_listener();
 0937 7C0000            xcall _LoadConfig_pc_listener
 093A                   .dbline 529
 093A           ;               
 093A           ;               //COMP_SERIAL_CmdReset();                                               // Initializes the RX buffer
 093A           ;               COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); // Enable RX interrupts  
 093A 10                push X
 093B 5001              mov A,1
 093D 7C0000            xcall _COMP_SERIAL_IntCntl
 0940 20                pop X
 0941                   .dbline 530
 0941           ;               COMP_SERIAL_Start(UART_PARITY_NONE);                    // Starts the UART.
 0941 10                push X
 0942 5000              mov A,0
 0944 7C0000            xcall _COMP_SERIAL_Start
 0947 20                pop X
 0948                   .dbline 532
 0948           ;               
 0948           ;               TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);             // Start the TX repeater.
 0948 10                push X
 0949 5000              mov A,0
 094B 7C0000            xcall _TX_REPEATER_Start
 094E 20                pop X
 094F                   .dbline 534
 094F           ;               
 094F           ;               TIMEOUT = 0;
 094F 62D000            mov REG[0xd0],>_TIMEOUT
 0952 550100            mov [_TIMEOUT+1],0
 0955 550000            mov [_TIMEOUT],0
 0958                   .dbline 535
 0958           ;               STATE = PC_MODE;
 0958 62D000            mov REG[0xd0],>_STATE
 095B 550102            mov [_STATE+1],2
 095E 550000            mov [_STATE],0
 0961                   .dbline 536
 0961           ;       }
 0961 807A              xjmp L132
 0963           L131:
 0963                   .dbline 537
 0963           ;       else if(mode == RX_MODE)
 0963 3DFB00            cmp [X-5],0
 0966 B02C              jnz L133
 0968 3DFC01            cmp [X-4],1
 096B B027              jnz L133
 096D           X38:
 096D                   .dbline 538
 096D           ;       {
 096D                   .dbline 539
 096D           ;               LoadConfig_receiver_config();
 096D 7C0000            xcall _LoadConfig_receiver_config
 0970                   .dbline 544
 0970           ;               
 0970           ;               // Clear the buffer.
 0970           ;               //RECEIVE_CmdReset();
 0970           ;               // Start the receiver.
 0970           ;               RECEIVE_Start(RECEIVE_PARITY_NONE);
 0970 10                push X
 0971 5000              mov A,0
 0973 7C0000            xcall _RECEIVE_Start
 0976 20                pop X
 0977                   .dbline 547
 0977           ;               
 0977           ;               // Start response timeout timer and enable its interrupt routine.
 0977           ;               TIMEOUT = 0;
 0977 62D000            mov REG[0xd0],>_TIMEOUT
 097A 550100            mov [_TIMEOUT+1],0
 097D 550000            mov [_TIMEOUT],0
 0980                   .dbline 548
 0980           ;               RX_TIMEOUT_EnableInt();
 0980 10                push X
 0981 7C0000            xcall _RX_TIMEOUT_EnableInt
 0984                   .dbline 549
 0984           ;               RX_TIMEOUT_Start();
 0984 7C0000            xcall _RX_TIMEOUT_Start
 0987 20                pop X
 0988                   .dbline 551
 0988           ;               
 0988           ;               STATE = RX_MODE;
 0988 62D000            mov REG[0xd0],>_STATE
 098B 550101            mov [_STATE+1],1
 098E 550000            mov [_STATE],0
 0991                   .dbline 552
 0991           ;       }
 0991 804A              xjmp L134
 0993           L133:
 0993                   .dbline 553
 0993           ;       else if(mode == TX_MODE)
 0993 3DFB00            cmp [X-5],0
 0996 B045              jnz L135
 0998 3DFC00            cmp [X-4],0
 099B B040              jnz L135
 099D           X39:
 099D                   .dbline 554
 099D           ;       {
 099D                   .dbline 555
 099D           ;               LoadConfig_transmitter_config();
 099D 7C0000            xcall _LoadConfig_transmitter_config
 09A0                   .dbline 557
 09A0           ;               // Start the transmitter.
 09A0           ;               TRANSMIT_Start(TRANSMIT_PARITY_NONE);
 09A0 10                push X
 09A1 5000              mov A,0
 09A3 7C0000            xcall _TRANSMIT_Start
 09A6 20                pop X
 09A7                   .dbline 559
 09A7           ;               
 09A7           ;               TIMEOUT = 0;
 09A7 62D000            mov REG[0xd0],>_TIMEOUT
 09AA 550100            mov [_TIMEOUT+1],0
 09AD 550000            mov [_TIMEOUT],0
 09B0                   .dbline 560
 09B0           ;               TX_TIMEOUT_EnableInt(); // Make sure interrupts are enabled.
 09B0 10                push X
 09B1 7C0000            xcall _TX_TIMEOUT_EnableInt
 09B4                   .dbline 561
 09B4           ;               TX_TIMEOUT_Start();             // Start the timer.
 09B4 7C0000            xcall _TX_TIMEOUT_Start
 09B7 20                pop X
 09B8           L137:
 09B8                   .dbline 564
 09B8           ;               
 09B8           ;               while(!TIMEOUT)
 09B8           ;               {
 09B8                   .dbline 567
 09B8           ;                       // Do nothing while we wait for one timeout period.
 09B8           ;                       // This is to allow everyone to get in the right configuration.
 09B8           ;               }
 09B8           L138:
 09B8                   .dbline 563
 09B8 62D000            mov REG[0xd0],>_TIMEOUT
 09BB 3C0000            cmp [_TIMEOUT],0
 09BE B006              jnz X40
 09C0 3C0100            cmp [_TIMEOUT+1],0
 09C3 AFF4              jz L137
 09C5           X40:
 09C5                   .dbline 569
 09C5           ;               
 09C5           ;               TX_TIMEOUT_Stop();              // Stop the timer.
 09C5 10                push X
 09C6 7C0000            xcall _TX_TIMEOUT_Stop
 09C9 20                pop X
 09CA                   .dbline 570
 09CA           ;               TIMEOUT = 0;                    // Reset the timeout flag.
 09CA 62D000            mov REG[0xd0],>_TIMEOUT
 09CD 550100            mov [_TIMEOUT+1],0
 09D0 550000            mov [_TIMEOUT],0
 09D3                   .dbline 572
 09D3           ;               
 09D3           ;               STATE = TX_MODE;
 09D3 62D000            mov REG[0xd0],>_STATE
 09D6 550100            mov [_STATE+1],0
 09D9 550000            mov [_STATE],0
 09DC                   .dbline 573
 09DC           ;       }
 09DC           L135:
 09DC           L134:
 09DC           L132:
 09DC                   .dbline 578
 09DC           ;       
 09DC           ;       // Make sure to keep the LED on (active low).
 09DC           ;       //PRT2DR &= 0b11111110;
 09DC           ;       
 09DC           ;       if(STATE == TX_MODE)
 09DC 62D000            mov REG[0xd0],>_STATE
 09DF 3C0000            cmp [_STATE],0
 09E2 B00B              jnz L140
 09E4 3C0100            cmp [_STATE+1],0
 09E7 B006              jnz L140
 09E9           X41:
 09E9                   .dbline 579
 09E9           ;       {
 09E9                   .dbline 580
 09E9           ;               PRT1DR |= 0b00000001;
 09E9 430401            or REG[0x4],1
 09EC                   .dbline 581
 09EC           ;       }
 09EC 8004              xjmp L141
 09EE           L140:
 09EE                   .dbline 583
 09EE           ;       else
 09EE           ;       {
 09EE                   .dbline 584
 09EE           ;               PRT1DR &= 0b11111110;
 09EE 4104FE            and REG[0x4],-2
 09F1                   .dbline 586
 09F1           ;               
 09F1           ;       }
 09F1           L141:
 09F1                   .dbline 589
 09F1           ;       
 09F1           ;       // Reconnect to the global bus.
 09F1           ;       PRT0GS |= 0b10000000;
 09F1 430280            or REG[0x2],-128
 09F4                   .dbline -2
 09F4           L128:
 09F4 20                pop X
 09F5                   .dbline 0 ; func end
 09F5 7F                ret
 09F6                   .dbsym l mode -5 I
 09F6                   .dbend
 09F6                   .dbfunc e unloadAllConfigs _unloadAllConfigs fV
 09F6           _unloadAllConfigs::
 09F6                   .dbline -1
 09F6                   .dbline 595
 09F6           ; }
 09F6           ; 
 09F6           ; // This function blindly unloads all user configurations. This will be called once,
 09F6           ; // when the system initially has no known state.
 09F6           ; void unloadAllConfigs(void)
 09F6           ; {
 09F6                   .dbline 596
 09F6           ;       UnloadConfig_pc_listener();
 09F6 7C0000            xcall _UnloadConfig_pc_listener
 09F9                   .dbline 597
 09F9           ;       UnloadConfig_receiver_config();
 09F9 7C0000            xcall _UnloadConfig_receiver_config
 09FC                   .dbline 598
 09FC           ;       UnloadConfig_transmitter_config();
 09FC 7C0000            xcall _UnloadConfig_transmitter_config
 09FF                   .dbline -2
 09FF           L142:
 09FF                   .dbline 0 ; func end
 09FF 7F                ret
 0A00                   .dbend
 0A00                   .dbfunc e unloadConfig _unloadConfig fV
 0A00           ;     config_num -> X-5
 0A00           _unloadConfig::
 0A00                   .dbline -1
 0A00 10                push X
 0A01 4F                mov X,SP
 0A02                   .dbline 604
 0A02           ; }
 0A02           ; 
 0A02           ; // This function unloads the configuration corresponding to the config number passed to it.
 0A02           ; // We do this instead of unloadAllConfigs to cut down on set up time.
 0A02           ; void unloadConfig(int config_num)
 0A02           ; {
 0A02                   .dbline 605
 0A02           ;       if(config_num == PC_MODE)
 0A02 3DFB00            cmp [X-5],0
 0A05 B00B              jnz L144
 0A07 3DFC02            cmp [X-4],2
 0A0A B006              jnz L144
 0A0C           X42:
 0A0C                   .dbline 606
 0A0C           ;       {
 0A0C                   .dbline 607
 0A0C           ;               UnloadConfig_pc_listener();
 0A0C 7C0000            xcall _UnloadConfig_pc_listener
 0A0F                   .dbline 608
 0A0F           ;       }
 0A0F 801D              xjmp L145
 0A11           L144:
 0A11                   .dbline 609
 0A11           ;       else if(config_num == RX_MODE)
 0A11 3DFB00            cmp [X-5],0
 0A14 B00B              jnz L146
 0A16 3DFC01            cmp [X-4],1
 0A19 B006              jnz L146
 0A1B           X43:
 0A1B                   .dbline 610
 0A1B           ;       {
 0A1B                   .dbline 611
 0A1B           ;               UnloadConfig_receiver_config();
 0A1B 7C0000            xcall _UnloadConfig_receiver_config
 0A1E                   .dbline 612
 0A1E           ;       }
 0A1E 800E              xjmp L147
 0A20           L146:
 0A20                   .dbline 613
 0A20           ;       else if(config_num == TX_MODE)
 0A20 3DFB00            cmp [X-5],0
 0A23 B009              jnz L148
 0A25 3DFC00            cmp [X-4],0
 0A28 B004              jnz L148
 0A2A           X44:
 0A2A                   .dbline 614
 0A2A           ;       {
 0A2A                   .dbline 615
 0A2A           ;               UnloadConfig_transmitter_config();
 0A2A 7C0000            xcall _UnloadConfig_transmitter_config
 0A2D                   .dbline 616
 0A2D           ;       }
 0A2D           L148:
 0A2D           L147:
 0A2D           L145:
 0A2D                   .dbline -2
 0A2D           L143:
 0A2D 20                pop X
 0A2E                   .dbline 0 ; func end
 0A2E 7F                ret
 0A2F                   .dbsym l config_num -5 I
 0A2F                   .dbend
 0A2F                   .dbfunc e initializeSlaves _initializeSlaves fV
 0A2F           ;   num_timeouts -> X+0
 0A2F           _initializeSlaves::
 0A2F                   .dbline -1
 0A2F 10                push X
 0A30 4F                mov X,SP
 0A31 3802              add SP,2
 0A33                   .dbline 620
 0A33           ; }
 0A33           ; 
 0A33           ; void initializeSlaves(void)
 0A33           ; {
 0A33                   .dbline 621
 0A33           ;       int num_timeouts = 0;
 0A33 560100            mov [X+1],0
 0A36 560000            mov [X+0],0
 0A39                   .dbline 623
 0A39           ;       
 0A39           ;       sayHello();
 0A39 9952              xcall _sayHello
 0A3B 8108              xjmp L152
 0A3D           L151:
 0A3D                   .dbline 628
 0A3D           ;       
 0A3D           ;       // This loop continuously probes and listens at intervals
 0A3D           ;       // set by the RX_TIMEOUT_DURATION variable.
 0A3D           ;       while(num_timeouts < MAX_TIMEOUTS)
 0A3D           ;       {                                       
 0A3D                   .dbline 629
 0A3D           ;               if(RECEIVE_cReadChar() == START_TRANSMIT)
 0A3D 10                push X
 0A3E 7C0000            xcall _RECEIVE_cReadChar
 0A41 62D000            mov REG[0xd0],>__r0
 0A44 20                pop X
 0A45 39FC              cmp A,-4
 0A47 B0D7              jnz L154
 0A49                   .dbline 630
 0A49           ;               {       
 0A49                   .dbline 631
 0A49           ;                       if(validTransmission())
 0A49 9997              xcall _validTransmission
 0A4B 62D000            mov REG[0xd0],>__r0
 0A4E 3C0000            cmp [__r0],0
 0A51 B006              jnz X45
 0A53 3C0000            cmp [__r1],0
 0A56 A0ED              jz L155
 0A58           X45:
 0A58                   .dbline 632
 0A58           ;                       {
 0A58                   .dbline 633
 0A58           ;                               if(COMMAND_TYPE == HELLO_BYTE)  // Someone else is out there!
 0A58 62D000            mov REG[0xd0],>_COMMAND_TYPE
 0A5B 3C00C8            cmp [_COMMAND_TYPE],-56
 0A5E B0E5              jnz L155
 0A60                   .dbline 634
 0A60           ;                               {
 0A60                   .dbline 636
 0A60           ;                                       // If this is for me, assign them an ID.
 0A60           ;                                       if(COMMAND_DESTINATION == MASTER_ID)
 0A60 62D000            mov REG[0xd0],>_COMMAND_DESTINATION
 0A63 3C0000            cmp [_COMMAND_DESTINATION],0
 0A66 B0DD              jnz L155
 0A68                   .dbline 637
 0A68           ;                                       {
 0A68                   .dbline 638
 0A68           ;                                               NUM_MODULES++;                  // Increment the number of modules connected.
 0A68 62D000            mov REG[0xd0],>_NUM_MODULES
 0A6B 7601              inc [_NUM_MODULES+1]
 0A6D 0E0000            adc [_NUM_MODULES],0
 0A70                   .dbline 639
 0A70           ;                                               num_timeouts = 0;               // Reset number of timeouts since we found someone.
 0A70 560100            mov [X+1],0
 0A73 560000            mov [X+0],0
 0A76                   .dbline 641
 0A76           ;                       
 0A76           ;                                               if(!assignID(NUM_MODULES))
 0A76 5100              mov A,[_NUM_MODULES]
 0A78 08                push A
 0A79 5101              mov A,[_NUM_MODULES+1]
 0A7B 08                push A
 0A7C 7C015C            xcall _assignID
 0A7F 38FE              add SP,-2
 0A81 62D000            mov REG[0xd0],>__r0
 0A84 3C0000            cmp [__r0],0
 0A87 B0BC              jnz L155
 0A89 3C0000            cmp [__r1],0
 0A8C B0B7              jnz L155
 0A8E           X46:
 0A8E                   .dbline 642
 0A8E           ;                                               {
 0A8E                   .dbline 646
 0A8E           ;                                                       // If the module did not respond that the ID was assigned,
 0A8E           ;                                                       // make an effort to ping it in case that transmission was lost
 0A8E           ;                                                       // before ultimately deciding that the module didn't configure.
 0A8E           ;                                                       if(!pingModule(NUM_MODULES))
 0A8E 62D000            mov REG[0xd0],>_NUM_MODULES
 0A91 5100              mov A,[_NUM_MODULES]
 0A93 08                push A
 0A94 5101              mov A,[_NUM_MODULES+1]
 0A96 08                push A
 0A97 7C0061            xcall _pingModule
 0A9A 38FE              add SP,-2
 0A9C 62D000            mov REG[0xd0],>__r0
 0A9F 3C0000            cmp [__r0],0
 0AA2 B0A1              jnz L155
 0AA4 3C0000            cmp [__r1],0
 0AA7 B09C              jnz L155
 0AA9           X47:
 0AA9                   .dbline 647
 0AA9           ;                                                       {
 0AA9                   .dbline 648
 0AA9           ;                                                               if(!pingModule(NUM_MODULES))
 0AA9 62D000            mov REG[0xd0],>_NUM_MODULES
 0AAC 5100              mov A,[_NUM_MODULES]
 0AAE 08                push A
 0AAF 5101              mov A,[_NUM_MODULES+1]
 0AB1 08                push A
 0AB2 7C0061            xcall _pingModule
 0AB5 38FE              add SP,-2
 0AB7 62D000            mov REG[0xd0],>__r0
 0ABA 3C0000            cmp [__r0],0
 0ABD B086              jnz L155
 0ABF 3C0000            cmp [__r1],0
 0AC2 B081              jnz L155
 0AC4           X48:
 0AC4                   .dbline 649
 0AC4           ;                                                               {
 0AC4                   .dbline 650
 0AC4           ;                                                                       if(!pingModule(NUM_MODULES))
 0AC4 62D000            mov REG[0xd0],>_NUM_MODULES
 0AC7 5100              mov A,[_NUM_MODULES]
 0AC9 08                push A
 0ACA 5101              mov A,[_NUM_MODULES+1]
 0ACC 08                push A
 0ACD 7C0061            xcall _pingModule
 0AD0 38FE              add SP,-2
 0AD2 62D000            mov REG[0xd0],>__r0
 0AD5 3C0000            cmp [__r0],0
 0AD8 B06B              jnz L155
 0ADA 3C0000            cmp [__r1],0
 0ADD B066              jnz L155
 0ADF           X49:
 0ADF                   .dbline 651
 0ADF           ;                                                                       {
 0ADF                   .dbline 652
 0ADF           ;                                                                               if(!pingModule(NUM_MODULES))
 0ADF 62D000            mov REG[0xd0],>_NUM_MODULES
 0AE2 5100              mov A,[_NUM_MODULES]
 0AE4 08                push A
 0AE5 5101              mov A,[_NUM_MODULES+1]
 0AE7 08                push A
 0AE8 7C0061            xcall _pingModule
 0AEB 38FE              add SP,-2
 0AED 62D000            mov REG[0xd0],>__r0
 0AF0 3C0000            cmp [__r0],0
 0AF3 B050              jnz L155
 0AF5 3C0000            cmp [__r1],0
 0AF8 B04B              jnz L155
 0AFA           X50:
 0AFA                   .dbline 653
 0AFA           ;                                                                               {
 0AFA                   .dbline 654
 0AFA           ;                                                                                       if(!pingModule(NUM_MODULES))
 0AFA 62D000            mov REG[0xd0],>_NUM_MODULES
 0AFD 5100              mov A,[_NUM_MODULES]
 0AFF 08                push A
 0B00 5101              mov A,[_NUM_MODULES+1]
 0B02 08                push A
 0B03 7C0061            xcall _pingModule
 0B06 38FE              add SP,-2
 0B08 62D000            mov REG[0xd0],>__r0
 0B0B 3C0000            cmp [__r0],0
 0B0E B035              jnz L155
 0B10 3C0000            cmp [__r1],0
 0B13 B030              jnz L155
 0B15           X51:
 0B15                   .dbline 655
 0B15           ;                                                                                       {
 0B15                   .dbline 656
 0B15           ;                                                                                               NUM_MODULES--;
 0B15 62D000            mov REG[0xd0],>_NUM_MODULES
 0B18 7A01              dec [_NUM_MODULES+1]
 0B1A 1E0000            sbb [_NUM_MODULES],0
 0B1D                   .dbline 657
 0B1D           ;                                                                                       }
 0B1D                   .dbline 658
 0B1D           ;                                                                               }
 0B1D                   .dbline 659
 0B1D           ;                                                                       }
 0B1D                   .dbline 660
 0B1D           ;                                                               }
 0B1D                   .dbline 661
 0B1D           ;                                                       }
 0B1D                   .dbline 662
 0B1D           ;                                               }
 0B1D                   .dbline 663
 0B1D           ;                                       }
 0B1D                   .dbline 664
 0B1D           ;                               }
 0B1D                   .dbline 665
 0B1D           ;                       }
 0B1D                   .dbline 666
 0B1D           ;               }
 0B1D 8026              xjmp L155
 0B1F           L154:
 0B1F                   .dbline 667
 0B1F           ;               else if(TIMEOUT >= RX_TIMEOUT_DURATION)
 0B1F 62D000            mov REG[0xd0],>_TIMEOUT
 0B22 5101              mov A,[_TIMEOUT+1]
 0B24 1105              sub A,5
 0B26 5100              mov A,[_TIMEOUT]
 0B28 3180              xor A,-128
 0B2A 1980              sbb A,(0 ^ 0x80)
 0B2C C017              jc L174
 0B2E           X52:
 0B2E                   .dbline 668
 0B2E           ;               {       
 0B2E                   .dbline 669
 0B2E           ;                       num_timeouts++;
 0B2E 7701              inc [X+1]
 0B30 0F0000            adc [X+0],0
 0B33                   .dbline 672
 0B33           ;                       
 0B33           ;                       // If we are not maxed out on modules, look for more.
 0B33           ;                       if(NUM_MODULES < MAX_MODULES)
 0B33 62D000            mov REG[0xd0],>_NUM_MODULES
 0B36 5101              mov A,[_NUM_MODULES+1]
 0B38 11FA              sub A,-6
 0B3A 5100              mov A,[_NUM_MODULES]
 0B3C 3180              xor A,-128
 0B3E 1980              sbb A,(0 ^ 0x80)
 0B40 D003              jnc L176
 0B42           X53:
 0B42                   .dbline 673
 0B42           ;                       {
 0B42                   .dbline 674
 0B42           ;                               sayHello();
 0B42 9849              xcall _sayHello
 0B44                   .dbline 675
 0B44           ;                       }
 0B44           L176:
 0B44                   .dbline 676
 0B44           ;               }
 0B44           L174:
 0B44           L155:
 0B44                   .dbline 677
 0B44           ;       }
 0B44           L152:
 0B44                   .dbline 627
 0B44 5201              mov A,[X+1]
 0B46 110A              sub A,10
 0B48 5200              mov A,[X+0]
 0B4A 3180              xor A,-128
 0B4C 1980              sbb A,(0 ^ 0x80)
 0B4E CEEE              jc L151
 0B50           X54:
 0B50                   .dbline 680
 0B50           ;       
 0B50           ;       // Switch back to PC mode.
 0B50           ;       configToggle(PC_MODE);
 0B50 5000              mov A,0
 0B52 08                push A
 0B53 5002              mov A,2
 0B55 08                push A
 0B56 9DAF              xcall _configToggle
 0B58 38FE              add SP,-2
 0B5A                   .dbline -2
 0B5A           L150:
 0B5A 38FE              add SP,-2
 0B5C 20                pop X
 0B5D                   .dbline 0 ; func end
 0B5D 7F                ret
 0B5E                   .dbsym l num_timeouts 0 I
 0B5E                   .dbend
 0B5E                   .dbfunc e xmitWait _xmitWait fV
 0B5E           ;              i -> X+0
 0B5E           _xmitWait::
 0B5E                   .dbline -1
 0B5E 10                push X
 0B5F 4F                mov X,SP
 0B60 3802              add SP,2
 0B62                   .dbline 684
 0B62           ; }
 0B62           ; 
 0B62           ; void xmitWait(void)
 0B62           ; {
 0B62                   .dbline 687
 0B62           ;       int i;
 0B62           ;       
 0B62           ;       for(i = 0; i < 25; i++)
 0B62 560100            mov [X+1],0
 0B65 560000            mov [X+0],0
 0B68           L179:
 0B68                   .dbline 688
 0B68           ;       {
 0B68                   .dbline 690
 0B68           ;               // Sit here and spin for about 50 microseconds.
 0B68           ;       }
 0B68           L180:
 0B68                   .dbline 687
 0B68 7701              inc [X+1]
 0B6A 0F0000            adc [X+0],0
 0B6D                   .dbline 687
 0B6D 5201              mov A,[X+1]
 0B6F 1119              sub A,25
 0B71 5200              mov A,[X+0]
 0B73 3180              xor A,-128
 0B75 1980              sbb A,(0 ^ 0x80)
 0B77 CFF0              jc L179
 0B79           X55:
 0B79                   .dbline -2
 0B79           L178:
 0B79 38FE              add SP,-2
 0B7B 20                pop X
 0B7C                   .dbline 0 ; func end
 0B7C 7F                ret
 0B7D                   .dbsym l i 0 I
 0B7D                   .dbend
 0B7D                   .dbfunc e TX_TIMEOUT_ISR _TX_TIMEOUT_ISR fV
 0B7D           _TX_TIMEOUT_ISR::
 0B7D                   .dbline -1
 0B7D 71C0              or F,-64
 0B7F 08                push A
 0B80 5DD0              mov A,REG[0xd0]
 0B82 08                push A
 0B83                   .dbline 694
 0B83           ; }
 0B83           ; 
 0B83           ; void TX_TIMEOUT_ISR(void)
 0B83           ; {     
 0B83                   .dbline 695
 0B83           ;       TIMEOUT++;
 0B83 62D000            mov REG[0xd0],>_TIMEOUT
 0B86 7601              inc [_TIMEOUT+1]
 0B88 0E0000            adc [_TIMEOUT],0
 0B8B                   .dbline 697
 0B8B           ;       
 0B8B           ;       M8C_ClearIntFlag(INT_CLR0,TX_TIMEOUT_INT_MASK);
 0B8B 62DAFD            mov REG[0xda],-3
 0B8E                   .dbline -2
 0B8E           L183:
 0B8E 18                pop A
 0B8F 60D0              mov REG[208],A
 0B91 18                pop A
 0B92                   .dbline 0 ; func end
 0B92 7E                reti
 0B93                   .dbend
 0B93                   .dbfunc e RX_TIMEOUT_ISR _RX_TIMEOUT_ISR fV
 0B93           _RX_TIMEOUT_ISR::
 0B93                   .dbline -1
 0B93 71C0              or F,-64
 0B95 08                push A
 0B96 5DD0              mov A,REG[0xd0]
 0B98 08                push A
 0B99                   .dbline 701
 0B99           ; }
 0B99           ; 
 0B99           ; void RX_TIMEOUT_ISR(void)
 0B99           ; {     
 0B99                   .dbline 702
 0B99           ;       TIMEOUT++;
 0B99 62D000            mov REG[0xd0],>_TIMEOUT
 0B9C 7601              inc [_TIMEOUT+1]
 0B9E 0E0000            adc [_TIMEOUT],0
 0BA1                   .dbline 704
 0BA1           ;       
 0BA1           ;       M8C_ClearIntFlag(INT_CLR0,RX_TIMEOUT_INT_MASK);
 0BA1 62DAFD            mov REG[0xda],-3
 0BA4                   .dbline -2
 0BA4           L184:
 0BA4 18                pop A
 0BA5 60D0              mov REG[208],A
 0BA7 18                pop A
 0BA8                   .dbline 0 ; func end
 0BA8 7E                reti
 0BA9                   .dbend
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _STATE::
 0000 0000              .byte 0,0
 0002                   .dbsym e STATE _STATE I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _PARAM2::
 0000 00                .byte 0
 0001                   .dbsym e PARAM2 _PARAM2 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _PARAM1::
 0000 00                .byte 0
 0001                   .dbsym e PARAM1 _PARAM1 c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_TYPE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_TYPE _COMMAND_TYPE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_DESTINATION::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_DESTINATION _COMMAND_DESTINATION c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _COMMAND_SOURCE::
 0000 00                .byte 0
 0001                   .dbsym e COMMAND_SOURCE _COMMAND_SOURCE c
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _NUM_MODULES::
 0000 0000              .byte 0,0
 0002                   .dbsym e NUM_MODULES _NUM_MODULES I
                        .area data(ram, con, rel)
 0000                   .dbfile C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
 0000           _TIMEOUT::
 0000 0000              .byte 0,0
 0002                   .dbsym e TIMEOUT _TIMEOUT I
                        .area lit(rom, con, rel)
 0000           L46:
 0000 4D6F64756C65732100        .byte 'M,'o,'d,'u,'l,'e,'s,33,0
