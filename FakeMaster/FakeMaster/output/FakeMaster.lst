0000: 80 67    JMP   0x0068
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0116) ; Generated by PSoC Designer 5.0.985.0
                                   (0117) ;
                                   (0118) ;@Id: boot.tpl#895 @
0004: 30       HALT                (0119) ;=============================================================================
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0120) ;  FILENAME:   boot.asm
                                   (0121) ;  VERSION:    4.18
                                   (0122) ;  DATE:       28 June 2007
0008: 7E       RETI                (0123) ;
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0124) ;  DESCRIPTION:
                                   (0125) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                   (0126) ;
000C: 7E       RETI                (0127) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
                                   (0128) ;
                                   (0129) ; NOTES:
                                   (0130) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
0010: 7E       RETI                (0131) ; the project's root directory to create BOOT.ASM. Any changes made to
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
                                   (0132) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0133) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0134) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
0014: 7E       RETI                (0135) ; are not accidentally modified.
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0136) ;
                                   (0137) ;=============================================================================
                                   (0138) 
0018: 7E       RETI                (0139) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0140) include "m8c.inc"			;Part specific file
                                   (0141) include "m8ssc.inc"			;Part specific file
                                   (0142) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
001C: 7E       RETI                (0143) 
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0144) ;--------------------------------------
                                   (0145) ; Export Declarations
                                   (0146) ;--------------------------------------
0020: 7E       RETI                (0147) 
0021: 30       HALT  
0022: 30       HALT  
0023: 30       HALT  
                                   (0148) export __Start
                                   (0149) IF	(TOOLCHAIN & HITECH)
0024: 7D 1F 7D LJMP  Dispatch_INTERRUPT_9(0150) ELSE
0027: 7E       RETI                (0151) export __bss_start
                                   (0152) export __data_start
                                   (0153) export __idata_start
0028: 7D 1F 53 LJMP  Dispatch_INTERRUPT_10(0154) export __func_lit_start
002B: 7E       RETI                (0155) export __text_start
                                   (0156) ENDIF
                                   (0157) export  _bGetPowerSetting
                                   (0158) export   bGetPowerSetting
002C: 7E       RETI                (0159) 
002D: 30       HALT  
002E: 30       HALT  
002F: 30       HALT  
                                   (0160) 
                                   (0161) ;--------------------------------------
                                   (0162) ; Optimization flags
0030: 7E       RETI                (0163) ;--------------------------------------
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
                                   (0164) ;
                                   (0165) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0166) ; boot.asm. See the notes in the banner comment at the beginning of
0034: 7E       RETI                (0167) ; this file.
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
                                   (0168) 
                                   (0169) ; Optimization for Assembly language (only) projects and C-language projects
0038: 7D 11 54 LJMP  0x1154        (0170) ; that do not depend on the C compiler to initialize the values of RAM variables.
003B: 7E       RETI                (0171) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0172) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0173) ;
003C: 7D 11 55 LJMP  0x1155        (0174) IF	(TOOLCHAIN & HITECH)
003F: 7E       RETI                (0175) ; The C compiler will customize the startup code - it's not required here
                                   (0176) 
                                   (0177) C_LANGUAGE_SUPPORT:              equ 0
                                   (0178) ELSE
0040: 7E       RETI                (0179) C_LANGUAGE_SUPPORT:              equ 1
0041: 30       HALT  
0042: 30       HALT  
0043: 30       HALT  
                                   (0180) ENDIF
                                   (0181) 
                                   (0182) 
0044: 7E       RETI                (0183) ; The following equate is required for proper operation. Reseting its value
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0184) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                   (0185) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                   (0186) ; and PLL_Lock must take place within user code. See the family data sheet for
0048: 7E       RETI                (0187) ; the requirements of starting the ECO and PLL lock mode.
0049: 30       HALT  
004A: 30       HALT  
004B: 30       HALT  
                                   (0188) ;
                                   (0189) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                   (0190) ;                invoking main
004C: 7E       RETI                (0191) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
004D: 30       HALT  
004E: 30       HALT  
004F: 30       HALT  
                                   (0192) ;               the time code in main starts executing.
                                   (0193) ;
                                   (0194) WAIT_FOR_32K:                    equ 1
0050: 7E       RETI                (0195) 
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
                                   (0196) 
                                   (0197) ; For historical reasons, by default the boot code uses an lcall instruction
                                   (0198) ; to invoke the user's _main code. If _main executes a return instruction,
0054: 7E       RETI                (0199) ; boot provides an infinite loop. By changing the following equate from zero
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
                                   (0200) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0201) ; bytes on the stack which are otherwise required for the return address. If
                                   (0202) ; this option is enabled, _main must not return. (Beginning with the 4.2
0058: 7E       RETI                (0203) ; release, the C compiler automatically places an infinite loop at the end
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
                                   (0204) ; of main, rather than a return instruction.)
                                   (0205) ;
                                   (0206) ENABLE_LJMP_TO_MAIN:             equ 0
005C: 7E       RETI                (0207) 
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0208) 
                                   (0209) ;-----------------------------------------------------------------------------
                                   (0210) ; Interrupt Vector Table
0060: 7E       RETI                (0211) ;-----------------------------------------------------------------------------
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0212) ;
                                   (0213) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                   (0214) ; a jump instruction to an ISR (Interrupt Service Routine), although
0064: 7E       RETI                (0215) ; very short ISRs could be encoded within the table itself. Normally,
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0216) ; vector jump targets are modified automatically according to the user
                                   (0217) ; modules selected. This occurs when the 'Generate Application' opera-
                                   (0218) ; tion is run causing PSoC Designer to create boot.asm and the other
                                   (0219) ; configuration files. If you need to hard code a vector, update the
                                   (0220) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0221) ; of this file.
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) 
                                   (0224)     AREA TOP (ROM, ABS, CON)
                                   (0225) 
                                   (0226)     org   0                        ;Reset Interrupt Vector
                                   (0227) IF	(TOOLCHAIN & HITECH)
                                   (0228) ;   jmp   __Start                  ;C compiler fills in this vector
                                   (0229) ELSE
                                   (0230)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0231) ENDIF
                                   (0232) 
                                   (0233)     org   04h                      ;Supply Monitor Interrupt Vector
                                   (0234)     halt                           ;Stop execution if power falls too low
0068: 71 10    OR    F,16          (0235) 
006A: 62 FA 00 MOV   REG[250],0    (0236)     org   08h                      ;Analog Column 0 Interrupt Vector
006D: 62 E3 87 MOV   REG[227],135  (0237)     // call	void_handler
0070: 70 EF    AND   F,239         (0238)     reti
                                   (0239) 
                                   (0240)     org   0Ch                      ;Analog Column 1 Interrupt Vector
0072: 50 20    MOV   A,32          (0241)     // call	void_handler
0074: 28       ROMX                (0242)     reti
0075: 50 40    MOV   A,64          (0243) 
0077: 28       ROMX                (0244)     org   10h                      ;Analog Column 2 Interrupt Vector
0078: 50 60    MOV   A,96          (0245)     // call	void_handler
007A: 28       ROMX                (0246)     reti
                                   (0247) 
                                   (0248)     org   14h                      ;Analog Column 3 Interrupt Vector
                                   (0249)     // call	void_handler
                                   (0250)     reti
                                   (0251) 
                                   (0252)     org   18h                      ;VC3 Interrupt Vector
                                   (0253)     // call	void_handler
                                   (0254)     reti
                                   (0255) 
007B: 41 FE FB AND   REG[254],251  (0256)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0257)     // call	void_handler
                                   (0258)     reti
                                   (0259) 
                                   (0260)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                   (0261)     // call	void_handler
                                   (0262)     reti
                                   (0263) 
                                   (0264)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                   (0265)     ljmp	Dispatch_INTERRUPT_9
007E: 50 80    MOV   A,128         (0266)     reti
0080: 4E       SWAP  SP,A          (0267) 
                                   (0268)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                   (0269)     ljmp	Dispatch_INTERRUPT_10
                                   (0270)     reti
                                   (0271) 
                                   (0272)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                   (0273)     // call	void_handler
                                   (0274)     reti
                                   (0275) 
                                   (0276)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
                                   (0277)     // call	void_handler
                                   (0278)     reti
                                   (0279) 
                                   (0280)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
                                   (0281)     // call	void_handler
                                   (0282)     reti
                                   (0283) 
                                   (0284)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
                                   (0285)     ljmp	_COMP_SERIAL_TX_ISR
                                   (0286)     reti
                                   (0287) 
                                   (0288)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
                                   (0289)     ljmp	_COMP_SERIAL_RX_ISR
                                   (0290)     reti
                                   (0291) 
                                   (0292)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
                                   (0293)     // call	void_handler
                                   (0294)     reti
                                   (0295) 
                                   (0296)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
                                   (0297)     // call	void_handler
0081: 55 F8 00 MOV   [248],0       (0298)     reti
0084: 55 F9 00 MOV   [249],0       (0299) 
                                   (0300)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
                                   (0301)     // call	void_handler
                                   (0302)     reti
                                   (0303) 
                                   (0304)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
                                   (0305)     // call	void_handler
                                   (0306)     reti
                                   (0307) 
                                   (0308)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                   (0309)     // call	void_handler
                                   (0310)     reti
                                   (0311) 
                                   (0312)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
                                   (0313)     // call	void_handler
                                   (0314)     reti
                                   (0315) 
                                   (0316)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                   (0317)     // call	void_handler
                                   (0318)     reti
                                   (0319) 
                                   (0320)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                   (0321)     // call	void_handler
                                   (0322)     reti
0087: 71 10    OR    F,16          (0323) 
0089: 62 E0 02 MOV   REG[224],2    (0324)     org   60h                      ;PSoC I2C Interrupt Vector
008C: 70 EF    AND   F,239         (0325)     // call	void_handler
008E: 62 E3 38 MOV   REG[227],56   (0326)     reti
                                   (0327) 
                                   (0328)     org   64h                      ;Sleep Timer Interrupt Vector
                                   (0329)     // call	void_handler
                                   (0330)     reti
                                   (0331) 
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;  Start of Execution.
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0336) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0337) ;
                                   (0338) 
                                   (0339) IF	(TOOLCHAIN & HITECH)
                                   (0340)  	AREA PD_startup(CODE, REL, CON)
                                   (0341) ELSE
                                   (0342)     org 68h
                                   (0343) ENDIF
                                   (0344) __Start:
                                   (0345) 
                                   (0346)     ; initialize SMP values for voltage stabilization, if required,
                                   (0347)     ; leaving power-on reset (POR) level at the default (low) level, at
                                   (0348)     ; least for now. 
                                   (0349)     ;
                                   (0350)     M8C_SetBank1
                                   (0351)     mov reg[0FAh], 0				;Reset flash location
                                   (0352)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
                                   (0353)     M8C_SetBank0
                                   (0354) 
                                   (0355)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
                                   (0356)     mov   A, 20h
0091: 62 71 05 MOV   REG[113],5    (0357)     romx
0094: 62 75 05 MOV   REG[117],5    (0358)     mov   A, 40h
0097: 62 79 05 MOV   REG[121],5    (0359)     romx
009A: 62 7D 05 MOV   REG[125],5    (0360)     mov   A, 60h
                                   (0361)     romx
                                   (0362)     ; %45%20%46%46% End workaround
                                   (0363) 
                                   (0364) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0365)     M8C_EnableWatchDog
                                   (0366) ENDIF
                                   (0367) 
                                   (0368) IF ( SELECT_32K )
                                   (0369)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                   (0370) ELSE
                                   (0371)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0372) ENDIF
                                   (0373) 
                                   (0374)     ;---------------------------
                                   (0375)     ; Set up the Temporary stack
                                   (0376)     ;---------------------------
                                   (0377)     ; A temporary stack is set up for the SSC instructions.
                                   (0378)     ; The real stack start will be assigned later.
                                   (0379)     ;
                                   (0380) _stack_start:          equ 80h
                                   (0381)     mov   A, _stack_start          ; Set top of stack to end of used RAM
                                   (0382)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0383) 
                                   (0384)     ;-----------------------------------------------
                                   (0385)     ; Set Power-related Trim & the AGND Bypass bit.
                                   (0386)     ;-----------------------------------------------
                                   (0387) 
009D: 62 D1 07 MOV   REG[209],7    (0388) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
00A0: 50 00    MOV   A,0           (0389)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
00A2: 4E       SWAP  SP,A          (0390)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
00A3: 62 D3 07 MOV   REG[211],7    (0391)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
00A6: 62 D0 00 MOV   REG[208],0    (0392)  ELSE                                          ; *** 12MHZ Main Oscillator ***
00A9: 62 D5 00 MOV   REG[213],0    (0393)   IF ( AGND_BYPASS )
00AC: 62 D4 00 MOV   REG[212],0    (0394)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0395)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0396)     ; bit in the write-only BDG_TR register. Recalculate the register
00AF: 71 C0    OR    F,192         (0397)     ; value using the proper trim values.
                                   (0398)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0399)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0400)   ENDIF
                                   (0401)  ENDIF
                                   (0402) ENDIF ; 5.0 V Operation
                                   (0403) 
                                   (0404) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                   (0405)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                   (0406)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                   (0407)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0408)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                   (0409)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0410)  ENDIF
                                   (0411) ENDIF ; 3.3 Volt Operation
                                   (0412) 
                                   (0413)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
                                   (0414)     mov  [bSSC_KEYSP], 0
00B1: 7C 05 EB LCALL 0x05EB        (0415) 
                                   (0416)     ;---------------------------------------
                                   (0417)     ; Initialize Crystal Oscillator and PLL
                                   (0418)     ;---------------------------------------
                                   (0419) 
                                   (0420) IF ( SELECT_32K & WAIT_FOR_32K )
                                   (0421)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                   (0422)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                   (0423)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                   (0424)     ; the ECO to stabilize.
                                   (0425)     ;
                                   (0426)     M8C_SetBank1
                                   (0427)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                   (0428)     M8C_SetBank0
                                   (0429)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                   (0430)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                   (0431)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                   (0432) .WaitFor1s:
                                   (0433)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                   (0434)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                   (0435)                                           ;   since interrupts are not globally enabled
                                   (0436) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                   (0437)     ; Either no ECO, or waiting for stable clock is to be done in main
                                   (0438)     M8C_SetBank1
                                   (0439)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
                                   (0440)     M8C_SetBank0
                                   (0441)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0442) 
                                   (0443) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                   (0444) 
                                   (0445) IF ( PLL_MODE )
                                   (0446)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
00B4: 62 D0 00 MOV   REG[208],0    (0447)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                   (0448)     ;
                                   (0449)     M8C_SetBank1
                                   (0450)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                   (0451)     M8C_SetBank0
                                   (0452)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                   (0453)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
00B7: 50 05    MOV   A,5           (0454) 
00B9: 57 E9    MOV   X,233         (0455) .WaitFor16ms:
00BB: 08       PUSH  A             (0456)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
00BC: 28       ROMX                (0457)     jz   .WaitFor16ms
00BD: 53 71    MOV   [__r0],A      (0458)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
00BF: 18       POP   A             (0459)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
00C0: 75       INC   X             (0460)     M8C_SetBank0
00C1: 09 00    ADC   A,0           (0461) 
00C3: 28       ROMX                (0462) IF      ( WAIT_FOR_32K )
00C4: 4B       SWAP  A,X           (0463) ELSE ; !( WAIT_FOR_32K )
00C5: 51 71    MOV   A,[113]       (0464)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                   (0465)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
00C7: 80 04    JMP   0x00CC        (0466) ENDIF ;(WAIT_FOR_32K)
                                   (0467) ENDIF ;(PLL_MODE)
                                   (0468) 
                                   (0469)     ;------------------------
                                   (0470)     ; Close CT leakage path.
                                   (0471)     ;------------------------
                                   (0472)     mov   reg[ACB00CR0], 05h
                                   (0473)     mov   reg[ACB01CR0], 05h
                                   (0474)     mov   reg[ACB02CR0], 05h
                                   (0475)     mov   reg[ACB03CR0], 05h
                                   (0476) 
                                   (0477) 
                                   (0478) IF	(TOOLCHAIN & HITECH)
                                   (0479)     ;---------------------------------------------
                                   (0480)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                   (0481)     ;---------------------------------------------
                                   (0482) 	global		__Lstackps
                                   (0483) 	mov     a,low __Lstackps
00C9: 75       INC   X             (0484) 	swap    a,sp
00CA: 09 00    ADC   A,0           (0485) 
                                   (0486) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0487)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                   (0488)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                   (0489)     RAM_SETPAGE_CUR 0
00CC: 62 E3 00 MOV   REG[227],0    (0490)     RAM_SETPAGE_MVW 0
00CF: 08       PUSH  A             (0491)     RAM_SETPAGE_MVR 0
00D0: 28       ROMX                (0492)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00D1: 60 D5    MOV   REG[213],A    (0493)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
00D3: 74       INC   A             (0494)     ELSE
00D4: A0 4B    JZ    0x0120        (0495)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
00D6: 18       POP   A             (0496)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
00D7: 75       INC   X             (0497) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00D8: 09 00    ADC   A,0           (0498) ELSE
00DA: 08       PUSH  A             (0499)     ;---------------------------------------------
00DB: 28       ROMX                (0500)     ; ImageCraft Enter the Large Memory Model, if applicable
00DC: 53 71    MOV   [__r0],A      (0501)     ;---------------------------------------------
00DE: 18       POP   A             (0502) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00DF: 75       INC   X             (0503)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00E0: 09 00    ADC   A,0           (0504)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00E2: 08       PUSH  A             (0505)     swap  A, SP
00E3: 28       ROMX                (0506)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
00E4: A0 1C    JZ    0x0101        (0507)     RAM_SETPAGE_CUR 0
00E6: 53 70    MOV   [__r1],A      (0508)     RAM_SETPAGE_MVW 0
00E8: 18       POP   A             (0509)     RAM_SETPAGE_MVR 0
                                   (0510) 
                                   (0511)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                   (0512)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0513)   ELSE
                                   (0514)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0515)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0516) ELSE
00E9: 75       INC   X             (0517)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
00EA: 09 00    ADC   A,0           (0518)     swap  SP, A
00EC: 08       PUSH  A             (0519) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00ED: 28       ROMX                (0520) ENDIF ;	TOOLCHAIN
00EE: 3F 71    MVI   [__r0],A      (0521) 
00F0: 47 71 FF TST   [113],255     (0522)     ;-------------------------
00F3: B0 06    JNZ   0x00FA        (0523)     ; Load Base Configuration
00F5: 5D D5    MOV   A,REG[213]    (0524)     ;-------------------------
00F7: 74       INC   A             (0525)     ; Load global parameter settings and load the user modules in the
00F8: 60 D5    MOV   REG[213],A    (0526)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0527)     ; to minimize start up time; (2) We may still need to play with the
00FA: 18       POP   A             (0528)     ; Sleep Timer.
00FB: 7A 70    DEC   [__r1]        (0529)     ;
00FD: BF EB    JNZ   0x00E9        (0530)     lcall LoadConfigInit
00FF: 8F C9    JMP   0x00C9        (0531) 
                                   (0532)     ;-----------------------------------
                                   (0533)     ; Initialize C Run-Time Environment
0101: 18       POP   A             (0534)     ;-----------------------------------
0102: 75       INC   X             (0535) IF ( C_LANGUAGE_SUPPORT )
0103: 09 00    ADC   A,0           (0536) IF ( SYSTEM_SMALL_MEMORY_MODEL )
0105: 08       PUSH  A             (0537)     mov  A,0                           ; clear the 'bss' segment to zero
0106: 28       ROMX                (0538)     mov  [__r0],<__bss_start
0107: 53 70    MOV   [__r1],A      (0539) BssLoop:
0109: 50 00    MOV   A,0           (0540)     cmp  [__r0],<__bss_end
                                   (0541)     jz   BssDone
                                   (0542)     mvi  [__r0],A
                                   (0543)     jmp  BssLoop
                                   (0544) BssDone:
                                   (0545)     mov  A,>__idata_start              ; copy idata to data segment
010B: 3F 71    MVI   [__r0],A      (0546)     mov  X,<__idata_start
010D: 47 71 FF TST   [113],255     (0547)     mov  [__r0],<__data_start
0110: B0 08    JNZ   0x0119        (0548) IDataLoop:
0112: 5D D5    MOV   A,REG[213]    (0549)     cmp  [__r0],<__data_end
0114: 74       INC   A             (0550)     jz   C_RTE_Done
0115: 60 D5    MOV   REG[213],A    (0551)     push A
0117: 50 00    MOV   A,0           (0552)     romx
                                   (0553)     mvi  [__r0],A
0119: 7A 70    DEC   [__r1]        (0554)     pop  A
011B: BF EF    JNZ   0x010B        (0555)     inc  X
011D: 18       POP   A             (0556)     adc  A,0
011E: 8F AA    JMP   0x00C9        (0557)     jmp  IDataLoop
                                   (0558) 
                                   (0559) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
0120: 18       POP   A             (0560) 
                                   (0561) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0562)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0563)                                        ; to use the Virtual Register page.
                                   (0564) 
                                   (0565)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0566)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0567)     ; text segment and may have been relocated by the Code Compressor.
                                   (0568)     ;
                                   (0569)     mov   A, >__pXIData                ; Get the address of the flash
                                   (0570)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                   (0571)     push  A
                                   (0572)     romx                               ; get the MSB of xidata's address
                                   (0573)     mov   [__r0], A
                                   (0574)     pop   A
                                   (0575)     inc   X
                                   (0576)     adc   A, 0
                                   (0577)     romx                               ; get the LSB of xidata's address
                                   (0578)     swap  A, X
                                   (0579)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0580)                                        ;   XIData structure list in flash
                                   (0581)     jmp   .AccessStruct
                                   (0582) 
                                   (0583)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0584)     ; values of C variables. Each structure contains 3 member elements.
                                   (0585)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0586)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0587)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0588)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0589)     ; value in the second member element, an unsigned byte:
                                   (0590)     ; (1) If the value of the second element is non-zero, it represents
                                   (0591)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0592)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0593)     ; the bytes are copied to the block of RAM.
                                   (0594)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0595)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0596)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0597) 
                                   (0598) .AccessNextStructLoop:
                                   (0599)     inc   X                            ; pXIData++
                                   (0600)     adc   A, 0
0121: 71 10    OR    F,16          (0601) .AccessStruct:                         ; Entry point for first block
                                   (0602)     ;
                                   (0603)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0604)     ;
                                   (0605)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                   (0606)     push  A
                                   (0607)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                   (0608)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
0123: 43 E3 20 OR    REG[227],32   (0609)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                   (0610)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                   (0611)     pop   A                            ; restore pXIData to [A,X]
                                   (0612)     inc   X                            ; pXIData++
                                   (0613)     adc   A, 0
0126: 70 EF    AND   F,239         (0614)     push  A
                                   (0615)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                   (0616)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                   (0617)     pop   A                            ; restore pXIData to [A,X]
                                   (0618)     inc   X                            ; pXIData++ (point to size)
                                   (0619)     adc   A, 0
                                   (0620)     push  A
                                   (0621)     romx                               ; Get the size (CPU.A <- *pXIData)
                                   (0622)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
0128: 62 E0 00 MOV   REG[224],0    (0623)     mov   [__r1], A                    ;             else downcount in __r1
                                   (0624)     pop   A                            ; restore pXIData to [A,X]
                                   (0625) 
                                   (0626) .CopyNextByteLoop:
                                   (0627)     ; For each byte in the structure's array member, copy from flash to RAM.
012B: 71 10    OR    F,16          (0628)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
012D: 62 E0 03 MOV   REG[224],3    (0629)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
0130: 43 E7 80 OR    REG[231],128  (0630)     ;         __r1 holds a non-zero count of the number of bytes remaining.
0133: 70 EF    AND   F,239         (0631)     ;
                                   (0632)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0633)     adc   A, 0
                                   (0634)     push  A
                                   (0635)     romx                               ; Get the data value (CPU.A <- *pXIData)
                                   (0636)     mvi   [__r0], A                    ; Transfer the data to RAM
0135: 62 E2 00 MOV   REG[226],0    (0637)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0638)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                   (0639)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                   (0640)     inc   A
                                   (0641)     mov   reg[ MVW_PP], A
                                   (0642) .CopyLoopTail:
                                   (0643)     pop   A                            ; restore pXIData to [A,X]
                                   (0644)     dec   [__r1]                       ; End of this array in flash?
0138: 7C 13 B4 LCALL __text_start  (0645)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                   (0646)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
013B: 8F FF    JMP   0x013B        (0647) 
                                   (0648) .ClearRAMBlockToZero:
                                   (0649)     pop   A                            ; restore pXIData to [A,X]
                                   (0650)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0651)     adc   A, 0
                                   (0652)     push  A
                                   (0653)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                   (0654)     mov   [__r1], A                    ; Initialize downcounter
                                   (0655)     mov   A, 0                         ; Initialize source data
                                   (0656) 
                                   (0657) .ClearRAMBlockLoop:
                                   (0658)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                   (0659)     ;         __r1 holds a non-zero count of the number of bytes remaining.
013D: 50 10    MOV   A,16          (0660)     ;
02DC: 71 10    OR    F,16          (0661)     mvi   [__r0], A                    ; Clear a byte

FILE: lib\psocconfigtbl.asm
02DE: 62 00 01 MOV   REG[0],1      (0257) ; Generated by PSoC Designer 5.0.985.0
02E1: 62 01 FE MOV   REG[1],254    (0258) ;
02E4: 70 EF    AND   F,239         (0259) include "m8c.inc"
02E6: 62 03 FE MOV   REG[3],254    (0260) ;  Personalization tables 
02E9: 62 02 01 MOV   REG[2],1      (0261) export LoadConfigTBL_transmitter_config_Bank1
02EC: 71 10    OR    F,16          (0262) export LoadConfigTBL_transmitter_config_Bank0
02EE: 62 02 00 MOV   REG[2],0      (0263) export LoadConfigTBL_transmitter_config_Ordered
02F1: 62 03 00 MOV   REG[3],0      (0264) export UnloadConfigTBL_transmitter_config_Bank1
02F4: 70 EF    AND   F,239         (0265) export UnloadConfigTBL_transmitter_config_Bank0
02F6: 62 01 00 MOV   REG[1],0      (0266) export ReloadConfigTBL_transmitter_config_Bank1
02F9: 71 10    OR    F,16          (0267) export ReloadConfigTBL_transmitter_config_Bank0
02FB: 62 04 03 MOV   REG[4],3      (0268) export LoadConfigTBL_pc_listener_Bank1
02FE: 62 05 FC MOV   REG[5],252    (0269) export LoadConfigTBL_pc_listener_Bank0
0301: 70 EF    AND   F,239         (0270) export UnloadConfigTBL_pc_listener_Bank1
0303: 62 07 FC MOV   REG[7],252    (0271) export UnloadConfigTBL_pc_listener_Bank0
0306: 62 06 02 MOV   REG[6],2      (0272) export LoadConfigTBL_receiver_config_Bank1
0309: 71 10    OR    F,16          (0273) export LoadConfigTBL_receiver_config_Bank0
030B: 62 06 00 MOV   REG[6],0      (0274) export UnloadConfigTBL_receiver_config_Bank1
030E: 62 07 00 MOV   REG[7],0      (0275) export UnloadConfigTBL_receiver_config_Bank0
0311: 70 EF    AND   F,239         (0276) export UnloadConfigTBL_Total_Bank1
0313: 62 05 00 MOV   REG[5],0      (0277) export UnloadConfigTBL_Total_Bank0
0316: 71 10    OR    F,16          (0278) AREA lit(rom, rel)
0318: 62 08 00 MOV   REG[8],0      (0279) LoadConfigTBL_pc_listener_Bank0:
031B: 62 09 FF MOV   REG[9],255    (0280) ;  Instance name COMP_SERIAL, User Module UART
031E: 70 EF    AND   F,239         (0281) ;       Instance name COMP_SERIAL, Block Name RX(DCB13)
0320: 62 0B FF MOV   REG[11],255   (0282) 	db		3fh, 00h		;COMP_SERIAL_RX_CONTROL_REG(DCB13CR0)
0323: 62 0A 00 MOV   REG[10],0     (0283) 	db		3dh, 00h		;COMP_SERIAL_(DCB13DR1)
0326: 71 10    OR    F,16          (0284) 	db		3eh, 00h		;COMP_SERIAL_RX_BUFFER_REG (DCB13DR2)
0328: 62 0A 00 MOV   REG[10],0     (0285) ;       Instance name COMP_SERIAL, Block Name TX(DCB12)
032B: 62 0B 00 MOV   REG[11],0     (0286) 	db		3bh, 00h		;COMP_SERIAL_TX_CONTROL_REG(DCB12CR0)
032E: 70 EF    AND   F,239         (0287) 	db		39h, 00h		;COMP_SERIAL_TX_BUFFER_REG (DCB12DR1)
0330: 62 09 00 MOV   REG[9],0      (0288) 	db		3ah, 00h		;COMP_SERIAL_(DCB12DR2)
0333: 71 10    OR    F,16          (0289) ;  Instance name LCD_1, User Module LCD
0335: 62 0C 00 MOV   REG[12],0     (0290) ;  Instance name TX_REPEATER, User Module TX8
0338: 62 0D 00 MOV   REG[13],0     (0291) ;       Instance name TX_REPEATER, Block Name TX8(DCB02)
033B: 70 EF    AND   F,239         (0292) 	db		2bh, 00h		;TX_REPEATER_CONTROL_REG  (DCB02CR0)
033D: 62 0F 00 MOV   REG[15],0     (0293) 	db		29h, 00h		;TX_REPEATER_TX_BUFFER_REG(DCB02DR1)
0340: 62 0E 00 MOV   REG[14],0     (0294) 	db		2ah, 00h		;TX_REPEATER_(DCB02DR2)
0343: 71 10    OR    F,16          (0295) 	db		ffh
0345: 62 0E 00 MOV   REG[14],0     (0296) LoadConfigTBL_pc_listener_Bank1:
0348: 62 0F 00 MOV   REG[15],0     (0297) ;  Instance name COMP_SERIAL, User Module UART
034B: 70 EF    AND   F,239         (0298) ;       Instance name COMP_SERIAL, Block Name RX(DCB13)
034D: 62 0D 00 MOV   REG[13],0     (0299) 	db		3ch, 05h		;COMP_SERIAL_RX_FUNC_REG   (DCB13FN)
0350: 71 10    OR    F,16          (0300) 	db		3dh, f6h		;COMP_SERIAL_RX_INPUT_REG  (DCB13IN)
0352: 62 10 00 MOV   REG[16],0     (0301) 	db		3eh, 80h		;COMP_SERIAL_RX_OUTPUT_REG (DCB13OU)
0355: 62 11 00 MOV   REG[17],0     (0302) ;       Instance name COMP_SERIAL, Block Name TX(DCB12)
0358: 70 EF    AND   F,239         (0303) 	db		38h, 1dh		;COMP_SERIAL_TX_FUNC_REG   (DCB12FN)
035A: 62 13 00 MOV   REG[19],0     (0304) 	db		39h, 06h		;COMP_SERIAL_TX_INPUT_REG  (DCB12IN)
035D: 62 12 00 MOV   REG[18],0     (0305) 	db		3ah, 85h		;COMP_SERIAL_TX_OUTPUT_REG (DCB12OU)
0360: 71 10    OR    F,16          (0306) ;  Instance name LCD_1, User Module LCD
0362: 62 12 00 MOV   REG[18],0     (0307) ;  Instance name TX_REPEATER, User Module TX8
0365: 62 13 00 MOV   REG[19],0     (0308) ;       Instance name TX_REPEATER, Block Name TX8(DCB02)
0368: 70 EF    AND   F,239         (0309) 	db		28h, 1dh		;TX_REPEATER_FUNC_REG     (DCB02FN)
036A: 62 11 00 MOV   REG[17],0     (0310) 	db		29h, 01h		;TX_REPEATER_INPUT_REG    (DCB02IN)
036D: 71 10    OR    F,16          (0311) 	db		2ah, 84h		;TX_REPEATER_OUTPUT_REG   (DCB02OU)
036F: 62 14 00 MOV   REG[20],0     (0312) 	db		ffh
0372: 62 15 00 MOV   REG[21],0     (0313) UnloadConfigTBL_pc_listener_Bank0:
0375: 70 EF    AND   F,239         (0314) ;  Instance name COMP_SERIAL, User Module UART
0377: 62 17 00 MOV   REG[23],0     (0315) ;       Instance name COMP_SERIAL, Block Name RX(DCB13)
037A: 62 16 00 MOV   REG[22],0     (0316) 	db		3fh, 00h		;COMP_SERIAL_CONTROL_0 (DCB13CR0)
037D: 71 10    OR    F,16          (0317) ;       Instance name COMP_SERIAL, Block Name TX(DCB12)
037F: 62 16 00 MOV   REG[22],0     (0318) 	db		3bh, 00h		;COMP_SERIAL_CONTROL_0 (DCB12CR0)
0382: 62 17 00 MOV   REG[23],0     (0319) ;  Instance name LCD_1, User Module LCD
0385: 70 EF    AND   F,239         (0320) ;  Instance name TX_REPEATER, User Module TX8
0387: 62 15 00 MOV   REG[21],0     (0321) ;       Instance name TX_REPEATER, Block Name TX8(DCB02)
038A: 71 10    OR    F,16          (0322) 	db		2bh, 00h		;TX_REPEATER_CONTROL_0 (DCB02CR0)
038C: 62 18 00 MOV   REG[24],0     (0323) 	db		ffh
038F: 62 19 00 MOV   REG[25],0     (0324) UnloadConfigTBL_pc_listener_Bank1:
0392: 70 EF    AND   F,239         (0325) ;  Instance name COMP_SERIAL, User Module UART
0394: 62 1B 00 MOV   REG[27],0     (0326) ;       Instance name COMP_SERIAL, Block Name RX(DCB13)
0397: 62 1A 00 MOV   REG[26],0     (0327) 	db		3ch, 00h		;COMP_SERIAL_DIG_BasicFunction (DCB13FN)
039A: 71 10    OR    F,16          (0328) 	db		3dh, 00h		;COMP_SERIAL_DIG_Input (DCB13IN)
039C: 62 1A 00 MOV   REG[26],0     (0329) 	db		3eh, 00h		;COMP_SERIAL_DIG_Output (DCB13OU)
039F: 62 1B 00 MOV   REG[27],0     (0330) ;       Instance name COMP_SERIAL, Block Name TX(DCB12)
03A2: 70 EF    AND   F,239         (0331) 	db		38h, 00h		;COMP_SERIAL_DIG_BasicFunction (DCB12FN)
03A4: 62 19 00 MOV   REG[25],0     (0332) 	db		39h, 00h		;COMP_SERIAL_DIG_Input (DCB12IN)
03A7: 71 10    OR    F,16          (0333) 	db		3ah, 00h		;COMP_SERIAL_DIG_Output (DCB12OU)
03A9: 62 1C 00 MOV   REG[28],0     (0334) ;  Instance name LCD_1, User Module LCD
03AC: 62 1D 00 MOV   REG[29],0     (0335) ;  Instance name TX_REPEATER, User Module TX8
03AF: 70 EF    AND   F,239         (0336) ;       Instance name TX_REPEATER, Block Name TX8(DCB02)
03B1: 62 1F 00 MOV   REG[31],0     (0337) 	db		28h, 00h		;TX_REPEATER_DIG_BasicFunction (DCB02FN)
03B4: 62 1E 00 MOV   REG[30],0     (0338) 	db		29h, 00h		;TX_REPEATER_DIG_Input (DCB02IN)
03B7: 71 10    OR    F,16          (0339) 	db		2ah, 00h		;TX_REPEATER_DIG_Output (DCB02OU)
03B9: 62 1E 00 MOV   REG[30],0     (0340) 	db		ffh
03BC: 62 1F 00 MOV   REG[31],0     (0341) 
03BF: 70 EF    AND   F,239         (0342) ;  Instance name COMP_SERIAL, User Module UART
03C1: 62 1D 00 MOV   REG[29],0     (0343) ;       Instance name COMP_SERIAL, Block Name RX(DCB13)
05EB: 62 D0 00 MOV   REG[208],0    (0344) ;       Instance name COMP_SERIAL, Block Name TX(DCB12)

FILE: lib\psocconfig.asm
05EE: 55 02 00 MOV   [2],0         (0081) ; Generated by PSoC Designer 5.0.985.0
                                   (0082) ;
05F1: 55 03 00 MOV   [3],0         (0083) INCLUDE "PSoCDynamic.inc"
05F4: 55 04 00 MOV   [4],0         (0084) ;==========================================================================
05F7: 55 05 FF MOV   [5],255       (0085) ;  PSoCConfig.asm
                                   (0086) ;  @PSOC_VERSION
05FA: 7C 06 01 LCALL 0x0601        (0087) ;
05FD: 7C 02 DC LCALL 0x02DC        (0088) ;  Version: 0.85
                                   (0089) ;  Revised: June 22, 2004
                                   (0090) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0091) ;
0600: 7F       RET                 (0092) ;  This file is generated by the Device Editor on Application Generation.
                                   (0093) ;  It contains code which loads the configuration data table generated in
                                   (0094) ;  the file PSoCConfigTBL.asm
                                   (0095) ;
                                   (0096) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0097) ;  Edits to this file will not be preserved.
                                   (0098) ;==========================================================================
                                   (0099) ;
                                   (0100) include "m8c.inc"
                                   (0101) include "memory.inc"
                                   (0102) include "GlobalParams.inc"
                                   (0103) 
                                   (0104) export LoadConfigInit
                                   (0105) export _LoadConfigInit
                                   (0106) export LoadConfig_transmitter_config
                                   (0107) export _LoadConfig_transmitter_config
                                   (0108) export UnloadConfig_transmitter_config
                                   (0109) export _UnloadConfig_transmitter_config
                                   (0110) export ReloadConfig_transmitter_config
                                   (0111) export _ReloadConfig_transmitter_config
                                   (0112) export LoadConfig_pc_listener
                                   (0113) export _LoadConfig_pc_listener
                                   (0114) export UnloadConfig_pc_listener
                                   (0115) export _UnloadConfig_pc_listener
0601: 71 10    OR    F,16          (0116) export LoadConfig_receiver_config
                                   (0117) export _LoadConfig_receiver_config
0603: 10       PUSH  X             (0118) export UnloadConfig_receiver_config
0604: 70 EF    AND   F,239         (0119) export _UnloadConfig_receiver_config
0606: 50 00    MOV   A,0           (0120) export UnloadConfig_Total
0608: 67       ASR   A             (0121) export _UnloadConfig_Total
                                   (0122) export ACTIVE_CONFIG_STATUS
0609: 50 02    MOV   A,2           (0123) export Port_2_Data_SHADE
060B: 57 44    MOV   X,68          (0124) export _Port_2_Data_SHADE
060D: 7C 08 27 LCALL 0x0827        (0125) export Port_2_DriveMode_0_SHADE
                                   (0126) export _Port_2_DriveMode_0_SHADE
0610: 50 01    MOV   A,1           (0127) export Port_2_DriveMode_1_SHADE
0612: 67       ASR   A             (0128) export _Port_2_DriveMode_1_SHADE
                                   (0129) 
0613: 50 02    MOV   A,2           (0130) 
0615: 57 A5    MOV   X,165         (0131) export NO_SHADOW
0617: 7C 08 27 LCALL 0x0827        (0132) export _NO_SHADOW
                                   (0133) 
061A: 62 D0 00 MOV   REG[208],0    (0134) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
                                   (0135) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
061D: 2E 02 01 OR    [2],1         (0136) 
0620: 70 EF    AND   F,239         (0137) AREA psoc_config(rom, rel)
0622: 20       POP   X             (0138) 
                                   (0139) ;---------------------------------------------------------------------------
                                   (0140) ; LoadConfigInit - Establish the start-up configuration (except for a few
0623: 7F       RET                 (0141) ;                  parameters handled by boot code, like CPU speed). This
                                   (0142) ;                  function can be called from user code, but typically it
                                   (0143) ;                  is only called from boot.
                                   (0144) ;
                                   (0145) ;       INPUTS: None.
                                   (0146) ;      RETURNS: Nothing.
                                   (0147) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
                                   (0148) ;               In the large memory model currently only the page
                                   (0149) ;               pointer registers listed below are modified.  This does
                                   (0150) ;               not guarantee that in future implementations of this
                                   (0151) ;               function other page pointer registers will not be
                                   (0152) ;               modified.
                                   (0153) ;          
                                   (0154) ;               Page Pointer Registers Modified: 
                                   (0155) ;               CUR_PP
                                   (0156) ;
                                   (0157) _LoadConfigInit:
                                   (0158)  LoadConfigInit:
                                   (0159)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0160)     RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0161) 	mov		[ACTIVE_CONFIG_STATUS], 0
                                   (0162) 
                                   (0163) 	mov		[Port_2_Data_SHADE], 0h
                                   (0164) 	mov		[Port_2_DriveMode_0_SHADE], 0h
                                   (0165) 	mov		[Port_2_DriveMode_1_SHADE], ffh
0624: 10       PUSH  X             (0166) 
0625: 70 EF    AND   F,239         (0167) 	lcall	LoadConfig_transmitter_config
0627: 50 00    MOV   A,0           (0168) 	lcall	LoadConfigTBL_transmitter_config_Ordered
0629: 67       ASR   A             (0169) 
                                   (0170) 
062A: 50 03    MOV   A,3           (0171)     RAM_EPILOGUE RAM_USE_CLASS_4
062C: 57 C5    MOV   X,197         (0172)     ret
062E: 7C 08 27 LCALL 0x0827        (0173) 
                                   (0174) ;---------------------------------------------------------------------------
0631: 50 01    MOV   A,1           (0175) ; Load Configuration transmitter_config
0633: 67       ASR   A             (0176) ;
                                   (0177) ;    Load configuration registers for transmitter_config.
0634: 50 03    MOV   A,3           (0178) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0636: 57 D8    MOV   X,216         (0179) ;
0638: 7C 08 27 LCALL 0x0827        (0180) ;       INPUTS: None.
                                   (0181) ;      RETURNS: Nothing.
                                   (0182) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
063B: 62 D0 00 MOV   REG[208],0    (0183) ;               modified as may the Page Pointer registers!
063E: 2E 02 01 OR    [2],1         (0184) ;               In the large memory model currently only the page
0641: 70 EF    AND   F,239         (0185) ;               pointer registers listed below are modified.  This does
0643: 20       POP   X             (0186) ;               not guarantee that in future implementations of this
                                   (0187) ;               function other page pointer registers will not be
                                   (0188) ;               modified.
0644: 7F       RET                 (0189) ;          
                                   (0190) ;               Page Pointer Registers Modified: 
                                   (0191) ;               CUR_PP
                                   (0192) ;
                                   (0193) _LoadConfig_transmitter_config:
                                   (0194)  LoadConfig_transmitter_config:
                                   (0195)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0196) 	M8C_SetBank1
                                   (0197) 
                                   (0198) 	push	x
                                   (0199)     M8C_SetBank0                    ; Force bank 0
                                   (0200)     mov     a, 0                    ; Specify bank 0
                                   (0201)     asr     a                       ; Store in carry flag
                                   (0202)                                     ; Load bank 0 table:
                                   (0203)     mov     A, >LoadConfigTBL_transmitter_config_Bank0
                                   (0204)     mov     X, <LoadConfigTBL_transmitter_config_Bank0
                                   (0205)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0206) 
                                   (0207)     mov     a, 1                    ; Specify bank 1
                                   (0208)     asr     a                       ; Store in carry flag
                                   (0209)                                     ; Load bank 1 table:
                                   (0210)     mov     A, >LoadConfigTBL_transmitter_config_Bank1
                                   (0211)     mov     X, <LoadConfigTBL_transmitter_config_Bank1
                                   (0212)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0213) 
                                   (0214) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
0645: 10       PUSH  X             (0215) ; set config active bit
0646: 70 EF    AND   F,239         (0216) 	or		[ACTIVE_CONFIG_STATUS+transmitter_config_ADDR_OFF], transmitter_config_BIT
0648: 50 00    MOV   A,0           (0217)     M8C_SetBank0                    ; Force return to bank 0
064A: 67       ASR   A             (0218) 	pop		x
                                   (0219) 
064B: 50 03    MOV   A,3           (0220)     RAM_EPILOGUE RAM_USE_CLASS_4
064D: 57 EB    MOV   X,235         (0221)     ret
064F: 7C 08 27 LCALL 0x0827        (0222) 
                                   (0223) ;---------------------------------------------------------------------------
0652: 50 01    MOV   A,1           (0224) ; Reload Configuration transmitter_config
0654: 67       ASR   A             (0225) ;
                                   (0226) ;    Reload configuration registers for transmitter_config.
0655: 50 03    MOV   A,3           (0227) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0657: 57 F2    MOV   X,242         (0228) ;
0659: 7C 08 27 LCALL 0x0827        (0229) ;       INPUTS: None.
                                   (0230) ;      RETURNS: Nothing.
065C: 71 10    OR    F,16          (0231) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
065E: 70 EF    AND   F,239         (0232) ;               modified as may the Page Pointer registers!
                                   (0233) ;               In the large memory model currently only the page
0660: 62 D0 00 MOV   REG[208],0    (0234) ;               pointer registers listed below are modified.  This does
0663: 26 02 FE AND   [2],254       (0235) ;               not guarantee that in future implementations of this
0666: 70 EF    AND   F,239         (0236) ;               function other page pointer registers will not be
0668: 20       POP   X             (0237) ;               modified.
                                   (0238) ;          
                                   (0239) ;               Page Pointer Registers Modified: 
0669: 7F       RET                 (0240) ;               CUR_PP
                                   (0241) ;
                                   (0242) _ReloadConfig_transmitter_config:
                                   (0243)  ReloadConfig_transmitter_config:
                                   (0244)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0245) 
                                   (0246) 	push	x
                                   (0247)     M8C_SetBank0                    ; Force bank 0
                                   (0248)     mov     a, 0                    ; Specify bank 0
                                   (0249)     asr     a                       ; Store in carry flag
                                   (0250)                                     ; Bank 0 table address:
                                   (0251)     mov     A, >ReloadConfigTBL_transmitter_config_Bank0
                                   (0252)     mov     X, <ReloadConfigTBL_transmitter_config_Bank0
                                   (0253)     lcall   LoadConfig              ; Reload the bank 0 values
                                   (0254) 
                                   (0255)     mov     a, 1                    ; Specify bank 1
                                   (0256)     asr     a                       ; Store in carry flag
                                   (0257)                                     ; Bank 1 table address:
                                   (0258)     mov     A, >ReloadConfigTBL_transmitter_config_Bank1
                                   (0259)     mov     X, <ReloadConfigTBL_transmitter_config_Bank1
                                   (0260)     lcall   LoadConfig              ; Reload the bank 1 values
                                   (0261) 
                                   (0262) ; set config active bit
                                   (0263) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
066A: 71 10    OR    F,16          (0264) 	or		[ACTIVE_CONFIG_STATUS+transmitter_config_ADDR_OFF], transmitter_config_BIT
                                   (0265)     M8C_SetBank0                    ; Force return to bank 0
066C: 41 04 DF AND   REG[4],223    (0266) 	pop		x
066F: 43 04 20 OR    REG[4],32     (0267) 
                                   (0268)     RAM_EPILOGUE RAM_USE_CLASS_4
0672: 41 05 DF AND   REG[5],223    (0269)     ret
                                   (0270) 
0675: 70 EF    AND   F,239         (0271) ;---------------------------------------------------------------------------
0677: 41 07 D7 AND   REG[7],215    (0272) ; Unload Configuration transmitter_config
                                   (0273) ;
067A: 41 06 D7 AND   REG[6],215    (0274) ;    Reset configuration registers for transmitter_config
067D: 43 06 28 OR    REG[6],40     (0275) ;    to their values as initially configured.
                                   (0276) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0680: 71 10    OR    F,16          (0277) ;
0682: 41 08 80 AND   REG[8],128    (0278) ;       INPUTS: None.
0685: 43 08 7F OR    REG[8],127    (0279) ;      RETURNS: Nothing.
                                   (0280) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0688: 41 09 80 AND   REG[9],128    (0281) ;               modified as may the Page Pointer registers!
                                   (0282) ;               In the large memory model currently only the page
068B: 70 EF    AND   F,239         (0283) ;               pointer registers listed below are modified.  This does
068D: 41 0B 80 AND   REG[11],128   (0284) ;               not guarantee that in future implementations of this
                                   (0285) ;               function other page pointer registers will not be
0690: 71 10    OR    F,16          (0286) ;               modified.
0692: 41 E1 00 AND   REG[225],0    (0287) ;          
0695: 43 E1 1C OR    REG[225],28   (0288) ;               Page Pointer Registers Modified: 
                                   (0289) ;               CUR_PP
0698: 70 EF    AND   F,239         (0290) ;
069A: 41 B0 0F AND   REG[176],15   (0291) _UnloadConfig_transmitter_config:
                                   (0292)  UnloadConfig_transmitter_config:
069D: 41 B8 0C AND   REG[184],12   (0293)     RAM_PROLOGUE RAM_USE_CLASS_4
06A0: 43 B8 91 OR    REG[184],145  (0294) 
                                   (0295) 	push	x
06A3: 10       PUSH  X             (0296)     M8C_SetBank0                    ; Force bank 0
06A4: 70 EF    AND   F,239         (0297)     mov     a, 0                    ; Specify bank 0
06A6: 50 00    MOV   A,0           (0298)     asr     a                       ; Store in carry flag
06A8: 67       ASR   A             (0299)                                     ; Bank 0 table address:
                                   (0300)     mov     A, >UnloadConfigTBL_transmitter_config_Bank0
06A9: 50 01    MOV   A,1           (0301)     mov     X, <UnloadConfigTBL_transmitter_config_Bank0
06AB: 57 C2    MOV   X,194         (0302)     lcall   LoadConfig              ; Unload the bank 0 values
06AD: 7C 08 27 LCALL 0x0827        (0303) 
                                   (0304)     mov     a, 1                    ; Specify bank 1
06B0: 50 01    MOV   A,1           (0305)     asr     a                       ; Store in carry flag
06B2: 67       ASR   A             (0306)                                     ; Bank 1 table address:
                                   (0307)     mov     A, >UnloadConfigTBL_transmitter_config_Bank1
06B3: 50 01    MOV   A,1           (0308)     mov     X, <UnloadConfigTBL_transmitter_config_Bank1
06B5: 57 D5    MOV   X,213         (0309)     lcall   LoadConfig              ; Unload the bank 1 values
06B7: 7C 08 27 LCALL 0x0827        (0310) 
                                   (0311) 	M8C_SetBank1
06BA: 62 D0 00 MOV   REG[208],0    (0312) 	M8C_SetBank0
                                   (0313) ; clear config active bit
06BD: 2E 02 02 OR    [2],2         (0314) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
06C0: 70 EF    AND   F,239         (0315) 	and		[ACTIVE_CONFIG_STATUS+transmitter_config_ADDR_OFF], ~transmitter_config_BIT
06C2: 20       POP   X             (0316)     M8C_SetBank0                    ; Force return to bank 0
                                   (0317) 	pop		x
                                   (0318) 
06C3: 7F       RET                 (0319)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0320)     ret
                                   (0321) 
                                   (0322) ;---------------------------------------------------------------------------
                                   (0323) ; Load Configuration pc_listener
                                   (0324) ;
                                   (0325) ;    Load configuration registers for pc_listener.
                                   (0326) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0327) ;
                                   (0328) ;       INPUTS: None.
                                   (0329) ;      RETURNS: Nothing.
                                   (0330) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0331) ;               modified as may the Page Pointer registers!
                                   (0332) ;               In the large memory model currently only the page
                                   (0333) ;               pointer registers listed below are modified.  This does
                                   (0334) ;               not guarantee that in future implementations of this
                                   (0335) ;               function other page pointer registers will not be
                                   (0336) ;               modified.
                                   (0337) ;          
                                   (0338) ;               Page Pointer Registers Modified: 
                                   (0339) ;               CUR_PP
                                   (0340) ;
                                   (0341) _LoadConfig_pc_listener:
                                   (0342)  LoadConfig_pc_listener:
                                   (0343)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0344) 	M8C_SetBank1
06C4: 10       PUSH  X             (0345) ; writing Port_1_DriveMode_0 register
06C5: 70 EF    AND   F,239         (0346) 	and		reg[ 4h], ~20h
06C7: 50 00    MOV   A,0           (0347) 	or		reg[ 4h], 20h
06C9: 67       ASR   A             (0348) ; writing Port_1_DriveMode_1 register
                                   (0349) 	and		reg[ 5h], ~20h
06CA: 50 01    MOV   A,1           (0350) ; writing Port_1_DriveMode_2 register
06CC: 57 E8    MOV   X,232         (0351) 	M8C_SetBank0
06CE: 7C 08 27 LCALL 0x0827        (0352) 	and		reg[ 7h], ~28h
                                   (0353) ; writing Port_1_GlobalSelect register
06D1: 50 01    MOV   A,1           (0354) 	and		reg[ 6h], ~28h
06D3: 67       ASR   A             (0355) 	or		reg[ 6h], 28h
                                   (0356) ; writing Port_2_DriveMode_0 register
06D4: 50 01    MOV   A,1           (0357) 	M8C_SetBank1
06D6: 57 EF    MOV   X,239         (0358) 	and		reg[ 8h], ~7fh
06D8: 7C 08 27 LCALL 0x0827        (0359) 	or		reg[ 8h], 7fh
                                   (0360) ; writing Port_2_DriveMode_1 register
06DB: 71 10    OR    F,16          (0361) 	and		reg[ 9h], ~7fh
                                   (0362) ; writing Port_2_DriveMode_2 register
06DD: 41 E1 00 AND   REG[225],0    (0363) 	M8C_SetBank0
06E0: 43 E1 99 OR    REG[225],153  (0364) 	and		reg[ bh], ~7fh
                                   (0365) ; writing OscillatorControl_1 register
06E3: 70 EF    AND   F,239         (0366) 	M8C_SetBank1
06E5: 41 B0 0F AND   REG[176],15   (0367) 	and		reg[e1h], ~ffh
06E8: 43 B0 50 OR    REG[176],80   (0368) 	or		reg[e1h], 1ch
                                   (0369) ; writing Row_0_InputMux register
06EB: 41 B8 0C AND   REG[184],12   (0370) 	M8C_SetBank0
06EE: 43 B8 42 OR    REG[184],66   (0371) 	and		reg[b0h], ~f0h
                                   (0372) ; writing Row_1_InputMux register
06F1: 41 0B 80 AND   REG[11],128   (0373) 	and		reg[b8h], ~f3h
06F4: 43 0B 7F OR    REG[11],127   (0374) 	or		reg[b8h], 91h
                                   (0375) 
06F7: 71 10    OR    F,16          (0376) 	push	x
06F9: 41 09 80 AND   REG[9],128    (0377)     M8C_SetBank0                    ; Force bank 0
06FC: 43 09 7F OR    REG[9],127    (0378)     mov     a, 0                    ; Specify bank 0
                                   (0379)     asr     a                       ; Store in carry flag
06FF: 41 08 80 AND   REG[8],128    (0380)                                     ; Load bank 0 table:
                                   (0381)     mov     A, >LoadConfigTBL_pc_listener_Bank0
0702: 70 EF    AND   F,239         (0382)     mov     X, <LoadConfigTBL_pc_listener_Bank0
0704: 41 06 D7 AND   REG[6],215    (0383)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0384) 
0707: 41 07 D7 AND   REG[7],215    (0385)     mov     a, 1                    ; Specify bank 1
070A: 43 07 28 OR    REG[7],40     (0386)     asr     a                       ; Store in carry flag
                                   (0387)                                     ; Load bank 1 table:
070D: 71 10    OR    F,16          (0388)     mov     A, >LoadConfigTBL_pc_listener_Bank1
070F: 41 05 DF AND   REG[5],223    (0389)     mov     X, <LoadConfigTBL_pc_listener_Bank1
0712: 43 05 20 OR    REG[5],32     (0390)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0391) 
0715: 41 04 DF AND   REG[4],223    (0392) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
0718: 70 EF    AND   F,239         (0393) ; set config active bit
                                   (0394) 	or		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
071A: 62 D0 00 MOV   REG[208],0    (0395)     M8C_SetBank0                    ; Force return to bank 0
071D: 26 02 FD AND   [2],253       (0396) 	pop		x
0720: 70 EF    AND   F,239         (0397) 
0722: 20       POP   X             (0398)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0399)     ret
                                   (0400) 
0723: 7F       RET                 (0401) ;---------------------------------------------------------------------------
                                   (0402) ; Unload Configuration pc_listener
                                   (0403) ;
                                   (0404) ;    Reset configuration registers for pc_listener
                                   (0405) ;    to their values as initially configured.
                                   (0406) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0407) ;
                                   (0408) ;       INPUTS: None.
                                   (0409) ;      RETURNS: Nothing.
                                   (0410) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0411) ;               modified as may the Page Pointer registers!
                                   (0412) ;               In the large memory model currently only the page
                                   (0413) ;               pointer registers listed below are modified.  This does
                                   (0414) ;               not guarantee that in future implementations of this
                                   (0415) ;               function other page pointer registers will not be
                                   (0416) ;               modified.
                                   (0417) ;          
                                   (0418) ;               Page Pointer Registers Modified: 
                                   (0419) ;               CUR_PP
                                   (0420) ;
                                   (0421) _UnloadConfig_pc_listener:
                                   (0422)  UnloadConfig_pc_listener:
                                   (0423)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0424) 
0724: 71 10    OR    F,16          (0425) 	push	x
                                   (0426)     M8C_SetBank0                    ; Force bank 0
0726: 41 00 FE AND   REG[0],254    (0427)     mov     a, 0                    ; Specify bank 0
                                   (0428)     asr     a                       ; Store in carry flag
0729: 41 01 FE AND   REG[1],254    (0429)                                     ; Bank 0 table address:
072C: 43 01 01 OR    REG[1],1      (0430)     mov     A, >UnloadConfigTBL_pc_listener_Bank0
                                   (0431)     mov     X, <UnloadConfigTBL_pc_listener_Bank0
072F: 41 04 FE AND   REG[4],254    (0432)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0433) 
0732: 41 05 FE AND   REG[5],254    (0434)     mov     a, 1                    ; Specify bank 1
0735: 43 05 01 OR    REG[5],1      (0435)     asr     a                       ; Store in carry flag
                                   (0436)                                     ; Bank 1 table address:
0738: 70 EF    AND   F,239         (0437)     mov     A, >UnloadConfigTBL_pc_listener_Bank1
073A: 41 07 FE AND   REG[7],254    (0438)     mov     X, <UnloadConfigTBL_pc_listener_Bank1
073D: 43 07 01 OR    REG[7],1      (0439)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0440) 
0740: 71 10    OR    F,16          (0441) 	M8C_SetBank1
0742: 41 08 80 AND   REG[8],128    (0442) ; writing OscillatorControl_1 register
0745: 43 08 7F OR    REG[8],127    (0443) 	and		reg[e1h], ~ffh
                                   (0444) 	or		reg[e1h], 99h
0748: 41 09 80 AND   REG[9],128    (0445) ; writing Row_0_InputMux register
                                   (0446) 	M8C_SetBank0
074B: 70 EF    AND   F,239         (0447) 	and		reg[b0h], ~f0h
074D: 41 0B 80 AND   REG[11],128   (0448) 	or		reg[b0h], 50h
                                   (0449) ; writing Row_1_InputMux register
0750: 71 10    OR    F,16          (0450) 	and		reg[b8h], ~f3h
0752: 41 60 CF AND   REG[96],207   (0451) 	or		reg[b8h], 42h
0755: 43 60 30 OR    REG[96],48    (0452) ; writing Port_2_DriveMode_2 register
                                   (0453) 	and		reg[ bh], ~7fh
0758: 70 EF    AND   F,239         (0454) 	or		reg[ bh], 7fh
075A: 41 60 C3 AND   REG[96],195   (0455) ; writing Port_2_DriveMode_1 register
075D: 43 60 34 OR    REG[96],52    (0456) 	M8C_SetBank1
                                   (0457) 	and		reg[ 9h], ~7fh
0760: 41 B0 CF AND   REG[176],207  (0458) 	or		reg[ 9h], 7fh
                                   (0459) ; writing Port_2_DriveMode_0 register
0763: 41 B5 FE AND   REG[181],254  (0460) 	and		reg[ 8h], ~7fh
                                   (0461) ; writing Port_1_GlobalSelect register
0766: 41 B8 CC AND   REG[184],204  (0462) 	M8C_SetBank0
0769: 43 B8 11 OR    REG[184],17   (0463) 	and		reg[ 6h], ~28h
                                   (0464) ; writing Port_1_DriveMode_2 register
076C: 41 BD BF AND   REG[189],191  (0465) 	and		reg[ 7h], ~28h
                                   (0466) 	or		reg[ 7h], 28h
076F: 10       PUSH  X             (0467) ; writing Port_1_DriveMode_1 register
0770: 70 EF    AND   F,239         (0468) 	M8C_SetBank1
0772: 50 00    MOV   A,0           (0469) 	and		reg[ 5h], ~20h
0774: 67       ASR   A             (0470) 	or		reg[ 5h], 20h
                                   (0471) ; writing Port_1_DriveMode_0 register
0775: 50 02    MOV   A,2           (0472) 	and		reg[ 4h], ~20h
0777: 57 03    MOV   X,3           (0473) 	M8C_SetBank0
0779: 7C 08 27 LCALL 0x0827        (0474) ; clear config active bit
                                   (0475) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
077C: 50 01    MOV   A,1           (0476) 	and		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], ~pc_listener_BIT
077E: 67       ASR   A             (0477)     M8C_SetBank0                    ; Force return to bank 0
                                   (0478) 	pop		x
077F: 50 02    MOV   A,2           (0479) 
0781: 57 16    MOV   X,22          (0480)     RAM_EPILOGUE RAM_USE_CLASS_4
0783: 7C 08 27 LCALL 0x0827        (0481)     ret
                                   (0482) 
0786: 62 D0 00 MOV   REG[208],0    (0483) ;---------------------------------------------------------------------------
                                   (0484) ; Load Configuration receiver_config
0789: 2E 02 04 OR    [2],4         (0485) ;
078C: 70 EF    AND   F,239         (0486) ;    Load configuration registers for receiver_config.
078E: 20       POP   X             (0487) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0488) ;
                                   (0489) ;       INPUTS: None.
078F: 7F       RET                 (0490) ;      RETURNS: Nothing.
                                   (0491) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
                                   (0492) ;               modified as may the Page Pointer registers!
                                   (0493) ;               In the large memory model currently only the page
                                   (0494) ;               pointer registers listed below are modified.  This does
                                   (0495) ;               not guarantee that in future implementations of this
                                   (0496) ;               function other page pointer registers will not be
                                   (0497) ;               modified.
                                   (0498) ;          
                                   (0499) ;               Page Pointer Registers Modified: 
                                   (0500) ;               CUR_PP
                                   (0501) ;
                                   (0502) _LoadConfig_receiver_config:
                                   (0503)  LoadConfig_receiver_config:
                                   (0504)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0505) 	M8C_SetBank1
                                   (0506) ; writing Port_0_DriveMode_0 register
                                   (0507) 	and		reg[ 0h], ~ 1h
                                   (0508) ; writing Port_0_DriveMode_1 register
                                   (0509) 	and		reg[ 1h], ~ 1h
                                   (0510) 	or		reg[ 1h],  1h
                                   (0511) ; writing Port_1_DriveMode_0 register
                                   (0512) 	and		reg[ 4h], ~ 1h
                                   (0513) ; writing Port_1_DriveMode_1 register
                                   (0514) 	and		reg[ 5h], ~ 1h
                                   (0515) 	or		reg[ 5h],  1h
0790: 10       PUSH  X             (0516) ; writing Port_1_DriveMode_2 register
0791: 70 EF    AND   F,239         (0517) 	M8C_SetBank0
0793: 50 00    MOV   A,0           (0518) 	and		reg[ 7h], ~ 1h
0795: 67       ASR   A             (0519) 	or		reg[ 7h],  1h
                                   (0520) ; writing Port_2_DriveMode_0 register
0796: 50 02    MOV   A,2           (0521) 	M8C_SetBank1
0798: 57 29    MOV   X,41          (0522) 	and		reg[ 8h], ~7fh
079A: 7C 08 27 LCALL 0x0827        (0523) 	or		reg[ 8h], 7fh
                                   (0524) ; writing Port_2_DriveMode_1 register
079D: 50 01    MOV   A,1           (0525) 	and		reg[ 9h], ~7fh
079F: 67       ASR   A             (0526) ; writing Port_2_DriveMode_2 register
                                   (0527) 	M8C_SetBank0
07A0: 50 02    MOV   A,2           (0528) 	and		reg[ bh], ~7fh
07A2: 57 30    MOV   X,48          (0529) ; writing AnalogColumnClockSelect register
07A4: 7C 08 27 LCALL 0x0827        (0530) 	M8C_SetBank1
                                   (0531) 	and		reg[60h], ~30h
07A7: 71 10    OR    F,16          (0532) 	or		reg[60h], 30h
                                   (0533) ; writing AnalogColumnInputSelect register
07A9: 41 60 CF AND   REG[96],207   (0534) 	M8C_SetBank0
                                   (0535) 	and		reg[60h], ~3ch
07AC: 70 EF    AND   F,239         (0536) 	or		reg[60h], 34h
07AE: 41 60 C3 AND   REG[96],195   (0537) ; writing Row_0_InputMux register
07B1: 43 60 28 OR    REG[96],40    (0538) 	and		reg[b0h], ~30h
                                   (0539) ; writing Row_0_OutputDrive_0 register
07B4: 41 B0 CF AND   REG[176],207  (0540) 	and		reg[b5h], ~ 1h
07B7: 43 B0 10 OR    REG[176],16   (0541) ; writing Row_1_InputMux register
                                   (0542) 	and		reg[b8h], ~33h
07BA: 41 B5 FE AND   REG[181],254  (0543) 	or		reg[b8h], 11h
07BD: 43 B5 01 OR    REG[181],1    (0544) ; writing Row_1_OutputDrive_0 register
                                   (0545) 	and		reg[bdh], ~40h
07C0: 41 B8 CC AND   REG[184],204  (0546) 
07C3: 43 B8 02 OR    REG[184],2    (0547) 	push	x
                                   (0548)     M8C_SetBank0                    ; Force bank 0
07C6: 41 BD BF AND   REG[189],191  (0549)     mov     a, 0                    ; Specify bank 0
07C9: 43 BD 40 OR    REG[189],64   (0550)     asr     a                       ; Store in carry flag
                                   (0551)                                     ; Load bank 0 table:
07CC: 41 0B 80 AND   REG[11],128   (0552)     mov     A, >LoadConfigTBL_receiver_config_Bank0
07CF: 43 0B 7F OR    REG[11],127   (0553)     mov     X, <LoadConfigTBL_receiver_config_Bank0
                                   (0554)     lcall   LoadConfig              ; Load the bank 0 values
07D2: 71 10    OR    F,16          (0555) 
07D4: 41 09 80 AND   REG[9],128    (0556)     mov     a, 1                    ; Specify bank 1
07D7: 43 09 7F OR    REG[9],127    (0557)     asr     a                       ; Store in carry flag
                                   (0558)                                     ; Load bank 1 table:
07DA: 41 08 80 AND   REG[8],128    (0559)     mov     A, >LoadConfigTBL_receiver_config_Bank1
                                   (0560)     mov     X, <LoadConfigTBL_receiver_config_Bank1
07DD: 70 EF    AND   F,239         (0561)     lcall   LoadConfig              ; Load the bank 1 values
07DF: 41 07 FE AND   REG[7],254    (0562) 
                                   (0563) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
07E2: 71 10    OR    F,16          (0564) ; set config active bit
07E4: 41 05 FE AND   REG[5],254    (0565) 	or		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
                                   (0566)     M8C_SetBank0                    ; Force return to bank 0
07E7: 41 04 FE AND   REG[4],254    (0567) 	pop		x
07EA: 43 04 01 OR    REG[4],1      (0568) 
                                   (0569)     RAM_EPILOGUE RAM_USE_CLASS_4
07ED: 41 01 FE AND   REG[1],254    (0570)     ret
                                   (0571) 
07F0: 41 00 FE AND   REG[0],254    (0572) ;---------------------------------------------------------------------------
07F3: 43 00 01 OR    REG[0],1      (0573) ; Unload Configuration receiver_config
07F6: 70 EF    AND   F,239         (0574) ;
                                   (0575) ;    Reset configuration registers for receiver_config
07F8: 62 D0 00 MOV   REG[208],0    (0576) ;    to their values as initially configured.
07FB: 26 02 FB AND   [2],251       (0577) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
07FE: 70 EF    AND   F,239         (0578) ;
0800: 20       POP   X             (0579) ;       INPUTS: None.
                                   (0580) ;      RETURNS: Nothing.
                                   (0581) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0801: 7F       RET                 (0582) ;               modified as may the Page Pointer registers!
                                   (0583) ;               In the large memory model currently only the page
                                   (0584) ;               pointer registers listed below are modified.  This does
                                   (0585) ;               not guarantee that in future implementations of this
                                   (0586) ;               function other page pointer registers will not be
                                   (0587) ;               modified.
                                   (0588) ;          
                                   (0589) ;               Page Pointer Registers Modified: 
                                   (0590) ;               CUR_PP
                                   (0591) ;
                                   (0592) _UnloadConfig_receiver_config:
                                   (0593)  UnloadConfig_receiver_config:
                                   (0594)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0595) 
                                   (0596) 	push	x
                                   (0597)     M8C_SetBank0                    ; Force bank 0
                                   (0598)     mov     a, 0                    ; Specify bank 0
                                   (0599)     asr     a                       ; Store in carry flag
                                   (0600)                                     ; Bank 0 table address:
                                   (0601)     mov     A, >UnloadConfigTBL_receiver_config_Bank0
                                   (0602)     mov     X, <UnloadConfigTBL_receiver_config_Bank0
                                   (0603)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0604) 
                                   (0605)     mov     a, 1                    ; Specify bank 1
                                   (0606)     asr     a                       ; Store in carry flag
                                   (0607)                                     ; Bank 1 table address:
0802: 10       PUSH  X             (0608)     mov     A, >UnloadConfigTBL_receiver_config_Bank1
0803: 70 EF    AND   F,239         (0609)     mov     X, <UnloadConfigTBL_receiver_config_Bank1
0805: 50 00    MOV   A,0           (0610)     lcall   LoadConfig              ; Unload the bank 1 values
0807: 67       ASR   A             (0611) 
                                   (0612) 	M8C_SetBank1
0808: 50 04    MOV   A,4           (0613) ; writing AnalogColumnClockSelect register
080A: 57 06    MOV   X,6           (0614) 	and		reg[60h], ~30h
080C: 7C 08 27 LCALL 0x0827        (0615) ; writing AnalogColumnInputSelect register
                                   (0616) 	M8C_SetBank0
080F: 50 01    MOV   A,1           (0617) 	and		reg[60h], ~3ch
0811: 67       ASR   A             (0618) 	or		reg[60h], 28h
                                   (0619) ; writing Row_0_InputMux register
0812: 50 04    MOV   A,4           (0620) 	and		reg[b0h], ~30h
0814: 57 87    MOV   X,135         (0621) 	or		reg[b0h], 10h
0816: 7C 08 27 LCALL 0x0827        (0622) ; writing Row_0_OutputDrive_0 register
                                   (0623) 	and		reg[b5h], ~ 1h
0819: 71 10    OR    F,16          (0624) 	or		reg[b5h],  1h
081B: 70 EF    AND   F,239         (0625) ; writing Row_1_InputMux register
                                   (0626) 	and		reg[b8h], ~33h
081D: 62 D0 00 MOV   REG[208],0    (0627) 	or		reg[b8h],  2h
0820: 55 02 00 MOV   [2],0         (0628) ; writing Row_1_OutputDrive_0 register
0823: 70 EF    AND   F,239         (0629) 	and		reg[bdh], ~40h
0825: 20       POP   X             (0630) 	or		reg[bdh], 40h
                                   (0631) ; writing Port_2_DriveMode_2 register
                                   (0632) 	and		reg[ bh], ~7fh
0826: 7F       RET                 (0633) 	or		reg[ bh], 7fh
                                   (0634) ; writing Port_2_DriveMode_1 register
                                   (0635) 	M8C_SetBank1
                                   (0636) 	and		reg[ 9h], ~7fh
                                   (0637) 	or		reg[ 9h], 7fh
                                   (0638) ; writing Port_2_DriveMode_0 register
                                   (0639) 	and		reg[ 8h], ~7fh
                                   (0640) ; writing Port_1_DriveMode_2 register
                                   (0641) 	M8C_SetBank0
                                   (0642) 	and		reg[ 7h], ~ 1h
                                   (0643) ; writing Port_1_DriveMode_1 register
                                   (0644) 	M8C_SetBank1
                                   (0645) 	and		reg[ 5h], ~ 1h
                                   (0646) ; writing Port_1_DriveMode_0 register
                                   (0647) 	and		reg[ 4h], ~ 1h
                                   (0648) 	or		reg[ 4h],  1h
                                   (0649) ; writing Port_0_DriveMode_1 register
                                   (0650) 	and		reg[ 1h], ~ 1h
                                   (0651) ; writing Port_0_DriveMode_0 register
                                   (0652) 	and		reg[ 0h], ~ 1h
                                   (0653) 	or		reg[ 0h],  1h
                                   (0654) 	M8C_SetBank0
0827: 38 02    ADD   SP,2          (0655) ; clear config active bit
0829: 10       PUSH  X             (0656) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
082A: 08       PUSH  A             (0657) 	and		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], ~receiver_config_BIT
082B: 4F       MOV   X,SP          (0658)     M8C_SetBank0                    ; Force return to bank 0
082C: 56 FC 00 MOV   [X-4],0       (0659) 	pop		x
082F: D0 04    JNC   0x0834        (0660) 
0831: 56 FC 01 MOV   [X-4],1       (0661)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0662)     ret
0834: 18       POP   A             (0663) 
0835: 20       POP   X             (0664) ;---------------------------------------------------------------------------
                                   (0665) ; Unload Configuration Total
                                   (0666) ;
0836: 70 EF    AND   F,239         (0667) ;    Reset configuration registers for Total
0838: 62 E3 00 MOV   REG[227],0    (0668) ;    to their values as initially configured.
083B: 10       PUSH  X             (0669) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
083C: 08       PUSH  A             (0670) ;
083D: 28       ROMX                (0671) ;       INPUTS: None.
083E: 39 FF    CMP   A,255         (0672) ;      RETURNS: Nothing.
0840: A0 1F    JZ    0x0860        (0673) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
0842: 4F       MOV   X,SP          (0674) ;               modified as may the Page Pointer registers!
0843: 48 FC 01 TST   [X-4],1       (0675) ;               In the large memory model currently only the page
0846: A0 03    JZ    0x084A        (0676) ;               pointer registers listed below are modified.  This does
0848: 71 10    OR    F,16          (0677) ;               not guarantee that in future implementations of this
                                   (0678) ;               function other page pointer registers will not be
084A: 54 FD    MOV   [X-3],A       (0679) ;               modified.
084C: 18       POP   A             (0680) ;          
084D: 20       POP   X             (0681) ;               Page Pointer Registers Modified: 
084E: 75       INC   X             (0682) ;               CUR_PP
084F: 09 00    ADC   A,0           (0683) ;
0851: 10       PUSH  X             (0684) _UnloadConfig_Total:
0852: 08       PUSH  A             (0685)  UnloadConfig_Total:
0853: 28       ROMX                (0686)     RAM_PROLOGUE RAM_USE_CLASS_4
0854: 4F       MOV   X,SP          (0687) 
0855: 59 FD    MOV   X,[X-3]       (0688) 	push	x
0857: 61 00    MOV   REG[X+0],A    (0689)     M8C_SetBank0                    ; Force bank 0
0859: 18       POP   A             (0690)     mov     a, 0                    ; Specify bank 0
085A: 20       POP   X             (0691)     asr     a                       ; Store in carry flag
085B: 75       INC   X             (0692)                                     ; Bank 0 table address:
085C: 09 00    ADC   A,0           (0693)     mov     A, >UnloadConfigTBL_Total_Bank0
085E: 8F D7    JMP   0x0836        (0694)     mov     X, <UnloadConfigTBL_Total_Bank0
                                   (0695)     lcall   LoadConfig              ; Unload the bank 0 values
0860: 38 FC    ADD   SP,252        (0696) 
0862: 70 3F    AND   F,63
0864: 71 C0    OR    F,192         (0697)     mov     a, 1                    ; Specify bank 1
0867: 43 E1 02 OR    REG[225],2    (0698)     asr     a                       ; Store in carry flag

FILE: lib\tx_timeout.asm
                                   (0102) ;;*****************************************************************************
086A: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: TX_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "TX_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
086B: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
086E: 7F       RET                 (0131) export  TX_TIMEOUT_EnableInt
                                   (0132) export _TX_TIMEOUT_EnableInt
                                   (0133) export  TX_TIMEOUT_DisableInt
                                   (0134) export _TX_TIMEOUT_DisableInt
                                   (0135) export  TX_TIMEOUT_Start
                                   (0136) export _TX_TIMEOUT_Start
                                   (0137) export  TX_TIMEOUT_Stop
                                   (0138) export _TX_TIMEOUT_Stop
                                   (0139) export  TX_TIMEOUT_WritePeriod
                                   (0140) export _TX_TIMEOUT_WritePeriod
                                   (0141) export  TX_TIMEOUT_WriteCompareValue
                                   (0142) export _TX_TIMEOUT_WriteCompareValue
                                   (0143) export  TX_TIMEOUT_wReadCompareValue
                                   (0144) export _TX_TIMEOUT_wReadCompareValue
                                   (0145) export  TX_TIMEOUT_wReadTimer
                                   (0146) export _TX_TIMEOUT_wReadTimer
                                   (0147) export  TX_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _TX_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wTX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wTX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wTX_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wTX_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wTX_TIMEOUT_ReadTimerSaveCV   ; deprecated
086F: 43 23 01 OR    REG[35],1     (0157) export _wTX_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
0872: 7F       RET                 (0159) export  wTX_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wTX_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wTX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wTX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA transmitter_config_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: TX_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
0873: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
0876: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  TX_TIMEOUT_EnableInt:
                                   (0200) _TX_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    TX_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: TX_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
0877: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
0879: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
087A: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
087C: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  TX_TIMEOUT_DisableInt:
                                   (0228) _TX_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    TX_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: TX_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
087D: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
087F: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
0880: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
0882: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  TX_TIMEOUT_Start:
                                   (0256) _TX_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    TX_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: TX_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
0883: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
0885: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
0886: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
0888: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  TX_TIMEOUT_Stop:
                                   (0284) _TX_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    TX_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  TX_TIMEOUT_WritePeriod:
                                   (0313) _TX_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[TX_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[TX_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: TX_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call TX_TIMEOUT_Stop to disable).
0889: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
088A: 38 03    ADD   SP,3          (0334) ;
088C: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
088E: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
088F: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
0891: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
0892: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
0894: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
0895: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
0897: 5D 26    MOV   A,REG[38]     (0343) ;
0899: 54 01    MOV   [X+1],A       (0344)  TX_TIMEOUT_WriteCompareValue:
089B: 5D 22    MOV   A,REG[34]     (0345) _TX_TIMEOUT_WriteCompareValue:
089D: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
089F: 50 00    MOV   A,0           (0347)    mov   reg[TX_TIMEOUT_COMPARE_LSB_REG], A
08A1: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
08A4: A0 03    JZ    0x08A8        (0349)    mov   reg[TX_TIMEOUT_COMPARE_MSB_REG], A
08A6: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
08A8: 54 00    MOV   [X+0],A       (0352) 
08AA: 70 FE    AND   F,254         (0353) .ENDSECTION
08AC: 41 23 FE AND   REG[35],254   (0354) 
08AF: 18       POP   A             (0355) 
08B0: 60 26    MOV   REG[38],A     (0356) .SECTION
08B2: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
08B3: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: TX_TIMEOUT_wReadCompareValue
08B5: 18       POP   A             (0359) ;
08B6: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
08B8: 18       POP   A             (0361) ;     Reads the Compare registers.
08B9: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
08BA: 70 3F    AND   F,63
08BC: 71 C0    OR    F,192         (0363) ;
08BE: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  TX_TIMEOUT_wReadCompareValue:
                                   (0374) _TX_TIMEOUT_wReadCompareValue:
                                   (0375)  wTX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0376) _wTX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[TX_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[TX_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: TX_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
08BF: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
08C1: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
08C3: 5C       MOV   X,A           (0409) ;
08C4: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
08C8: 43 E1 04 OR    REG[225],4    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\tx_repeater.asm
                                   (0109) ;;*****************************************************************************
08CB: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_REPEATER.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_REPEATER.inc"
08CC: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
08CF: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_REPEATER_SetTxIntMode
                                   (0143) export  _TX_REPEATER_SetTxIntMode
                                   (0144) export   TX_REPEATER_EnableInt
                                   (0145) export  _TX_REPEATER_EnableInt
                                   (0146) export   TX_REPEATER_DisableInt
                                   (0147) export  _TX_REPEATER_DisableInt
                                   (0148) export   TX_REPEATER_Start
                                   (0149) export  _TX_REPEATER_Start
                                   (0150) export   TX_REPEATER_Stop
                                   (0151) export  _TX_REPEATER_Stop
                                   (0152) export   TX_REPEATER_SendData
                                   (0153) export  _TX_REPEATER_SendData
                                   (0154) export   TX_REPEATER_bReadTxStatus
                                   (0155) export  _TX_REPEATER_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_REPEATER_ReadTxStatus
                                   (0160) export  _bTX_REPEATER_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_REPEATER_PutSHexByte
                                   (0166) export _TX_REPEATER_PutSHexByte
                                   (0167) export  TX_REPEATER_PutSHexInt
                                   (0168) export _TX_REPEATER_PutSHexInt
                                   (0169) 
08D0: 71 10    OR    F,16          (0170) export  TX_REPEATER_CPutString
08D2: 21 01    AND   A,1           (0171) export _TX_REPEATER_CPutString
08D4: A0 07    JZ    0x08DC        (0172) export  TX_REPEATER_PutString
08D6: 43 28 10 OR    REG[40],16    (0173) export _TX_REPEATER_PutString
08D9: 70 EF    AND   F,239         (0174) export  TX_REPEATER_PutChar
                                   (0175) export _TX_REPEATER_PutChar
08DB: 7F       RET                 (0176) export  TX_REPEATER_Write
                                   (0177) export _TX_REPEATER_Write
                                   (0178) export  TX_REPEATER_CWrite
08DC: 41 28 EF AND   REG[40],239   (0179) export _TX_REPEATER_CWrite
08DF: 70 EF    AND   F,239         (0180) export  TX_REPEATER_PutCRLF
                                   (0181) export _TX_REPEATER_PutCRLF 
08E1: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_REPEATER_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
08E2: 29 01    OR    A,1           (0211) ;    functions.
08E4: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  TX_REPEATER_EnableInt:
08E6: 7F       RET                 (0214) _TX_REPEATER_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_REPEATER_INT_REG, TX_REPEATER_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_REPEATER_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
08E7: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
08EA: 7F       RET                 (0242)  TX_REPEATER_DisableInt:
                                   (0243) _TX_REPEATER_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_REPEATER_INT_REG, TX_REPEATER_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_REPEATER_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
08EB: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
08ED: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_REPEATER_SetTxIntMode:
                                   (0276) _TX_REPEATER_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_REPEATER_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_REPEATER_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_REPEATER_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_REPEATER_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
08EE: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
08F0: 7F       RET                 (0303) ;
08F1: 30       HALT  
08F2: 31 32    XOR   A,50
08F4: 33 34    XOR   A,[X+52]
08F6: 35 36    XOR   [X+54],A
08F8: 37 38 39 XOR   [X+56],57
08FB: 41 42 43 AND   REG[66],67
08FE: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_REPEATER_Start:
                                   (0317) _TX_REPEATER_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_REPEATER_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_REPEATER_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0901: 08       PUSH  A             (0335) ;
0902: 67       ASR   A             (0336) ;  RETURNS:  none
0903: 67       ASR   A             (0337) ;
0904: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0905: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0906: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0908: FF E7    INDEX 0x08F1        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
090A: 90 0F    CALL  0x091B        (0342) ;    responsibility to perserve their values across calls to fastcall16 
090C: 18       POP   A             (0343) ;    functions.
090D: 21 0F    AND   A,15          (0344) ;
090F: FF E0    INDEX 0x08F1        (0345)  TX_REPEATER_Stop:
0911: 90 08    CALL  0x091B        (0346) _TX_REPEATER_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0913: 7F       RET                 (0348)    and   REG[TX_REPEATER_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_REPEATER_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_REPEATER_SendData:
                                   (0375) _TX_REPEATER_SendData:
0914: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0915: 9F EA    CALL  0x0901        (0377)    mov REG[TX_REPEATER_TX_BUFFER_REG], A
0917: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0918: 9F E7    CALL  0x0901        (0379)    ret
                                   (0380) .ENDSECTION
091A: 7F       RET                 (0381) 
091B: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_REPEATER_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_REPEATER_bReadTxStatus:
                                   (0405) _TX_REPEATER_bReadTxStatus:
                                   (0406)  bTX_REPEATER_ReadTxStatus:
                                   (0407) _bTX_REPEATER_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_REPEATER_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
091E: AF FC    JZ    0x091B        (0416) ;  FUNCTION NAME: TX_REPEATER_PutSHexByte
0920: 60 29    MOV   REG[41],A
                                   (0417) ;
0922: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_REPEATER_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_REPEATER_PutSHexByte:
                                   (0441) _TX_REPEATER_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_REPEATER_HEX_STR          ; Get Hex value
                                   (0450)     call  TX_REPEATER_PutChar          ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_REPEATER_HEX_STR          ; Get Hex value
                                   (0454)     call  TX_REPEATER_PutChar          ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
0923: 70 BF    AND   F,191         (0456)     ret
0925: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0927: 52 00    MOV   A,[X+0]       (0459) .SECTION
0929: A0 06    JZ    0x0930        (0460) ;-----------------------------------------------------------------------------
092B: 9F EE    CALL  0x091B        (0461) ;  FUNCTION NAME: TX_REPEATER_PutSHexInt
092D: 75       INC   X             (0462) ;
092E: 8F F8    JMP   0x0927        (0463) ;  DESCRIPTION:
0930: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0932: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0934: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_REPEATER_PutSHexInt:
                                   (0482) _TX_REPEATER_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_REPEATER_PutSHexByte      ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_REPEATER_PutSHexByte      ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_REPEATER_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0935: 70 BF    AND   F,191         (0503) ;  RETURNS:
0937: 62 D3 07 MOV   REG[211],7    (0504) ;     none
093A: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
093B: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
093D: A0 1A    JZ    0x0958        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
093F: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
0941: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_REPEATER_CONTROL_REG], TX_REPEATER_TX_BUFFER_EMPTY    ; Check Tx Status
0943: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0945: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_REPEATER_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0947: 52 00    MOV   A,[X+0]       (0518)    endm
0949: 49 2B 10 TST   REG[43],16
094C: AF FC    JZ    0x0949        (0519) 
094E: 60 29    MOV   REG[41],A
0950: 4F       MOV   X,SP          (0520) 
0951: 62 D3 07 MOV   REG[211],7    (0521)  TX_REPEATER_PutChar:
0954: 77 FD    INC   [X-3]         (0522) _TX_REPEATER_PutChar:
0956: 8F E4    JMP   0x093B        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0958: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
095A: 71 C0    OR    F,192         (0526)    ret
095C: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_REPEATER_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_REPEATER_PutString:
                                   (0563) _TX_REPEATER_PutString:
095D: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
095E: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
0961: B0 06    JNZ   0x0968        (0569)    call  TX_REPEATER_PutChar                ; Send character to Tx port
0963: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
0966: A0 1D    JZ    0x0984        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
0968: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
0969: 52 FC    MOV   A,[X-4]       (0575)    ret
096B: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
096D: 28       ROMX                (0577) 
096E: 49 2B 10 TST   REG[43],16
0971: AF FC    JZ    0x096E        (0578) .SECTION
0973: 60 29    MOV   REG[41],A
0975: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_REPEATER_Write
0976: 07 FD 01 ADD   [X-3],1       (0581) ;
0979: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
097C: 17 FB 01 SUB   [X-5],1       (0585) ;
097F: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0982: 8F DB    JMP   0x095E        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0984: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_REPEATER_Write:
                                   (0610) _TX_REPEATER_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
0985: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
0986: 10       PUSH  X             (0622)    ENDIF
0987: 28       ROMX                (0623) 
0988: A0 0B    JZ    0x0994        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
098A: 9F 8F    CALL  0x091B        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
098C: 20       POP   X             (0626)    mov   A,[X]
098D: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
098E: 75       INC   X             (0628)    mov   X, SP
098F: DF F5    JNC   0x0985        (0629)    RAM_SETPAGE_IDX2STK
0991: 74       INC   A             (0630)    inc   [X+STR_LSB]
0992: 8F F2    JMP   0x0985        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
0994: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
0996: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_REPEATER_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
0997: 50 0D    MOV   A,13          (0663) ;
0999: 9F 80    CALL  0x091B        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
099B: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
099D: 9F 7C    CALL  0x091B        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
09A1: 43 E1 04 OR    REG[225],4    (0668) 

FILE: lib\transmit.asm
                                   (0109) ;;*****************************************************************************
09A4: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TRANSMIT.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TRANSMIT.inc"
09A5: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
09A8: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TRANSMIT_SetTxIntMode
                                   (0143) export  _TRANSMIT_SetTxIntMode
                                   (0144) export   TRANSMIT_EnableInt
                                   (0145) export  _TRANSMIT_EnableInt
                                   (0146) export   TRANSMIT_DisableInt
                                   (0147) export  _TRANSMIT_DisableInt
                                   (0148) export   TRANSMIT_Start
                                   (0149) export  _TRANSMIT_Start
                                   (0150) export   TRANSMIT_Stop
                                   (0151) export  _TRANSMIT_Stop
                                   (0152) export   TRANSMIT_SendData
                                   (0153) export  _TRANSMIT_SendData
                                   (0154) export   TRANSMIT_bReadTxStatus
                                   (0155) export  _TRANSMIT_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTRANSMIT_ReadTxStatus
                                   (0160) export  _bTRANSMIT_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TRANSMIT_PutSHexByte
                                   (0166) export _TRANSMIT_PutSHexByte
                                   (0167) export  TRANSMIT_PutSHexInt
                                   (0168) export _TRANSMIT_PutSHexInt
                                   (0169) 
09A9: 71 10    OR    F,16          (0170) export  TRANSMIT_CPutString
09AB: 21 01    AND   A,1           (0171) export _TRANSMIT_CPutString
09AD: A0 07    JZ    0x09B5        (0172) export  TRANSMIT_PutString
09AF: 43 28 10 OR    REG[40],16    (0173) export _TRANSMIT_PutString
09B2: 70 EF    AND   F,239         (0174) export  TRANSMIT_PutChar
                                   (0175) export _TRANSMIT_PutChar
09B4: 7F       RET                 (0176) export  TRANSMIT_Write
                                   (0177) export _TRANSMIT_Write
                                   (0178) export  TRANSMIT_CWrite
09B5: 41 28 EF AND   REG[40],239   (0179) export _TRANSMIT_CWrite
09B8: 70 EF    AND   F,239         (0180) export  TRANSMIT_PutCRLF
                                   (0181) export _TRANSMIT_PutCRLF 
09BA: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TRANSMIT_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
09BB: 29 01    OR    A,1           (0211) ;    functions.
09BD: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  TRANSMIT_EnableInt:
09BF: 7F       RET                 (0214) _TRANSMIT_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TRANSMIT_INT_REG, TRANSMIT_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TRANSMIT_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
09C0: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
09C3: 7F       RET                 (0242)  TRANSMIT_DisableInt:
                                   (0243) _TRANSMIT_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TRANSMIT_INT_REG, TRANSMIT_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TRANSMIT_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
09C4: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
09C6: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TRANSMIT_SetTxIntMode:
                                   (0276) _TRANSMIT_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TRANSMIT_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TRANSMIT_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TRANSMIT_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TRANSMIT_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
09C7: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
09C9: 7F       RET                 (0303) ;
09CA: 30       HALT  
09CB: 31 32    XOR   A,50
09CD: 33 34    XOR   A,[X+52]
09CF: 35 36    XOR   [X+54],A
09D1: 37 38 39 XOR   [X+56],57
09D4: 41 42 43 AND   REG[66],67
09D7: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TRANSMIT_Start:
                                   (0317) _TRANSMIT_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TRANSMIT_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TRANSMIT_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
09DA: 08       PUSH  A             (0335) ;
09DB: 67       ASR   A             (0336) ;  RETURNS:  none
09DC: 67       ASR   A             (0337) ;
09DD: 67       ASR   A             (0338) ;  SIDE EFFECTS:
09DE: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
09DF: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
09E1: FF E7    INDEX 0x09CA        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
09E3: 90 0F    CALL  0x09F4        (0342) ;    responsibility to perserve their values across calls to fastcall16 
09E5: 18       POP   A             (0343) ;    functions.
09E6: 21 0F    AND   A,15          (0344) ;
09E8: FF E0    INDEX 0x09CA        (0345)  TRANSMIT_Stop:
09EA: 90 08    CALL  0x09F4        (0346) _TRANSMIT_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
09EC: 7F       RET                 (0348)    and   REG[TRANSMIT_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TRANSMIT_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TRANSMIT_SendData:
                                   (0375) _TRANSMIT_SendData:
09ED: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
09EE: 9F EA    CALL  0x09DA        (0377)    mov REG[TRANSMIT_TX_BUFFER_REG], A
09F0: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
09F1: 9F E7    CALL  0x09DA        (0379)    ret
                                   (0380) .ENDSECTION
09F3: 7F       RET                 (0381) 
09F4: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TRANSMIT_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TRANSMIT_bReadTxStatus:
                                   (0405) _TRANSMIT_bReadTxStatus:
                                   (0406)  bTRANSMIT_ReadTxStatus:
                                   (0407) _bTRANSMIT_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TRANSMIT_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
09F7: AF FC    JZ    0x09F4        (0416) ;  FUNCTION NAME: TRANSMIT_PutSHexByte
09F9: 60 29    MOV   REG[41],A
                                   (0417) ;
09FB: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TRANSMIT_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TRANSMIT_PutSHexByte:
                                   (0441) _TRANSMIT_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TRANSMIT_HEX_STR             ; Get Hex value
                                   (0450)     call  TRANSMIT_PutChar             ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TRANSMIT_HEX_STR             ; Get Hex value
                                   (0454)     call  TRANSMIT_PutChar             ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
09FC: 70 BF    AND   F,191         (0456)     ret
09FE: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0A00: 52 00    MOV   A,[X+0]       (0459) .SECTION
0A02: A0 06    JZ    0x0A09        (0460) ;-----------------------------------------------------------------------------
0A04: 9F EE    CALL  0x09F4        (0461) ;  FUNCTION NAME: TRANSMIT_PutSHexInt
0A06: 75       INC   X             (0462) ;
0A07: 8F F8    JMP   0x0A00        (0463) ;  DESCRIPTION:
0A09: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
0A0B: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
0A0D: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TRANSMIT_PutSHexInt:
                                   (0482) _TRANSMIT_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TRANSMIT_PutSHexByte         ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TRANSMIT_PutSHexByte         ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TRANSMIT_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
0A0E: 70 BF    AND   F,191         (0503) ;  RETURNS:
0A10: 62 D3 07 MOV   REG[211],7    (0504) ;     none
0A13: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0A14: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0A16: A0 1A    JZ    0x0A31        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
0A18: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
0A1A: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TRANSMIT_CONTROL_REG], TRANSMIT_TX_BUFFER_EMPTY    ; Check Tx Status
0A1C: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
0A1E: 60 D3    MOV   REG[211],A    (0517)    mov REG[TRANSMIT_TX_BUFFER_REG], @Source    ; Write data to Tx Port
0A20: 52 00    MOV   A,[X+0]       (0518)    endm
0A22: 49 2B 10 TST   REG[43],16
0A25: AF FC    JZ    0x0A22        (0519) 
0A27: 60 29    MOV   REG[41],A
0A29: 4F       MOV   X,SP          (0520) 
0A2A: 62 D3 07 MOV   REG[211],7    (0521)  TRANSMIT_PutChar:
0A2D: 77 FD    INC   [X-3]         (0522) _TRANSMIT_PutChar:
0A2F: 8F E4    JMP   0x0A14        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
0A31: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
0A33: 71 C0    OR    F,192         (0526)    ret
0A35: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TRANSMIT_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TRANSMIT_PutString:
                                   (0563) _TRANSMIT_PutString:
0A36: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
0A37: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
0A3A: B0 06    JNZ   0x0A41        (0569)    call  TRANSMIT_PutChar                   ; Send character to Tx port
0A3C: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
0A3F: A0 1D    JZ    0x0A5D        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
0A41: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
0A42: 52 FC    MOV   A,[X-4]       (0575)    ret
0A44: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
0A46: 28       ROMX                (0577) 
0A47: 49 2B 10 TST   REG[43],16
0A4A: AF FC    JZ    0x0A47        (0578) .SECTION
0A4C: 60 29    MOV   REG[41],A
0A4E: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TRANSMIT_Write
0A4F: 07 FD 01 ADD   [X-3],1       (0581) ;
0A52: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
0A55: 17 FB 01 SUB   [X-5],1       (0585) ;
0A58: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0A5B: 8F DB    JMP   0x0A37        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0A5D: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TRANSMIT_Write:
                                   (0610) _TRANSMIT_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
0A5E: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
0A5F: 10       PUSH  X             (0622)    ENDIF
0A60: 28       ROMX                (0623) 
0A61: A0 0B    JZ    0x0A6D        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
0A63: 9F 8F    CALL  0x09F4        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
0A65: 20       POP   X             (0626)    mov   A,[X]
0A66: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
0A67: 75       INC   X             (0628)    mov   X, SP
0A68: DF F5    JNC   0x0A5E        (0629)    RAM_SETPAGE_IDX2STK
0A6A: 74       INC   A             (0630)    inc   [X+STR_LSB]
0A6B: 8F F2    JMP   0x0A5E        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
0A6D: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
0A6F: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TRANSMIT_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
0A70: 50 0D    MOV   A,13          (0663) ;
0A72: 9F 80    CALL  0x09F4        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
0A74: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
0A76: 9F 7C    CALL  0x09F4        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
0A79: 43 E1 02 OR    REG[225],2    (0668) 

FILE: lib\rx_timeout.asm
                                   (0102) ;;*****************************************************************************
0A7C: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: RX_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "RX_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
0A7D: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
0A80: 7F       RET                 (0131) export  RX_TIMEOUT_EnableInt
                                   (0132) export _RX_TIMEOUT_EnableInt
                                   (0133) export  RX_TIMEOUT_DisableInt
                                   (0134) export _RX_TIMEOUT_DisableInt
                                   (0135) export  RX_TIMEOUT_Start
                                   (0136) export _RX_TIMEOUT_Start
                                   (0137) export  RX_TIMEOUT_Stop
                                   (0138) export _RX_TIMEOUT_Stop
                                   (0139) export  RX_TIMEOUT_WritePeriod
                                   (0140) export _RX_TIMEOUT_WritePeriod
                                   (0141) export  RX_TIMEOUT_WriteCompareValue
                                   (0142) export _RX_TIMEOUT_WriteCompareValue
                                   (0143) export  RX_TIMEOUT_wReadCompareValue
                                   (0144) export _RX_TIMEOUT_wReadCompareValue
                                   (0145) export  RX_TIMEOUT_wReadTimer
                                   (0146) export _RX_TIMEOUT_wReadTimer
                                   (0147) export  RX_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _RX_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wRX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wRX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wRX_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wRX_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wRX_TIMEOUT_ReadTimerSaveCV   ; deprecated
0A81: 43 23 01 OR    REG[35],1     (0157) export _wRX_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
0A84: 7F       RET                 (0159) export  wRX_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wRX_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wRX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wRX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA receiver_config_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: RX_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
0A85: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
0A88: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  RX_TIMEOUT_EnableInt:
                                   (0200) _RX_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    RX_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: RX_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
0A89: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
0A8B: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
0A8C: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
0A8E: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  RX_TIMEOUT_DisableInt:
                                   (0228) _RX_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    RX_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: RX_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
0A8F: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
0A91: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
0A92: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
0A94: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  RX_TIMEOUT_Start:
                                   (0256) _RX_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    RX_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: RX_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
0A95: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
0A97: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
0A98: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
0A9A: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  RX_TIMEOUT_Stop:
                                   (0284) _RX_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    RX_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: RX_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  RX_TIMEOUT_WritePeriod:
                                   (0313) _RX_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[RX_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[RX_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: RX_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call RX_TIMEOUT_Stop to disable).
0A9B: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
0A9C: 38 03    ADD   SP,3          (0334) ;
0A9E: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
0AA0: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
0AA1: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
0AA3: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
0AA4: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
0AA6: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
0AA7: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
0AA9: 5D 26    MOV   A,REG[38]     (0343) ;
0AAB: 54 01    MOV   [X+1],A       (0344)  RX_TIMEOUT_WriteCompareValue:
0AAD: 5D 22    MOV   A,REG[34]     (0345) _RX_TIMEOUT_WriteCompareValue:
0AAF: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
0AB1: 50 00    MOV   A,0           (0347)    mov   reg[RX_TIMEOUT_COMPARE_LSB_REG], A
0AB3: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
0AB6: A0 03    JZ    0x0ABA        (0349)    mov   reg[RX_TIMEOUT_COMPARE_MSB_REG], A
0AB8: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
0ABA: 54 00    MOV   [X+0],A       (0352) 
0ABC: 70 FE    AND   F,254         (0353) .ENDSECTION
0ABE: 41 23 FE AND   REG[35],254   (0354) 
0AC1: 18       POP   A             (0355) 
0AC2: 60 26    MOV   REG[38],A     (0356) .SECTION
0AC4: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
0AC5: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: RX_TIMEOUT_wReadCompareValue
0AC7: 18       POP   A             (0359) ;
0AC8: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
0ACA: 18       POP   A             (0361) ;     Reads the Compare registers.
0ACB: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
0ACC: 70 3F    AND   F,63
0ACE: 71 C0    OR    F,192         (0363) ;
0AD0: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  RX_TIMEOUT_wReadCompareValue:
                                   (0374) _RX_TIMEOUT_wReadCompareValue:
                                   (0375)  wRX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0376) _wRX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[RX_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[RX_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: RX_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
0AD1: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
0AD3: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
0AD5: 5C       MOV   X,A           (0409) ;
0AD6: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
0AD9: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\receiveint.asm
0ADA: 10       PUSH  X             (0104) ;;*****************************************************************************
0ADB: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RECEIVEINT.asm
0ADD: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0ADE: 58 01    MOV   X,[1]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0AE0: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
0AE2: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0AE3: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0AE5: B0 04    JNZ   0x0AEA        (0115) 
0AE7: 18       POP   A             (0116) include "m8c.inc"
0AE8: 80 62    JMP   0x0B4B        (0117) include "memory.inc"
                                   (0118) include "RECEIVE.inc"
                                   (0119) 
                                   (0120) 
0AEA: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0AEB: 21 E0    AND   A,224         (0124) export  _RECEIVE_ISR
0AED: A0 12    JZ    0x0B00        (0125) 
                                   (0126) 
0AEF: 2C 00    OR    [0],A         (0127) IF (RECEIVE_RXBUF_ENABLE)
                                   (0128) export  RECEIVE_aRxBuffer
0AF1: 49 2A 00 TST   REG[42],0     (0129) export _RECEIVE_aRxBuffer
                                   (0130) export  RECEIVE_bRxCnt
0AF4: 21 20    AND   A,32          (0131) export _RECEIVE_bRxCnt
0AF6: A0 54    JZ    0x0B4B        (0132) export  RECEIVE_fStatus
                                   (0133) export _RECEIVE_fStatus
                                   (0134) ENDIF
                                   (0135) 
0AF8: 41 2B FE AND   REG[43],254   (0136) 
0AFB: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
0AFE: 80 4C    JMP   0x0B4B        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RECEIVE_RXBUF_ENABLE)
0B00: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RECEIVE_fStatus:
                                   (0144) _RECEIVE_fStatus:      BLK  1
0B02: 47 00 01 TST   [0],1         (0145)  RECEIVE_bRxCnt:
0B05: B0 45    JNZ   0x0B4B        (0146) _RECEIVE_bRxCnt:       BLK  1
                                   (0147) AREA RECEIVE_RAM(RAM,REL,CON)
0B07: 39 00    CMP   A,0           (0148)  RECEIVE_aRxBuffer:    
0B09: B0 14    JNZ   0x0B1E        (0149) _RECEIVE_aRxBuffer:    BLK RECEIVE_RX_BUFFER_SIZE
0B0B: 2E 00 01 OR    [0],1         (0150) ENDIF
                                   (0151) 
0B0E: 62 D3 00 MOV   REG[211],0    (0152) 
0B11: 70 3F    AND   F,63
0B13: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0B15: 56 48 00 MOV   [X+72],0      (0154) 
0B18: 70 3F    AND   F,63
0B1A: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0B1C: 80 2E    JMP   0x0B4B        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
0B1E: 39 01    CMP   A,1           (0162) ;------------------------
0B20: C0 2A    JC    0x0B4B        (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0B22: 3C 01 0F CMP   [1],15        (0167) ;------------------------
0B25: C0 14    JC    0x0B3A        (0168) 
0B27: 2E 00 10 OR    [0],16        (0169) 
                                   (0170) ;------------------------
0B2A: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0B2D: 70 3F    AND   F,63
0B2F: 71 80    OR    F,128         (0172) ;------------------------
0B31: 56 48 00 MOV   [X+72],0      (0173) 
0B34: 70 3F    AND   F,63
0B36: 71 00    OR    F,0           (0174) 
0B38: 80 12    JMP   0x0B4B        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0B3A: 75       INC   X             (0179) 
0B3B: 5A 01    MOV   [1],X         (0180) 
0B3D: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0B3E: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0B41: 70 3F    AND   F,63
0B43: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RECEIVE_ISR
0B45: 54 48    MOV   [X+72],A      (0185) ;
0B47: 70 3F    AND   F,63
0B49: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0B4B: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0B4C: 60 D3    MOV   REG[211],A    (0191) _RECEIVE_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0B4E: 20       POP   X             (0195)    ; Insert your custom code below this banner
0B4F: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0B51: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\receive.asm
                                   (0121) ;;*****************************************************************************
0B54: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RECEIVE.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RECEIVE.inc"
0B55: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
0B58: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RECEIVE_EnableInt
                                   (0155) export  _RECEIVE_EnableInt
                                   (0156) export   RECEIVE_DisableInt
                                   (0157) export  _RECEIVE_DisableInt
                                   (0158) export   RECEIVE_Start
                                   (0159) export  _RECEIVE_Start
                                   (0160) export   RECEIVE_Stop
                                   (0161) export  _RECEIVE_Stop
                                   (0162) export   RECEIVE_bReadRxData
                                   (0163) export  _RECEIVE_bReadRxData
                                   (0164) export   RECEIVE_bReadRxStatus
                                   (0165) export  _RECEIVE_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRECEIVE_ReadRxData
                                   (0170) export _bRECEIVE_ReadRxData
                                   (0171) export  bRECEIVE_ReadRxStatus
                                   (0172) export _bRECEIVE_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RECEIVE_cGetChar
0B59: 29 01    OR    A,1           (0179) export _RECEIVE_cGetChar
0B5B: 60 2B    MOV   REG[43],A     (0180) export  RECEIVE_cReadChar
                                   (0181) export _RECEIVE_cReadChar
0B5D: 7F       RET                 (0182) export  RECEIVE_iReadChar
                                   (0183) export _RECEIVE_iReadChar
                                   (0184) 
                                   (0185) IF (RECEIVE_RXBUF_ENABLE)
                                   (0186) export  RECEIVE_CmdReset
                                   (0187) export _RECEIVE_CmdReset
                                   (0188) export  RECEIVE_bCmdCheck
                                   (0189) export _RECEIVE_bCmdCheck
                                   (0190) export  RECEIVE_bCmdLength
                                   (0191) export _RECEIVE_bCmdLength
                                   (0192) export  RECEIVE_bErrCheck
                                   (0193) export _RECEIVE_bErrCheck
                                   (0194) 
                                   (0195) export  RECEIVE_szGetParam
                                   (0196) export _RECEIVE_szGetParam
                                   (0197) export  RECEIVE_szGetRestOfParams
                                   (0198) export _RECEIVE_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RECEIVE_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0B5E: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0B61: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RECEIVE_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RECEIVE_EnableInt:
                                   (0238) _RECEIVE_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0B62: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask RECEIVE_INT_REG, RECEIVE_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0B64: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RECEIVE_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RECEIVE_DisableInt:
                                   (0267) _RECEIVE_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RECEIVE_INT_REG, RECEIVE_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0B65: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
0B67: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RECEIVE_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RECEIVE_Start:
                                   (0297) _RECEIVE_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RECEIVE_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RECEIVE_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0B68: 49 2B 08 TST   REG[43],8     (0311) ;
0B6B: AF FC    JZ    0x0B68        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0B6D: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0B6F: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RECEIVE_Stop:
                                   (0326) _RECEIVE_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RECEIVE_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RECEIVE_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0B70: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
0B72: 08       PUSH  A             (0347) ;
0B73: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0B75: B0 04    JNZ   0x0B7A        (0349) ;    The A and X registers may be modified by this or future implementations
0B77: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0B78: 80 0B    JMP   0x0B84        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0B7A: 5D 2A    MOV   A,REG[42]     (0354) ;
0B7C: 4B       SWAP  A,X           (0355)  RECEIVE_bReadRxData:
                                   (0356) _RECEIVE_bReadRxData:
0B7D: 18       POP   A             (0357)  bRECEIVE_ReadRxData:
0B7E: 21 A0    AND   A,160         (0358) _bRECEIVE_ReadRxData:
0B80: B0 03    JNZ   0x0B84        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0B82: 4B       SWAP  A,X           (0360)    mov A, REG[RECEIVE_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0B83: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0B84: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RECEIVE_bReadRxStatus
                                   (0368) ;
0B86: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RECEIVE_bReadRxStatus:
                                   (0388) _RECEIVE_bReadRxStatus:
                                   (0389)  bRECEIVE_ReadRxStatus:
                                   (0390) _bRECEIVE_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RECEIVE_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RECEIVE_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0B87: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0B89: 21 E8    AND   A,232         (0408) ;
0B8B: 08       PUSH  A             (0409) ;  ARGUMENTS:
0B8C: 21 08    AND   A,8           (0410) ;      none
0B8E: B0 07    JNZ   0x0B96        (0411) ;
0B90: 18       POP   A             (0412) ;  RETURNS:
0B91: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0B93: 4B       SWAP  A,X           (0414) ;
0B94: 80 07    JMP   0x0B9C        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0B96: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0B97: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0B99: 4B       SWAP  A,X           (0420) ;    functions.
0B9A: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0B9C: 7F       RET                 (0426)  RECEIVE_cGetChar:
                                   (0427) _RECEIVE_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RECEIVE_CONTROL_REG],RECEIVE_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RECEIVE_RX_BUFFER_REG]             ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RECEIVE_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RECEIVE_cReadChar:
                                   (0463) _RECEIVE_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RECEIVE_CONTROL_REG]                         ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RECEIVE_RX_COMPLETE                              ; Check if a character is ready
0B9D: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0BA0: 55 48 00 MOV   [72],0        (0470)    pop  A
0BA3: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0BA6: 55 7A 00 MOV   [PARAM+1],0   (0472) 
0BA9: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0BAC: 55 01 00 MOV   [1],0         (0474)    mov  A,REG[RECEIVE_RX_BUFFER_REG]                       ; Read data first, then
0BAF: 26 00 00 AND   [0],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0BB2: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RECEIVE_RX_PARITY_ERROR | RECEIVE_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RECEIVE_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RECEIVE_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0BB3: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0BB6: 51 00    MOV   A,[0]         (0511) ;        0x40CC    Overrun Error
0BB8: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0BBA: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RECEIVE_iReadChar:
                                   (0523) _RECEIVE_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RECEIVE_CONTROL_REG]                         ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RECEIVE_RX_ERROR|RECEIVE_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RECEIVE_RX_COMPLETE                              ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RECEIVE_RX_NO_DATA                               ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RECEIVE_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RECEIVE_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RECEIVE_RX_BUFFER_REG]                       ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RECEIVE_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RECEIVE_RXBUF_ENABLE)
                                   (0552) .SECTION
0BBB: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0BBE: 51 00    MOV   A,[0]         (0554) ;-----------------------------------------------------------------------------
0BC0: 21 F0    AND   A,240         (0555) ;
0BC2: 26 00 0F AND   [0],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0BC5: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RECEIVE_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RECEIVE_CmdReset:
0BC6: 62 D0 00 MOV   REG[208],0    (0587) _RECEIVE_CmdReset:
0BC9: 51 01    MOV   A,[1]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RECEIVE_aRxBuffer
0BCB: 7F       RET                 (0590)    mov [RECEIVE_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RECEIVE_bRxCnt
                                   (0594)    mov [RECEIVE_bRxCnt], 0x00
                                   (0595)    and [RECEIVE_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RECEIVE_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RECEIVE_bCmdCheck:
                                   (0628) _RECEIVE_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RECEIVE_fStatus
                                   (0631)    mov A,  [RECEIVE_fStatus]
                                   (0632)    and A, RECEIVE_RX_BUF_CMDTERM                 ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RECEIVE_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0BCC: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0BCE: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0BD1: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0BD4: 50 48    MOV   A,72          (0648) ;     BYTE  fStatus - Status of command receive buffer.
0BD6: 02 7A    ADD   A,[PARAM+1]   (0649) ;                     Returns non-zero value in A if command is valid.
0BD8: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0BD9: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0BDB: B0 04    JNZ   0x0BE0        (0653) ;           0x10 => Software Buffer OverRun
0BDD: 10       PUSH  X             (0654) ;
0BDE: 80 33    JMP   0x0C12        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0BE0: 39 00    CMP   A,0           (0660) ;    functions.
0BE2: B0 11    JNZ   0x0BF4        (0661) ;          
0BE4: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0BE5: 76 7A    INC   [PARAM+1]     (0663) ;          CUR_PP
0BE7: 52 00    MOV   A,[X+0]       (0664) ;
0BE9: 3C 7A 0F CMP   [PARAM+1],15  (0665) ;     Error Status is clear when read.
0BEC: BF F3    JNZ   0x0BE0        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0BEE: 10       PUSH  X             (0669) ;
                                   (0670)  RECEIVE_bErrCheck:
0BEF: 56 00 00 MOV   [X+0],0       (0671) _RECEIVE_bErrCheck:
0BF2: 80 1F    JMP   0x0C12        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RECEIVE_fStatus
                                   (0674)    mov A,  [RECEIVE_fStatus]
0BF4: 10       PUSH  X             (0675)    and A, RECEIVE_RX_BUF_ERROR                   ; Mask off Error status
                                   (0676)    and [RECEIVE_fStatus], ~RECEIVE_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0BF5: 75       INC   X             (0679) .ENDSECTION
0BF6: 76 7A    INC   [PARAM+1]     (0680) 
0BF8: 3C 7A 0F CMP   [PARAM+1],15  (0681) .SECTION
0BFB: AF F3    JZ    0x0BEF        (0682) ;-----------------------------------------------------------------------------
0BFD: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RECEIVE_bCmdLength
0BFF: A0 12    JZ    0x0C12        (0684) ;
0C01: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0C03: BF F1    JNZ   0x0BF5        (0686) ;     Get length of command string
                                   (0687) ;
0C05: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0C08: 76 7A    INC   [PARAM+1]     (0689) ;     none.
0C0A: 3C 7A 0F CMP   [PARAM+1],15  (0690) ;
0C0D: B0 04    JNZ   0x0C12        (0691) ;  RETURNS:
0C0F: 55 7A 0F MOV   [PARAM+1],15  (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0C12: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0C13: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0C14: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0C17: B0 0B    JNZ   0x0C23        (0699) ;    functions.
0C19: 20       POP   X             (0700) ;          
0C1A: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0C1C: 50 00    MOV   A,0           (0702) ;          CUR_PP
0C1E: 70 3F    AND   F,63
0C20: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RECEIVE_bCmdLength:
0C22: 7F       RET                 (0705) _RECEIVE_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RECEIVE_bRxCnt
0C23: 20       POP   X             (0708)    mov A,  [RECEIVE_bRxCnt]
0C24: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0C26: 70 3F    AND   F,63
0C28: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0C2A: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RECEIVE_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0C2B: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0C2E: 50 48    MOV   A,72          (0744) ;     each lexically distinct element into a null-terminated string by replacing
0C30: 02 7A    ADD   A,[PARAM+1]   (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0C32: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0C33: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RECEIVE_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RECEIVE_szGetParam, is
0C36: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\lcd_2.asm
0C37: 10       PUSH  X             (0210) ;;*****************************************************************************
0C38: 28       ROMX                (0211) ;;*****************************************************************************
0C39: B0 04    JNZ   0x0C3E        (0212) ;;  FILENAME:   LCD_2.asm
0C3B: 20       POP   X             (0213) ;;  Version: 1.5, Updated on 2009/7/10 at 10:44:58
0C3C: 18       POP   A             (0214) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0215) ;;
0C3D: 7F       RET                 (0216) ;;  DESCRIPTION: LCD User Module software implementation file
                                   (0217) ;;               for the M8C based PSoC family of devices.
                                   (0218) ;;
0C3E: 90 44    CALL  0x0C84        (0219) ;; This set of functions is written for the common 2 and 4 line
0C40: 20       POP   X             (0220) ;; LCDs that use the Hitachi HD44780A controller.
0C41: 18       POP   A             (0221) ;;
0C42: 75       INC   X             (0222) ;;  LCD connections to PSoC port
0C43: DF F2    JNC   0x0C36        (0223) ;;
0C45: 74       INC   A             (0224) ;;    PX.0 ==> LCD D4
0C46: 8F EF    JMP   0x0C36        (0225) ;;    PX.1 ==> LCD D5
0C48: 30       HALT  
0C49: 31 32    XOR   A,50
0C4B: 33 34    XOR   A,[X+52]
0C4D: 35 36    XOR   [X+54],A
0C4F: 37 38 39 XOR   [X+56],57
0C52: 41 42 43 AND   REG[66],67
0C55: 44 45 46 OR    REG[X+69],70
                                   (0226) ;;    PX.2 ==> LCD D6
                                   (0227) ;;    PX.3 ==> LCD D7
                                   (0228) ;;    PX.4 ==> LCD E
                                   (0229) ;;    PX.5 ==> LCD RS
                                   (0230) ;;    PX.6 ==> LCD R/W
                                   (0231) ;;
                                   (0232) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0233) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0234) ;;        This means it is the caller's responsibility to preserve any values
                                   (0235) ;;        in the X and A registers that are still needed after the API functions
                                   (0236) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0237) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0238) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0239) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0240) ;;-----------------------------------------------------------------------------
                                   (0241) ;;  Copyright (c) Cypress Semiconductor 2001-2006. All Rights Reserved.
                                   (0242) ;;*****************************************************************************
                                   (0243) ;;*****************************************************************************
                                   (0244) 
                                   (0245) include "m8c.inc"
                                   (0246) include "memory.inc"
                                   (0247) include "LCD_2.inc"
                                   (0248) 
                                   (0249) ;-----------------------------------------------
                                   (0250) ;  Global Symbols
                                   (0251) ;-----------------------------------------------
                                   (0252) 
                                   (0253) export   LCD_2_Start
                                   (0254) export  _LCD_2_Start
                                   (0255) export   LCD_2_Init
                                   (0256) export  _LCD_2_Init
                                   (0257) 
                                   (0258) export   LCD_2_WriteData
                                   (0259) export  _LCD_2_WriteData
                                   (0260) 
0C58: 08       PUSH  A             (0261) export   LCD_2_Control
0C59: 67       ASR   A             (0262) export  _LCD_2_Control
0C5A: 67       ASR   A             (0263) 
0C5B: 67       ASR   A             (0264) export  LCD_2_PrString
0C5C: 67       ASR   A             (0265) export _LCD_2_PrString
0C5D: 21 0F    AND   A,15          (0266) 
0C5F: FF E7    INDEX 0x0C48        (0267) export  LCD_2_PrCString
0C61: 90 21    CALL  0x0C84        (0268) export _LCD_2_PrCString
0C63: 18       POP   A             (0269) 
0C64: 21 0F    AND   A,15          (0270) export  LCD_2_Position
0C66: FF E0    INDEX 0x0C48        (0271) export _LCD_2_Position
0C68: 90 1A    CALL  0x0C84        (0272) 
                                   (0273) export  LCD_2_PrHexByte
0C6A: 7F       RET                 (0274) export _LCD_2_PrHexByte
                                   (0275) 
                                   (0276) export  LCD_2_PrHexInt
                                   (0277) export _LCD_2_PrHexInt
                                   (0278) 
                                   (0279) export  LCD_2_Delay50uTimes
                                   (0280) export _LCD_2_Delay50uTimes
                                   (0281) 
                                   (0282) export  LCD_2_Delay50u
                                   (0283) export _LCD_2_Delay50u
                                   (0284) 
                                   (0285) ;-----------------------------------------------
                                   (0286) ; If bargraph functions not required, don't
                                   (0287) ; export the function names.
                                   (0288) ;-----------------------------------------------
                                   (0289) 
                                   (0290) IF (LCD_2_BARGRAPH_ENABLE)
                                   (0291) export  LCD_2_InitBG
                                   (0292) export _LCD_2_InitBG
                                   (0293) 
                                   (0294) export  LCD_2_InitVBG
                                   (0295) export _LCD_2_InitVBG
                                   (0296) 
                                   (0297) ; NOTE: The two functions,
                                   (0298) ;
                                   (0299) ;    LCD_2_DrawVBG and
                                   (0300) ;    LCD_2_DrawBG
                                   (0301) ;
                                   (0302) ; are implemented using both fastcall16 and legacy fastcall16 because they
                                   (0303) ; fall into a special and rare case where the calling sequences specified
                                   (0304) ; by the two disciplines are incompatible. The fastcall16 versions are
                                   (0305) ; provided for both C and Assembly users in all memory models. The legacy
0C6B: 4B       SWAP  A,X           (0306) ; fastcall16 versions are provided only to support existing small memory
0C6C: 9F EA    CALL  0x0C58        (0307) ; model assembly language code---they do not work in the large memory
0C6E: 5B       MOV   A,X           (0308) ; model.
0C6F: 9F E7    CALL  0x0C58        (0309) ;
                                   (0310) ; ** The legacy fastcall16 versions are provided on a temporary basis to
0C71: 7F       RET                 (0311) ; ** ease the transition to the 4.2 release of PSoC Designer. Their use is
                                   (0312) ; ** deprecated and their status is "No Further Maintenance".
                                   (0313) ;
                                   (0314) ; The fastcall16 versions of these functions are distinguished by a
                                   (0315) ; leading underscore in the name. The legacy fastcall16 names (which appear
                                   (0316) ; in this comment) do not have the leading underscore. Details on the
                                   (0317) ; calling sequence to be used for fastcall16 are given in the user module
                                   (0318) ; datasheet.
                                   (0319) ;
                                   (0320) ; Fastcall16 versions:
                                   (0321) export _LCD_2_DrawVBG
                                   (0322) export _LCD_2_DrawBG
                                   (0323) 
                                   (0324) IF SYSTEM_SMALL_MEMORY_MODEL
                                   (0325) ; Legacy Fastcall versions:
                                   (0326) export  LCD_2_DrawVBG
                                   (0327) export  LCD_2_DrawBG
                                   (0328) ENDIF  ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0329) 
                                   (0330) ENDIF  ; BARGRAPH_ENABLE
                                   (0331) 
                                   (0332) ;
                                   (0333) ; The following functions are deprecated and will be eliminated in a future
                                   (0334) ; version of PSoC Designer.
                                   (0335) ;
                                   (0336) export   LCD_2_Write_Data
                                   (0337) export  _LCD_2_Write_Data
                                   (0338) 
                                   (0339) 
                                   (0340) ;-----------------------------------------------
                                   (0341) ;  EQUATES
                                   (0342) ;-----------------------------------------------
                                   (0343) 
0C72: 70 BF    AND   F,191         (0344) LCD_2_Port:           equ    PRT2DR
0C74: 60 D3    MOV   REG[211],A    (0345) LCD_2_PortMode0:      equ    PRT2DM0
                                   (0346) LCD_2_PortMode1:      equ    PRT2DM1
0C76: 52 00    MOV   A,[X+0]       (0347) 
0C78: A0 06    JZ    0x0C7F        (0348) LCD_2_E:              equ    10h
                                   (0349) LCD_2_RW:             equ    40h
0C7A: 90 08    CALL  0x0C84        (0350) LCD_2_RS:             equ    20h
0C7C: 75       INC   X             (0351) 
0C7D: 8F F8    JMP   0x0C76        (0352) LCD_2_DATA_MASK:      equ    0Fh
0C7F: 70 3F    AND   F,63
                                   (0353) LCD_2_READY_BIT:      equ    08h
0C81: 71 C0    OR    F,192         (0354) 
0C83: 7F       RET                 (0355) LCD_2_DATA_READ:      equ    ( LCD_2_E | LCD_2_RW | LCD_2_RS )
                                   (0356) LCD_2_CNTL_READ:      equ    ( LCD_2_E | LCD_2_RW )
                                   (0357) LCD_2_PORT_WRITE:     equ    7Fh
                                   (0358) LCD_2_PORT_MASK:      equ    7Fh
                                   (0359) 
                                   (0360) LCD_2_DISP_INC:       equ    03h
                                   (0361) LCD_2_DISP_OFF:       equ    08h
                                   (0362) LCD_2_DISP_ON:        equ    0Ch
                                   (0363) LCD_2_4BIT_2LINE:     equ    2Ch
                                   (0364) 
                                   (0365) 
                                   (0366) ;-----------------------------------------------
                                   (0367) ;      Bargraph definitions
                                   (0368) ;-----------------------------------------------
                                   (0369) 
                                   (0370) LCD_2_BG_CHAR_WIDTH:  equ    16     ; 16 characters in width
                                   (0371) LCD_2_BG_SEG_WIDTH:   equ    80     ; 16 * 5 = 80
                                   (0372) LCD_2_BG_COL_START:   equ     0     ; Always start in the left most column
                                   (0373) 
                                   (0374)                                   ; Offsets for 2x16, 2x20, 4x20
                                   (0375)                                   ; Change these values for a custom LCD
                                   (0376) 
                                   (0377) LCD_2_ROW1_OFFSET:    equ    80h    ; Address/command offset for row 1
                                   (0378) LCD_2_ROW2_OFFSET:    equ    C0h    ; Address/command offset for row 2
                                   (0379) LCD_2_ROW3_OFFSET:    equ    94h    ; Address/command offset for row 1
                                   (0380) LCD_2_ROW4_OFFSET:    equ    D4h    ; Address/command offset for row 2
                                   (0381) 
                                   (0382) LCD_2_BG_ROW1_OFFSET: equ    80h    ; Address/command offset for row 1
                                   (0383) LCD_2_BG_ROW2_OFFSET: equ    C0h    ; Address/command offset for row 2
                                   (0384) 
                                   (0385) LCD_2_CG_RAM_OFFSET:  equ    40h    ; Offset to character RAM
                                   (0386) 
0C84: 90 65    CALL  0x0CEB        (0387) AREA UserModules (ROM, REL)
                                   (0388) 
0C86: 08       PUSH  A             (0389) .SECTION
0C87: 67       ASR   A             (0390) ;-----------------------------------------------------------------------------
0C88: 67       ASR   A             (0391) ;  FUNCTION NAME: LCD_2_PrCString
0C89: 67       ASR   A             (0392) ;
0C8A: 67       ASR   A             (0393) ;  DESCRIPTION:
0C8B: 21 0F    AND   A,15          (0394) ;    Print constant (ROM) string to LCD
0C8D: 90 3B    CALL  0x0CCA        (0395) ;-----------------------------------------------------------------------------
0C8F: 18       POP   A             (0396) ;
0C90: 21 0F    AND   A,15          (0397) ;  ARGUMENTS:
0C92: 40       NOP                 (0398) ;     A:X  Pointer to String
0C93: 40       NOP                 (0399) ;          A contains MSB of string address
0C94: 40       NOP                 (0400) ;          X contains LSB of string address
0C95: 90 33    CALL  0x0CCA        (0401) ;
                                   (0402) ;  RETURNS:  none
0C97: 7F       RET                 (0403) ;
                                   (0404) ;  SIDE EFFECTS:
                                   (0405) ;    The A and X registers may be modified by this or future implementations
                                   (0406) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0407) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0408) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0409) ;    functions.
                                   (0410) ;          
                                   (0411) ;    Currently only the page pointer registers listed below are modified: 
                                   (0412) ;          CUR_PP
                                   (0413) ;
                                   (0414)  LCD_2_PrCString:
                                   (0415) _LCD_2_PrCString:
                                   (0416)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0417)  .Loop_PrCString:
                                   (0418)     push  A                            ; Store ROM pointer
                                   (0419)     push  X
                                   (0420)     romx                               ; Get character from ROM
                                   (0421)     jnz   .LCD_PrCString_WR            ; print character and advance pointer
                                   (0422)     pop   X                            ; Restore the stack
                                   (0423)     pop   A
                                   (0424)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0425)     ret                                ; Return
                                   (0426) 
                                   (0427) .LCD_PrCString_WR:
                                   (0428)     call  LCD_2_WriteData              ; Write data to LCD
                                   (0429)     pop   X                            ; Get ROM pointer
                                   (0430)     pop   A
                                   (0431)     inc   X                            ; Inc LSB of pointer
                                   (0432)     jnc   .Loop_PrCString
0C98: 90 51    CALL  0x0CEB        (0433)     inc   A                            ; Inc MSB of pointer if LSB overflow
                                   (0434)     jmp   .Loop_PrCString
0C9A: 08       PUSH  A             (0435) 
0C9B: 67       ASR   A             (0436) .ENDSECTION
0C9C: 67       ASR   A             (0437) 
0C9D: 67       ASR   A             (0438) ;-----------------------------------------------------------------------------
0C9E: 67       ASR   A             (0439) ;  FUNCTION NAME: LCD_2_PrHexByte
0C9F: 21 0F    AND   A,15          (0440) ;
0CA1: 90 09    CALL  0x0CAC        (0441) ;  DESCRIPTION:
0CA3: 18       POP   A             (0442) ;     Print a byte in Hex (two characters) to current LCD position
0CA4: 21 0F    AND   A,15          (0443) ;
0CA6: 40       NOP                 (0444) ;-----------------------------------------------------------------------------
0CA7: 40       NOP                 (0445) ;
0CA8: 40       NOP                 (0446) ;  ARGUMENTS:
0CA9: 90 01    CALL  0x0CAC        (0447) ;     A  => (BYTE) Data/char to be printed
                                   (0448) ;
0CAB: 7F       RET                 (0449) ;  RETURNS: none
                                   (0450) ;
                                   (0451) ;  SIDE EFFECTS:
                                   (0452) ;    The A and X registers may be modified by this or future implementations
                                   (0453) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0454) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0455) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0456) ;    functions.
                                   (0457) ;          
                                   (0458) ;    Currently only the page pointer registers listed below are modified: 
                                   (0459) ;          CUR_PP
                                   (0460) ;
                                   (0461) .LITERAL
                                   (0462) LCD_2_HEX_STR::
                                   (0463)      DS    "0123456789ABCDEF"
                                   (0464) .ENDLITERAL
                                   (0465) .SECTION
                                   (0466) 
                                   (0467)  LCD_2_PrHexByte:
                                   (0468) _LCD_2_PrHexByte:
                                   (0469)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0470)     push  A                            ; Save lower nibble
                                   (0471)     asr   A                            ; Shift high nibble to right
                                   (0472)     asr   A
                                   (0473)     asr   A
                                   (0474)     asr   A
                                   (0475)     and   A,0Fh                        ; Mask off nibble
                                   (0476)     index LCD_2_HEX_STR                  ; Get Hex value
                                   (0477)     call  LCD_2_WriteData              ; Write data to screen
0CAC: 08       PUSH  A             (0478)     pop   A                            ; Restore value
0CAD: 62 D0 00 MOV   REG[208],0    (0479)     and   A,0Fh                        ; Mask off lower nibble
0CB0: 26 03 80 AND   [3],128       (0480)     index LCD_2_HEX_STR                  ; Get Hex value
0CB3: 51 03    MOV   A,[3]         (0481)     call  LCD_2_WriteData              ; Write data to screen
0CB5: 60 08    MOV   REG[8],A      (0482)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0483)     ret
0CB7: 18       POP   A             (0484) .ENDSECTION
0CB8: 21 0F    AND   A,15          (0485) 
0CBA: 29 10    OR    A,16          (0486) .SECTION
0CBC: 2A 03    OR    A,[3]         (0487) ;-----------------------------------------------------------------------------
0CBE: 60 08    MOV   REG[8],A      (0488) ;  FUNCTION NAME: LCD_2_PrHexInt
0CC0: 53 03    MOV   [3],A         (0489) ;
0CC2: 40       NOP                 (0490) ;  DESCRIPTION:
0CC3: 21 8F    AND   A,143         (0491) ;     Print an Int in Hex (four characters) to current LCD position
0CC5: 53 03    MOV   [3],A         (0492) ;
0CC7: 60 08    MOV   REG[8],A      (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;
0CC9: 7F       RET                 (0495) ;  ARGUMENTS:
                                   (0496) ;     A:X Integer value
                                   (0497) ;         A  contains LSB of Int
                                   (0498) ;         X  contains MSB of Int
                                   (0499) ;
                                   (0500) ;  RETURNS: none
                                   (0501) ;
                                   (0502) ;  SIDE EFFECTS:
                                   (0503) ;    The A and X registers may be modified by this or future implementations
                                   (0504) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0505) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0506) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0507) ;    functions.
                                   (0508) ;          
                                   (0509) ;    Currently only the page pointer registers listed below are modified: 
                                   (0510) ;          CUR_PP
                                   (0511) ;
                                   (0512)  LCD_2_PrHexInt:
                                   (0513) _LCD_2_PrHexInt:
                                   (0514)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0515)     swap  A,X
                                   (0516)     call  LCD_2_PrHexByte              ; Print MSB
                                   (0517)     mov   A,X                          ; Move LSB into position
                                   (0518)     call  LCD_2_PrHexByte              ; Print LSB
                                   (0519)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0520)     ret
                                   (0521) .ENDSECTION
                                   (0522) 
                                   (0523) .SECTION
0CCA: 08       PUSH  A             (0524) ;-----------------------------------------------------------------------------
0CCB: 62 D0 00 MOV   REG[208],0    (0525) ;  FUNCTION NAME: LCD_2_PrString
0CCE: 26 03 80 AND   [3],128       (0526) ;
0CD1: 2E 03 20 OR    [3],32        (0527) ;  DESCRIPTION:
0CD4: 51 03    MOV   A,[3]         (0528) ;     Print (RAM) ASCII string to LCD
0CD6: 60 08    MOV   REG[8],A      (0529) ;
                                   (0530) ;-----------------------------------------------------------------------------
0CD8: 18       POP   A             (0531) ;
0CD9: 21 0F    AND   A,15          (0532) ;  ARGUMENTS:
0CDB: 29 30    OR    A,48          (0533) ;     A:X contains pointer to string
0CDD: 2A 03    OR    A,[3]         (0534) ;         X  contains LSB of string pointer
0CDF: 60 08    MOV   REG[8],A      (0535) ;         A  contains MSB or page of string pointer (not used at this time)
0CE1: 53 03    MOV   [3],A         (0536) ;
0CE3: 40       NOP                 (0537) ;  RETURNS:
0CE4: 21 AF    AND   A,175         (0538) ;
0CE6: 53 03    MOV   [3],A         (0539) ;  SIDE EFFECTS:
0CE8: 60 08    MOV   REG[8],A      (0540) ;    The A and X registers may be modified by this or future implementations
                                   (0541) ;    of this function.  The same is true for all RAM page pointer registers in
0CEA: 7F       RET                 (0542) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0543) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0544) ;    functions.
                                   (0545) ;          
                                   (0546) ;    Currently only the page pointer registers listed below are modified: 
                                   (0547) ;          CUR_PP
                                   (0548) ;          IDX_PP
                                   (0549) ;
                                   (0550) ;
                                   (0551)  LCD_2_PrString:
                                   (0552) _LCD_2_PrString:
                                   (0553)     RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0554)     RAM_SETPAGE_IDX A
                                   (0555)  .Loop_PrString:
                                   (0556)     mov   A,[X]                        ; Get value pointed to by X
                                   (0557)     jz    .End_LCD_PrString            ; Check for end of string
                                   (0558)     ;LCD_2_writeData is known not to modify X so no need to preserve
                                   (0559)     call  LCD_2_WriteData              ; Write data to screen
                                   (0560)     inc   X                            ; Advance pointer to next character
                                   (0561)     jmp   .Loop_PrString               ; Go get next character
                                   (0562) .End_LCD_PrString:
                                   (0563)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0564)     ret
                                   (0565) .ENDSECTION
                                   (0566) 
                                   (0567) .SECTION
                                   (0568) ;-----------------------------------------------------------------------------
                                   (0569) ;  FUNCTION NAME: LCD_2_WriteData
                                   (0570) ;
                                   (0571) ;  DESCRIPTION:
0CEB: 08       PUSH  A             (0572) ;     Write a byte to the LCD's data register.
0CEC: 62 D0 00 MOV   REG[208],0    (0573) ;
0CEF: 26 03 80 AND   [3],128       (0574) ;-----------------------------------------------------------------------------
0CF2: 51 03    MOV   A,[3]         (0575) ;
0CF4: 60 08    MOV   REG[8],A      (0576) ;  ARGUMENTS:
                                   (0577) ;    A contains byte to be written to LCD data register
0CF6: 26 04 F0 AND   [4],240       (0578) ;
0CF9: 51 04    MOV   A,[4]         (0579) ;  RETURNS: none
0CFB: 71 10    OR    F,16          (0580) ;
0CFD: 60 08    MOV   REG[8],A      (0581) ;  SIDE EFFECTS:
0CFF: 70 EF    AND   F,239         (0582) ;    The A and X registers may be modified by this or future implementations
                                   (0583) ;    of this function.  The same is true for all RAM page pointer registers in
0D01: 2E 03 40 OR    [3],64        (0584) ;    the Large Memory Model.  When necessary, it is the calling function's
0D04: 51 03    MOV   A,[3]         (0585) ;    responsibility to preserve their values across calls to fastcall16 
0D06: 60 08    MOV   REG[8],A      (0586) ;    functions.
0D08: 40       NOP                 (0587) ;          
                                   (0588) ;    Currently only the page pointer registers listed below are modified: 
0D09: 10       PUSH  X             (0589) ;          CUR_PP
0D0A: 57 FF    MOV   X,255         (0590) ;
                                   (0591)  LCD_2_WriteData:
                                   (0592) _LCD_2_WriteData:
0D0C: 2E 03 50 OR    [3],80        (0593)  LCD_2_Write_Data:   ; Do not use
0D0F: 51 03    MOV   A,[3]         (0594) _LCD_2_Write_Data:   ; Do not use
0D11: 60 08    MOV   REG[8],A      (0595)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0596)     call  LCD_2_Check_Ready            ; Make sure controller is ready
0D13: 40       NOP                 (0597)                                        ; A is preserved in LCD_2_Check_Ready
0D14: 40       NOP                 (0598)     push  A                            ; Save copy of character
0D15: 5D 08    MOV   A,REG[8]      (0599)     asr   A                            ; Shift high nibble to right
                                   (0600)     asr   A
                                   (0601)     asr   A
                                   (0602)     asr   A
                                   (0603)     and   A,0Fh                        ; Mask off high nibble
                                   (0604)     call  LCD_2_WDATA_Nibble           ; Write Upper nibble
                                   (0605)     pop   A                            ; Retrieve copy of character
                                   (0606)     and   A,0Fh                        ; Mask off high nibble
                                   (0607)     nop
                                   (0608)     nop
                                   (0609)     nop
                                   (0610)     call  LCD_2_WDATA_Nibble   ; Write Lower nibble
0D17: 08       PUSH  A             (0611)     RAM_EPILOGUE RAM_USE_CLASS_1
0D18: 26 03 C0 AND   [3],192       (0612)     ret
0D1B: 51 03    MOV   A,[3]         (0613) .ENDSECTION
0D1D: 60 08    MOV   REG[8],A      (0614) 
                                   (0615) .SECTION
0D1F: 40       NOP                 (0616) ;-----------------------------------------------------------------------------
0D20: 40       NOP                 (0617) ;  FUNCTION NAME: LCD_2_Control
0D21: 40       NOP                 (0618) ;
                                   (0619) ;  DESCRIPTION:
0D22: 2E 03 50 OR    [3],80        (0620) ;     Write a byte to the LCD's control register.
0D25: 51 03    MOV   A,[3]         (0621) ;
0D27: 60 08    MOV   REG[8],A      (0622) ;-----------------------------------------------------------------------------
                                   (0623) ;
0D29: 40       NOP                 (0624) ;  ARGUMENTS:
0D2A: 40       NOP                 (0625) ;     A contains data to be written to LCD control register.
                                   (0626) ;
0D2B: 26 03 C0 AND   [3],192       (0627) ;  RETURNS: none
0D2E: 51 03    MOV   A,[3]         (0628) ;
0D30: 60 08    MOV   REG[8],A      (0629) ;  SIDE EFFECTS:
                                   (0630) ;    The A and X registers may be modified by this or future implementations
0D32: 18       POP   A             (0631) ;    of this function.  The same is true for all RAM page pointer registers in
0D33: 21 08    AND   A,8           (0632) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0633) ;    responsibility to preserve their values across calls to fastcall16 
0D35: A0 04    JZ    0x0D3A        (0634) ;    functions.
0D37: 79       DEC   X             (0635) ;          
0D38: BF D3    JNZ   0x0D0C        (0636) ;    Currently only the page pointer registers listed below are modified: 
                                   (0637) ;          CUR_PP
0D3A: 20       POP   X             (0638) ;
                                   (0639)  LCD_2_Control:
0D3B: 2E 04 7F OR    [4],127       (0640) _LCD_2_Control:
0D3E: 51 04    MOV   A,[4]         (0641)     RAM_PROLOGUE RAM_USE_CLASS_1
0D40: 71 10    OR    F,16          (0642)     call  LCD_2_Check_Ready            ; Make sure controller is ready
0D42: 60 08    MOV   REG[8],A      (0643)                                        ; A is preserved in LCD_2_Check_Ready
0D44: 70 EF    AND   F,239         (0644)     push  A                            ; Save copy of byte
0D46: 18       POP   A             (0645)     asr   A                            ; Shift Upper Nibble to right
                                   (0646)     asr   A
0D47: 7F       RET                 (0647)     asr   A
                                   (0648)     asr   A
                                   (0649)     and   A,0Fh                        ; Mask off, just in case
                                   (0650)     call  LCD_2_WCNTL_Nibble           ; Write high nibble
                                   (0651)     pop   A                            ; Restore copy of byte
                                   (0652)     and   A,0Fh                        ; Mask off high nibble
                                   (0653)     nop
                                   (0654)     nop
                                   (0655)     nop
                                   (0656)     call  LCD_2_WCNTL_Nibble             ; Write Lower nibble
                                   (0657)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0658)     ret
                                   (0659) .ENDSECTION
                                   (0660) 
                                   (0661) .SECTION
                                   (0662) ;-----------------------------------------------------------------------------
                                   (0663) ;  FUNCTION NAME: LCD_2_WCNTL_Nibble
                                   (0664) ;
                                   (0665) ;  DESCRIPTION:
                                   (0666) ;     Write a single nibble to the LCD's command register
                                   (0667) ;
                                   (0668) ;-----------------------------------------------------------------------------
                                   (0669) ;
                                   (0670) ;  ARGUMENTS:
                                   (0671) ;     A[3:0]   Contains Nibble to be written to command register
                                   (0672) ;
                                   (0673) ;  RETURNS: none
                                   (0674) ;
                                   (0675) ;  SIDE EFFECTS:
                                   (0676) ;    The A and X registers may be modified by this or future implementations
                                   (0677) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0678) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0679) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0680) ;    functions.
                                   (0681) ;          
                                   (0682) ;    Currently only the page pointer registers listed below are modified: 
                                   (0683) ;          CUR_PP
0D48: 62 D0 00 MOV   REG[208],0    (0684) ;
                                   (0685)  LCD_2_WCNTL_Nibble:
0D4B: 26 04 80 AND   [4],128       (0686)     RAM_PROLOGUE RAM_USE_CLASS_4
0D4E: 2E 04 7F OR    [4],127       (0687)     push  A
0D51: 26 05 80 AND   [5],128       (0688)     RAM_SETPAGE_CUR >Port_2_Data_SHADE           ; Set CUR_PP to LCD variable address
                                   (0689)     and   [Port_2_Data_SHADE],~LCD_2_PORT_MASK
0D54: 51 04    MOV   A,[4]         (0690)     mov   A,[Port_2_Data_SHADE]
0D56: 71 10    OR    F,16          (0691)     mov   reg[LCD_2_Port],A                      ; Reset control lines
0D58: 60 08    MOV   REG[8],A      (0692) 
0D5A: 51 05    MOV   A,[5]         (0693)     pop   A
0D5C: 60 09    MOV   REG[9],A      (0694)     and   A,LCD_2_DATA_MASK                      ; Make sure no bogus data in MSN
0D5E: 70 EF    AND   F,239         (0695)     or    A,LCD_2_E                              ; Bring "E" Enable line high
                                   (0696)     or    A,[Port_2_Data_SHADE]                  ; OR in bit 7 just
0D60: 50 FA    MOV   A,250         (0697)     mov   reg[LCD_2_Port], A                     ; Write data
0D62: 90 67    CALL  0x0DCB        (0698)     mov   [Port_2_Data_SHADE],A                  ; Keep shadow register in sync
0D64: 50 FA    MOV   A,250         (0699)     nop
0D66: 90 63    CALL  0x0DCB        (0700)     and   A,(~LCD_2_PORT_MASK|LCD_2_DATA_MASK)   ; Disable E signal and leave data on bus.
                                   (0701)     mov   [Port_2_Data_SHADE],A                  ; Keep shadow register in sync
0D68: 50 03    MOV   A,3           (0702)     mov   reg[LCD_2_Port],A
0D6A: 9F 40    CALL  0x0CAC        (0703)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0704)     ret
0D6C: 50 52    MOV   A,82          (0705) .ENDSECTION
0D6E: 90 5B    CALL  0x0DCB        (0706) 
                                   (0707) .SECTION
0D70: 50 03    MOV   A,3           (0708) ;-----------------------------------------------------------------------------
0D72: 9F 38    CALL  0x0CAC        (0709) ;  FUNCTION NAME: LCD_2_WDATA_Nibble
                                   (0710) ;
0D74: 90 63    CALL  0x0DD9        (0711) ;  DESCRIPTION:
0D76: 90 61    CALL  0x0DD9        (0712) ;     Write a single nibble to the LCD's DATA register
0D78: 90 5F    CALL  0x0DD9        (0713) ;
                                   (0714) ;-----------------------------------------------------------------------------
0D7A: 50 03    MOV   A,3           (0715) ;
0D7C: 9F 2E    CALL  0x0CAC        (0716) ;  ARGUMENTS:
                                   (0717) ;     A[3:0]   Contains Nibble to be written to data register
0D7E: 50 5A    MOV   A,90          (0718) ;
0D80: 90 49    CALL  0x0DCB        (0719) ;  RETURNS: none
                                   (0720) ;
0D82: 50 02    MOV   A,2           (0721) ;  SIDE EFFECTS:
0D84: 9F 26    CALL  0x0CAC        (0722) ;    The A and X registers may be modified by this or future implementations
                                   (0723) ;    of this function.  The same is true for all RAM page pointer registers in
0D86: 50 5A    MOV   A,90          (0724) ;    the Large Memory Model.  When necessary, it is the calling function's
0D88: 90 41    CALL  0x0DCB        (0725) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0726) ;    functions.
0D8A: 50 08    MOV   A,8           (0727) ;          
0D8C: 9F 0A    CALL  0x0C98        (0728) ;    Currently only the page pointer registers listed below are modified: 
0D8E: 50 5A    MOV   A,90          (0729) ;          CUR_PP
0D90: 90 39    CALL  0x0DCB        (0730) ;
                                   (0731) LCD_2_WDATA_Nibble:
0D92: 50 01    MOV   A,1           (0732)     RAM_PROLOGUE RAM_USE_CLASS_4
0D94: 9F 02    CALL  0x0C98        (0733)     push  A
0D96: 50 5A    MOV   A,90          (0734)     RAM_SETPAGE_CUR >Port_2_Data_SHADE          ; Set CUR_PP to LCD variable address
0D98: 90 31    CALL  0x0DCB        (0735)     and   [Port_2_Data_SHADE],~LCD_2_PORT_MASK
                                   (0736)     or    [Port_2_Data_SHADE],LCD_2_RS                ; Raise RS to signify a Data Write
0D9A: 50 06    MOV   A,6           (0737)     mov   A,[Port_2_Data_SHADE]
0D9C: 9E FA    CALL  0x0C98        (0738)     mov   reg[LCD_2_Port],A
                                   (0739) 
0D9E: 50 0E    MOV   A,14          (0740)     pop   A
0DA0: 9E F6    CALL  0x0C98        (0741)     and   A,LCD_2_DATA_MASK                           ; Make sure no bogus data in A[7:4]
                                   (0742)     or    A,(LCD_2_E | LCD_2_RS)                      ; Bring "E" Enable line high
0DA2: 50 2C    MOV   A,44          (0743)     or    A,[Port_2_Data_SHADE]                       ; Keep shadow in sync
0DA4: 9E F2    CALL  0x0C98        (0744)     mov   reg[LCD_2_Port], A                            ; Write data
                                   (0745)     mov   [Port_2_Data_SHADE],A                       ; Keep shadow in sync
0DA6: 50 08    MOV   A,8           (0746)     NOP
0DA8: 9E EE    CALL  0x0C98        (0747)     and   A,(~LCD_2_PORT_MASK|LCD_2_DATA_MASK|LCD_2_RS)  ; Disable E signal and leave Data on bus
                                   (0748)     mov   [Port_2_Data_SHADE],A                       ; keep shadow in sync
0DAA: 50 0C    MOV   A,12          (0749)     mov   reg[LCD_2_Port],A
0DAC: 9E EA    CALL  0x0C98        (0750)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0751)     ret
0DAE: 50 03    MOV   A,3           (0752) .ENDSECTION
0DB0: 9E E6    CALL  0x0C98        (0753) 
                                   (0754) .SECTION
0DB2: 50 5A    MOV   A,90          (0755) ;-----------------------------------------------------------------------------
0DB4: 90 15    CALL  0x0DCB        (0756) ;  FUNCTION NAME: LCD_2_Check_Ready
                                   (0757) ;
0DB6: 7F       RET                 (0758) ;  DESCRIPTION:
0DB7: 80 C0    JMP   0x0E78
0DB9: 94 D4    CALL  0x128F
                                   (0759) ;     Wait until LCD has completed last command.
                                   (0760) ;
                                   (0761) ;-----------------------------------------------------------------------------
                                   (0762) ;
                                   (0763) ;  ARGUMENTS: none
                                   (0764) ;
                                   (0765) ;  RETURNS: none
                                   (0766) ;
                                   (0767) ;  SIDE EFFECTS:
                                   (0768) ;    The A and X registers may be modified by this or future implementations
                                   (0769) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0770) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0771) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0772) ;    functions.
                                   (0773) ;          
                                   (0774) ;    Currently only the page pointer registers listed below are modified: 
                                   (0775) ;          CUR_PP
                                   (0776) ;
                                   (0777) ;     If LCD is not present, this routine may never return.
                                   (0778) ;
                                   (0779) LCD_2_Check_Ready:
                                   (0780)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0781)     push  A                                           ; Save Accumulator
                                   (0782)     RAM_SETPAGE_CUR >Port_2_Data_SHADE                ; Set CUR_PP to LCD variable address
                                   (0783)     and   [Port_2_Data_SHADE],~LCD_2_PORT_MASK        ; Mask of all LCD bits
                                   (0784)     mov   A,[Port_2_Data_SHADE]
                                   (0785)     mov   reg[LCD_2_Port],A                           ; Zero LCD port bits
                                   (0786) 
                                   (0787)     and   [Port_2_DriveMode_0_SHADE],~LCD_2_DATA_MASK ; Clear out LCD mode bits.
                                   (0788)     mov   A,[Port_2_DriveMode_0_SHADE]
                                   (0789)     M8C_SetBank1                                      ; Change port mode to read status
                                   (0790)     mov   reg[LCD_2_PortMode0],A                      ; Setup LCD Port for reading
0DBB: 21 03    AND   A,3           (0791)     M8C_SetBank0
0DBD: 10       PUSH  X             (0792) 
0DBE: FF F7    INDEX 0x0DB7        (0793)     or    [Port_2_Data_SHADE],LCD_2_RW                ; Raise RW to signify Read operation
0DC0: 4F       MOV   X,SP          (0794)     mov   A,[Port_2_Data_SHADE]
0DC1: 03 FF    ADD   A,[X-1]       (0795)     mov   reg[LCD_2_Port],A
0DC3: 20       POP   X             (0796)     NOP
                                   (0797) 
0DC4: 9E D2    CALL  0x0C98        (0798)     push  X							                            ; Save 'X' register
0DC6: 70 3F    AND   F,63
0DC8: 71 C0    OR    F,192         (0799)     mov   X,255                         			            ; 255 Attempts
0DCA: 7F       RET                 (0800) 
                                   (0801) .LCD_RDY_LOOP:
                                   (0802)     or    [Port_2_Data_SHADE], LCD_2_CNTL_READ                  ; Raise E to start cycle
                                   (0803)     mov   A,[Port_2_Data_SHADE]
                                   (0804)     mov   reg[LCD_2_Port],A
                                   (0805) 
                                   (0806)     nop                                               ; Wait 2 nops to make sure data is ready
                                   (0807)     nop
                                   (0808)     mov   A,reg[LCD_2_Port]
                                   (0809) 
                                   (0810) ; The code below is used to work around the async read issue with the ICE with the 
                                   (0811) ; 25/26xxx family of devices.  It will help to eliminate "Invalid memory reference" 
                                   (0812) ; errors.  It is not required when running without the ICE or when using any other 
                                   (0813) ; family besides the 25/26xxx family. If not using the ICE or with any other family
                                   (0814) ; the ICE_PORT_SYNC flag should be set to 0.
                                   (0815) IF(ICE_PORT_SYNC)                          
                                   (0816)     mov   reg[ 0xfa], A                    
                                   (0817)     mov   A, reg[0xfa]                     
                                   (0818) ENDIF   
                                   (0819)                                    
                                   (0820)     push  A
                                   (0821)     and   [Port_2_Data_SHADE],(~LCD_2_PORT_MASK | LCD_2_RW)     ; Lower E signal
                                   (0822)     mov   A,[Port_2_Data_SHADE]
                                   (0823)     mov   reg[LCD_2_Port],A
                                   (0824) 
                                   (0825)     nop                                    ; Add delay for the slowest part and the
                                   (0826)     nop                                    ; fastest PSoC
                                   (0827)     nop
0DCB: 90 0C    CALL  0x0DD9        (0828)                                                                 ; Get the LSBs
0DCD: 78       DEC   A             (0829)     or    [Port_2_Data_SHADE],LCD_2_CNTL_READ                   ; Raise E to start cycle
0DCE: BF FC    JNZ   0x0DCB        (0830)     mov   A,[Port_2_Data_SHADE]
                                   (0831)     mov   reg[LCD_2_Port],A
0DD0: 7F       RET                 (0832) 
0DD1: 08       PUSH  A
0DD2: 19 3A    SBB   A,58
0DD4: 7C 01 01 LCALL 0x0101
0DD7: 01 01    ADD   A,1
                                   (0833)     nop
                                   (0834)     nop
                                   (0835) 
                                   (0836)     and   [Port_2_Data_SHADE],(~LCD_2_PORT_MASK | LCD_2_RW)     ; Lower E signal
                                   (0837)     mov   A,[Port_2_Data_SHADE]
                                   (0838)     mov   reg[LCD_2_Port],A
                                   (0839) 
                                   (0840)     pop   A
                                   (0841)     and   A,LCD_2_READY_BIT                                       ; Check busy
                                   (0842) 
                                   (0843)     jz    .UNLOCK
                                   (0844)     dec   X
                                   (0845)     jnz   .LCD_RDY_LOOP                                         ; If LCD still busy, read again for 255 times
                                   (0846) .UNLOCK:
                                   (0847)     pop   X							                            ; Restore 'X' register
                                   (0848) 
                                   (0849)     or    [Port_2_DriveMode_0_SHADE],LCD_2_PORT_WRITE ; Revert Data bit to Write mode
                                   (0850)     mov   A,[Port_2_DriveMode_0_SHADE]
                                   (0851)     M8C_SetBank1
                                   (0852)     mov   reg[LCD_2_PortMode0],A                      ; Setup LCD Port for writing
                                   (0853)     M8C_SetBank0
                                   (0854)     pop   A
                                   (0855)     RAM_EPILOGUE RAM_USE_CLASS_4                                ; Restore Accumulator
                                   (0856)     ret
                                   (0857) .ENDSECTION
                                   (0858) 
                                   (0859) .SECTION
                                   (0860) ;-----------------------------------------------------------------------------
                                   (0861) ;  FUNCTION NAME: LCD_2_Start
                                   (0862) ;  FUNCTION NAME: LCD_2_Init
                                   (0863) ;
                                   (0864) ;  DESCRIPTION:
                                   (0865) ;     Initialize LCD
                                   (0866) ;
                                   (0867) ;-----------------------------------------------------------------------------
                                   (0868) ;
                                   (0869) ;  ARGUMENTS: none
                                   (0870) ;
                                   (0871) ;  RETURNS: none
0DD9: 08       PUSH  A             (0872) ;
0DDA: 71 10    OR    F,16          (0873) ;  SIDE EFFECTS:
0DDC: 5D E0    MOV   A,REG[224]    (0874) ;    The A and X registers may be modified by this or future implementations
0DDE: 70 EF    AND   F,239         (0875) ;    of this function.  The same is true for all RAM page pointer registers in
0DE0: 21 07    AND   A,7           (0876) ;    the Large Memory Model.  When necessary, it is the calling function's
0DE2: 39 05    CMP   A,5           (0877) ;    responsibility to preserve their values across calls to fastcall16 
0DE4: D0 06    JNC   0x0DEB        (0878) ;    functions.
0DE6: FF E9    INDEX 0x0DD1        (0879) ;          
                                   (0880) ;    Currently only the page pointer registers listed below are modified: 
0DE8: 78       DEC   A             (0881) ;          CUR_PP
0DE9: BF FE    JNZ   0x0DE8        (0882) ;
                                   (0883) ;  THEORY of OPERATION or PROCEDURE:
0DEB: 18       POP   A             (0884) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0885) ;    This initialization is a bit long, but it should work for
0DEC: 7F       RET                 (0886) ;    most 2 and 4 line LCDs.
                                   (0887) ;
                                   (0888)  LCD_2_Start:
                                   (0889) _LCD_2_Start:
                                   (0890)  LCD_2_Init:
                                   (0891) _LCD_2_Init:
                                   (0892)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0893)     RAM_SETPAGE_CUR >Port_2_Data_SHADE                          ; Set CUR_PP to LCD variable address
                                   (0894) 
                                   (0895)     and   [Port_2_DriveMode_0_SHADE],~LCD_2_PORT_MASK           ; Mask off LCD bits
                                   (0896)     or    [Port_2_DriveMode_0_SHADE],LCD_2_PORT_WRITE           ; Set LCD port for writing
                                   (0897)     and   [Port_2_DriveMode_1_SHADE],~LCD_2_PORT_MASK           ; Mask off LCD bits
                                   (0898) 
                                   (0899)     mov   A,[Port_2_DriveMode_0_SHADE]
                                   (0900)     M8C_SetBank1
                                   (0901)     mov   reg[LCD_2_PortMode0],A                                ; Setup LCD Port for writing
                                   (0902)     mov   A,[Port_2_DriveMode_1_SHADE]
                                   (0903)     mov   reg[LCD_2_PortMode1],A
                                   (0904)     M8C_SetBank0
                                   (0905) 
                                   (0906)     mov   A,250                             ; Delay for 12.5 mSec (250 * 50uSec)
                                   (0907)     call  LCD_2_Delay50uTimes
                                   (0908)     mov   A,250                             ; Delay for 12.5 mSec (250 * 50uSec)
                                   (0909)     call  LCD_2_Delay50uTimes
                                   (0910) 
                                   (0911)     mov   A,03h
                                   (0912)     call  LCD_2_WCNTL_Nibble
                                   (0913) 
                                   (0914)     mov   A,82                              ; Delay for 4.1 mSec (82 * 50uSec)
                                   (0915)     call  LCD_2_Delay50uTimes
                                   (0916) 
                                   (0917)     mov   A,03h
                                   (0918)     call  LCD_2_WCNTL_Nibble
                                   (0919) 
                                   (0920)     call  LCD_2_Delay50u
                                   (0921)     call  LCD_2_Delay50u
                                   (0922)     call  LCD_2_Delay50u
                                   (0923) 
                                   (0924)     mov   A,03h
                                   (0925)     call  LCD_2_WCNTL_Nibble
                                   (0926) 
                                   (0927)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0928)     call  LCD_2_Delay50uTimes
                                   (0929) 
                                   (0930)     mov   A,02h
                                   (0931)     call  LCD_2_WCNTL_Nibble
                                   (0932) 
                                   (0933)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0934)     call  LCD_2_Delay50uTimes
                                   (0935) 
                                   (0936)     mov   A,08h
                                   (0937)     call  LCD_2_Control
                                   (0938)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0939)     call  LCD_2_Delay50uTimes
                                   (0940) 
                                   (0941)     mov   A,01h
                                   (0942)     call  LCD_2_Control
                                   (0943)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0944)     call  LCD_2_Delay50uTimes
                                   (0945) 
                                   (0946)     mov   A,06h
                                   (0947)     call  LCD_2_Control
                                   (0948) 
                                   (0949)     mov   A,0Eh
                                   (0950)     call  LCD_2_Control
                                   (0951) 
                                   (0952)     mov   A,LCD_2_4BIT_2LINE                  ; Setup for 4 bit interface, 2 line
                                   (0953)     call  LCD_2_Control
                                   (0954) 
                                   (0955)     mov   A,LCD_2_DISP_OFF
                                   (0956)     call  LCD_2_Control
                                   (0957) 
                                   (0958)     mov   A,LCD_2_DISP_ON
                                   (0959)     call  LCD_2_Control
                                   (0960) 
                                   (0961)     mov   A,LCD_2_DISP_INC
                                   (0962)     call  LCD_2_Control
                                   (0963) 
                                   (0964)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0965)     call  LCD_2_Delay50uTimes
                                   (0966)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0967)     ret
                                   (0968) .ENDSECTION
                                   (0969) 
                                   (0970) ;-----------------------------------------------------------------------------
                                   (0971) ;  FUNCTION NAME: LCD_2_Position
                                   (0972) ;
                                   (0973) ;  DESCRIPTION:
                                   (0974) ;     Position Cursor at Row and Col location
                                   (0975) ;
                                   (0976) ;-----------------------------------------------------------------------------
                                   (0977) ;
                                   (0978) ;  ARGUMENTS:
                                   (0979) ;     A => Row  0 to 3
                                   (0980) ;     X => Col  0 to 39+
                                   (0981) ;
                                   (0982) ;  RETURNS:  none
                                   (0983) ;
                                   (0984) ;  SIDE EFFECTS:
                                   (0985) ;    The A and X registers may be modified by this or future implementations
                                   (0986) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0987) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0988) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0989) ;    functions.
                                   (0990) ;
                                   (0991) .LITERAL
                                   (0992) LCD_2_ROW_OFFSET::
                                   (0993)      DB    LCD_2_ROW1_OFFSET, LCD_2_ROW2_OFFSET, LCD_2_ROW3_OFFSET, LCD_2_ROW4_OFFSET
                                   (0994) .ENDLITERAL
                                   (0995) 
                                   (0996) .SECTION
                                   (0997)  LCD_2_Position:
                                   (0998) _LCD_2_Position:
                                   (0999)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1000)     and   A,03h                        ; Mask off 2 bits for row address 0 to 3
                                   (1001)     push  X                            ; Store COL
                                   (1002)     index LCD_2_ROW_OFFSET ; Get ROW memory offset from table
                                   (1003)     mov   X,SP                         ; Get Stack pointer
                                   (1004)     add   A,[X+(-1)]                   ; Add the COL to the display pointer
                                   (1005)     pop   X
                                   (1006) 
                                   (1007)     call  LCD_2_Control                ; Write control byte
                                   (1008)     RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1009)     ret
                                   (1010) .ENDSECTION
                                   (1011) 
                                   (1012) .SECTION
                                   (1013) ;-----------------------------------------------------------------------------
                                   (1014) ;  FUNCTION NAME: LCD_2_Delay50uTimes
                                   (1015) ;
0DED: 4F       MOV   X,SP          (1016) ;  DESCRIPTION:
0DEE: 10       PUSH  X             (1017) ;     Delay increments of 50uSeconds
0DEF: 52 FD    MOV   A,[X-3]       (1018) ;
0DF1: 59 FC    MOV   X,[X-4]       (1019) ;-----------------------------------------------------------------------------
0DF3: 70 3F    AND   F,63
0DF5: 71 C0    OR    F,192         (1020) ;
0DF7: 9F C2    CALL  0x0DBB        (1021) ;  ARGUMENTS:
                                   (1022) ;     A contains the delay multiplier
0DF9: 20       POP   X             (1023) ;
                                   (1024) ;  RETURNS:
                                   (1025) ;
0DFA: 3D FA 00 CMP   [X-6],0       (1026) ;  SIDE EFFECTS:
0DFD: B0 05    JNZ   0x0E03        (1027) ;    The A and X registers may be modified by this or future implementations
0DFF: 50 00    MOV   A,0           (1028) ;    of this function.  The same is true for all RAM page pointer registers in
0E01: 80 11    JMP   0x0E13        (1029) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1030) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1031) ;    functions.
0E03: 3D FA 06 CMP   [X-6],6       (1032) ;
0E06: D0 07    JNC   0x0E0E        (1033) ;
0E08: 52 FA    MOV   A,[X-6]       (1034)  LCD_2_Delay50uTimes:
0E0A: 15 FA    SUB   [X-6],A       (1035) _LCD_2_Delay50uTimes:
0E0C: 80 06    JMP   0x0E13        (1036)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1037)     call  LCD_2_Delay50u
                                   (1038)     dec   A
0E0E: 50 06    MOV   A,6           (1039)     jnz   LCD_2_Delay50uTimes
0E10: 17 FA 05 SUB   [X-6],5       (1040)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1041)     ret
                                   (1042) 
0E13: 9E 6F    CALL  0x0C84        (1043) .ENDSECTION
                                   (1044) 
0E15: 7B FB    DEC   [X-5]         (1045) ;-----------------------------------------------------------------------------
0E17: BF E2    JNZ   0x0DFA        (1046) ;  FUNCTION NAME: LCD_2_Delay50u
0E19: 70 3F    AND   F,63
0E1B: 71 C0    OR    F,192         (1047) ;
0E1D: 7F       RET                 (1048) ;  DESCRIPTION:
                                   (1049) ;     Delay 50uSec for any clock frequency from 1.5MHz to 24MHz
                                   (1050) ;     Slower clock frequencies the delay will be;
                                   (1051) ;           1.5
                                   (1052) ;        -------------- * 50uSec
                                   (1053) ;        clock_freq(MHz)
                                   (1054) ;
                                   (1055) ;
                                   (1056) ;-----------------------------------------------------------------------------
                                   (1057) ;
                                   (1058) ;  ARGUMENTS: none
                                   (1059) ;
                                   (1060) ;  RETURNS: none
                                   (1061) ;
                                   (1062) ;  SIDE EFFECTS:
                                   (1063) ;    The A and X registers may be modified by this or future implementations
                                   (1064) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1065) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1066) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1067) ;    functions.
                                   (1068) ;
                                   (1069) ;  THEORY of OPERATION or PROCEDURE:
                                   (1070) ;
                                   (1071) .LITERAL
                                   (1072)  LCD_2_Delay50u_Table::
                                   (1073)      DB    08h,  19h,   3Ah,   7Ch,   01h,    01h,    01h,   01h
                                   (1074) ;         3MHz, 6MHz, 12MHz, 24MHz, 1.5MHz, 750kHz, 188kHz, 94kHz
                                   (1075) .ENDLITERAL
                                   (1076) .SECTION
                                   (1077) 
                                   (1078)   LCD_2_Delay50u:
                                   (1079)  _LCD_2_Delay50u:                      ; [11]  Call
                                   (1080)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1081)     push  A
                                   (1082)     M8C_SetBank1                         ; [4]
                                   (1083)     mov   A, reg[OSC_CR0]                ; [6] Get delay value
                                   (1084)     M8C_SetBank0                         ; [4]
                                   (1085)     and   A,07h                          ; [4] Mask off only the clock bits
                                   (1086)     cmp   A,05h
                                   (1087)     jnc   .Delay50u_End
                                   (1088)     index LCD_2_Delay50u_Table ; [13] Get delay value
                                   (1089) .Delay50u_Loop:                          ;
                                   (1090)     dec   A                              ; [4]
                                   (1091)     jnz   .Delay50u_Loop                 ; [5]
                                   (1092) .Delay50u_End:
                                   (1093)     pop   A
                                   (1094)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1095)     ret
                                   (1096) .ENDSECTION
                                   (1097) 
                                   (1098) 
                                   (1099) ;-----------------------------------------------------------------------------
                                   (1100) ;      If bargraph is not enabled, the following functions are not required.
                                   (1101) ;-----------------------------------------------------------------------------
                                   (1102) 
                                   (1103) IF (LCD_2_BARGRAPH_ENABLE)
                                   (1104) 
                                   (1105) IF SYSTEM_SMALL_MEMORY_MODEL
                                   (1106) .SECTION
                                   (1107) ;-----------------------------------------------------------------------------
                                   (1108) ;  FUNCTION NAME: LCD_2_DrawBG
                                   (1109) ;
                                   (1110) ;  DESCRIPTION:
                                   (1111) ;  This legacy fastcall version are provided only to support existing small
                                   (1112) ;  memory model assembly language code---it does not work in the large memory
                                   (1113) ;  model.
                                   (1114) ;
                                   (1115) ;  ** This legacy fastcall version is provided on a temporary basis to
                                   (1116) ;  ** ease the transition to the 4.2 release of PSoC Designer. Its use is
                                   (1117) ;  ** deprecated and its status is "No Further Maintenance". If you call this
                                   (1118) ;  ** function in assembly you should convert to _LCD_2_DrawVBG
                                   (1119) ;  ** (with a leading underscore) and the fastcall16 interface
                                   (1120) ;
                                   (1121) ;  Draw a horizontal bargraph on the LCD with the given parameters.  This
                                   (1122) ;  is a legacy function that is intended to support existing Assembly
                                   (1123) ;  language programs that call this function.  This should not be used for
                                   (1124) ;  new code or with Large Memory Model programs.
                                   (1125) ;-----------------------------------------------------------------------------
                                   (1126) ;
                                   (1127) ;  LEGACY FASTCALL ARGUMENTS:
                                   (1128) ;    A    => Starting row for bargraph 0 to 3
                                   (1129) ;   [X]   => Starting Column for bargraph 0 to 39+
                                   (1130) ;   [x-1] => Length of bargraph in chars 1 to 40+
                                   (1131) ;   [X-2] => Position of pointer in segments 5 times Length
                                   (1132) ;
                                   (1133) ;
                                   (1134) ;  RETURNS:  none
                                   (1135) ;
                                   (1136) ;  SIDE EFFECTS:
                                   (1137) ;    The A and X registers may be modified by this or future implementations
                                   (1138) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1139) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1140) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1141) ;    functions.
                                   (1142) ;
                                   (1143) ;    If LCD_2_Init is not called before this function, the
                                   (1144) ;    bargraph will not be drawn properly.
                                   (1145) ;
                                   (1146) ; Stack offset constants
                                   (1147) BG_COLX:       equ  0                   ; Stack position of Column
                                   (1148) BG_CHAR_LENX:  equ -1                   ; Stack position of Length
                                   (1149) BG_LENGTHX:    equ -2                   ; Stack position of bargraph pointer position
                                   (1150) 
                                   (1151) 
                                   (1152) LCD_2_DrawBG:
                                   (1153)     push  X
                                   (1154)     mov   X,[X+BG_COLX]                 ; Row in A, Col in X
                                   (1155)     call  LCD_2_Position               ; Set cursor position
                                   (1156)     pop   X                             ; Restore pointer
                                   (1157) 
                                   (1158) .LCD_BG_LOOP1X:
                                   (1159)     cmp   [X+BG_LENGTHX],00h            ; Check for past end of BG
                                   (1160)     jnz   .LCD_CHECK1X
                                   (1161)     mov   A,00h                         ; Load empty character
                                   (1162)     jmp   .LCD_BG_DOITX                 ;
                                   (1163) 
                                   (1164) .LCD_CHECK1X:
                                   (1165)     cmp   [X+BG_LENGTHX],06h            ; Check if BG pointer is at this character
                                   (1166)     jnc   .LCD_CHECK2X                  ; Note yet, use full character
                                   (1167)     mov   A,[X+BG_LENGTHX]
                                   (1168)     sub   [X+BG_LENGTHX],A
0E1E: 4F       MOV   X,SP          (1169)     jmp   .LCD_BG_DOITX
0E1F: 52 FD    MOV   A,[X-3]       (1170) 
0E21: 21 03    AND   A,3           (1171) .LCD_CHECK2X:                           ; Put index to full character
                                   (1172)     mov   A, 06h
0E23: 08       PUSH  A             (1173)     sub   [X+BG_LENGTHX],05h            ; Subtract another 5 positions
0E24: FF 91    INDEX 0x0DB7        (1174) 
0E26: 03 FC    ADD   A,[X-4]       (1175) .LCD_BG_DOITX:
0E28: 9E 6E    CALL  0x0C98        (1176)     call  LCD_2_WriteData              ; Display BG character
0E2A: 3D FA 00 CMP   [X-6],0       (1177) 
0E2D: B0 05    JNZ   0x0E33        (1178)     dec   [X+BG_CHAR_LENX]              ; Dec Char count
0E2F: 50 20    MOV   A,32          (1179)     jnz   .LCD_BG_LOOP1X                ; Do it all over again
0E31: 80 13    JMP   0x0E45        (1180)     ret
                                   (1181) .ENDSECTION
0E33: 3D FA 09 CMP   [X-6],9       (1182) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
0E36: D0 09    JNC   0x0E40        (1183) 
                                   (1184) .SECTION
0E38: 52 FA    MOV   A,[X-6]       (1185) ;-----------------------------------------------------------------------------
0E3A: 78       DEC   A             (1186) ;  FUNCTION NAME: LCD_2_DrawBG
0E3B: 56 FA 00 MOV   [X-6],0       (1187) ;
0E3E: 80 06    JMP   0x0E45        (1188) ;  DESCRIPTION:
                                   (1189) ;     Draw a horizontal bargraph on the LCD with the given parameters.
                                   (1190) ;
0E40: 17 FA 08 SUB   [X-6],8       (1191) ;
0E43: 50 07    MOV   A,7           (1192) ;-----------------------------------------------------------------------------
                                   (1193) ;
                                   (1194) ;  FASTCALL16 ARGUMENTS:
0E45: 9E 3D    CALL  0x0C84        (1195) ;   [SP-3] => Starting row for bargraph 0 to 3
0E47: 18       POP   A             (1196) ;   [SP-4] => Starting Column for bargraph 0 to 39+
0E48: 78       DEC   A             (1197) ;   [SP-5] => Length of bargraph in chars 1 to 40+
0E49: 7B FB    DEC   [X-5]         (1198) ;   [SP-6] => Position of pointer in segments 5 times Length
0E4B: BF D7    JNZ   0x0E23        (1199) ;
0E4D: 70 3F    AND   F,63
0E4F: 71 C0    OR    F,192         (1200) ;
0E51: 7F       RET                 (1201) ;  RETURNS:  none
                                   (1202) ;
                                   (1203) ;  SIDE EFFECTS:
                                   (1204) ;    The A and X registers may be modified by this or future implementations
                                   (1205) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1206) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1207) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1208) ;    functions.
                                   (1209) ;          
                                   (1210) ;    Currently only the page pointer registers listed below are modified: 
                                   (1211) ;          CUR_PP
                                   (1212) ;
                                   (1213) ;    If LCD_2_Init is not called before this function, the
                                   (1214) ;    bargraph will not be drawn properly.
                                   (1215) ;
                                   (1216) ; Stack offset constants
                                   (1217) BG_ROW:       equ -3
                                   (1218) BG_COL:       equ -4                   ; Stack position of Column
                                   (1219) BG_CHAR_LEN:  equ -5                   ; Stack position of Length
                                   (1220) BG_LENGTH:    equ -6                   ; Stack position of bargraph pointer position
                                   (1221) 
                                   (1222) 
                                   (1223) _LCD_2_DrawBG:
                                   (1224)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1225)     mov   X, SP
                                   (1226)     push  X
                                   (1227)     mov   A,[X+BG_ROW]                 ; Row in A
                                   (1228)     mov   X,[X+BG_COL]                 ; Col in X
                                   (1229)     RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1230)     call  LCD_2_Position               ; Set cursor position
                                   (1231)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1232)     pop  X
                                   (1233) 
                                   (1234) .LCD_BG_LOOP1:
                                   (1235)     cmp   [X+BG_LENGTH],00h            ; Check for past end of BG
                                   (1236)     jnz   .LCD_CHECK1
                                   (1237)     mov   A,00h                        ; Load empty character
                                   (1238)     jmp   .LCD_BG_DOIT                  ;
0E52: 4F       MOV   X,SP          (1239) 
0E53: 08       PUSH  A             (1240) .LCD_CHECK1:
0E54: 08       PUSH  A             (1241)     cmp   [X+BG_LENGTH],06h            ; Check if BG pointer is at this character
                                   (1242)     jnc   .LCD_CHECK2                   ; Note yet, use full character
0E55: 50 40    MOV   A,64          (1243)     mov   A,[X+BG_LENGTH]
0E57: 9E 3F    CALL  0x0C98        (1244)     sub   [X+BG_LENGTH],A
0E59: 56 00 01 MOV   [X+0],1       (1245)     jmp   .LCD_BG_DOIT
                                   (1246) 
                                   (1247) .LCD_CHECK2:                            ; Put index to full character
0E5C: 56 01 08 MOV   [X+1],8       (1248)     mov   A, 06h
                                   (1249)     sub   [X+BG_LENGTH],05h            ; Subtract another 5 positions
0E5F: 52 00    MOV   A,[X+0]       (1250) 
0E61: 3B 01    CMP   A,[X+1]       (1251) .LCD_BG_DOIT:
0E63: D0 05    JNC   0x0E69        (1252)     call  LCD_2_WriteData              ; Display BG character
0E65: 50 00    MOV   A,0           (1253) 
0E67: 80 03    JMP   0x0E6B        (1254)     dec   [X+BG_CHAR_LEN]              ; Dec Char count
                                   (1255)     jnz   .LCD_BG_LOOP1                 ; Do it all over again
0E69: 50 FF    MOV   A,255         (1256)     RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1257)     ret
0E6B: 9E 17    CALL  0x0C84        (1258) .ENDSECTION
0E6D: 7B 01    DEC   [X+1]         (1259) 
0E6F: BF EF    JNZ   0x0E5F        (1260) IF SYSTEM_SMALL_MEMORY_MODEL
0E71: 77 00    INC   [X+0]         (1261) .SECTION
0E73: 3D 00 09 CMP   [X+0],9       (1262) ;-----------------------------------------------------------------------------
0E76: BF E5    JNZ   0x0E5C        (1263) ;  FUNCTION NAME: LCD_2_DrawVBG
                                   (1264) ;
0E78: 18       POP   A             (1265) ;  DESCRIPTION:
0E79: 18       POP   A             (1266) ;  This legacy fastcall version are provided only to support existing small
0E7A: 50 0C    MOV   A,12          (1267) ;  memory model assembly language code---it does not work in the large memory
0E7C: 9E 1A    CALL  0x0C98        (1268) ;  model.
0E7E: 70 3F    AND   F,63
0E80: 71 C0    OR    F,192         (1269) ;
0E82: 7F       RET                 (1270) ;  ** This legacy fastcall version is provided on a temporary basis to
0E83: 00       SWI   
0E84: 10       PUSH  X
0E85: 18       POP   A
0E86: 1C 1E    SBB   [30],A
0E88: 1F 1F 00 SBB   [X+31],0
0E8B: 10       PUSH  X
0E8C: 08       PUSH  A
0E8D: 04 02    ADD   [2],A
0E8F: 01 00    ADD   A,0
                                   (1271) ;  ** ease the transition to the 4.2 release of PSoC Designer. Its use is
                                   (1272) ;  ** deprecated and its status is "No Further Maintenance". If you call this
                                   (1273) ;  ** function in assembly you should convert to _LCD_2_DrawVBG
                                   (1274) ;  ** (with a leading underscore) and the fastcall16 interface
                                   (1275) ;
                                   (1276) ;  Draw a vertical bargraph on the LCD with the given parameters. This
                                   (1277) ;  is a legacy function that is intended to support existing Assembly
                                   (1278) ;  language programs that call this function.  This should not be used for
                                   (1279) ;  new code or with Large Memory Model programs.
                                   (1280) ;-----------------------------------------------------------------------------
                                   (1281) ;
                                   (1282) ;  LEGACY FASTCALL ARGUMENTS:
                                   (1283) ;    A    => Starting row for bargraph 0 to 3
                                   (1284) ;   [X]   => Starting Column for bargraph 0 to 40+
                                   (1285) ;   [x-1] => Height of bargraph in chars 1 - 4
                                   (1286) ;   [X-2] => Position of pointer in segments 8 times height
                                   (1287) ;  RETURNS:
                                   (1288) ;
                                   (1289) ;  SIDE EFFECTS:
                                   (1290) ;    The A and X registers may be modified by this or future implementations
                                   (1291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1293) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1294) ;    functions.
                                   (1295) ;    
                                   (1296) ;    If LCD_2_Init is not called before this function, the
                                   (1297) ;    bargraph will not be drawn properly.
                                   (1298) ;
                                   (1299) ; Stack offset constants
                                   (1300) VBG_COLX:            equ  0
                                   (1301) VBG_CHAR_HEIGHTX:    equ -1
                                   (1302) VBG_SEG_HEIGHTX:     equ -2
                                   (1303) 
                                   (1304) LCD_2_DrawVBG:
                                   (1305) 
                                   (1306)     and   A,03h                        ; Make sure only rows 0 - 3 are valid
                                   (1307) .VBG_LOOPX:
                                   (1308)     push  A
                                   (1309)     index LCD_2_ROW_OFFSET  ; Get row offset
                                   (1310)     add   A,[X+VBG_COLX]                ; Add column offset to position
                                   (1311)     call  LCD_2_Control                ; Position Cursor
                                   (1312)     cmp   [X+VBG_SEG_HEIGHTX],00h       ; Check for zero segs
                                   (1313)     jnz   .VBG_NZ_SEGX
                                   (1314)     mov   A,' '                        ; Load space character
                                   (1315)     jmp   .VBG_WRITE_CHARX
                                   (1316) .VBG_NZ_SEGX:
                                   (1317)     cmp   [X+VBG_SEG_HEIGHTX],09h       ; Check for full segment
                                   (1318)     jnc   .VBG_FULL_SEGX
                                   (1319)                                         ; Partial segment between 1 and 8
0E91: 4F       MOV   X,SP          (1320)     mov   A,[X+VBG_SEG_HEIGHTX]
0E92: 38 03    ADD   SP,3          (1321)     dec   A
0E94: 54 02    MOV   [X+2],A       (1322)     mov   [X+VBG_SEG_HEIGHTX],00h       ; Zero segment height
                                   (1323)     jmp   .VBG_WRITE_CHARX
0E96: 50 40    MOV   A,64          (1324) 
0E98: 9D FE    CALL  0x0C98        (1325) .VBG_FULL_SEGX:                          ; Bargaph
0E9A: 56 00 00 MOV   [X+0],0       (1326)     sub   [X+VBG_SEG_HEIGHTX],08h       ; Subtract full segment
                                   (1327)     mov   A,07h                        ; Load full segment
                                   (1328) 
0E9D: 56 01 08 MOV   [X+1],8       (1329) .VBG_WRITE_CHARX:                        ; Write character to display
                                   (1330)     call  LCD_2_WriteData              ; Write value
0EA0: 52 00    MOV   A,[X+0]       (1331)     pop   A
0EA2: 3D 02 00 CMP   [X+2],0       (1332)     dec   A
0EA5: B0 05    JNZ   0x0EAB        (1333)     dec   [X+VBG_CHAR_HEIGHTX]
0EA7: FF DA    INDEX 0x0E83        (1334)     jnz   .VBG_LOOPX
0EA9: 80 03    JMP   0x0EAD        (1335)     ret
                                   (1336) .ENDSECTION
0EAB: FF DD    INDEX 0x0E8A        (1337) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (1338) 
0EAD: 9D D5    CALL  0x0C84        (1339) .SECTION
0EAF: 7B 01    DEC   [X+1]         (1340) ;-----------------------------------------------------------------------------
0EB1: BF EE    JNZ   0x0EA0        (1341) ;  FUNCTION NAME: LCD_2_DrawVBG
0EB3: 77 00    INC   [X+0]         (1342) ;
0EB5: 3D 00 07 CMP   [X+0],7       (1343) ;  DESCRIPTION:
0EB8: BF E4    JNZ   0x0E9D        (1344) ;     Draw a vertical bargraph on the LCD with the given parameters.
                                   (1345) ;
0EBA: 38 FD    ADD   SP,253        (1346) ;
0EBC: 50 0C    MOV   A,12          (1347) ;-----------------------------------------------------------------------------
0EBE: 9D D8    CALL  0x0C98        (1348) ;
0EC0: 70 3F    AND   F,63
0EC2: 71 C0    OR    F,192         (1349) ;  FASTCALL16 ARGUMENTS:
0EC5: 08       PUSH  A             (1350) ;

FILE: lib\lcd_1.asm
0EC6: 10       PUSH  X             (0210) ;;*****************************************************************************
0EC7: 28       ROMX                (0211) ;;*****************************************************************************
0EC8: B0 04    JNZ   0x0ECD        (0212) ;;  FILENAME:   LCD_1.asm
0ECA: 20       POP   X             (0213) ;;  Version: 1.5, Updated on 2009/7/10 at 10:44:58
0ECB: 18       POP   A             (0214) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0215) ;;
0ECC: 7F       RET                 (0216) ;;  DESCRIPTION: LCD User Module software implementation file
                                   (0217) ;;               for the M8C based PSoC family of devices.
                                   (0218) ;;
0ECD: 90 44    CALL  0x0F13        (0219) ;; This set of functions is written for the common 2 and 4 line
0ECF: 20       POP   X             (0220) ;; LCDs that use the Hitachi HD44780A controller.
0ED0: 18       POP   A             (0221) ;;
0ED1: 75       INC   X             (0222) ;;  LCD connections to PSoC port
0ED2: DF F2    JNC   0x0EC5        (0223) ;;
0ED4: 74       INC   A             (0224) ;;    PX.0 ==> LCD D4
0ED5: 8F EF    JMP   0x0EC5        (0225) ;;    PX.1 ==> LCD D5
0ED7: 30       HALT  
0ED8: 31 32    XOR   A,50
0EDA: 33 34    XOR   A,[X+52]
0EDC: 35 36    XOR   [X+54],A
0EDE: 37 38 39 XOR   [X+56],57
0EE1: 41 42 43 AND   REG[66],67
0EE4: 44 45 46 OR    REG[X+69],70
                                   (0226) ;;    PX.2 ==> LCD D6
                                   (0227) ;;    PX.3 ==> LCD D7
                                   (0228) ;;    PX.4 ==> LCD E
                                   (0229) ;;    PX.5 ==> LCD RS
                                   (0230) ;;    PX.6 ==> LCD R/W
                                   (0231) ;;
                                   (0232) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0233) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0234) ;;        This means it is the caller's responsibility to preserve any values
                                   (0235) ;;        in the X and A registers that are still needed after the API functions
                                   (0236) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0237) ;;        responsibility to preserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0238) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0239) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0240) ;;-----------------------------------------------------------------------------
                                   (0241) ;;  Copyright (c) Cypress Semiconductor 2001-2006. All Rights Reserved.
                                   (0242) ;;*****************************************************************************
                                   (0243) ;;*****************************************************************************
                                   (0244) 
                                   (0245) include "m8c.inc"
                                   (0246) include "memory.inc"
                                   (0247) include "LCD_1.inc"
                                   (0248) 
                                   (0249) ;-----------------------------------------------
                                   (0250) ;  Global Symbols
                                   (0251) ;-----------------------------------------------
                                   (0252) 
                                   (0253) export   LCD_1_Start
                                   (0254) export  _LCD_1_Start
                                   (0255) export   LCD_1_Init
                                   (0256) export  _LCD_1_Init
                                   (0257) 
                                   (0258) export   LCD_1_WriteData
                                   (0259) export  _LCD_1_WriteData
                                   (0260) 
0EE7: 08       PUSH  A             (0261) export   LCD_1_Control
0EE8: 67       ASR   A             (0262) export  _LCD_1_Control
0EE9: 67       ASR   A             (0263) 
0EEA: 67       ASR   A             (0264) export  LCD_1_PrString
0EEB: 67       ASR   A             (0265) export _LCD_1_PrString
0EEC: 21 0F    AND   A,15          (0266) 
0EEE: FF E7    INDEX 0x0ED7        (0267) export  LCD_1_PrCString
0EF0: 90 21    CALL  0x0F13        (0268) export _LCD_1_PrCString
0EF2: 18       POP   A             (0269) 
0EF3: 21 0F    AND   A,15          (0270) export  LCD_1_Position
0EF5: FF E0    INDEX 0x0ED7        (0271) export _LCD_1_Position
0EF7: 90 1A    CALL  0x0F13        (0272) 
                                   (0273) export  LCD_1_PrHexByte
0EF9: 7F       RET                 (0274) export _LCD_1_PrHexByte
                                   (0275) 
                                   (0276) export  LCD_1_PrHexInt
                                   (0277) export _LCD_1_PrHexInt
                                   (0278) 
                                   (0279) export  LCD_1_Delay50uTimes
                                   (0280) export _LCD_1_Delay50uTimes
                                   (0281) 
                                   (0282) export  LCD_1_Delay50u
                                   (0283) export _LCD_1_Delay50u
                                   (0284) 
                                   (0285) ;-----------------------------------------------
                                   (0286) ; If bargraph functions not required, don't
                                   (0287) ; export the function names.
                                   (0288) ;-----------------------------------------------
                                   (0289) 
                                   (0290) IF (LCD_1_BARGRAPH_ENABLE)
                                   (0291) export  LCD_1_InitBG
                                   (0292) export _LCD_1_InitBG
                                   (0293) 
                                   (0294) export  LCD_1_InitVBG
                                   (0295) export _LCD_1_InitVBG
                                   (0296) 
                                   (0297) ; NOTE: The two functions,
                                   (0298) ;
                                   (0299) ;    LCD_1_DrawVBG and
                                   (0300) ;    LCD_1_DrawBG
                                   (0301) ;
                                   (0302) ; are implemented using both fastcall16 and legacy fastcall16 because they
                                   (0303) ; fall into a special and rare case where the calling sequences specified
                                   (0304) ; by the two disciplines are incompatible. The fastcall16 versions are
                                   (0305) ; provided for both C and Assembly users in all memory models. The legacy
0EFA: 4B       SWAP  A,X           (0306) ; fastcall16 versions are provided only to support existing small memory
0EFB: 9F EA    CALL  0x0EE7        (0307) ; model assembly language code---they do not work in the large memory
0EFD: 5B       MOV   A,X           (0308) ; model.
0EFE: 9F E7    CALL  0x0EE7        (0309) ;
                                   (0310) ; ** The legacy fastcall16 versions are provided on a temporary basis to
0F00: 7F       RET                 (0311) ; ** ease the transition to the 4.2 release of PSoC Designer. Their use is
                                   (0312) ; ** deprecated and their status is "No Further Maintenance".
                                   (0313) ;
                                   (0314) ; The fastcall16 versions of these functions are distinguished by a
                                   (0315) ; leading underscore in the name. The legacy fastcall16 names (which appear
                                   (0316) ; in this comment) do not have the leading underscore. Details on the
                                   (0317) ; calling sequence to be used for fastcall16 are given in the user module
                                   (0318) ; datasheet.
                                   (0319) ;
                                   (0320) ; Fastcall16 versions:
                                   (0321) export _LCD_1_DrawVBG
                                   (0322) export _LCD_1_DrawBG
                                   (0323) 
                                   (0324) IF SYSTEM_SMALL_MEMORY_MODEL
                                   (0325) ; Legacy Fastcall versions:
                                   (0326) export  LCD_1_DrawVBG
                                   (0327) export  LCD_1_DrawBG
                                   (0328) ENDIF  ; SYSTEM_SMALL_MEMORY_MODEL
                                   (0329) 
                                   (0330) ENDIF  ; BARGRAPH_ENABLE
                                   (0331) 
                                   (0332) ;
                                   (0333) ; The following functions are deprecated and will be eliminated in a future
                                   (0334) ; version of PSoC Designer.
                                   (0335) ;
                                   (0336) export   LCD_1_Write_Data
                                   (0337) export  _LCD_1_Write_Data
                                   (0338) 
                                   (0339) 
                                   (0340) ;-----------------------------------------------
                                   (0341) ;  EQUATES
                                   (0342) ;-----------------------------------------------
                                   (0343) 
0F01: 70 BF    AND   F,191         (0344) LCD_1_Port:           equ    PRT2DR
0F03: 60 D3    MOV   REG[211],A    (0345) LCD_1_PortMode0:      equ    PRT2DM0
                                   (0346) LCD_1_PortMode1:      equ    PRT2DM1
0F05: 52 00    MOV   A,[X+0]       (0347) 
0F07: A0 06    JZ    0x0F0E        (0348) LCD_1_E:              equ    10h
                                   (0349) LCD_1_RW:             equ    40h
0F09: 90 08    CALL  0x0F13        (0350) LCD_1_RS:             equ    20h
0F0B: 75       INC   X             (0351) 
0F0C: 8F F8    JMP   0x0F05        (0352) LCD_1_DATA_MASK:      equ    0Fh
0F0E: 70 3F    AND   F,63
                                   (0353) LCD_1_READY_BIT:      equ    08h
0F10: 71 C0    OR    F,192         (0354) 
0F12: 7F       RET                 (0355) LCD_1_DATA_READ:      equ    ( LCD_1_E | LCD_1_RW | LCD_1_RS )
                                   (0356) LCD_1_CNTL_READ:      equ    ( LCD_1_E | LCD_1_RW )
                                   (0357) LCD_1_PORT_WRITE:     equ    7Fh
                                   (0358) LCD_1_PORT_MASK:      equ    7Fh
                                   (0359) 
                                   (0360) LCD_1_DISP_INC:       equ    03h
                                   (0361) LCD_1_DISP_OFF:       equ    08h
                                   (0362) LCD_1_DISP_ON:        equ    0Ch
                                   (0363) LCD_1_4BIT_2LINE:     equ    2Ch
                                   (0364) 
                                   (0365) 
                                   (0366) ;-----------------------------------------------
                                   (0367) ;      Bargraph definitions
                                   (0368) ;-----------------------------------------------
                                   (0369) 
                                   (0370) LCD_1_BG_CHAR_WIDTH:  equ    16     ; 16 characters in width
                                   (0371) LCD_1_BG_SEG_WIDTH:   equ    80     ; 16 * 5 = 80
                                   (0372) LCD_1_BG_COL_START:   equ     0     ; Always start in the left most column
                                   (0373) 
                                   (0374)                                   ; Offsets for 2x16, 2x20, 4x20
                                   (0375)                                   ; Change these values for a custom LCD
                                   (0376) 
                                   (0377) LCD_1_ROW1_OFFSET:    equ    80h    ; Address/command offset for row 1
                                   (0378) LCD_1_ROW2_OFFSET:    equ    C0h    ; Address/command offset for row 2
                                   (0379) LCD_1_ROW3_OFFSET:    equ    94h    ; Address/command offset for row 1
                                   (0380) LCD_1_ROW4_OFFSET:    equ    D4h    ; Address/command offset for row 2
                                   (0381) 
                                   (0382) LCD_1_BG_ROW1_OFFSET: equ    80h    ; Address/command offset for row 1
                                   (0383) LCD_1_BG_ROW2_OFFSET: equ    C0h    ; Address/command offset for row 2
                                   (0384) 
                                   (0385) LCD_1_CG_RAM_OFFSET:  equ    40h    ; Offset to character RAM
                                   (0386) 
0F13: 90 65    CALL  0x0F7A        (0387) AREA UserModules (ROM, REL)
                                   (0388) 
0F15: 08       PUSH  A             (0389) .SECTION
0F16: 67       ASR   A             (0390) ;-----------------------------------------------------------------------------
0F17: 67       ASR   A             (0391) ;  FUNCTION NAME: LCD_1_PrCString
0F18: 67       ASR   A             (0392) ;
0F19: 67       ASR   A             (0393) ;  DESCRIPTION:
0F1A: 21 0F    AND   A,15          (0394) ;    Print constant (ROM) string to LCD
0F1C: 90 3B    CALL  0x0F59        (0395) ;-----------------------------------------------------------------------------
0F1E: 18       POP   A             (0396) ;
0F1F: 21 0F    AND   A,15          (0397) ;  ARGUMENTS:
0F21: 40       NOP                 (0398) ;     A:X  Pointer to String
0F22: 40       NOP                 (0399) ;          A contains MSB of string address
0F23: 40       NOP                 (0400) ;          X contains LSB of string address
0F24: 90 33    CALL  0x0F59        (0401) ;
                                   (0402) ;  RETURNS:  none
0F26: 7F       RET                 (0403) ;
                                   (0404) ;  SIDE EFFECTS:
                                   (0405) ;    The A and X registers may be modified by this or future implementations
                                   (0406) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0407) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0408) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0409) ;    functions.
                                   (0410) ;          
                                   (0411) ;    Currently only the page pointer registers listed below are modified: 
                                   (0412) ;          CUR_PP
                                   (0413) ;
                                   (0414)  LCD_1_PrCString:
                                   (0415) _LCD_1_PrCString:
                                   (0416)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0417)  .Loop_PrCString:
                                   (0418)     push  A                            ; Store ROM pointer
                                   (0419)     push  X
                                   (0420)     romx                               ; Get character from ROM
                                   (0421)     jnz   .LCD_PrCString_WR            ; print character and advance pointer
                                   (0422)     pop   X                            ; Restore the stack
                                   (0423)     pop   A
                                   (0424)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0425)     ret                                ; Return
                                   (0426) 
                                   (0427) .LCD_PrCString_WR:
                                   (0428)     call  LCD_1_WriteData              ; Write data to LCD
                                   (0429)     pop   X                            ; Get ROM pointer
                                   (0430)     pop   A
                                   (0431)     inc   X                            ; Inc LSB of pointer
                                   (0432)     jnc   .Loop_PrCString
0F27: 90 51    CALL  0x0F7A        (0433)     inc   A                            ; Inc MSB of pointer if LSB overflow
                                   (0434)     jmp   .Loop_PrCString
0F29: 08       PUSH  A             (0435) 
0F2A: 67       ASR   A             (0436) .ENDSECTION
0F2B: 67       ASR   A             (0437) 
0F2C: 67       ASR   A             (0438) ;-----------------------------------------------------------------------------
0F2D: 67       ASR   A             (0439) ;  FUNCTION NAME: LCD_1_PrHexByte
0F2E: 21 0F    AND   A,15          (0440) ;
0F30: 90 09    CALL  0x0F3B        (0441) ;  DESCRIPTION:
0F32: 18       POP   A             (0442) ;     Print a byte in Hex (two characters) to current LCD position
0F33: 21 0F    AND   A,15          (0443) ;
0F35: 40       NOP                 (0444) ;-----------------------------------------------------------------------------
0F36: 40       NOP                 (0445) ;
0F37: 40       NOP                 (0446) ;  ARGUMENTS:
0F38: 90 01    CALL  0x0F3B        (0447) ;     A  => (BYTE) Data/char to be printed
                                   (0448) ;
0F3A: 7F       RET                 (0449) ;  RETURNS: none
                                   (0450) ;
                                   (0451) ;  SIDE EFFECTS:
                                   (0452) ;    The A and X registers may be modified by this or future implementations
                                   (0453) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0454) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0455) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0456) ;    functions.
                                   (0457) ;          
                                   (0458) ;    Currently only the page pointer registers listed below are modified: 
                                   (0459) ;          CUR_PP
                                   (0460) ;
                                   (0461) .LITERAL
                                   (0462) LCD_1_HEX_STR::
                                   (0463)      DS    "0123456789ABCDEF"
                                   (0464) .ENDLITERAL
                                   (0465) .SECTION
                                   (0466) 
                                   (0467)  LCD_1_PrHexByte:
                                   (0468) _LCD_1_PrHexByte:
                                   (0469)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0470)     push  A                            ; Save lower nibble
                                   (0471)     asr   A                            ; Shift high nibble to right
                                   (0472)     asr   A
                                   (0473)     asr   A
                                   (0474)     asr   A
                                   (0475)     and   A,0Fh                        ; Mask off nibble
                                   (0476)     index LCD_1_HEX_STR                  ; Get Hex value
                                   (0477)     call  LCD_1_WriteData              ; Write data to screen
0F3B: 08       PUSH  A             (0478)     pop   A                            ; Restore value
0F3C: 62 D0 00 MOV   REG[208],0    (0479)     and   A,0Fh                        ; Mask off lower nibble
0F3F: 26 03 80 AND   [3],128       (0480)     index LCD_1_HEX_STR                  ; Get Hex value
0F42: 51 03    MOV   A,[3]         (0481)     call  LCD_1_WriteData              ; Write data to screen
0F44: 60 08    MOV   REG[8],A      (0482)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0483)     ret
0F46: 18       POP   A             (0484) .ENDSECTION
0F47: 21 0F    AND   A,15          (0485) 
0F49: 29 10    OR    A,16          (0486) .SECTION
0F4B: 2A 03    OR    A,[3]         (0487) ;-----------------------------------------------------------------------------
0F4D: 60 08    MOV   REG[8],A      (0488) ;  FUNCTION NAME: LCD_1_PrHexInt
0F4F: 53 03    MOV   [3],A         (0489) ;
0F51: 40       NOP                 (0490) ;  DESCRIPTION:
0F52: 21 8F    AND   A,143         (0491) ;     Print an Int in Hex (four characters) to current LCD position
0F54: 53 03    MOV   [3],A         (0492) ;
0F56: 60 08    MOV   REG[8],A      (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;
0F58: 7F       RET                 (0495) ;  ARGUMENTS:
                                   (0496) ;     A:X Integer value
                                   (0497) ;         A  contains LSB of Int
                                   (0498) ;         X  contains MSB of Int
                                   (0499) ;
                                   (0500) ;  RETURNS: none
                                   (0501) ;
                                   (0502) ;  SIDE EFFECTS:
                                   (0503) ;    The A and X registers may be modified by this or future implementations
                                   (0504) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0505) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0506) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0507) ;    functions.
                                   (0508) ;          
                                   (0509) ;    Currently only the page pointer registers listed below are modified: 
                                   (0510) ;          CUR_PP
                                   (0511) ;
                                   (0512)  LCD_1_PrHexInt:
                                   (0513) _LCD_1_PrHexInt:
                                   (0514)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0515)     swap  A,X
                                   (0516)     call  LCD_1_PrHexByte              ; Print MSB
                                   (0517)     mov   A,X                          ; Move LSB into position
                                   (0518)     call  LCD_1_PrHexByte              ; Print LSB
                                   (0519)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0520)     ret
                                   (0521) .ENDSECTION
                                   (0522) 
                                   (0523) .SECTION
0F59: 08       PUSH  A             (0524) ;-----------------------------------------------------------------------------
0F5A: 62 D0 00 MOV   REG[208],0    (0525) ;  FUNCTION NAME: LCD_1_PrString
0F5D: 26 03 80 AND   [3],128       (0526) ;
0F60: 2E 03 20 OR    [3],32        (0527) ;  DESCRIPTION:
0F63: 51 03    MOV   A,[3]         (0528) ;     Print (RAM) ASCII string to LCD
0F65: 60 08    MOV   REG[8],A      (0529) ;
                                   (0530) ;-----------------------------------------------------------------------------
0F67: 18       POP   A             (0531) ;
0F68: 21 0F    AND   A,15          (0532) ;  ARGUMENTS:
0F6A: 29 30    OR    A,48          (0533) ;     A:X contains pointer to string
0F6C: 2A 03    OR    A,[3]         (0534) ;         X  contains LSB of string pointer
0F6E: 60 08    MOV   REG[8],A      (0535) ;         A  contains MSB or page of string pointer (not used at this time)
0F70: 53 03    MOV   [3],A         (0536) ;
0F72: 40       NOP                 (0537) ;  RETURNS:
0F73: 21 AF    AND   A,175         (0538) ;
0F75: 53 03    MOV   [3],A         (0539) ;  SIDE EFFECTS:
0F77: 60 08    MOV   REG[8],A      (0540) ;    The A and X registers may be modified by this or future implementations
                                   (0541) ;    of this function.  The same is true for all RAM page pointer registers in
0F79: 7F       RET                 (0542) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0543) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0544) ;    functions.
                                   (0545) ;          
                                   (0546) ;    Currently only the page pointer registers listed below are modified: 
                                   (0547) ;          CUR_PP
                                   (0548) ;          IDX_PP
                                   (0549) ;
                                   (0550) ;
                                   (0551)  LCD_1_PrString:
                                   (0552) _LCD_1_PrString:
                                   (0553)     RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0554)     RAM_SETPAGE_IDX A
                                   (0555)  .Loop_PrString:
                                   (0556)     mov   A,[X]                        ; Get value pointed to by X
                                   (0557)     jz    .End_LCD_PrString            ; Check for end of string
                                   (0558)     ;LCD_1_writeData is known not to modify X so no need to preserve
                                   (0559)     call  LCD_1_WriteData              ; Write data to screen
                                   (0560)     inc   X                            ; Advance pointer to next character
                                   (0561)     jmp   .Loop_PrString               ; Go get next character
                                   (0562) .End_LCD_PrString:
                                   (0563)     RAM_EPILOGUE RAM_USE_CLASS_3
                                   (0564)     ret
                                   (0565) .ENDSECTION
                                   (0566) 
                                   (0567) .SECTION
                                   (0568) ;-----------------------------------------------------------------------------
                                   (0569) ;  FUNCTION NAME: LCD_1_WriteData
                                   (0570) ;
                                   (0571) ;  DESCRIPTION:
0F7A: 08       PUSH  A             (0572) ;     Write a byte to the LCD's data register.
0F7B: 62 D0 00 MOV   REG[208],0    (0573) ;
0F7E: 26 03 80 AND   [3],128       (0574) ;-----------------------------------------------------------------------------
0F81: 51 03    MOV   A,[3]         (0575) ;
0F83: 60 08    MOV   REG[8],A      (0576) ;  ARGUMENTS:
                                   (0577) ;    A contains byte to be written to LCD data register
0F85: 26 04 F0 AND   [4],240       (0578) ;
0F88: 51 04    MOV   A,[4]         (0579) ;  RETURNS: none
0F8A: 71 10    OR    F,16          (0580) ;
0F8C: 60 08    MOV   REG[8],A      (0581) ;  SIDE EFFECTS:
0F8E: 70 EF    AND   F,239         (0582) ;    The A and X registers may be modified by this or future implementations
                                   (0583) ;    of this function.  The same is true for all RAM page pointer registers in
0F90: 2E 03 40 OR    [3],64        (0584) ;    the Large Memory Model.  When necessary, it is the calling function's
0F93: 51 03    MOV   A,[3]         (0585) ;    responsibility to preserve their values across calls to fastcall16 
0F95: 60 08    MOV   REG[8],A      (0586) ;    functions.
0F97: 40       NOP                 (0587) ;          
                                   (0588) ;    Currently only the page pointer registers listed below are modified: 
0F98: 10       PUSH  X             (0589) ;          CUR_PP
0F99: 57 FF    MOV   X,255         (0590) ;
                                   (0591)  LCD_1_WriteData:
                                   (0592) _LCD_1_WriteData:
0F9B: 2E 03 50 OR    [3],80        (0593)  LCD_1_Write_Data:   ; Do not use
0F9E: 51 03    MOV   A,[3]         (0594) _LCD_1_Write_Data:   ; Do not use
0FA0: 60 08    MOV   REG[8],A      (0595)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0596)     call  LCD_1_Check_Ready            ; Make sure controller is ready
0FA2: 40       NOP                 (0597)                                        ; A is preserved in LCD_1_Check_Ready
0FA3: 40       NOP                 (0598)     push  A                            ; Save copy of character
0FA4: 5D 08    MOV   A,REG[8]      (0599)     asr   A                            ; Shift high nibble to right
                                   (0600)     asr   A
                                   (0601)     asr   A
                                   (0602)     asr   A
                                   (0603)     and   A,0Fh                        ; Mask off high nibble
                                   (0604)     call  LCD_1_WDATA_Nibble           ; Write Upper nibble
                                   (0605)     pop   A                            ; Retrieve copy of character
                                   (0606)     and   A,0Fh                        ; Mask off high nibble
                                   (0607)     nop
                                   (0608)     nop
                                   (0609)     nop
                                   (0610)     call  LCD_1_WDATA_Nibble   ; Write Lower nibble
0FA6: 08       PUSH  A             (0611)     RAM_EPILOGUE RAM_USE_CLASS_1
0FA7: 26 03 C0 AND   [3],192       (0612)     ret
0FAA: 51 03    MOV   A,[3]         (0613) .ENDSECTION
0FAC: 60 08    MOV   REG[8],A      (0614) 
                                   (0615) .SECTION
0FAE: 40       NOP                 (0616) ;-----------------------------------------------------------------------------
0FAF: 40       NOP                 (0617) ;  FUNCTION NAME: LCD_1_Control
0FB0: 40       NOP                 (0618) ;
                                   (0619) ;  DESCRIPTION:
0FB1: 2E 03 50 OR    [3],80        (0620) ;     Write a byte to the LCD's control register.
0FB4: 51 03    MOV   A,[3]         (0621) ;
0FB6: 60 08    MOV   REG[8],A      (0622) ;-----------------------------------------------------------------------------
                                   (0623) ;
0FB8: 40       NOP                 (0624) ;  ARGUMENTS:
0FB9: 40       NOP                 (0625) ;     A contains data to be written to LCD control register.
                                   (0626) ;
0FBA: 26 03 C0 AND   [3],192       (0627) ;  RETURNS: none
0FBD: 51 03    MOV   A,[3]         (0628) ;
0FBF: 60 08    MOV   REG[8],A      (0629) ;  SIDE EFFECTS:
                                   (0630) ;    The A and X registers may be modified by this or future implementations
0FC1: 18       POP   A             (0631) ;    of this function.  The same is true for all RAM page pointer registers in
0FC2: 21 08    AND   A,8           (0632) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0633) ;    responsibility to preserve their values across calls to fastcall16 
0FC4: A0 04    JZ    0x0FC9        (0634) ;    functions.
0FC6: 79       DEC   X             (0635) ;          
0FC7: BF D3    JNZ   0x0F9B        (0636) ;    Currently only the page pointer registers listed below are modified: 
                                   (0637) ;          CUR_PP
0FC9: 20       POP   X             (0638) ;
                                   (0639)  LCD_1_Control:
0FCA: 2E 04 7F OR    [4],127       (0640) _LCD_1_Control:
0FCD: 51 04    MOV   A,[4]         (0641)     RAM_PROLOGUE RAM_USE_CLASS_1
0FCF: 71 10    OR    F,16          (0642)     call  LCD_1_Check_Ready            ; Make sure controller is ready
0FD1: 60 08    MOV   REG[8],A      (0643)                                        ; A is preserved in LCD_1_Check_Ready
0FD3: 70 EF    AND   F,239         (0644)     push  A                            ; Save copy of byte
0FD5: 18       POP   A             (0645)     asr   A                            ; Shift Upper Nibble to right
                                   (0646)     asr   A
0FD6: 7F       RET                 (0647)     asr   A
                                   (0648)     asr   A
                                   (0649)     and   A,0Fh                        ; Mask off, just in case
                                   (0650)     call  LCD_1_WCNTL_Nibble           ; Write high nibble
                                   (0651)     pop   A                            ; Restore copy of byte
                                   (0652)     and   A,0Fh                        ; Mask off high nibble
                                   (0653)     nop
                                   (0654)     nop
                                   (0655)     nop
                                   (0656)     call  LCD_1_WCNTL_Nibble             ; Write Lower nibble
                                   (0657)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0658)     ret
                                   (0659) .ENDSECTION
                                   (0660) 
                                   (0661) .SECTION
                                   (0662) ;-----------------------------------------------------------------------------
                                   (0663) ;  FUNCTION NAME: LCD_1_WCNTL_Nibble
                                   (0664) ;
                                   (0665) ;  DESCRIPTION:
                                   (0666) ;     Write a single nibble to the LCD's command register
                                   (0667) ;
                                   (0668) ;-----------------------------------------------------------------------------
                                   (0669) ;
                                   (0670) ;  ARGUMENTS:
                                   (0671) ;     A[3:0]   Contains Nibble to be written to command register
                                   (0672) ;
                                   (0673) ;  RETURNS: none
                                   (0674) ;
                                   (0675) ;  SIDE EFFECTS:
                                   (0676) ;    The A and X registers may be modified by this or future implementations
                                   (0677) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0678) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0679) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0680) ;    functions.
                                   (0681) ;          
                                   (0682) ;    Currently only the page pointer registers listed below are modified: 
                                   (0683) ;          CUR_PP
0FD7: 62 D0 00 MOV   REG[208],0    (0684) ;
                                   (0685)  LCD_1_WCNTL_Nibble:
0FDA: 26 04 80 AND   [4],128       (0686)     RAM_PROLOGUE RAM_USE_CLASS_4
0FDD: 2E 04 7F OR    [4],127       (0687)     push  A
0FE0: 26 05 80 AND   [5],128       (0688)     RAM_SETPAGE_CUR >Port_2_Data_SHADE           ; Set CUR_PP to LCD variable address
                                   (0689)     and   [Port_2_Data_SHADE],~LCD_1_PORT_MASK
0FE3: 51 04    MOV   A,[4]         (0690)     mov   A,[Port_2_Data_SHADE]
0FE5: 71 10    OR    F,16          (0691)     mov   reg[LCD_1_Port],A                      ; Reset control lines
0FE7: 60 08    MOV   REG[8],A      (0692) 
0FE9: 51 05    MOV   A,[5]         (0693)     pop   A
0FEB: 60 09    MOV   REG[9],A      (0694)     and   A,LCD_1_DATA_MASK                      ; Make sure no bogus data in MSN
0FED: 70 EF    AND   F,239         (0695)     or    A,LCD_1_E                              ; Bring "E" Enable line high
                                   (0696)     or    A,[Port_2_Data_SHADE]                  ; OR in bit 7 just
0FEF: 50 FA    MOV   A,250         (0697)     mov   reg[LCD_1_Port], A                     ; Write data
0FF1: 90 67    CALL  0x105A        (0698)     mov   [Port_2_Data_SHADE],A                  ; Keep shadow register in sync
0FF3: 50 FA    MOV   A,250         (0699)     nop
0FF5: 90 63    CALL  0x105A        (0700)     and   A,(~LCD_1_PORT_MASK|LCD_1_DATA_MASK)   ; Disable E signal and leave data on bus.
                                   (0701)     mov   [Port_2_Data_SHADE],A                  ; Keep shadow register in sync
0FF7: 50 03    MOV   A,3           (0702)     mov   reg[LCD_1_Port],A
0FF9: 9F 40    CALL  0x0F3B        (0703)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0704)     ret
0FFB: 50 52    MOV   A,82          (0705) .ENDSECTION
0FFD: 90 5B    CALL  0x105A        (0706) 
                                   (0707) .SECTION
0FFF: 50 03    MOV   A,3           (0708) ;-----------------------------------------------------------------------------
1001: 9F 38    CALL  0x0F3B        (0709) ;  FUNCTION NAME: LCD_1_WDATA_Nibble
                                   (0710) ;
1003: 90 63    CALL  0x1068        (0711) ;  DESCRIPTION:
1005: 90 61    CALL  0x1068        (0712) ;     Write a single nibble to the LCD's DATA register
1007: 90 5F    CALL  0x1068        (0713) ;
                                   (0714) ;-----------------------------------------------------------------------------
1009: 50 03    MOV   A,3           (0715) ;
100B: 9F 2E    CALL  0x0F3B        (0716) ;  ARGUMENTS:
                                   (0717) ;     A[3:0]   Contains Nibble to be written to data register
100D: 50 5A    MOV   A,90          (0718) ;
100F: 90 49    CALL  0x105A        (0719) ;  RETURNS: none
                                   (0720) ;
1011: 50 02    MOV   A,2           (0721) ;  SIDE EFFECTS:
1013: 9F 26    CALL  0x0F3B        (0722) ;    The A and X registers may be modified by this or future implementations
                                   (0723) ;    of this function.  The same is true for all RAM page pointer registers in
1015: 50 5A    MOV   A,90          (0724) ;    the Large Memory Model.  When necessary, it is the calling function's
1017: 90 41    CALL  0x105A        (0725) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0726) ;    functions.
1019: 50 08    MOV   A,8           (0727) ;          
101B: 9F 0A    CALL  0x0F27        (0728) ;    Currently only the page pointer registers listed below are modified: 
101D: 50 5A    MOV   A,90          (0729) ;          CUR_PP
101F: 90 39    CALL  0x105A        (0730) ;
                                   (0731) LCD_1_WDATA_Nibble:
1021: 50 01    MOV   A,1           (0732)     RAM_PROLOGUE RAM_USE_CLASS_4
1023: 9F 02    CALL  0x0F27        (0733)     push  A
1025: 50 5A    MOV   A,90          (0734)     RAM_SETPAGE_CUR >Port_2_Data_SHADE          ; Set CUR_PP to LCD variable address
1027: 90 31    CALL  0x105A        (0735)     and   [Port_2_Data_SHADE],~LCD_1_PORT_MASK
                                   (0736)     or    [Port_2_Data_SHADE],LCD_1_RS                ; Raise RS to signify a Data Write
1029: 50 06    MOV   A,6           (0737)     mov   A,[Port_2_Data_SHADE]
102B: 9E FA    CALL  0x0F27        (0738)     mov   reg[LCD_1_Port],A
                                   (0739) 
102D: 50 0E    MOV   A,14          (0740)     pop   A
102F: 9E F6    CALL  0x0F27        (0741)     and   A,LCD_1_DATA_MASK                           ; Make sure no bogus data in A[7:4]
                                   (0742)     or    A,(LCD_1_E | LCD_1_RS)                      ; Bring "E" Enable line high
1031: 50 2C    MOV   A,44          (0743)     or    A,[Port_2_Data_SHADE]                       ; Keep shadow in sync
1033: 9E F2    CALL  0x0F27        (0744)     mov   reg[LCD_1_Port], A                            ; Write data
                                   (0745)     mov   [Port_2_Data_SHADE],A                       ; Keep shadow in sync
1035: 50 08    MOV   A,8           (0746)     NOP
1037: 9E EE    CALL  0x0F27        (0747)     and   A,(~LCD_1_PORT_MASK|LCD_1_DATA_MASK|LCD_1_RS)  ; Disable E signal and leave Data on bus
                                   (0748)     mov   [Port_2_Data_SHADE],A                       ; keep shadow in sync
1039: 50 0C    MOV   A,12          (0749)     mov   reg[LCD_1_Port],A
103B: 9E EA    CALL  0x0F27        (0750)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0751)     ret
103D: 50 03    MOV   A,3           (0752) .ENDSECTION
103F: 9E E6    CALL  0x0F27        (0753) 
                                   (0754) .SECTION
1041: 50 5A    MOV   A,90          (0755) ;-----------------------------------------------------------------------------
1043: 90 15    CALL  0x105A        (0756) ;  FUNCTION NAME: LCD_1_Check_Ready
                                   (0757) ;
1045: 7F       RET                 (0758) ;  DESCRIPTION:
1046: 80 C0    JMP   0x1107
1048: 94 D4    CALL  0x151E
                                   (0759) ;     Wait until LCD has completed last command.
                                   (0760) ;
                                   (0761) ;-----------------------------------------------------------------------------
                                   (0762) ;
                                   (0763) ;  ARGUMENTS: none
                                   (0764) ;
                                   (0765) ;  RETURNS: none
                                   (0766) ;
                                   (0767) ;  SIDE EFFECTS:
                                   (0768) ;    The A and X registers may be modified by this or future implementations
                                   (0769) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0770) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0771) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0772) ;    functions.
                                   (0773) ;          
                                   (0774) ;    Currently only the page pointer registers listed below are modified: 
                                   (0775) ;          CUR_PP
                                   (0776) ;
                                   (0777) ;     If LCD is not present, this routine may never return.
                                   (0778) ;
                                   (0779) LCD_1_Check_Ready:
                                   (0780)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0781)     push  A                                           ; Save Accumulator
                                   (0782)     RAM_SETPAGE_CUR >Port_2_Data_SHADE                ; Set CUR_PP to LCD variable address
                                   (0783)     and   [Port_2_Data_SHADE],~LCD_1_PORT_MASK        ; Mask of all LCD bits
                                   (0784)     mov   A,[Port_2_Data_SHADE]
                                   (0785)     mov   reg[LCD_1_Port],A                           ; Zero LCD port bits
                                   (0786) 
                                   (0787)     and   [Port_2_DriveMode_0_SHADE],~LCD_1_DATA_MASK ; Clear out LCD mode bits.
                                   (0788)     mov   A,[Port_2_DriveMode_0_SHADE]
                                   (0789)     M8C_SetBank1                                      ; Change port mode to read status
                                   (0790)     mov   reg[LCD_1_PortMode0],A                      ; Setup LCD Port for reading
104A: 21 03    AND   A,3           (0791)     M8C_SetBank0
104C: 10       PUSH  X             (0792) 
104D: FF F7    INDEX 0x1046        (0793)     or    [Port_2_Data_SHADE],LCD_1_RW                ; Raise RW to signify Read operation
104F: 4F       MOV   X,SP          (0794)     mov   A,[Port_2_Data_SHADE]
1050: 03 FF    ADD   A,[X-1]       (0795)     mov   reg[LCD_1_Port],A
1052: 20       POP   X             (0796)     NOP
                                   (0797) 
1053: 9E D2    CALL  0x0F27        (0798)     push  X							                            ; Save 'X' register
1055: 70 3F    AND   F,63
1057: 71 C0    OR    F,192         (0799)     mov   X,255                         			            ; 255 Attempts
1059: 7F       RET                 (0800) 
                                   (0801) .LCD_RDY_LOOP:
                                   (0802)     or    [Port_2_Data_SHADE], LCD_1_CNTL_READ                  ; Raise E to start cycle
                                   (0803)     mov   A,[Port_2_Data_SHADE]
                                   (0804)     mov   reg[LCD_1_Port],A
                                   (0805) 
                                   (0806)     nop                                               ; Wait 2 nops to make sure data is ready
                                   (0807)     nop
                                   (0808)     mov   A,reg[LCD_1_Port]
                                   (0809) 
                                   (0810) ; The code below is used to work around the async read issue with the ICE with the 
                                   (0811) ; 25/26xxx family of devices.  It will help to eliminate "Invalid memory reference" 
                                   (0812) ; errors.  It is not required when running without the ICE or when using any other 
                                   (0813) ; family besides the 25/26xxx family. If not using the ICE or with any other family
                                   (0814) ; the ICE_PORT_SYNC flag should be set to 0.
                                   (0815) IF(ICE_PORT_SYNC)                          
                                   (0816)     mov   reg[ 0xfa], A                    
                                   (0817)     mov   A, reg[0xfa]                     
                                   (0818) ENDIF   
                                   (0819)                                    
                                   (0820)     push  A
                                   (0821)     and   [Port_2_Data_SHADE],(~LCD_1_PORT_MASK | LCD_1_RW)     ; Lower E signal
                                   (0822)     mov   A,[Port_2_Data_SHADE]
                                   (0823)     mov   reg[LCD_1_Port],A
                                   (0824) 
                                   (0825)     nop                                    ; Add delay for the slowest part and the
                                   (0826)     nop                                    ; fastest PSoC
                                   (0827)     nop
105A: 90 0C    CALL  0x1068        (0828)                                                                 ; Get the LSBs
105C: 78       DEC   A             (0829)     or    [Port_2_Data_SHADE],LCD_1_CNTL_READ                   ; Raise E to start cycle
105D: BF FC    JNZ   0x105A        (0830)     mov   A,[Port_2_Data_SHADE]
                                   (0831)     mov   reg[LCD_1_Port],A
105F: 7F       RET                 (0832) 
1060: 08       PUSH  A
1061: 19 3A    SBB   A,58
1063: 7C 01 01 LCALL 0x0101
1066: 01 01    ADD   A,1
                                   (0833)     nop
                                   (0834)     nop
                                   (0835) 
                                   (0836)     and   [Port_2_Data_SHADE],(~LCD_1_PORT_MASK | LCD_1_RW)     ; Lower E signal
                                   (0837)     mov   A,[Port_2_Data_SHADE]
                                   (0838)     mov   reg[LCD_1_Port],A
                                   (0839) 
                                   (0840)     pop   A
                                   (0841)     and   A,LCD_1_READY_BIT                                       ; Check busy
                                   (0842) 
                                   (0843)     jz    .UNLOCK
                                   (0844)     dec   X
                                   (0845)     jnz   .LCD_RDY_LOOP                                         ; If LCD still busy, read again for 255 times
                                   (0846) .UNLOCK:
                                   (0847)     pop   X							                            ; Restore 'X' register
                                   (0848) 
                                   (0849)     or    [Port_2_DriveMode_0_SHADE],LCD_1_PORT_WRITE ; Revert Data bit to Write mode
                                   (0850)     mov   A,[Port_2_DriveMode_0_SHADE]
                                   (0851)     M8C_SetBank1
                                   (0852)     mov   reg[LCD_1_PortMode0],A                      ; Setup LCD Port for writing
                                   (0853)     M8C_SetBank0
                                   (0854)     pop   A
                                   (0855)     RAM_EPILOGUE RAM_USE_CLASS_4                                ; Restore Accumulator
                                   (0856)     ret
                                   (0857) .ENDSECTION
                                   (0858) 
                                   (0859) .SECTION
                                   (0860) ;-----------------------------------------------------------------------------
                                   (0861) ;  FUNCTION NAME: LCD_1_Start
                                   (0862) ;  FUNCTION NAME: LCD_1_Init
                                   (0863) ;
                                   (0864) ;  DESCRIPTION:
                                   (0865) ;     Initialize LCD
                                   (0866) ;
                                   (0867) ;-----------------------------------------------------------------------------
                                   (0868) ;
                                   (0869) ;  ARGUMENTS: none
                                   (0870) ;
                                   (0871) ;  RETURNS: none
1068: 08       PUSH  A             (0872) ;
1069: 71 10    OR    F,16          (0873) ;  SIDE EFFECTS:
106B: 5D E0    MOV   A,REG[224]    (0874) ;    The A and X registers may be modified by this or future implementations
106D: 70 EF    AND   F,239         (0875) ;    of this function.  The same is true for all RAM page pointer registers in
106F: 21 07    AND   A,7           (0876) ;    the Large Memory Model.  When necessary, it is the calling function's
1071: 39 05    CMP   A,5           (0877) ;    responsibility to preserve their values across calls to fastcall16 
1073: D0 06    JNC   0x107A        (0878) ;    functions.
1075: FF E9    INDEX 0x1060        (0879) ;          
                                   (0880) ;    Currently only the page pointer registers listed below are modified: 
1077: 78       DEC   A             (0881) ;          CUR_PP
1078: BF FE    JNZ   0x1077        (0882) ;
                                   (0883) ;  THEORY of OPERATION or PROCEDURE:
107A: 18       POP   A             (0884) ;    REGISTERS ARE VOLATILE: THE A AND X REGISTERS MAY BE MODIFIED!
                                   (0885) ;    This initialization is a bit long, but it should work for
107B: 7F       RET                 (0886) ;    most 2 and 4 line LCDs.
                                   (0887) ;
                                   (0888)  LCD_1_Start:
                                   (0889) _LCD_1_Start:
                                   (0890)  LCD_1_Init:
                                   (0891) _LCD_1_Init:
                                   (0892)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0893)     RAM_SETPAGE_CUR >Port_2_Data_SHADE                          ; Set CUR_PP to LCD variable address
                                   (0894) 
                                   (0895)     and   [Port_2_DriveMode_0_SHADE],~LCD_1_PORT_MASK           ; Mask off LCD bits
                                   (0896)     or    [Port_2_DriveMode_0_SHADE],LCD_1_PORT_WRITE           ; Set LCD port for writing
                                   (0897)     and   [Port_2_DriveMode_1_SHADE],~LCD_1_PORT_MASK           ; Mask off LCD bits
                                   (0898) 
                                   (0899)     mov   A,[Port_2_DriveMode_0_SHADE]
                                   (0900)     M8C_SetBank1
                                   (0901)     mov   reg[LCD_1_PortMode0],A                                ; Setup LCD Port for writing
                                   (0902)     mov   A,[Port_2_DriveMode_1_SHADE]
                                   (0903)     mov   reg[LCD_1_PortMode1],A
                                   (0904)     M8C_SetBank0
                                   (0905) 
                                   (0906)     mov   A,250                             ; Delay for 12.5 mSec (250 * 50uSec)
                                   (0907)     call  LCD_1_Delay50uTimes
                                   (0908)     mov   A,250                             ; Delay for 12.5 mSec (250 * 50uSec)
                                   (0909)     call  LCD_1_Delay50uTimes
                                   (0910) 
                                   (0911)     mov   A,03h
                                   (0912)     call  LCD_1_WCNTL_Nibble
                                   (0913) 
                                   (0914)     mov   A,82                              ; Delay for 4.1 mSec (82 * 50uSec)
                                   (0915)     call  LCD_1_Delay50uTimes
                                   (0916) 
                                   (0917)     mov   A,03h
                                   (0918)     call  LCD_1_WCNTL_Nibble
                                   (0919) 
                                   (0920)     call  LCD_1_Delay50u
                                   (0921)     call  LCD_1_Delay50u
                                   (0922)     call  LCD_1_Delay50u
                                   (0923) 
                                   (0924)     mov   A,03h
                                   (0925)     call  LCD_1_WCNTL_Nibble
                                   (0926) 
                                   (0927)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0928)     call  LCD_1_Delay50uTimes
                                   (0929) 
                                   (0930)     mov   A,02h
                                   (0931)     call  LCD_1_WCNTL_Nibble
                                   (0932) 
                                   (0933)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0934)     call  LCD_1_Delay50uTimes
                                   (0935) 
                                   (0936)     mov   A,08h
                                   (0937)     call  LCD_1_Control
                                   (0938)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0939)     call  LCD_1_Delay50uTimes
                                   (0940) 
                                   (0941)     mov   A,01h
                                   (0942)     call  LCD_1_Control
                                   (0943)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0944)     call  LCD_1_Delay50uTimes
                                   (0945) 
                                   (0946)     mov   A,06h
                                   (0947)     call  LCD_1_Control
                                   (0948) 
                                   (0949)     mov   A,0Eh
                                   (0950)     call  LCD_1_Control
                                   (0951) 
                                   (0952)     mov   A,LCD_1_4BIT_2LINE                  ; Setup for 4 bit interface, 2 line
                                   (0953)     call  LCD_1_Control
                                   (0954) 
                                   (0955)     mov   A,LCD_1_DISP_OFF
                                   (0956)     call  LCD_1_Control
                                   (0957) 
                                   (0958)     mov   A,LCD_1_DISP_ON
                                   (0959)     call  LCD_1_Control
                                   (0960) 
                                   (0961)     mov   A,LCD_1_DISP_INC
                                   (0962)     call  LCD_1_Control
                                   (0963) 
                                   (0964)     mov   A,90                              ; Delay for 4.5 mSec (90 * 50uSec)
                                   (0965)     call  LCD_1_Delay50uTimes
                                   (0966)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0967)     ret
                                   (0968) .ENDSECTION
                                   (0969) 
                                   (0970) ;-----------------------------------------------------------------------------
                                   (0971) ;  FUNCTION NAME: LCD_1_Position
                                   (0972) ;
                                   (0973) ;  DESCRIPTION:
                                   (0974) ;     Position Cursor at Row and Col location
                                   (0975) ;
                                   (0976) ;-----------------------------------------------------------------------------
                                   (0977) ;
                                   (0978) ;  ARGUMENTS:
                                   (0979) ;     A => Row  0 to 3
                                   (0980) ;     X => Col  0 to 39+
                                   (0981) ;
                                   (0982) ;  RETURNS:  none
                                   (0983) ;
                                   (0984) ;  SIDE EFFECTS:
                                   (0985) ;    The A and X registers may be modified by this or future implementations
                                   (0986) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0987) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0988) ;    responsibility to preserve their values across calls to fastcall16 
                                   (0989) ;    functions.
                                   (0990) ;
                                   (0991) .LITERAL
                                   (0992) LCD_1_ROW_OFFSET::
                                   (0993)      DB    LCD_1_ROW1_OFFSET, LCD_1_ROW2_OFFSET, LCD_1_ROW3_OFFSET, LCD_1_ROW4_OFFSET
                                   (0994) .ENDLITERAL
                                   (0995) 
                                   (0996) .SECTION
                                   (0997)  LCD_1_Position:
                                   (0998) _LCD_1_Position:
                                   (0999)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1000)     and   A,03h                        ; Mask off 2 bits for row address 0 to 3
                                   (1001)     push  X                            ; Store COL
                                   (1002)     index LCD_1_ROW_OFFSET ; Get ROW memory offset from table
                                   (1003)     mov   X,SP                         ; Get Stack pointer
                                   (1004)     add   A,[X+(-1)]                   ; Add the COL to the display pointer
                                   (1005)     pop   X
                                   (1006) 
                                   (1007)     call  LCD_1_Control                ; Write control byte
                                   (1008)     RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1009)     ret
                                   (1010) .ENDSECTION
                                   (1011) 
                                   (1012) .SECTION
                                   (1013) ;-----------------------------------------------------------------------------
                                   (1014) ;  FUNCTION NAME: LCD_1_Delay50uTimes
                                   (1015) ;
107C: 4F       MOV   X,SP          (1016) ;  DESCRIPTION:
107D: 10       PUSH  X             (1017) ;     Delay increments of 50uSeconds
107E: 52 FD    MOV   A,[X-3]       (1018) ;
1080: 59 FC    MOV   X,[X-4]       (1019) ;-----------------------------------------------------------------------------
1082: 70 3F    AND   F,63
1084: 71 C0    OR    F,192         (1020) ;
1086: 9F C2    CALL  0x104A        (1021) ;  ARGUMENTS:
                                   (1022) ;     A contains the delay multiplier
1088: 20       POP   X             (1023) ;
                                   (1024) ;  RETURNS:
                                   (1025) ;
1089: 3D FA 00 CMP   [X-6],0       (1026) ;  SIDE EFFECTS:
108C: B0 05    JNZ   0x1092        (1027) ;    The A and X registers may be modified by this or future implementations
108E: 50 00    MOV   A,0           (1028) ;    of this function.  The same is true for all RAM page pointer registers in
1090: 80 11    JMP   0x10A2        (1029) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1030) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1031) ;    functions.
1092: 3D FA 06 CMP   [X-6],6       (1032) ;
1095: D0 07    JNC   0x109D        (1033) ;
1097: 52 FA    MOV   A,[X-6]       (1034)  LCD_1_Delay50uTimes:
1099: 15 FA    SUB   [X-6],A       (1035) _LCD_1_Delay50uTimes:
109B: 80 06    JMP   0x10A2        (1036)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1037)     call  LCD_1_Delay50u
                                   (1038)     dec   A
109D: 50 06    MOV   A,6           (1039)     jnz   LCD_1_Delay50uTimes
109F: 17 FA 05 SUB   [X-6],5       (1040)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1041)     ret
                                   (1042) 
10A2: 9E 6F    CALL  0x0F13        (1043) .ENDSECTION
                                   (1044) 
10A4: 7B FB    DEC   [X-5]         (1045) ;-----------------------------------------------------------------------------
10A6: BF E2    JNZ   0x1089        (1046) ;  FUNCTION NAME: LCD_1_Delay50u
10A8: 70 3F    AND   F,63
10AA: 71 C0    OR    F,192         (1047) ;
10AC: 7F       RET                 (1048) ;  DESCRIPTION:
                                   (1049) ;     Delay 50uSec for any clock frequency from 1.5MHz to 24MHz
                                   (1050) ;     Slower clock frequencies the delay will be;
                                   (1051) ;           1.5
                                   (1052) ;        -------------- * 50uSec
                                   (1053) ;        clock_freq(MHz)
                                   (1054) ;
                                   (1055) ;
                                   (1056) ;-----------------------------------------------------------------------------
                                   (1057) ;
                                   (1058) ;  ARGUMENTS: none
                                   (1059) ;
                                   (1060) ;  RETURNS: none
                                   (1061) ;
                                   (1062) ;  SIDE EFFECTS:
                                   (1063) ;    The A and X registers may be modified by this or future implementations
                                   (1064) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1065) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1066) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1067) ;    functions.
                                   (1068) ;
                                   (1069) ;  THEORY of OPERATION or PROCEDURE:
                                   (1070) ;
                                   (1071) .LITERAL
                                   (1072)  LCD_1_Delay50u_Table::
                                   (1073)      DB    08h,  19h,   3Ah,   7Ch,   01h,    01h,    01h,   01h
                                   (1074) ;         3MHz, 6MHz, 12MHz, 24MHz, 1.5MHz, 750kHz, 188kHz, 94kHz
                                   (1075) .ENDLITERAL
                                   (1076) .SECTION
                                   (1077) 
                                   (1078)   LCD_1_Delay50u:
                                   (1079)  _LCD_1_Delay50u:                      ; [11]  Call
                                   (1080)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1081)     push  A
                                   (1082)     M8C_SetBank1                         ; [4]
                                   (1083)     mov   A, reg[OSC_CR0]                ; [6] Get delay value
                                   (1084)     M8C_SetBank0                         ; [4]
                                   (1085)     and   A,07h                          ; [4] Mask off only the clock bits
                                   (1086)     cmp   A,05h
                                   (1087)     jnc   .Delay50u_End
                                   (1088)     index LCD_1_Delay50u_Table ; [13] Get delay value
                                   (1089) .Delay50u_Loop:                          ;
                                   (1090)     dec   A                              ; [4]
                                   (1091)     jnz   .Delay50u_Loop                 ; [5]
                                   (1092) .Delay50u_End:
                                   (1093)     pop   A
                                   (1094)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1095)     ret
                                   (1096) .ENDSECTION
                                   (1097) 
                                   (1098) 
                                   (1099) ;-----------------------------------------------------------------------------
                                   (1100) ;      If bargraph is not enabled, the following functions are not required.
                                   (1101) ;-----------------------------------------------------------------------------
                                   (1102) 
                                   (1103) IF (LCD_1_BARGRAPH_ENABLE)
                                   (1104) 
                                   (1105) IF SYSTEM_SMALL_MEMORY_MODEL
                                   (1106) .SECTION
                                   (1107) ;-----------------------------------------------------------------------------
                                   (1108) ;  FUNCTION NAME: LCD_1_DrawBG
                                   (1109) ;
                                   (1110) ;  DESCRIPTION:
                                   (1111) ;  This legacy fastcall version are provided only to support existing small
                                   (1112) ;  memory model assembly language code---it does not work in the large memory
                                   (1113) ;  model.
                                   (1114) ;
                                   (1115) ;  ** This legacy fastcall version is provided on a temporary basis to
                                   (1116) ;  ** ease the transition to the 4.2 release of PSoC Designer. Its use is
                                   (1117) ;  ** deprecated and its status is "No Further Maintenance". If you call this
                                   (1118) ;  ** function in assembly you should convert to _LCD_1_DrawVBG
                                   (1119) ;  ** (with a leading underscore) and the fastcall16 interface
                                   (1120) ;
                                   (1121) ;  Draw a horizontal bargraph on the LCD with the given parameters.  This
                                   (1122) ;  is a legacy function that is intended to support existing Assembly
                                   (1123) ;  language programs that call this function.  This should not be used for
                                   (1124) ;  new code or with Large Memory Model programs.
                                   (1125) ;-----------------------------------------------------------------------------
                                   (1126) ;
                                   (1127) ;  LEGACY FASTCALL ARGUMENTS:
                                   (1128) ;    A    => Starting row for bargraph 0 to 3
                                   (1129) ;   [X]   => Starting Column for bargraph 0 to 39+
                                   (1130) ;   [x-1] => Length of bargraph in chars 1 to 40+
                                   (1131) ;   [X-2] => Position of pointer in segments 5 times Length
                                   (1132) ;
                                   (1133) ;
                                   (1134) ;  RETURNS:  none
                                   (1135) ;
                                   (1136) ;  SIDE EFFECTS:
                                   (1137) ;    The A and X registers may be modified by this or future implementations
                                   (1138) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1139) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1140) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1141) ;    functions.
                                   (1142) ;
                                   (1143) ;    If LCD_1_Init is not called before this function, the
                                   (1144) ;    bargraph will not be drawn properly.
                                   (1145) ;
                                   (1146) ; Stack offset constants
                                   (1147) BG_COLX:       equ  0                   ; Stack position of Column
                                   (1148) BG_CHAR_LENX:  equ -1                   ; Stack position of Length
                                   (1149) BG_LENGTHX:    equ -2                   ; Stack position of bargraph pointer position
                                   (1150) 
                                   (1151) 
                                   (1152) LCD_1_DrawBG:
                                   (1153)     push  X
                                   (1154)     mov   X,[X+BG_COLX]                 ; Row in A, Col in X
                                   (1155)     call  LCD_1_Position               ; Set cursor position
                                   (1156)     pop   X                             ; Restore pointer
                                   (1157) 
                                   (1158) .LCD_BG_LOOP1X:
                                   (1159)     cmp   [X+BG_LENGTHX],00h            ; Check for past end of BG
                                   (1160)     jnz   .LCD_CHECK1X
                                   (1161)     mov   A,00h                         ; Load empty character
                                   (1162)     jmp   .LCD_BG_DOITX                 ;
                                   (1163) 
                                   (1164) .LCD_CHECK1X:
                                   (1165)     cmp   [X+BG_LENGTHX],06h            ; Check if BG pointer is at this character
                                   (1166)     jnc   .LCD_CHECK2X                  ; Note yet, use full character
                                   (1167)     mov   A,[X+BG_LENGTHX]
                                   (1168)     sub   [X+BG_LENGTHX],A
10AD: 4F       MOV   X,SP          (1169)     jmp   .LCD_BG_DOITX
10AE: 52 FD    MOV   A,[X-3]       (1170) 
10B0: 21 03    AND   A,3           (1171) .LCD_CHECK2X:                           ; Put index to full character
                                   (1172)     mov   A, 06h
10B2: 08       PUSH  A             (1173)     sub   [X+BG_LENGTHX],05h            ; Subtract another 5 positions
10B3: FF 91    INDEX 0x1046        (1174) 
10B5: 03 FC    ADD   A,[X-4]       (1175) .LCD_BG_DOITX:
10B7: 9E 6E    CALL  0x0F27        (1176)     call  LCD_1_WriteData              ; Display BG character
10B9: 3D FA 00 CMP   [X-6],0       (1177) 
10BC: B0 05    JNZ   0x10C2        (1178)     dec   [X+BG_CHAR_LENX]              ; Dec Char count
10BE: 50 20    MOV   A,32          (1179)     jnz   .LCD_BG_LOOP1X                ; Do it all over again
10C0: 80 13    JMP   0x10D4        (1180)     ret
                                   (1181) .ENDSECTION
10C2: 3D FA 09 CMP   [X-6],9       (1182) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
10C5: D0 09    JNC   0x10CF        (1183) 
                                   (1184) .SECTION
10C7: 52 FA    MOV   A,[X-6]       (1185) ;-----------------------------------------------------------------------------
10C9: 78       DEC   A             (1186) ;  FUNCTION NAME: LCD_1_DrawBG
10CA: 56 FA 00 MOV   [X-6],0       (1187) ;
10CD: 80 06    JMP   0x10D4        (1188) ;  DESCRIPTION:
                                   (1189) ;     Draw a horizontal bargraph on the LCD with the given parameters.
                                   (1190) ;
10CF: 17 FA 08 SUB   [X-6],8       (1191) ;
10D2: 50 07    MOV   A,7           (1192) ;-----------------------------------------------------------------------------
                                   (1193) ;
                                   (1194) ;  FASTCALL16 ARGUMENTS:
10D4: 9E 3D    CALL  0x0F13        (1195) ;   [SP-3] => Starting row for bargraph 0 to 3
10D6: 18       POP   A             (1196) ;   [SP-4] => Starting Column for bargraph 0 to 39+
10D7: 78       DEC   A             (1197) ;   [SP-5] => Length of bargraph in chars 1 to 40+
10D8: 7B FB    DEC   [X-5]         (1198) ;   [SP-6] => Position of pointer in segments 5 times Length
10DA: BF D7    JNZ   0x10B2        (1199) ;
10DC: 70 3F    AND   F,63
10DE: 71 C0    OR    F,192         (1200) ;
10E0: 7F       RET                 (1201) ;  RETURNS:  none
                                   (1202) ;
                                   (1203) ;  SIDE EFFECTS:
                                   (1204) ;    The A and X registers may be modified by this or future implementations
                                   (1205) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1206) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1207) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1208) ;    functions.
                                   (1209) ;          
                                   (1210) ;    Currently only the page pointer registers listed below are modified: 
                                   (1211) ;          CUR_PP
                                   (1212) ;
                                   (1213) ;    If LCD_1_Init is not called before this function, the
                                   (1214) ;    bargraph will not be drawn properly.
                                   (1215) ;
                                   (1216) ; Stack offset constants
                                   (1217) BG_ROW:       equ -3
                                   (1218) BG_COL:       equ -4                   ; Stack position of Column
                                   (1219) BG_CHAR_LEN:  equ -5                   ; Stack position of Length
                                   (1220) BG_LENGTH:    equ -6                   ; Stack position of bargraph pointer position
                                   (1221) 
                                   (1222) 
                                   (1223) _LCD_1_DrawBG:
                                   (1224)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1225)     mov   X, SP
                                   (1226)     push  X
                                   (1227)     mov   A,[X+BG_ROW]                 ; Row in A
                                   (1228)     mov   X,[X+BG_COL]                 ; Col in X
                                   (1229)     RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1230)     call  LCD_1_Position               ; Set cursor position
                                   (1231)     RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1232)     pop  X
                                   (1233) 
                                   (1234) .LCD_BG_LOOP1:
                                   (1235)     cmp   [X+BG_LENGTH],00h            ; Check for past end of BG
                                   (1236)     jnz   .LCD_CHECK1
                                   (1237)     mov   A,00h                        ; Load empty character
                                   (1238)     jmp   .LCD_BG_DOIT                  ;
10E1: 4F       MOV   X,SP          (1239) 
10E2: 08       PUSH  A             (1240) .LCD_CHECK1:
10E3: 08       PUSH  A             (1241)     cmp   [X+BG_LENGTH],06h            ; Check if BG pointer is at this character
                                   (1242)     jnc   .LCD_CHECK2                   ; Note yet, use full character
10E4: 50 40    MOV   A,64          (1243)     mov   A,[X+BG_LENGTH]
10E6: 9E 3F    CALL  0x0F27        (1244)     sub   [X+BG_LENGTH],A
10E8: 56 00 01 MOV   [X+0],1       (1245)     jmp   .LCD_BG_DOIT
                                   (1246) 
                                   (1247) .LCD_CHECK2:                            ; Put index to full character
10EB: 56 01 08 MOV   [X+1],8       (1248)     mov   A, 06h
                                   (1249)     sub   [X+BG_LENGTH],05h            ; Subtract another 5 positions
10EE: 52 00    MOV   A,[X+0]       (1250) 
10F0: 3B 01    CMP   A,[X+1]       (1251) .LCD_BG_DOIT:
10F2: D0 05    JNC   0x10F8        (1252)     call  LCD_1_WriteData              ; Display BG character
10F4: 50 00    MOV   A,0           (1253) 
10F6: 80 03    JMP   0x10FA        (1254)     dec   [X+BG_CHAR_LEN]              ; Dec Char count
                                   (1255)     jnz   .LCD_BG_LOOP1                 ; Do it all over again
10F8: 50 FF    MOV   A,255         (1256)     RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1257)     ret
10FA: 9E 17    CALL  0x0F13        (1258) .ENDSECTION
10FC: 7B 01    DEC   [X+1]         (1259) 
10FE: BF EF    JNZ   0x10EE        (1260) IF SYSTEM_SMALL_MEMORY_MODEL
1100: 77 00    INC   [X+0]         (1261) .SECTION
1102: 3D 00 09 CMP   [X+0],9       (1262) ;-----------------------------------------------------------------------------
1105: BF E5    JNZ   0x10EB        (1263) ;  FUNCTION NAME: LCD_1_DrawVBG
                                   (1264) ;
1107: 18       POP   A             (1265) ;  DESCRIPTION:
1108: 18       POP   A             (1266) ;  This legacy fastcall version are provided only to support existing small
1109: 50 0C    MOV   A,12          (1267) ;  memory model assembly language code---it does not work in the large memory
110B: 9E 1A    CALL  0x0F27        (1268) ;  model.
110D: 70 3F    AND   F,63
110F: 71 C0    OR    F,192         (1269) ;
1111: 7F       RET                 (1270) ;  ** This legacy fastcall version is provided on a temporary basis to
1112: 00       SWI   
1113: 10       PUSH  X
1114: 18       POP   A
1115: 1C 1E    SBB   [30],A
1117: 1F 1F 00 SBB   [X+31],0
111A: 10       PUSH  X
111B: 08       PUSH  A
111C: 04 02    ADD   [2],A
111E: 01 00    ADD   A,0
                                   (1271) ;  ** ease the transition to the 4.2 release of PSoC Designer. Its use is
                                   (1272) ;  ** deprecated and its status is "No Further Maintenance". If you call this
                                   (1273) ;  ** function in assembly you should convert to _LCD_1_DrawVBG
                                   (1274) ;  ** (with a leading underscore) and the fastcall16 interface
                                   (1275) ;
                                   (1276) ;  Draw a vertical bargraph on the LCD with the given parameters. This
                                   (1277) ;  is a legacy function that is intended to support existing Assembly
                                   (1278) ;  language programs that call this function.  This should not be used for
                                   (1279) ;  new code or with Large Memory Model programs.
                                   (1280) ;-----------------------------------------------------------------------------
                                   (1281) ;
                                   (1282) ;  LEGACY FASTCALL ARGUMENTS:
                                   (1283) ;    A    => Starting row for bargraph 0 to 3
                                   (1284) ;   [X]   => Starting Column for bargraph 0 to 40+
                                   (1285) ;   [x-1] => Height of bargraph in chars 1 - 4
                                   (1286) ;   [X-2] => Position of pointer in segments 8 times height
                                   (1287) ;  RETURNS:
                                   (1288) ;
                                   (1289) ;  SIDE EFFECTS:
                                   (1290) ;    The A and X registers may be modified by this or future implementations
                                   (1291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1293) ;    responsibility to preserve their values across calls to fastcall16 
                                   (1294) ;    functions.
                                   (1295) ;    
                                   (1296) ;    If LCD_1_Init is not called before this function, the
                                   (1297) ;    bargraph will not be drawn properly.
                                   (1298) ;
                                   (1299) ; Stack offset constants
                                   (1300) VBG_COLX:            equ  0
                                   (1301) VBG_CHAR_HEIGHTX:    equ -1
                                   (1302) VBG_SEG_HEIGHTX:     equ -2
                                   (1303) 
                                   (1304) LCD_1_DrawVBG:
                                   (1305) 
                                   (1306)     and   A,03h                        ; Make sure only rows 0 - 3 are valid
                                   (1307) .VBG_LOOPX:
                                   (1308)     push  A
                                   (1309)     index LCD_1_ROW_OFFSET  ; Get row offset
                                   (1310)     add   A,[X+VBG_COLX]                ; Add column offset to position
                                   (1311)     call  LCD_1_Control                ; Position Cursor
                                   (1312)     cmp   [X+VBG_SEG_HEIGHTX],00h       ; Check for zero segs
                                   (1313)     jnz   .VBG_NZ_SEGX
                                   (1314)     mov   A,' '                        ; Load space character
                                   (1315)     jmp   .VBG_WRITE_CHARX
                                   (1316) .VBG_NZ_SEGX:
                                   (1317)     cmp   [X+VBG_SEG_HEIGHTX],09h       ; Check for full segment
                                   (1318)     jnc   .VBG_FULL_SEGX
                                   (1319)                                         ; Partial segment between 1 and 8
1120: 4F       MOV   X,SP          (1320)     mov   A,[X+VBG_SEG_HEIGHTX]
1121: 38 03    ADD   SP,3          (1321)     dec   A
1123: 54 02    MOV   [X+2],A       (1322)     mov   [X+VBG_SEG_HEIGHTX],00h       ; Zero segment height
                                   (1323)     jmp   .VBG_WRITE_CHARX
1125: 50 40    MOV   A,64          (1324) 
1127: 9D FE    CALL  0x0F27        (1325) .VBG_FULL_SEGX:                          ; Bargaph
1129: 56 00 00 MOV   [X+0],0       (1326)     sub   [X+VBG_SEG_HEIGHTX],08h       ; Subtract full segment
                                   (1327)     mov   A,07h                        ; Load full segment
                                   (1328) 
112C: 56 01 08 MOV   [X+1],8       (1329) .VBG_WRITE_CHARX:                        ; Write character to display
                                   (1330)     call  LCD_1_WriteData              ; Write value
112F: 52 00    MOV   A,[X+0]       (1331)     pop   A
1131: 3D 02 00 CMP   [X+2],0       (1332)     dec   A
1134: B0 05    JNZ   0x113A        (1333)     dec   [X+VBG_CHAR_HEIGHTX]
1136: FF DA    INDEX 0x1112        (1334)     jnz   .VBG_LOOPX
1138: 80 03    JMP   0x113C        (1335)     ret
                                   (1336) .ENDSECTION
113A: FF DD    INDEX 0x1119        (1337) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                   (1338) 
113C: 9D D5    CALL  0x0F13        (1339) .SECTION
113E: 7B 01    DEC   [X+1]         (1340) ;-----------------------------------------------------------------------------
1140: BF EE    JNZ   0x112F        (1341) ;  FUNCTION NAME: LCD_1_DrawVBG
1142: 77 00    INC   [X+0]         (1342) ;
1144: 3D 00 07 CMP   [X+0],7       (1343) ;  DESCRIPTION:
1147: BF E4    JNZ   0x112C        (1344) ;     Draw a vertical bargraph on the LCD with the given parameters.
                                   (1345) ;
1149: 38 FD    ADD   SP,253        (1346) ;
114B: 50 0C    MOV   A,12          (1347) ;-----------------------------------------------------------------------------
114D: 9D D8    CALL  0x0F27        (1348) ;
114F: 70 3F    AND   F,63
1151: 71 C0    OR    F,192         (1349) ;  FASTCALL16 ARGUMENTS:
1154: 7E       RETI                (1350) ;

FILE: lib\comp_serialint.asm
                                   (0102) ;;*****************************************************************************
                                   (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME:   COMP_SERIALINT.asm
                                   (0105) ;;  Version: 5.2, Updated on 2009/7/10 at 10:46:57
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION:  UART Interrupt Service Routine.
                                   (0109) ;;-----------------------------------------------------------------------------
                                   (0110) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0111) ;;*****************************************************************************
                                   (0112) ;;*****************************************************************************
                                   (0113) 
                                   (0114) 
                                   (0115) include "COMP_SERIAL.inc"
                                   (0116) include "memory.inc"
                                   (0117) include "m8c.inc"
                                   (0118) 
                                   (0119) ;-----------------------------------------------
                                   (0120) ;  Global Symbols
                                   (0121) ;-----------------------------------------------
                                   (0122) export  _COMP_SERIAL_TX_ISR
                                   (0123) export  _COMP_SERIAL_RX_ISR
                                   (0124) 
                                   (0125) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0126) export  COMP_SERIAL_aRxBuffer
                                   (0127) export _COMP_SERIAL_aRxBuffer
                                   (0128) export  COMP_SERIAL_bRxCnt
                                   (0129) export _COMP_SERIAL_bRxCnt
                                   (0130) export  COMP_SERIAL_fStatus
                                   (0131) export _COMP_SERIAL_fStatus
                                   (0132) ENDIF
                                   (0133) 
                                   (0134) 
                                   (0135) ;-----------------------------------------------
                                   (0136) ; Variable Allocation
                                   (0137) ;-----------------------------------------------
                                   (0138) AREA InterruptRAM (RAM, REL, CON)
                                   (0139) 
                                   (0140) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0141)  COMP_SERIAL_fStatus:
                                   (0142) _COMP_SERIAL_fStatus:      BLK  1
                                   (0143)  COMP_SERIAL_bRxCnt:
                                   (0144) _COMP_SERIAL_bRxCnt:       BLK  1
                                   (0145) AREA COMP_SERIAL_RAM (RAM, REL, CON)
                                   (0146)  COMP_SERIAL_aRxBuffer:
                                   (0147) _COMP_SERIAL_aRxBuffer:    BLK COMP_SERIAL_RX_BUFFER_SIZE
                                   (0148) ENDIF
                                   (0149) 
                                   (0150) AREA InterruptRAM (RAM, REL, CON)
                                   (0151) 
1155: 08       PUSH  A             (0152) ;@PSoC_UserCode_INIT@ (Do not change this line.)
1156: 10       PUSH  X             (0153) ;---------------------------------------------------
1157: 5D D3    MOV   A,REG[211]
                                   (0154) ; Insert your custom declarations below this banner
                                   (0155) ;---------------------------------------------------
1159: 08       PUSH  A             (0156) 
                                   (0157) ;------------------------
                                   (0158) ;  Includes
115A: 58 07    MOV   X,[7]         (0159) ;------------------------
115C: 5D 3F    MOV   A,REG[63]     (0160) 
115E: 08       PUSH  A             (0161) 
                                   (0162) ;------------------------
115F: 21 08    AND   A,8           (0163) ;  Constant Definitions
1161: B0 04    JNZ   0x1166        (0164) ;------------------------
1163: 18       POP   A             (0165) 
1164: 80 5E    JMP   0x11C3        (0166) 
                                   (0167) ;------------------------
                                   (0168) ; Variable Allocation
1166: 18       POP   A             (0169) ;------------------------
                                   (0170) 
                                   (0171) 
1167: 21 E0    AND   A,224         (0172) ;---------------------------------------------------
1169: A0 12    JZ    0x117C        (0173) ; Insert your custom declarations above this banner
                                   (0174) ;---------------------------------------------------
116B: 2C 06    OR    [6],A         (0175) ;@PSoC_UserCode_END@ (Do not change this line.)
116D: 49 3E 00 TST   REG[62],0     (0176) 
1170: 21 20    AND   A,32          (0177) 
1172: A0 50    JZ    0x11C3        (0178) AREA UserModules (ROM, REL, CON)
                                   (0179) 
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: _COMP_SERIAL_TX_ISR
1174: 41 3F FE AND   REG[63],254   (0182) ;
1177: 43 3F 01 OR    REG[63],1     (0183) ;  DESCRIPTION:
117A: 80 48    JMP   0x11C3        (0184) ;     UART TX interrupt handler for instance COMP_SERIAL.
                                   (0185) ;
                                   (0186) ;     This is a place holder function.  If the user requires use of an interrupt
                                   (0187) ;     handler for this function, then place code where specified.
117C: 5D 3E    MOV   A,REG[62]     (0188) ;-----------------------------------------------------------------------------
                                   (0189) 
                                   (0190) _COMP_SERIAL_TX_ISR:
117E: 47 06 01 TST   [6],1         (0191)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
1181: B0 41    JNZ   0x11C3        (0192)    ;---------------------------------------------------
                                   (0193)    ; Insert your custom code below this banner
1183: 39 3B    CMP   A,59          (0194)    ;---------------------------------------------------
1185: B0 14    JNZ   0x119A        (0195)    ;   NOTE: interrupt service routines must preserve
1187: 2E 06 01 OR    [6],1         (0196)    ;   the values of the A and X CPU registers.
                                   (0197)    
                                   (0198)    ;---------------------------------------------------
                                   (0199)    ; Insert your custom code above this banner
118A: 62 D3 00 MOV   REG[211],0    (0200)    ;---------------------------------------------------
118D: 70 3F    AND   F,63
118F: 71 80    OR    F,128         (0201)    ;@PSoC_UserCode_END@ (Do not change this line.)
1191: 56 08 00 MOV   [X+8],0       (0202)    reti
1194: 70 3F    AND   F,63
1196: 71 00    OR    F,0           (0203) 
1198: 80 2A    JMP   0x11C3        (0204) 
                                   (0205) ;-----------------------------------------------------------------------------
                                   (0206) ;  FUNCTION NAME: _COMP_SERIAL_RX_ISR
                                   (0207) ;
                                   (0208) ;  DESCRIPTION:
                                   (0209) ;     UART RX interrupt handler for instance COMP_SERIAL.
                                   (0210) ;     This ISR handles the background processing of received characters if
                                   (0211) ;     the buffer is enabled.
                                   (0212) ;
                                   (0213) ;
                                   (0214) ;  The following assumes that the RX buffer feature has been enabled.
                                   (0215) ;
                                   (0216) ;  SIDE EFFECTS:
                                   (0217) ;     There are 3 posible errors that may occur with the serial port.
119A: 39 20    CMP   A,32          (0218) ;      1) Parity Error
119C: C0 26    JC    0x11C3        (0219) ;      2) Framing Error
                                   (0220) ;      3) OverRun Error
                                   (0221) ;
                                   (0222) ;  This user module check for parity and framing error.  If either of these
                                   (0223) ;  two errors are detected, the data is read and ignored.  When an overRun
119E: 62 D3 00 MOV   REG[211],0    (0224) ;  error occurs, the last byte was lost, but the current byte is valid.  For
11A1: 3C 07 3F CMP   [7],63        (0225) ;  this reason this error is ignored at this time.  Code could be added to
11A4: C0 11    JC    0x11B6        (0226) ;  this ISR to set a flag if an error condition occurs.
11A6: 70 3F    AND   F,63
11A8: 71 80    OR    F,128         (0227) ;
11AA: 56 08 00 MOV   [X+8],0       (0228) ;  THEORY of OPERATION:
11AD: 70 3F    AND   F,63
11AF: 71 00    OR    F,0           (0229) ;     When using the RX buffer feature, the ISR collects received characters
11B1: 2E 06 10 OR    [6],16        (0230) ;     in a buffer until the user defined command terminator is detected.  After
11B4: 80 0E    JMP   0x11C3        (0231) ;     the command terminator is detected, the command bit is set and all other
11B6: 70 3F    AND   F,63
                                   (0232) ;     characters will be ignored until the command bit is reset.  Up to
                                   (0233) ;     buffer_size - 1 characters will be collected waiting for a command
                                   (0234) ;     terminator.  After that, the characters will be discarded, although
11B8: 71 80    OR    F,128         (0235) ;     a command determinator will still cause the command bit to be set.
11BA: 54 08    MOV   [X+8],A       (0236) ;
11BC: 70 3F    AND   F,63
11BE: 71 00    OR    F,0           (0237) ;-----------------------------------------------------------------------------
11C0: 75       INC   X             (0238) _COMP_SERIAL_RX_ISR:
11C1: 5A 07    MOV   [7],X         (0239) 
11C3: 18       POP   A
                                   (0240)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                   (0241)    ;---------------------------------------------------
                                   (0242)    ; Insert your custom code below this banner
11C4: 60 D3    MOV   REG[211],A    (0243)    ;---------------------------------------------------
                                   (0244)    ;   NOTE: interrupt service routines must preserve
                                   (0245)    ;   the values of the A and X CPU registers.
                                   (0246) 
11C6: 20       POP   X             (0247)    ;---------------------------------------------------
11C7: 18       POP   A             (0248)    ; Insert your custom code above this banner
                                   (0249)    ;---------------------------------------------------
                                   (0250)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0251) 
                                   (0252) IF (COMP_SERIAL_RXBUF_ENABLE)
11C9: 43 E1 40 OR    REG[225],64   (0253)    push A

FILE: lib\comp_serial.asm
11CC: 43 E1 80 OR    REG[225],128  (0180) ;;*****************************************************************************
                                   (0181) ;;*****************************************************************************
11CF: 7F       RET                 (0182) ;;  Filename:   COMP_SERIAL.asm
                                   (0183) ;;  Version: 5.2, Updated on 2009/7/10 at 10:46:57
                                   (0184) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0185) ;;
                                   (0186) ;;  DESCRIPTION:  UART User Module software implementation file for the
                                   (0187) ;;                22/24/25/26/27xxx families.
                                   (0188) ;;
                                   (0189) ;;
                                   (0190) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0191) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0192) ;;        This means it is the caller's responsibility to preserve any values
                                   (0193) ;;        in the X and A registers that are still needed after the API functions
                                   (0194) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0195) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0196) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0197) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0198) ;;-----------------------------------------------------------------------------
                                   (0199) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0200) ;;*****************************************************************************
                                   (0201) ;;*****************************************************************************
                                   (0202) 
                                   (0203) 
                                   (0204) include "m8c.inc"
                                   (0205) include "memory.inc"
                                   (0206) include "COMP_SERIAL.inc"
                                   (0207) 
                                   (0208) ;-----------------------------------------------
                                   (0209) ;  Global Symbols
                                   (0210) ;-----------------------------------------------
11D0: 41 E1 BF AND   REG[225],191  (0211) ;-------------------------------------------------------------------
11D3: 41 E1 7F AND   REG[225],127  (0212) ;  Declare the functions global for both assembler and C compiler.
                                   (0213) ;
11D6: 7F       RET                 (0214) ;  Note that there are two names for each API. First name is
                                   (0215) ;  assembler reference. Name with underscore is name refence for
                                   (0216) ;  C compiler.  Calling function in C source code does not require
                                   (0217) ;  the underscore.
                                   (0218) ;-------------------------------------------------------------------
                                   (0219) export  COMP_SERIAL_SetTxIntMode
                                   (0220) export _COMP_SERIAL_SetTxIntMode
                                   (0221) export  COMP_SERIAL_EnableInt
                                   (0222) export _COMP_SERIAL_EnableInt
                                   (0223) export  COMP_SERIAL_DisableInt
                                   (0224) export _COMP_SERIAL_DisableInt
                                   (0225) 
                                   (0226) export  COMP_SERIAL_Start
                                   (0227) export _COMP_SERIAL_Start
                                   (0228) export  COMP_SERIAL_Stop
                                   (0229) export _COMP_SERIAL_Stop
                                   (0230) export  COMP_SERIAL_SendData
                                   (0231) export _COMP_SERIAL_SendData
                                   (0232) export  COMP_SERIAL_bReadTxStatus
                                   (0233) export _COMP_SERIAL_bReadTxStatus
                                   (0234) export  COMP_SERIAL_bReadRxData
                                   (0235) export _COMP_SERIAL_bReadRxData
                                   (0236) export  COMP_SERIAL_bReadRxStatus
                                   (0237) export _COMP_SERIAL_bReadRxStatus
                                   (0238) 
                                   (0239) export  COMP_SERIAL_IntCntl
                                   (0240) export _COMP_SERIAL_IntCntl
                                   (0241) 
                                   (0242) export  COMP_SERIAL_TxIntMode
                                   (0243) export _COMP_SERIAL_TxIntMode
                                   (0244) 
                                   (0245) export  COMP_SERIAL_PutSHexByte
                                   (0246) export _COMP_SERIAL_PutSHexByte
11D7: 71 10    OR    F,16          (0247) export  COMP_SERIAL_PutSHexInt
11D9: 21 01    AND   A,1           (0248) export _COMP_SERIAL_PutSHexInt
11DB: A0 07    JZ    0x11E3        (0249) 
11DD: 43 38 10 OR    REG[56],16    (0250) export  COMP_SERIAL_CPutString
11E0: 70 EF    AND   F,239         (0251) export _COMP_SERIAL_CPutString
                                   (0252) export  COMP_SERIAL_PutString
11E2: 7F       RET                 (0253) export _COMP_SERIAL_PutString
                                   (0254) export  COMP_SERIAL_PutChar
                                   (0255) export _COMP_SERIAL_PutChar
11E3: 41 38 EF AND   REG[56],239   (0256) export  COMP_SERIAL_Write
11E6: 70 EF    AND   F,239         (0257) export _COMP_SERIAL_Write
                                   (0258) export  COMP_SERIAL_CWrite
11E8: 7F       RET                 (0259) export _COMP_SERIAL_CWrite
                                   (0260) 
                                   (0261) export  COMP_SERIAL_cGetChar
                                   (0262) export _COMP_SERIAL_cGetChar
                                   (0263) export  COMP_SERIAL_cReadChar
                                   (0264) export _COMP_SERIAL_cReadChar
                                   (0265) export  COMP_SERIAL_iReadChar
                                   (0266) export _COMP_SERIAL_iReadChar
                                   (0267) export  COMP_SERIAL_PutCRLF
                                   (0268) export _COMP_SERIAL_PutCRLF
                                   (0269) 
                                   (0270) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0271) export  COMP_SERIAL_CmdReset
                                   (0272) export _COMP_SERIAL_CmdReset
                                   (0273) export  COMP_SERIAL_bCmdCheck
                                   (0274) export _COMP_SERIAL_bCmdCheck
                                   (0275) export  COMP_SERIAL_bCmdLength
                                   (0276) export _COMP_SERIAL_bCmdLength
                                   (0277) export  COMP_SERIAL_bErrCheck
                                   (0278) export _COMP_SERIAL_bErrCheck
                                   (0279) 
                                   (0280) export  COMP_SERIAL_szGetParam
                                   (0281) export _COMP_SERIAL_szGetParam
                                   (0282) export  COMP_SERIAL_szGetRestOfParams
                                   (0283) export _COMP_SERIAL_szGetRestOfParams
                                   (0284) ENDIF
                                   (0285) 
                                   (0286) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0287) ; WARNING WARNING WARNING
                                   (0288) ; The following exports are for backwards compatibility only and should
                                   (0289) ; not be used for new designs. They may be eliminated in a future release.
11E9: 29 01    OR    A,1           (0290) ; Their status is "NO FURTHER MAINTENANCE". 
11EB: 60 3B    MOV   REG[59],A     (0291) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
11ED: 60 3F    MOV   REG[63],A     (0292) export  bCOMP_SERIAL_ReadTxStatus
                                   (0293) export _bCOMP_SERIAL_ReadTxStatus
11EF: 91 2A    CALL  0x131B        (0294) export  bCOMP_SERIAL_ReadRxData
                                   (0295) export _bCOMP_SERIAL_ReadRxData
                                   (0296) export  bCOMP_SERIAL_ReadRxStatus
11F1: 7F       RET                 (0297) export _bCOMP_SERIAL_ReadRxStatus
                                   (0298) 	
                                   (0299) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0300) ;             END WARNING
                                   (0301) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0302) 
                                   (0303) ;-----------------------------------------------
                                   (0304) ; Variable Allocation
                                   (0305) ;-----------------------------------------------
                                   (0306) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0307)     
                                   (0308) area COMP_SERIAL_RAM (RAM, REL, CON)
                                   (0309)     
                                   (0310)  ptrParam:   BLK  1
                                   (0311) 
                                   (0312) ENDIF
                                   (0313) 
                                   (0314) area text (ROM,REL)
                                   (0315) 
                                   (0316) ;-----------------------------------------------
                                   (0317) ;  EQUATES
                                   (0318) ;-----------------------------------------------
                                   (0319) bfCONTROL_REG_START_BIT:        equ    1    ; Control register start bit
                                   (0320) bfFUNCTION_REG_TX_INT_MODE_BIT: equ 0x10    ; the TX Int Mode bit
                                   (0321) 
                                   (0322) area UserModules (ROM, REL, CON)
                                   (0323) 
                                   (0324) ;=============================================================================
11F2: 41 3B FE AND   REG[59],254   (0325) ;=============================================================================
11F5: 41 3F FE AND   REG[63],254   (0326) ;
                                   (0327) ;     Low-Level Commands
11F8: 7F       RET                 (0328) ;
                                   (0329) ;=============================================================================
                                   (0330) ;=============================================================================
                                   (0331) 
                                   (0332) .SECTION
                                   (0333) ;-----------------------------------------------------------------------------
                                   (0334) ;  FUNCTION NAME: COMP_SERIAL_EnableInt
                                   (0335) ;
                                   (0336) ;  DESCRIPTION:
                                   (0337) ;     Enables this UART's interrupt by setting the interrupt enable mask
                                   (0338) ;     bit associated with this User Module. Remember to call the global
                                   (0339) ;     interrupt enable function by using the macro: M8C_EnableGInt.
                                   (0340) ;-----------------------------------------------------------------------------
                                   (0341) ;
                                   (0342) ;  ARGUMENTS:
                                   (0343) ;     none.
                                   (0344) ;
                                   (0345) ;  RETURNS:
                                   (0346) ;     none.
                                   (0347) ;
                                   (0348) ;  SIDE EFFECTS:
                                   (0349) ;    The A and X registers may be modified by this or future implementations
                                   (0350) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
                                   (0354) ;
                                   (0355)  COMP_SERIAL_EnableInt:
11F9: 60 39    MOV   REG[57],A     (0356) _COMP_SERIAL_EnableInt:
                                   (0357)    RAM_PROLOGUE RAM_USE_CLASS_1
11FB: 7F       RET                 (0358)    M8C_EnableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0359)    M8C_EnableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
                                   (0360)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0361)    ret
                                   (0362) .ENDSECTION
                                   (0363) 
                                   (0364)     
                                   (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: COMP_SERIAL_DisableInt
                                   (0368) ;
                                   (0369) ;  DESCRIPTION:
                                   (0370) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
                                   (0371) ;     associated with this User Module.
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:
                                   (0375) ;     none.
                                   (0376) ;
                                   (0377) ;  RETURNS:
                                   (0378) ;     none.
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  COMP_SERIAL_DisableInt:
                                   (0388) _COMP_SERIAL_DisableInt:
11FC: 5D 3B    MOV   A,REG[59]     (0389)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0390)    M8C_DisableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
11FE: 7F       RET                 (0391)    M8C_DisableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
                                   (0392)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0393)    ret
                                   (0394) .ENDSECTION
                                   (0395) 
                                   (0396) 
                                   (0397) .SECTION
                                   (0398) ;-----------------------------------------------------------------------------
                                   (0399) ;  FUNCTION NAME: COMP_SERIAL_SetTxIntMode(BYTE bTxIntMode)
                                   (0400) ;
                                   (0401) ;  DESCRIPTION:
                                   (0402) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0403) ;-----------------------------------------------------------------------------
                                   (0404) ;
                                   (0405) ;  ARGUMENTS:
                                   (0406) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0407) ;        Passed in the A register
                                   (0408) ;
                                   (0409) ;  RETURNS:
                                   (0410) ;     none.
                                   (0411) ;
                                   (0412) ;  SIDE EFFECTS:
                                   (0413) ;    The A and X registers may be modified by this or future implementations
                                   (0414) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0415) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0416) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0417) ;    functions.
                                   (0418) ;
                                   (0419) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0420) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0421) ;     on TX register empty or TX transmit complete
11FF: 5D 3E    MOV   A,REG[62]     (0422) ;
                                   (0423)  COMP_SERIAL_SetTxIntMode:
1201: 7F       RET                 (0424) _COMP_SERIAL_SetTxIntMode:
                                   (0425)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0426)    M8C_SetBank1
                                   (0427)    and   A, COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0428)    jz    .SetModeRegEmpty
                                   (0429)    or    REG[COMP_SERIAL_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0430)    M8C_SetBank0
                                   (0431)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0432)    ret
                                   (0433) 
                                   (0434) .SetModeRegEmpty:
                                   (0435)    and   REG[COMP_SERIAL_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0436)    M8C_SetBank0
                                   (0437)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0438)    ret
                                   (0439) .ENDSECTION
                                   (0440) 
                                   (0441) 
                                   (0442) .SECTION
                                   (0443) ;-----------------------------------------------------------------------------
                                   (0444) ;  FUNCTION NAME: COMP_SERIAL_Start(BYTE bParity)
                                   (0445) ;
                                   (0446) ;  DESCRIPTION:
                                   (0447) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0448) ;-----------------------------------------------------------------------------
                                   (0449) ;
                                   (0450) ;  ARGUMENTS:
                                   (0451) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
                                   (0452) ;        Passed in the A register.
                                   (0453) ;
                                   (0454) ;  RETURNS:
                                   (0455) ;     none.
1202: 5D 3F    MOV   A,REG[63]     (0456) ;
                                   (0457) ;  SIDE EFFECTS:
1204: 7F       RET                 (0458) ;    The A and X registers may be modified by this or future implementations
                                   (0459) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0460) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0461) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0462) ;    functions.
                                   (0463) ;
                                   (0464)  COMP_SERIAL_Start:
                                   (0465) _COMP_SERIAL_Start:
                                   (0466)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0467)    ; Note, Proxy Class 4 only if receive buffer used; otherwise Proxy Class 1.
                                   (0468) 
                                   (0469)    or    A, bfCONTROL_REG_START_BIT
                                   (0470)    mov   REG[COMP_SERIAL_TX_CONTROL_REG], A
                                   (0471)    mov   REG[COMP_SERIAL_RX_CONTROL_REG], A
                                   (0472) IF ( COMP_SERIAL_RXBUF_ENABLE )
                                   (0473)    call  _COMP_SERIAL_CmdReset
                                   (0474) ENDIF
                                   (0475)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0476)    ret
                                   (0477) .ENDSECTION
                                   (0478) 
                                   (0479) 
                                   (0480) .SECTION
                                   (0481) ;-----------------------------------------------------------------------------
                                   (0482) ;  FUNCTION NAME: COMP_SERIAL_Stop
                                   (0483) ;
                                   (0484) ;  DESCRIPTION:
                                   (0485) ;     Disables UART operation.
                                   (0486) ;-----------------------------------------------------------------------------
                                   (0487) ;
                                   (0488) ;  ARGUMENTS:
1205: 21 01    AND   A,1           (0489) ;     none.
1207: 71 10    OR    F,16          (0490) ;
1209: 39 01    CMP   A,1           (0491) ;  RETURNS:
120B: A0 06    JZ    0x1212        (0492) ;     none.
                                   (0493) ;
120D: 41 38 EF AND   REG[56],239   (0494) ;  SIDE EFFECTS:
1210: 80 04    JMP   0x1215        (0495) ;    The A and X registers may be modified by this or future implementations
                                   (0496) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0497) ;    the Large Memory Model.  When necessary, it is the calling function's
1212: 43 38 10 OR    REG[56],16    (0498) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0499) ;    functions.
                                   (0500) ;
1215: 70 EF    AND   F,239         (0501)  COMP_SERIAL_Stop:
                                   (0502) _COMP_SERIAL_Stop:
1217: 7F       RET                 (0503)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0504)    and   REG[COMP_SERIAL_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0505)    and   REG[COMP_SERIAL_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0506)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0507)    ret
                                   (0508) .ENDSECTION
                                   (0509) 
                                   (0510) 
                                   (0511) .SECTION
                                   (0512) ;-----------------------------------------------------------------------------
                                   (0513) ;  FUNCTION NAME: COMP_SERIAL_SendData
                                   (0514) ;
                                   (0515) ;  DESCRIPTION:
                                   (0516) ;     Initiates a transmission of data.
                                   (0517) ;-----------------------------------------------------------------------------
                                   (0518) ;
                                   (0519) ;  ARGUMENTS:
                                   (0520) ;     BYTE  TxData - data to transmit. PASSED in A register.
                                   (0521) ;
                                   (0522) ;  RETURNS:
                                   (0523) ;     none.
                                   (0524) ;
                                   (0525) ;  SIDE EFFECTS:
                                   (0526) ;    The A and X registers may be modified by this or future implementations
                                   (0527) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0528) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0529) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0530) ;    functions.
                                   (0531) ;
                                   (0532)  COMP_SERIAL_SendData:
                                   (0533) _COMP_SERIAL_SendData:
                                   (0534)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0535)    mov REG[COMP_SERIAL_TX_BUFFER_REG], A
1218: 08       PUSH  A             (0536)    RAM_EPILOGUE RAM_USE_CLASS_1
1219: 21 01    AND   A,1           (0537)    ret
121B: A0 06    JZ    0x1222        (0538) .ENDSECTION
                                   (0539) 
121D: 43 E1 80 OR    REG[225],128  (0540) 
1220: 80 04    JMP   0x1225        (0541) .SECTION
                                   (0542) ;-----------------------------------------------------------------------------
                                   (0543) ;  FUNCTION NAME: COMP_SERIAL_bReadTxStatus
1222: 41 E1 7F AND   REG[225],127  (0544) ;
                                   (0545) ;  DESCRIPTION:
                                   (0546) ;     Reads the Tx Status bits in the Control/Status register.
1225: 18       POP   A             (0547) ;-----------------------------------------------------------------------------
1226: 21 02    AND   A,2           (0548) ;
1228: A0 06    JZ    0x122F        (0549) ;  ARGUMENTS:
                                   (0550) ;     none.
122A: 43 E1 40 OR    REG[225],64   (0551) ;
122D: 80 04    JMP   0x1232        (0552) ;  RETURNS:
                                   (0553) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
                                   (0554) ;           status bits (returned in A)
122F: 41 E1 BF AND   REG[225],191  (0555) ;
                                   (0556) ;  SIDE EFFECTS:
                                   (0557) ;    The A and X registers may be modified by this or future implementations
                                   (0558) ;    of this function.  The same is true for all RAM page pointer registers in
1232: 7F       RET                 (0559) ;    the Large Memory Model.  When necessary, it is the calling function's
1233: 30       HALT  
1234: 31 32    XOR   A,50
1236: 33 34    XOR   A,[X+52]
1238: 35 36    XOR   [X+54],A
123A: 37 38 39 XOR   [X+56],57
123D: 41 42 43 AND   REG[66],67
1240: 44 45 46 OR    REG[X+69],70
                                   (0560) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0561) ;    functions.
                                   (0562) ;
                                   (0563)  COMP_SERIAL_bReadTxStatus:
                                   (0564) _COMP_SERIAL_bReadTxStatus:
                                   (0565)  bCOMP_SERIAL_ReadTxStatus:                      ; For backwards compatibility only
                                   (0566) _bCOMP_SERIAL_ReadTxStatus:                      ; For backwards compatibility only
                                   (0567)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0568)    mov A,  REG[COMP_SERIAL_TX_CONTROL_REG]
                                   (0569)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0570)    ret
                                   (0571) .ENDSECTION
                                   (0572) 
                                   (0573) 
                                   (0574) .SECTION
                                   (0575) ;-----------------------------------------------------------------------------
                                   (0576) ;  FUNCTION NAME: COMP_SERIAL_bReadRxData
                                   (0577) ;
                                   (0578) ;  DESCRIPTION:
                                   (0579) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0580) ;     sure data is valid.
                                   (0581) ;-----------------------------------------------------------------------------
                                   (0582) ;
                                   (0583) ;  ARGUMENTS:
                                   (0584) ;     none.
                                   (0585) ;
                                   (0586) ;  RETURNS:
                                   (0587) ;     bRxData - returned in A.
                                   (0588) ;
                                   (0589) ;  SIDE EFFECTS:
                                   (0590) ;    The A and X registers may be modified by this or future implementations
                                   (0591) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0592) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0593) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0594) ;    functions.
                                   (0595) ;
                                   (0596)  COMP_SERIAL_bReadRxData:
                                   (0597) _COMP_SERIAL_bReadRxData:
                                   (0598)  bCOMP_SERIAL_ReadRxData:                        ; For backwards compatibility only
                                   (0599) _bCOMP_SERIAL_ReadRxData:                        ; For backwards compatibility only
                                   (0600)    RAM_PROLOGUE RAM_USE_CLASS_1
1243: 08       PUSH  A             (0601)    mov A, REG[COMP_SERIAL_RX_BUFFER_REG]
1244: 67       ASR   A             (0602)    RAM_EPILOGUE RAM_USE_CLASS_1
1245: 67       ASR   A             (0603)    ret
1246: 67       ASR   A             (0604) .ENDSECTION
1247: 67       ASR   A             (0605) 
1248: 21 0F    AND   A,15          (0606) 
124A: FF E7    INDEX 0x1233        (0607) .SECTION
124C: 90 0F    CALL  0x125D        (0608) ;-----------------------------------------------------------------------------
124E: 18       POP   A             (0609) ;  FUNCTION NAME: COMP_SERIAL_bReadRxStatus
124F: 21 0F    AND   A,15          (0610) ;
1251: FF E0    INDEX 0x1233        (0611) ;  DESCRIPTION:
1253: 90 08    CALL  0x125D        (0612) ;     Reads the RX Status bits in the Control/Status register.
                                   (0613) ;-----------------------------------------------------------------------------
1255: 7F       RET                 (0614) ;
                                   (0615) ;  ARGUMENTS:
                                   (0616) ;     none.
                                   (0617) ;
                                   (0618) ;  RETURNS:
                                   (0619) ;     BYTE  bRXStatus - receive status data.  Use the following defined bits
                                   (0620) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0621) ;           returned in A.
                                   (0622) ;
                                   (0623) ;  SIDE EFFECTS:
                                   (0624) ;    The A and X registers may be modified by this or future implementations
                                   (0625) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0626) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0627) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0628) ;    functions.
                                   (0629) ;
                                   (0630)  COMP_SERIAL_bReadRxStatus:
                                   (0631) _COMP_SERIAL_bReadRxStatus:
                                   (0632)  bCOMP_SERIAL_ReadRxStatus:                      ; For backwards compatibility only
                                   (0633) _bCOMP_SERIAL_ReadRxStatus:                      ; For backwards compatibility only
                                   (0634)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0635)    mov A,  REG[COMP_SERIAL_RX_CONTROL_REG]
                                   (0636)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0637)    ret
                                   (0638) .ENDSECTION
                                   (0639) 
                                   (0640) 
                                   (0641) .SECTION
                                   (0642) ;-----------------------------------------------------------------------------
                                   (0643) ;  FUNCTION NAME: COMP_SERIAL_TxIntMode
                                   (0644) ;
1256: 4B       SWAP  A,X           (0645) ;  DESCRIPTION:
1257: 9F EA    CALL  0x1243        (0646) ;     This function is used to change the TX Interrupt mode.
1259: 5B       MOV   A,X           (0647) ;-----------------------------------------------------------------------------
125A: 9F E7    CALL  0x1243        (0648) ;
                                   (0649) ;  ARGUMENTS:
125C: 7F       RET                 (0650) ;     A => Tx Interrupt mode
125D: 49 3B 10 TST   REG[59],16
                                   (0651) ;             0 => Interrupt on TX_Reg_Empty  (Default)
                                   (0652) ;             1 => Interrupt on TX Complete
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none.
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
                                   (0663) ;
                                   (0664)  COMP_SERIAL_TxIntMode:
                                   (0665) _COMP_SERIAL_TxIntMode:
                                   (0666)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0667) 
                                   (0668)    and  A,COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0669)    M8C_SetBank1
                                   (0670)    cmp  A,COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0671)    jz   .SetTxCmpMode
                                   (0672) 
                                   (0673)    and  reg[COMP_SERIAL_TX_FUNC_REG],0xEF        ; Set Interrupt on Tx_Reg_Empty
                                   (0674)    jmp  .TxIntMode_End
                                   (0675) 
                                   (0676) .SetTxCmpMode:                                       ; Set Interrupt on TX Complete
                                   (0677)    or   reg[COMP_SERIAL_TX_FUNC_REG],0x10
                                   (0678) 
                                   (0679) .TxIntMode_End:
                                   (0680)    M8C_SetBank0
                                   (0681)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0682)    ret
                                   (0683) .ENDSECTION
                                   (0684) 
                                   (0685)     
1260: AF FC    JZ    0x125D        (0686) .SECTION
1262: 60 39    MOV   REG[57],A
                                   (0687) ;-----------------------------------------------------------------------------
1264: 7F       RET                 (0688) ;  FUNCTION NAME: COMP_SERIAL_IntCntl
                                   (0689) ;
                                   (0690) ;  DESCRIPTION:
                                   (0691) ;     This function is used to enable/disable the Rx and Tx interrupt.
                                   (0692) ;-----------------------------------------------------------------------------
                                   (0693) ;
                                   (0694) ;  ARGUMENTS:
                                   (0695) ;     A => Interrupt mask
                                   (0696) ;
                                   (0697) ;  RETURNS:
                                   (0698) ;     none.
                                   (0699) ;
                                   (0700) ;  SIDE EFFECTS:
                                   (0701) ;    The A and X registers may be modified by this or future implementations
                                   (0702) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0703) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0704) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0705) ;    functions.
                                   (0706) ;
                                   (0707) ;  THEORY of OPERATION or PROCEDURE:
                                   (0708) ;     Set or Clears the Tx/Rx user module interrupt enable mask bit in the TX
                                   (0709) ;     and RX block.
                                   (0710) ;
                                   (0711)  COMP_SERIAL_IntCntl:
                                   (0712) _COMP_SERIAL_IntCntl:
                                   (0713)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0714) 
                                   (0715)    push A
                                   (0716)    and  A,COMP_SERIAL_ENABLE_RX_INT
                                   (0717)    jz   .DisRxInt
                                   (0718)      ; Enable Rx Interrupt
                                   (0719)    M8C_EnableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
1265: 49 3F 08 TST   REG[63],8     (0720)    jmp  .CheckTxInt
1268: AF FC    JZ    0x1265        (0721) .DisRxInt:
126A: 5D 3E    MOV   A,REG[62]     (0722)      ; Disable Rx Interrupt
                                   (0723)    M8C_DisableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
126C: 7F       RET                 (0724) 
                                   (0725) .CheckTxInt:
                                   (0726)    pop  A
                                   (0727)    and  A,COMP_SERIAL_ENABLE_TX_INT
                                   (0728)    jz   .DisTxInt
                                   (0729)      ; Enable Tx Interrupt
                                   (0730)    M8C_EnableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0731)    jmp  .End_IntCntl
                                   (0732) .DisTxInt:
                                   (0733)      ; Disable Tx Interrupt
                                   (0734)    M8C_DisableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0735) 
                                   (0736) .End_IntCntl:
                                   (0737)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0738)    ret
                                   (0739) .ENDSECTION
                                   (0740) 
                                   (0741) 
                                   (0742) ;=============================================================================
                                   (0743) ;=============================================================================
                                   (0744) ;
                                   (0745) ;     High-Level Commands
                                   (0746) ;
                                   (0747) ;=============================================================================
                                   (0748) ;=============================================================================
                                   (0749) 
                                   (0750) 
                                   (0751) ;-----------------------------------------------------------------------------
                                   (0752) ;  FUNCTION NAME: COMP_SERIAL_PutSHexByte
                                   (0753) ;
                                   (0754) ;  DESCRIPTION:
126D: 5D 3F    MOV   A,REG[63]     (0755) ;     Print a byte in Hex (two characters) to the UART Tx
126F: 08       PUSH  A             (0756) ;-----------------------------------------------------------------------------
1270: 21 08    AND   A,8           (0757) ;
1272: B0 04    JNZ   0x1277        (0758) ;  ARGUMENTS:
1274: 18       POP   A             (0759) ;     A  => (BYTE) Data/char to be printed
1275: 80 0B    JMP   0x1281        (0760) ;
                                   (0761) ;  RETURNS:
                                   (0762) ;     none.
1277: 5D 3E    MOV   A,REG[62]     (0763) ;
1279: 4B       SWAP  A,X           (0764) ;  SIDE EFFECTS:
                                   (0765) ;    The A and X registers may be modified by this or future implementations
127A: 18       POP   A             (0766) ;    of this function.  The same is true for all RAM page pointer registers in
127B: 21 A0    AND   A,160         (0767) ;    the Large Memory Model.  When necessary, it is the calling function's
127D: B0 03    JNZ   0x1281        (0768) ;    responsibility to perserve their values across calls to fastcall16 
127F: 4B       SWAP  A,X           (0769) ;    functions.
                                   (0770) ;
1280: 7F       RET                 (0771) .LITERAL
                                   (0772) COMP_SERIAL_HEX_STR:
                                   (0773)      DS    "0123456789ABCDEF"
1281: 50 00    MOV   A,0           (0774) .ENDLITERAL
                                   (0775) 
                                   (0776) .SECTION
                                   (0777)  COMP_SERIAL_PutSHexByte:
1283: 7F       RET                 (0778) _COMP_SERIAL_PutSHexByte:
                                   (0779)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0780)    push  A                             ; Save lower nibble
                                   (0781)    asr   A                             ; Shift high nibble to right
                                   (0782)    asr   A
                                   (0783)    asr   A
                                   (0784)    asr   A
                                   (0785)    and   A,0Fh                         ; Mask off nibble
                                   (0786)    index COMP_SERIAL_HEX_STR           ; Get Hex value
                                   (0787)    call  COMP_SERIAL_PutChar           ; Write data to screen
                                   (0788)    pop   A                             ; Restore value
                                   (0789)    and   A,0Fh                         ; Mask off lower nibble
                                   (0790)    index COMP_SERIAL_HEX_STR           ; Get Hex value
                                   (0791)    call  COMP_SERIAL_PutChar           ; Write data to screen
                                   (0792)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0793)    ret
                                   (0794) .ENDSECTION
                                   (0795) 
                                   (0796) 
                                   (0797) .SECTION
                                   (0798) ;-----------------------------------------------------------------------------
                                   (0799) ;  FUNCTION NAME: COMP_SERIAL_PutSHexInt
                                   (0800) ;
                                   (0801) ;  DESCRIPTION:
                                   (0802) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0803) ;-----------------------------------------------------------------------------
                                   (0804) ;
                                   (0805) ;  ARGUMENTS:
                                   (0806) ;     Pointer to string
                                   (0807) ;     A  => ASB of Int
                                   (0808) ;     X  => MSB of Int
                                   (0809) ;
                                   (0810) ;  RETURNS:
                                   (0811) ;     none.
                                   (0812) ;
                                   (0813) ;  SIDE EFFECTS:
                                   (0814) ;    The A and X registers may be modified by this or future implementations
                                   (0815) ;    of this function.  The same is true for all RAM page pointer registers in
1284: 5D 3F    MOV   A,REG[63]     (0816) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0817) ;    responsibility to perserve their values across calls to fastcall16 
1286: 21 E8    AND   A,232         (0818) ;    functions.
1288: 08       PUSH  A             (0819) ;
1289: 21 08    AND   A,8           (0820) 
128B: B0 07    JNZ   0x1293        (0821)  COMP_SERIAL_PutSHexInt:
128D: 18       POP   A             (0822) _COMP_SERIAL_PutSHexInt:
128E: 29 01    OR    A,1           (0823)    RAM_PROLOGUE RAM_USE_CLASS_1
1290: 4B       SWAP  A,X           (0824)    swap  A,X
1291: 80 07    JMP   0x1299        (0825)    call  COMP_SERIAL_PutSHexByte       ; Print MSB
                                   (0826)    mov   A,X                           ; Move LSB into position
                                   (0827)    call  COMP_SERIAL_PutSHexByte       ; Print LSB
1293: 18       POP   A             (0828)    RAM_EPILOGUE RAM_USE_CLASS_1
1294: 21 E0    AND   A,224         (0829)    ret
1296: 4B       SWAP  A,X           (0830) .ENDSECTION
1297: 5D 3E    MOV   A,REG[62]     (0831) 
                                   (0832) 
                                   (0833) .SECTION
                                   (0834) ;-----------------------------------------------------------------------------
                                   (0835) ;  FUNCTION NAME: COMP_SERIAL_PutChar
1299: 7F       RET                 (0836) ;
                                   (0837) ;  DESCRIPTION:
                                   (0838) ;     Send character out through UART TX port.
                                   (0839) ;-----------------------------------------------------------------------------
                                   (0840) ;
                                   (0841) ;  ARGUMENTS:
                                   (0842) ;     A has Character to send to UART Tx Port
                                   (0843) ;
                                   (0844) ;  RETURNS:
                                   (0845) ;     none
                                   (0846) ;
                                   (0847) ;  SIDE EFFECTS:
                                   (0848) ;    The A and X registers may be modified by this or future implementations
                                   (0849) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0850) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0851) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0852) ;    functions.
                                   (0853) ;
                                   (0854) 
                                   (0855)    macro InLinePutChar( Source )
                                   (0856) .BufEmptyWaitLoop:
                                   (0857)    tst REG[COMP_SERIAL_TX_CONTROL_REG], COMP_SERIAL_TX_BUFFER_EMPTY     ; Check Tx Status
                                   (0858)    jz  .BufEmptyWaitLoop
                                   (0859)    mov REG[COMP_SERIAL_TX_BUFFER_REG], @Source     ; Write data to Tx Port
                                   (0860)    endm
                                   (0861) 
                                   (0862)  COMP_SERIAL_PutChar:
                                   (0863) _COMP_SERIAL_PutChar:
                                   (0864)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0865)    InLinePutChar A
                                   (0866)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0867)    ret
129A: 70 BF    AND   F,191         (0868) .ENDSECTION
129C: 60 D3    MOV   REG[211],A    (0869) 
                                   (0870) 
129E: 52 00    MOV   A,[X+0]       (0871) .SECTION
12A0: A0 06    JZ    0x12A7        (0872) ;-----------------------------------------------------------------------------
12A2: 9F B9    CALL  0x125D        (0873) ;  FUNCTION NAME: COMP_SERIAL_cGetChar
12A4: 75       INC   X             (0874) ;
12A5: 8F F8    JMP   0x129E        (0875) ;  DESCRIPTION:
12A7: 70 3F    AND   F,63
                                   (0876) ;     Read character from UART RX port.
                                   (0877) ;-----------------------------------------------------------------------------
12A9: 71 C0    OR    F,192         (0878) ;
12AB: 7F       RET                 (0879) ;  ARGUMENTS:
                                   (0880) ;      none
                                   (0881) ;
                                   (0882) ;  RETURNS:
                                   (0883) ;     char that is returned from UART
                                   (0884) ;
                                   (0885) ;  SIDE EFFECTS:
                                   (0886) ;    The A and X registers may be modified by this or future implementations
                                   (0887) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0888) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0889) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0890) ;    functions.
                                   (0891) ;
                                   (0892) ;    Program flow will stay in this function until a character is received.
                                   (0893) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0894) ;    the delay between characters is less than the watchdog timeout.
                                   (0895) ;
                                   (0896)  COMP_SERIAL_cGetChar:
                                   (0897) _COMP_SERIAL_cGetChar:
                                   (0898)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0899)    tst REG[COMP_SERIAL_RX_CONTROL_REG],COMP_SERIAL_RX_REG_FULL    ; Check if a character is ready
                                   (0900)    jz  COMP_SERIAL_cGetChar                              ; If not loop
                                   (0901)    mov A, REG[COMP_SERIAL_RX_BUFFER_REG]                 ; Get character
                                   (0902)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0903)    ret
                                   (0904) .ENDSECTION
                                   (0905) 
                                   (0906) 
                                   (0907) .SECTION
                                   (0908) ;-----------------------------------------------------------------------------
                                   (0909) ;  FUNCTION NAME: COMP_SERIAL_cReadChar
                                   (0910) ;
                                   (0911) ;  DESCRIPTION:
                                   (0912) ;     Read character from UART RX port.
                                   (0913) ;-----------------------------------------------------------------------------
                                   (0914) ;
12AC: 70 BF    AND   F,191         (0915) ;  ARGUMENTS:
12AE: 62 D3 07 MOV   REG[211],7    (0916) ;      none
12B1: 4F       MOV   X,SP          (0917) ;
                                   (0918) ;  RETURNS:
                                   (0919) ;     char that is returned from UART
12B2: 52 FB    MOV   A,[X-5]       (0920) ;
12B4: A0 1A    JZ    0x12CF        (0921) ;  SIDE EFFECTS:
12B6: 7B FB    DEC   [X-5]         (0922) ;    The A and X registers may be modified by this or future implementations
                                   (0923) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0924) ;    the Large Memory Model.  When necessary, it is the calling function's
12B8: 52 FC    MOV   A,[X-4]       (0925) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0926) ;    functions.
                                   (0927) ;
12BA: 59 FD    MOV   X,[X-3]       (0928) ;    A valid 0x00 character will be ignored, since a 0x00 return value
12BC: 60 D3    MOV   REG[211],A    (0929) ;    implies a valid character or an error condition occured.
12BE: 52 00    MOV   A,[X+0]       (0930) ;
12C0: 49 3B 10 TST   REG[59],16
12C3: AF FC    JZ    0x12C0        (0931)  COMP_SERIAL_cReadChar:
12C5: 60 39    MOV   REG[57],A
12C7: 4F       MOV   X,SP          (0932) _COMP_SERIAL_cReadChar:
12C8: 62 D3 07 MOV   REG[211],7    (0933)    RAM_PROLOGUE RAM_USE_CLASS_1
12CB: 77 FD    INC   [X-3]         (0934)    mov  A,REG[COMP_SERIAL_RX_CONTROL_REG]                  ; Get Status of RX
12CD: 8F E4    JMP   0x12B2        (0935)    push A
12CF: 70 3F    AND   F,63
                                   (0936)    and  A,COMP_SERIAL_RX_COMPLETE                          ; Check if a character is ready
                                   (0937)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
12D1: 71 C0    OR    F,192         (0938)    pop  A
12D3: 7F       RET                 (0939)    jmp  .RX_NO_VALID_CHAR
                                   (0940) 
                                   (0941) .RX_DATA_RDY:
                                   (0942)    mov  A,REG[COMP_SERIAL_RX_BUFFER_REG ]          
                                   (0943)    swap A,X                                                ; determine if data is valid
                                   (0944) 
                                   (0945)    pop  A                                                  ; Check for errors
                                   (0946)    and  A,(COMP_SERIAL_RX_PARITY_ERROR | COMP_SERIAL_RX_FRAMING_ERROR)
                                   (0947)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0948)    swap A,X                                                ; Put data in A and exit
                                   (0949)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0950)    ret
                                   (0951) 
                                   (0952) .RX_NO_VALID_CHAR:
                                   (0953)    mov A,0x00                                              ; Zero out character
                                   (0954) 
                                   (0955)  End_COMP_SERIAL_cReadChar:
                                   (0956)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0957)    ret
                                   (0958) .ENDSECTION
                                   (0959) 
                                   (0960) 
                                   (0961) .SECTION
                                   (0962) ;-----------------------------------------------------------------------------
                                   (0963) ;  FUNCTION NAME: COMP_SERIAL_iReadChar
                                   (0964) ;
                                   (0965) ;  WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0966) ;  to just set a value in the upper byte if error conditions exists.
                                   (0967) ;
                                   (0968) ;  DESCRIPTION:
                                   (0969) ;     Read character from UART RX port.
                                   (0970) ;-----------------------------------------------------------------------------
                                   (0971) ;
                                   (0972) ;  ARGUMENTS:
                                   (0973) ;      none
                                   (0974) ;
                                   (0975) ;  RETURNS:
                                   (0976) ;     An integer value is returned.  A negative value inplies and error
12D4: 4F       MOV   X,SP          (0977) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0978) ;
12D5: 3D FA 00 CMP   [X-6],0       (0979) ;     Error Codes:
12D8: B0 06    JNZ   0x12DF        (0980) ;        0x80CC    Parity Error
12DA: 3D FB 00 CMP   [X-5],0       (0981) ;        0x40CC    Overrun Error
12DD: A0 1D    JZ    0x12FB        (0982) ;        0x20CC    Framing Error
                                   (0983) ;        0x01CC    No Data available
                                   (0984) ;
12DF: 10       PUSH  X             (0985) ;  SIDE EFFECTS:
12E0: 52 FC    MOV   A,[X-4]       (0986) ;    The A and X registers may be modified by this or future implementations
12E2: 59 FD    MOV   X,[X-3]       (0987) ;    of this function.  The same is true for all RAM page pointer registers in
12E4: 28       ROMX                (0988) ;    the Large Memory Model.  When necessary, it is the calling function's
12E5: 49 3B 10 TST   REG[59],16
12E8: AF FC    JZ    0x12E5        (0989) ;    responsibility to perserve their values across calls to fastcall16 
12EA: 60 39    MOV   REG[57],A
12EC: 20       POP   X             (0990) ;    functions.
12ED: 07 FD 01 ADD   [X-3],1       (0991) ;
12F0: 0F FC 00 ADC   [X-4],0       (0992)  COMP_SERIAL_iReadChar:
12F3: 17 FB 01 SUB   [X-5],1       (0993) _COMP_SERIAL_iReadChar:
12F6: 1F FA 00 SBB   [X-6],0       (0994)    RAM_PROLOGUE RAM_USE_CLASS_1
12F9: 8F DB    JMP   0x12D5        (0995)    mov  A,REG[COMP_SERIAL_RX_CONTROL_REG]                  ; Get Status of RX
12FB: 70 3F    AND   F,63
                                   (0996)                                                            ; Mask only errors and data ready
                                   (0997)    and  A,(COMP_SERIAL_RX_ERROR|COMP_SERIAL_RX_REG_FULL)
12FD: 71 C0    OR    F,192         (0998)    push A
12FF: 7F       RET                 (0999)    and  A,COMP_SERIAL_RX_COMPLETE                          ; Check if a character is ready
                                   (1000)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (1001)    pop  A
                                   (1002)    or   A,COMP_SERIAL_RX_NO_DATA                           ; Add no data flag
                                   (1003)    swap A,X
                                   (1004)    jmp  End_COMP_SERIAL_iReadChar
                                   (1005) 
                                   (1006) .RX_GET_DATA:
                                   (1007)    pop  A
                                   (1008)    and  A,COMP_SERIAL_RX_ERROR
                                   (1009)    swap A,X
                                   (1010)    mov  A,REG[COMP_SERIAL_RX_BUFFER_REG ]                  ; Read data first, then
                                   (1011)                                                            ; determine if data is valid
                                   (1012) 
                                   (1013)  End_COMP_SERIAL_iReadChar:
                                   (1014)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1015)    ret
                                   (1016) .ENDSECTION
                                   (1017) 
                                   (1018) 
                                   (1019) .SECTION
                                   (1020) ;-----------------------------------------------------------------------------
                                   (1021) ;  FUNCTION NAME: COMP_SERIAL_PutString
                                   (1022) ;
                                   (1023) ;  DESCRIPTION:
                                   (1024) ;     Send String out through UART TX port.
                                   (1025) ;-----------------------------------------------------------------------------
                                   (1026) ;
                                   (1027) ;  ARGUMENTS:
                                   (1028) ;     Pointer to String
1300: 08       PUSH  A             (1029) ;     A has MSB of string address
1301: 10       PUSH  X             (1030) ;     X has LSB of string address
1302: 28       ROMX                (1031) ;
1303: A0 0B    JZ    0x130F        (1032) ;  RETURNS:
1305: 9F 56    CALL  0x125D        (1033) ;     none
1307: 20       POP   X             (1034) ;
1308: 18       POP   A             (1035) ;  SIDE EFFECTS:
1309: 75       INC   X             (1036) ;    The A and X registers may be modified by this or future implementations
130A: DF F5    JNC   0x1300        (1037) ;    of this function.  The same is true for all RAM page pointer registers in
130C: 74       INC   A             (1038) ;    the Large Memory Model.  When necessary, it is the calling function's
130D: 8F F2    JMP   0x1300        (1039) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1040) ;    functions.
                                   (1041) ;          
                                   (1042) ;    Currently only the page pointer registers listed below are modified: 
130F: 38 FE    ADD   SP,254        (1043) ;          IDX_PP
                                   (1044) ;
1311: 7F       RET                 (1045)  COMP_SERIAL_PutString:
                                   (1046) _COMP_SERIAL_PutString:
                                   (1047)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (1048)    RAM_SETPAGE_IDX A
                                   (1049) .PutStringLoop:
                                   (1050)    mov   A,[X]                                   ; Get value pointed to by X
                                   (1051)    jz    End_PutString                           ; Check for end of string
                                   (1052)    call  COMP_SERIAL_PutChar                     ; Send character to Tx port
                                   (1053)    inc   X                                       ; Advance pointer to next character
                                   (1054)    jmp   .PutStringLoop                          ; Get next character
                                   (1055) 
                                   (1056) End_PutString:
                                   (1057)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (1058)    ret
                                   (1059) .ENDSECTION
                                   (1060)     
                                   (1061) .SECTION
                                   (1062) ;-----------------------------------------------------------------------------
                                   (1063) ;  FUNCTION NAME: COMP_SERIAL_Write
                                   (1064) ;
                                   (1065) ;  DESCRIPTION:
                                   (1066) ;     Send String of length X to serial port
                                   (1067) ;-----------------------------------------------------------------------------
                                   (1068) ;
                                   (1069) ;  ARGUMENTS:
                                   (1070) ;     Pointer to String
                                   (1071) ;     [SP-5] Count of characters to send
                                   (1072) ;     [SP-4] has MSB of string address
1312: 50 0D    MOV   A,13          (1073) ;     [SP-3] has LSB of string address
1314: 9F 47    CALL  0x125D        (1074) ;
1316: 50 0A    MOV   A,10          (1075) ;  RETURNS:
1318: 9F 43    CALL  0x125D        (1076) ;     none
                                   (1077) ;
131A: 7F       RET                 (1078) ;  SIDE EFFECTS:
                                   (1079) ;    The A and X registers may be modified by this or future implementations
                                   (1080) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1081) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1082) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1083) ;    functions.
                                   (1084) ;          
                                   (1085) ;    Currently only the page pointer registers listed below are modified: 
                                   (1086) ;          IDX_PP
                                   (1087) ;
                                   (1088) CNT_LEN:    equ -5                               ; Length of data to send
                                   (1089) STR_MSB:    equ -4                               ; MSB pointer of string 
                                   (1090) STR_LSB:    equ -3                               ; LSB pointer of string 
                                   (1091) 
                                   (1092)  COMP_SERIAL_Write:
                                   (1093) _COMP_SERIAL_Write:
                                   (1094)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (1095)    RAM_SETPAGE_IDX2STK                           ; Refer indexed addrs to the stack
                                   (1096)    mov   X, SP                                   ; Establish the frame pointer 
                                   (1097) 
                                   (1098) .NextByteLoop:
                                   (1099)    mov   A, [X+CNT_LEN]                          ; End of the string?
                                   (1100)    jz    .End_Write                              ;   Yes, prepare to exit
                                   (1101)    dec   [X+CNT_LEN]                             ; Decrement counter
                                   (1102) 
                                   (1103)    IF SYSTEM_LARGE_MEMORY_MODEL
                                   (1104)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
                                   (1105)    ENDIF
                                   (1106) 
                                   (1107)    mov   X, [X+STR_LSB]                          ; Load pointer to char to send
                                   (1108)    RAM_SETPAGE_IDX A                             ; switch index pages
                                   (1109)    mov   A, [X]                                  ; Grab the data
                                   (1110)    InLinePutChar A                               ; Put data in empty TX buf reg
                                   (1111)    mov   X, SP                                   ; Recover frame pointer
                                   (1112)    RAM_SETPAGE_IDX2STK                           ; Prepare for stack access
                                   (1113)    inc   [X+STR_LSB]                             ; Point to next byte, but do not
                                   (1114)    jmp   .NextByteLoop                           ;    cross RAM page boundary!
                                   (1115) 
                                   (1116) .End_Write:
                                   (1117)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (1118)    ret
                                   (1119) .ENDSECTION
                                   (1120)     
131B: 62 D0 00 MOV   REG[208],0    (1121) 
131E: 55 08 00 MOV   [8],0         (1122) .SECTION
1321: 62 D0 00 MOV   REG[208],0    (1123) ;-----------------------------------------------------------------------------
1324: 55 07 00 MOV   [7],0         (1124) ;  FUNCTION NAME: COMP_SERIAL_CWrite
1327: 26 06 00 AND   [6],0         (1125) ;
132A: 62 D0 00 MOV   REG[208],0    (1126) ;             WARNING WARNING NOT COMPLETE
132D: 55 78 00 MOV   [TIMEOUT+2],0 (1127) ;
                                   (1128) ;  DESCRIPTION:
1330: 7F       RET                 (1129) ;     Send String of length X to serial port
                                   (1130) ;-----------------------------------------------------------------------------
                                   (1131) ;
                                   (1132) ;  ARGUMENTS:
                                   (1133) ;     [SP-4] MSB of Count of character to send
                                   (1134) ;     [SP-3] LSB of Count of character to send
                                   (1135) ;     [SP-2] has MSB of string address
                                   (1136) ;     [SP-1] has LSB of string address
                                   (1137) ;
                                   (1138) ;  RETURNS:
                                   (1139) ;     none
                                   (1140) ;
                                   (1141) ;  SIDE EFFECTS:
                                   (1142) ;    The A and X registers may be modified by this or future implementations
                                   (1143) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1144) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1145) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1146) ;    functions.
                                   (1147) ;
                                   (1148) CLEN_MSB:   equ -6           ; MSB Length of data to send
                                   (1149) CLEN_LSB:   equ -5           ; LSB Length of data to send
                                   (1150) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (1151) CSTR_LSB:   equ -3           ; LSB pointer of string
                                   (1152) 
                                   (1153)  COMP_SERIAL_CWrite:
                                   (1154) _COMP_SERIAL_CWrite:
                                   (1155)    RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1156)    mov   X,SP
                                   (1157) .CW_Loop:
                                   (1158)    cmp   [X+CLEN_MSB],0x00                  ; Check for zero counter
                                   (1159)    jnz   .CW_WRITEIT
                                   (1160)    cmp   [X+CLEN_LSB],0x00
                                   (1161)    jz    .End_CWrite                        ; Leave if done
                                   (1162) 
                                   (1163) .CW_WRITEIT:                                
1331: 62 D0 00 MOV   REG[208],0    (1164)    push  X                                  ; Save frame pointer
1334: 51 06    MOV   A,[6]         (1165)    mov   A,[X+CSTR_MSB]
1336: 21 01    AND   A,1           (1166)    mov   X,[X+CSTR_LSB]
                                   (1167)    romx                                     ; Get character from ROM
1338: 7F       RET                 (1168)    InLinePutChar A                          ; Put data in empty TX buf reg
                                   (1169)    pop   X                                  ; Restore frame pointer
                                   (1170)    add   [X+CSTR_LSB],1                     ; Increment the string pointer
                                   (1171)    adc   [X+CSTR_MSB],0
                                   (1172)    sub   [X+CLEN_LSB],0x01                  ; Dec the counter
                                   (1173)    sbb   [X+CLEN_MSB],0x00
                                   (1174)    jmp   .CW_Loop
                                   (1175) 
                                   (1176) .End_CWrite:
                                   (1177)    RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1178)    ret
                                   (1179) .ENDSECTION
                                   (1180) 
                                   (1181) 
                                   (1182) .SECTION
                                   (1183) ;-----------------------------------------------------------------------------
                                   (1184) ;  FUNCTION NAME: COMP_SERIAL_CPutString
                                   (1185) ;
                                   (1186) ;  DESCRIPTION:
                                   (1187) ;     Send String out through UART TX port.
                                   (1188) ;-----------------------------------------------------------------------------
                                   (1189) ;
                                   (1190) ;  ARGUMENTS:
                                   (1191) ;     Pointer to String
                                   (1192) ;     A has MSB of string address
                                   (1193) ;     X has LSB of string address
                                   (1194) ;
                                   (1195) ;  RETURNS:
                                   (1196) ;     none
                                   (1197) ;
                                   (1198) ;  SIDE EFFECTS:
                                   (1199) ;    The A and X registers may be modified by this or future implementations
                                   (1200) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1202) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1203) ;    functions.
                                   (1204) ;
                                   (1205)  COMP_SERIAL_CPutString:
                                   (1206) _COMP_SERIAL_CPutString:
                                   (1207)    RAM_PROLOGUE RAM_USE_CLASS_1
1339: 62 D0 00 MOV   REG[208],0    (1208)    push  A                                       ; Store ROM pointer
133C: 51 06    MOV   A,[6]         (1209)    push  X
133E: 21 F0    AND   A,240         (1210)    romx                                          ; Get character from ROM
1340: 26 06 0F AND   [6],15        (1211)    jz    .End_CPutString
                                   (1212)    call  COMP_SERIAL_PutChar                     ; Print character
1343: 7F       RET                 (1213)    pop   X
                                   (1214)    pop   A
                                   (1215)    inc   X                                       ; Inc LSB of pointer
                                   (1216)    jnc   COMP_SERIAL_CPutString                  ; Check for carry
                                   (1217)    inc   A                                       ; Inc MSB of pointer
                                   (1218)    jmp   COMP_SERIAL_CPutString
                                   (1219) 
                                   (1220) 
                                   (1221) .End_CPutString:
                                   (1222)    add   SP, -2
                                   (1223)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1224)    ret
                                   (1225) .ENDSECTION
                                   (1226) 
                                   (1227) 
                                   (1228) .SECTION
                                   (1229) ;-----------------------------------------------------------------------------
                                   (1230) ;  FUNCTION NAME: COMP_SERIAL_PutCRLF
                                   (1231) ;
                                   (1232) ;  DESCRIPTION:
                                   (1233) ;     Send a CR and LF
                                   (1234) ;-----------------------------------------------------------------------------
                                   (1235) ;
                                   (1236) ;  ARGUMENTS:
                                   (1237) ;     none.
                                   (1238) ;
                                   (1239) ;  RETURNS:
                                   (1240) ;     none.
                                   (1241) ;
                                   (1242) ;  SIDE EFFECTS:
1344: 62 D0 00 MOV   REG[208],0    (1243) ;    The A and X registers may be modified by this or future implementations
1347: 51 07    MOV   A,[7]         (1244) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1245) ;    the Large Memory Model.  When necessary, it is the calling function's
1349: 7F       RET                 (1246) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1247) ;    functions.
                                   (1248) ;
                                   (1249)  COMP_SERIAL_PutCRLF:
                                   (1250) _COMP_SERIAL_PutCRLF:
                                   (1251)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1252)    mov  A,0x0D                        ; Send CR
                                   (1253)    call COMP_SERIAL_PutChar
                                   (1254)    mov  A,0x0A                        ; Send LF
                                   (1255)    call COMP_SERIAL_PutChar
                                   (1256)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1257)    ret
                                   (1258) .ENDSECTION
                                   (1259) 
                                   (1260) 
                                   (1261) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (1262) ;=============================================================================
                                   (1263) ;=============================================================================
                                   (1264) ;
                                   (1265) ;     Command Buffer commands
                                   (1266) ;
                                   (1267) ;=============================================================================
                                   (1268) ;=============================================================================
                                   (1269) 
                                   (1270) .SECTION
                                   (1271) ;-----------------------------------------------------------------------------
                                   (1272) ;  FUNCTION NAME: COMP_SERIAL_CmdReset
                                   (1273) ;
                                   (1274) ;  DESCRIPTION:
                                   (1275) ;     Reset command string and status flags
                                   (1276) ;-----------------------------------------------------------------------------
                                   (1277) ;
                                   (1278) ;  ARGUMENTS:
                                   (1279) ;     none.
                                   (1280) ;
                                   (1281) ;  RETURNS:
                                   (1282) ;     none.
                                   (1283) ;
                                   (1284) ;  SIDE EFFECTS:
                                   (1285) ;    The A and X registers may be modified by this or future implementations
                                   (1286) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1287) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1288) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1289) ;    functions.
                                   (1290) ;          
                                   (1291) ;    Currently only the page pointer registers listed below are modified: 
                                   (1292) ;          CUR_PP
                                   (1293) ;
                                   (1294) ;  THEORY of OPERATION or PROCEDURE:
                                   (1295) ;     Clear the command buffer, command counter, and flag.
                                   (1296) ;
                                   (1297)  COMP_SERIAL_CmdReset:
                                   (1298) _COMP_SERIAL_CmdReset:
                                   (1299)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1300)    RAM_SETPAGE_CUR >COMP_SERIAL_aRxBuffer
134A: 70 BF    AND   F,191         (1301)    mov [COMP_SERIAL_aRxBuffer], 0x00
                                   (1302)    RAM_SETPAGE_CUR >COMP_SERIAL_bRxCnt
134C: 62 D0 00 MOV   REG[208],0    (1303)    mov [COMP_SERIAL_bRxCnt], 0x00
134F: 50 08    MOV   A,8           (1304)    and [COMP_SERIAL_fStatus], 0x00
1351: 02 78    ADD   A,[TIMEOUT+2] (1305)    RAM_SETPAGE_CUR >ptrParam
1353: 5C       MOV   X,A           (1306)    mov [ptrParam],0x00
1354: 62 D3 00 MOV   REG[211],0    (1307)    RAM_EPILOGUE RAM_USE_CLASS_4
1357: 52 00    MOV   A,[X+0]       (1308)    ret
1359: B0 04    JNZ   0x135E        (1309) .ENDSECTION
135B: 10       PUSH  X             (1310) 
135C: 80 33    JMP   0x1390        (1311) 
                                   (1312) .SECTION
                                   (1313) ;-----------------------------------------------------------------------------
                                   (1314) ;  FUNCTION NAME: COMP_SERIAL_bCmdCheck
135E: 39 2C    CMP   A,44          (1315) ;
1360: B0 11    JNZ   0x1372        (1316) ;  DESCRIPTION:
1362: 75       INC   X             (1317) ;     Check to see if valid command in buffer.
1363: 76 78    INC   [TIMEOUT+2]   (1318) ;-----------------------------------------------------------------------------
1365: 52 00    MOV   A,[X+0]       (1319) ;
1367: 3C 78 3F CMP   [TIMEOUT+2],63(1320) ;  ARGUMENTS:
136A: BF F3    JNZ   0x135E        (1321) ;     none.
                                   (1322) ;
                                   (1323) ;  RETURNS:
136C: 10       PUSH  X             (1324) ;     BYTE  fStatus - Status of command receive buffer.
                                   (1325) ;                     Returns non-zero value in A if command is valid.
136D: 56 00 00 MOV   [X+0],0       (1326) ;
1370: 80 1F    JMP   0x1390        (1327) ;  SIDE EFFECTS:
                                   (1328) ;    The A and X registers may be modified by this or future implementations
                                   (1329) ;    of this function.  The same is true for all RAM page pointer registers in
1372: 10       PUSH  X             (1330) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1331) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1332) ;    functions.
1373: 75       INC   X             (1333) ;          
1374: 76 78    INC   [TIMEOUT+2]   (1334) ;    Currently only the page pointer registers listed below are modified: 
1376: 3C 78 3F CMP   [TIMEOUT+2],63(1335) ;          CUR_PP
1379: AF F3    JZ    0x136D        (1336) ;
137B: 52 00    MOV   A,[X+0]       (1337) ;  THEORY of OPERATION or PROCEDURE:
137D: A0 12    JZ    0x1390        (1338) ;     Read the status and control register.
137F: 39 2C    CMP   A,44          (1339) ;
1381: BF F1    JNZ   0x1373        (1340)  COMP_SERIAL_bCmdCheck:
1383: 56 00 00 MOV   [X+0],0       (1341) _COMP_SERIAL_bCmdCheck:
1386: 76 78    INC   [TIMEOUT+2]   (1342)    RAM_PROLOGUE RAM_USE_CLASS_4
1388: 3C 78 3F CMP   [TIMEOUT+2],63(1343)    RAM_SETPAGE_CUR >COMP_SERIAL_fStatus
138B: B0 04    JNZ   0x1390        (1344)    mov A,  [COMP_SERIAL_fStatus]
138D: 55 78 3F MOV   [TIMEOUT+2],63(1345)    and A, COMP_SERIAL_RX_BUF_CMDTERM             ; Mask off Command status
                                   (1346)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1347)    ret
1390: 20       POP   X             (1348) .ENDSECTION
1391: 10       PUSH  X             (1349)     
1392: 3D 00 00 CMP   [X+0],0       (1350) 
1395: B0 0B    JNZ   0x13A1        (1351) .SECTION
1397: 20       POP   X             (1352) ;-----------------------------------------------------------------------------
1398: 57 00    MOV   X,0           (1353) ;  FUNCTION NAME: COMP_SERIAL_bErrCheck
139A: 50 00    MOV   A,0           (1354) ;
139C: 70 3F    AND   F,63
139E: 71 C0    OR    F,192         (1355) ;  DESCRIPTION:
                                   (1356) ;     Check to see if an error has occured since last CmdReset
13A0: 7F       RET                 (1357) ;-----------------------------------------------------------------------------
                                   (1358) ;
                                   (1359) ;  ARGUMENTS:
13A1: 20       POP   X             (1360) ;     none.
13A2: 50 00    MOV   A,0           (1361) ;
13A4: 70 3F    AND   F,63
13A6: 71 C0    OR    F,192         (1362) ;  RETURNS:
                                   (1363) ;     BYTE  fStatus - Status of command receive buffer.
13A8: 7F       RET                 (1364) ;                     Returns non-zero value in A if command is valid.
                                   (1365) ;           0x80 => Parity Error
                                   (1366) ;           0x40 => OverRun Error
                                   (1367) ;           0x20 => Framing Error
                                   (1368) ;           0x10 => Software Buffer OverRun
                                   (1369) ;
                                   (1370) ;  SIDE EFFECTS:
                                   (1371) ;    The A and X registers may be modified by this or future implementations
                                   (1372) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1373) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1374) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1375) ;    functions.
                                   (1376) ;          
                                   (1377) ;    Currently only the page pointer registers listed below are modified: 
                                   (1378) ;          CUR_PP
                                   (1379) ;     Error Status is clear when read.
                                   (1380) ;
                                   (1381) ;  THEORY of OPERATION or PROCEDURE:
                                   (1382) ;     Read RX buffer error status and clear status
                                   (1383) ;
                                   (1384)  COMP_SERIAL_bErrCheck:
                                   (1385) _COMP_SERIAL_bErrCheck:
                                   (1386)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1387)    RAM_SETPAGE_CUR >COMP_SERIAL_fStatus
                                   (1388)    mov A,  [COMP_SERIAL_fStatus]
                                   (1389)    and A, COMP_SERIAL_RX_BUF_ERROR               ; Mask off Error status
                                   (1390)    and [COMP_SERIAL_fStatus], ~COMP_SERIAL_RX_BUF_ERROR
                                   (1391)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1392)    ret
                                   (1393) .ENDSECTION
                                   (1394) 
13A9: 62 D0 00 MOV   REG[208],0    (1395) .SECTION
13AC: 50 08    MOV   A,8           (1396) ;-----------------------------------------------------------------------------
13AE: 02 78    ADD   A,[TIMEOUT+2] (1397) ;  FUNCTION NAME: COMP_SERIAL_bCmdLength
13B0: 5C       MOV   X,A           (1398) ;
13B1: 50 00    MOV   A,0           (1399) ;  DESCRIPTION:
                                   (1400) ;     Get length of command string
__text_start:
_main:
  angle                --> X+2
  tempValue            --> X+0
13B4: 10       PUSH  X             (1401) ;-----------------------------------------------------------------------------
13B5: 4F       MOV   X,SP
13B6: 38 06    ADD   SP,6

FILE: C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
(0100) //----------------------------------------------------------------------------
13B8: 56 01 00 MOV   [X+1],0
13BB: 56 00 00 MOV   [X+0],0
(0101) // C main line
13BE: 56 02 00 MOV   [X+2],0
13C1: 56 03 00 MOV   [X+3],0
13C4: 56 04 00 MOV   [X+4],0
13C7: 56 05 00 MOV   [X+5],0
(0102) //----------------------------------------------------------------------------
(0103) 
13CA: 62 D0 00 MOV   REG[208],0
13CD: 55 73 00 MOV   [NUM_MODULES+1],0
13D0: 55 72 00 MOV   [NUM_MODULES],0
(0104) #include <m8c.h>        	// part specific constants and macros
(0105) #include "PSoCAPI.h"    	// PSoC API definitions for all User Modules
13D3: 71 01    OR    F,1
(0106) #include "psocdynamic.h"
13D5: 43 E0 20 OR    REG[224],32
(0107) #include <stdlib.h>
(0108) #include <string.h>
13D8: 7C 1C BC LCALL _unloadAllConfigs
(0109) #pragma interrupt_handler TX_TIMEOUT_ISR
13DB: 50 00    MOV   A,0
13DD: 08       PUSH  A
13DE: 50 01    MOV   A,1
13E0: 08       PUSH  A
13E1: 97 E4    CALL  _configToggle
13E3: 38 FE    ADD   SP,254
(0110) #pragma interrupt_handler RX_TIMEOUT_ISR
(0111) 
(0112) // These defines are used as parameters of the configToggle function.
13E5: 62 D0 00 MOV   REG[208],0
13E8: 51 77    MOV   A,[TIMEOUT+1]
13EA: 11 C8    SUB   A,200
13EC: 51 76    MOV   A,[TIMEOUT]
13EE: 31 80    XOR   A,128
13F0: 19 80    SBB   A,128
13F2: CF F2    JC    0x13E5
(0113) // Passing one or the other in the function call switches the system between PC, TX, and RX modes.
(0114) #define		PC_MODE						(2)
(0115) #define		RX_MODE						(1)
13F4: 7C 1D DA LCALL _initializeSlaves
13F7: 80 0F    JMP   0x1407
(0116) #define		TX_MODE						(0)
(0117) 
(0118) // These defines are used as comparisons to find what port the newest module is connected to.
(0119) #define		PORT_1						('A')
13F9: 10       PUSH  X
13FA: 7C 13 31 LCALL 0x1331
13FD: 62 D0 00 MOV   REG[208],0
1400: 20       POP   X
1401: 39 00    CMP   A,0
1403: AF F5    JZ    0x13F9
(0120) #define		PORT_2						('B')
(0121) #define		PORT_3						('C')
1405: 95 49    CALL  _decodeTransmission
1407: 8F F1    JMP   0x13F9
(0122) #define		PORT_4						('D')
(0123) 
(0124) // These defines are used as transmission indicators.
(0125) #define		START_TRANSMIT				(252)	// Indicates the beginning of a transmission.
(0126) #define		END_TRANSMIT				(253)	// Indicates the end of a transmission.
(0127) #define		HELLO_BYTE					(200)	// Indicates master is ready to talk.
(0128) #define		ID_ASSIGNMENT				(201)	// Indicates an ID assignment from the master.
(0129) #define		ID_ASSIGN_OK				(202)	// Indicates an ID assignment is acknowledged.
(0130) #define		PING						(203)	// Indicates that someone is pinging someone else.
(0131) #define		CLEAR_CONFIG				(204)	// Indicates that the master is asking for a config clear.
(0132) #define		CONFIG_CLEARED				(205)	// Indicates that a module has cleared its own config.
(0133) #define		MASTER_ID					(0)		// The master node's ID.
(0134) #define		BROADCAST					(254)	// The broadcast ID for talking to all nodes.
(0135) #define		BLANK_MODULE_ID				(251)	// This is the ID of an unconfigured module.
(0136) 
(0137) // These defines are used to fill in the instruction we are using on the servo.
(0138) #define		PING_SERVO					(1)		// This is the instruction number for ping.
(0139) #define		READ_SERVO					(2)		// This is the instruction number for a read.
(0140) #define		WRITE_SERVO					(3)		// This is the instruction number for a write.
(0141) #define		RESET_SERVO					(6)		// This is the instruction to reset the servo EEPROM.
(0142) 
(0143) // These defines are used for transmission timing.
(0144) #define 	RX_TIMEOUT_DURATION			(5)		// This is receive wait time in 1 ms units.
(0145) 
(0146) // These defines are used for the initial probing stage, where receive waits are longer to make
(0147) // sure of transmission failure or success.
(0148) #define		BOOT_TIMEOUT				(200)	// This is boot wait time in 1 ms units.
(0149) #define		MAX_TIMEOUTS				(10)	// Number of timeouts allowed before hello mode exit.
(0150) 
(0151) // This is the maximum number of allowable modules per branch out from the master
(0152) #define		MAX_MODULES					(250)
(0153) 
1409: 10       PUSH  X
140A: 7C 0B 70 LCALL 0x0B70
140D: 62 D0 00 MOV   REG[208],0
1410: 20       POP   X
1411: 39 FF    CMP   A,255
1413: B0 E2    JNZ   0x14F6
(0154) #define		SERVO_START					(255)
(0155) 
1415: 10       PUSH  X
1416: 7C 0B 68 LCALL 0x0B68
1419: 20       POP   X
141A: 62 D0 00 MOV   REG[208],0
141D: 53 79    MOV   [PARAM],A
(0156) // This function receives a mode identifier as a parameter and toggles the
141F: 10       PUSH  X
1420: 7C 0B 68 LCALL 0x0B68
1423: 20       POP   X
1424: 62 D0 00 MOV   REG[208],0
1427: 53 79    MOV   [PARAM],A
(0157) // system configuration between receive and transmit modes for half duplex UART.
1429: 10       PUSH  X
142A: 7C 0B 68 LCALL 0x0B68
142D: 20       POP   X
142E: 62 D0 00 MOV   REG[208],0
1431: 53 79    MOV   [PARAM],A
(0158) void configToggle(int mode);
1433: 10       PUSH  X
1434: 7C 0B 68 LCALL 0x0B68
1437: 20       POP   X
1438: 62 D0 00 MOV   REG[208],0
143B: 53 79    MOV   [PARAM],A
(0159) 
143D: 10       PUSH  X
143E: 7C 0B 68 LCALL 0x0B68
1441: 20       POP   X
1442: 62 D0 00 MOV   REG[208],0
1445: 53 79    MOV   [PARAM],A
(0160) // This function pings the index passed to it. Returns 1 on success, 0 on fail.
1447: 51 79    MOV   A,[PARAM]
1449: 62 D0 00 MOV   REG[208],0
144C: 05 01    ADD   [X+1],A
144E: 0F 00 00 ADC   [X+0],0
(0161) int pingModule(int module_id);
1451: 10       PUSH  X
1452: 7C 0B 68 LCALL 0x0B68
1455: 20       POP   X
1456: 62 D0 00 MOV   REG[208],0
1459: 53 79    MOV   [PARAM],A
(0162) 
145B: 51 79    MOV   A,[PARAM]
145D: 62 D0 00 MOV   REG[208],0
1460: 07 01 00 ADD   [X+1],0
1463: 0D 00    ADC   [X+0],A
(0163) // This function assigns an ID to a module.
(0164) int assignID(int assigned_ID);
1465: 52 01    MOV   A,[X+1]
1467: 53 6E    MOV   [__r3],A
1469: 52 00    MOV   A,[X+0]
146B: 53 6F    MOV   [__r2],A
146D: 47 6F 80 TST   [__r2],128
1470: A0 09    JZ    0x147A
1472: 55 70 FF MOV   [__r1],255
1475: 55 71 FF MOV   [__r0],255
1478: 80 0A    JMP   0x1483
147A: 62 D0 00 MOV   REG[208],0
147D: 55 70 00 MOV   [__r1],0
1480: 55 71 00 MOV   [__r0],0
1483: 62 D0 00 MOV   REG[208],0
1486: 51 71    MOV   A,[__r0]
1488: 08       PUSH  A
1489: 51 70    MOV   A,[__r1]
148B: 08       PUSH  A
148C: 51 6F    MOV   A,[__r2]
148E: 08       PUSH  A
148F: 51 6E    MOV   A,[__r3]
1491: 08       PUSH  A
1492: 7C 23 FA LCALL __long2fp
1495: 18       POP   A
1496: 53 6E    MOV   [__r3],A
1498: 18       POP   A
1499: 53 6F    MOV   [__r2],A
149B: 18       POP   A
149C: 53 70    MOV   [__r1],A
149E: 18       POP   A
149F: 53 71    MOV   [__r0],A
14A1: 50 44    MOV   A,68
14A3: 08       PUSH  A
14A4: 50 7F    MOV   A,127
14A6: 08       PUSH  A
14A7: 50 C0    MOV   A,192
14A9: 08       PUSH  A
14AA: 50 00    MOV   A,0
14AC: 08       PUSH  A
14AD: 51 71    MOV   A,[__r0]
14AF: 08       PUSH  A
14B0: 51 70    MOV   A,[__r1]
14B2: 08       PUSH  A
14B3: 51 6F    MOV   A,[__r2]
14B5: 08       PUSH  A
14B6: 51 6E    MOV   A,[__r3]
14B8: 08       PUSH  A
14B9: 7C 21 1C LCALL __fpdiv
14BC: 18       POP   A
14BD: 53 6E    MOV   [__r3],A
14BF: 18       POP   A
14C0: 53 6F    MOV   [__r2],A
14C2: 18       POP   A
14C3: 53 70    MOV   [__r1],A
14C5: 18       POP   A
14C6: 38 FC    ADD   SP,252
14C8: 08       PUSH  A
14C9: 51 70    MOV   A,[__r1]
14CB: 08       PUSH  A
14CC: 51 6F    MOV   A,[__r2]
14CE: 08       PUSH  A
14CF: 51 6E    MOV   A,[__r3]
14D1: 08       PUSH  A
14D2: 50 43    MOV   A,67
14D4: 08       PUSH  A
14D5: 50 96    MOV   A,150
14D7: 08       PUSH  A
14D8: 50 00    MOV   A,0
14DA: 08       PUSH  A
14DB: 08       PUSH  A
14DC: 7C 21 FF LCALL __fpmul
14DF: 18       POP   A
14E0: 54 05    MOV   [X+5],A
14E2: 18       POP   A
14E3: 54 04    MOV   [X+4],A
14E5: 18       POP   A
14E6: 54 03    MOV   [X+3],A
14E8: 18       POP   A
14E9: 54 02    MOV   [X+2],A
14EB: 38 FC    ADD   SP,252
(0165) 
(0166) int validTransmission(void);
14ED: 62 D0 00 MOV   REG[208],0
14F0: 55 77 05 MOV   [TIMEOUT+1],5
14F3: 55 76 00 MOV   [TIMEOUT],0
14F6: 62 D0 00 MOV   REG[208],0
14F9: 51 77    MOV   A,[TIMEOUT+1]
14FB: 11 05    SUB   A,5
14FD: 51 76    MOV   A,[TIMEOUT]
14FF: 31 80    XOR   A,128
1501: 19 80    SBB   A,128
1503: CF 05    JC    0x1409
(0167) 
(0168) void decodeTransmission(void);
(0169) 
(0170) void sayHello(void);
1505: 10       PUSH  X
1506: 7C 0A 85 LCALL 0x0A85
1509: 20       POP   X
(0171) 
150A: 62 D0 00 MOV   REG[208],0
150D: 55 77 00 MOV   [TIMEOUT+1],0
1510: 55 76 00 MOV   [TIMEOUT],0
(0172) void moveMotor(int motor_id);
(0173) 
1513: 10       PUSH  X
1514: 7C 0D 48 LCALL 0x0D48
1517: 20       POP   X
(0174) void servoInstruction(char id, char length, char instruction, char address, char value);
1518: 10       PUSH  X
1519: 50 00    MOV   A,0
151B: 5C       MOV   X,A
151C: 7C 0D BB LCALL 0x0DBB
151F: 20       POP   X
(0175) 
1520: 10       PUSH  X
1521: 50 01    MOV   A,1
1523: 08       PUSH  A
1524: 50 B1    MOV   A,177
1526: 5C       MOV   X,A
1527: 18       POP   A
1528: 7C 0C 36 LCALL 0x0C36
152B: 20       POP   X
(0176) int clearConfig(int module_id);
152C: 10       PUSH  X
152D: 50 00    MOV   A,0
152F: 5C       MOV   X,A
1530: 7C 0D BB LCALL 0x0DBB
1533: 20       POP   X
(0177) // This function checks the current mode and unloads the configuration for that mode.
1534: 10       PUSH  X
1535: 50 01    MOV   A,1
1537: 08       PUSH  A
1538: 50 A9    MOV   A,169
153A: 5C       MOV   X,A
153B: 18       POP   A
153C: 7C 0C 36 LCALL 0x0C36
153F: 20       POP   X
(0178) void unloadAllConfigs(void);
1540: 10       PUSH  X
1541: 57 07    MOV   X,7
1543: 50 00    MOV   A,0
1545: 7C 0D BB LCALL 0x0DBB
1548: 20       POP   X
(0179) // This function unloads the configuration corresponding to the number passed to it.
1549: 62 D0 00 MOV   REG[208],0
154C: 50 07    MOV   A,7
154E: 08       PUSH  A
154F: 10       PUSH  X
1550: 52 02    MOV   A,[X+2]
1552: 08       PUSH  A
1553: 52 03    MOV   A,[X+3]
1555: 08       PUSH  A
1556: 52 04    MOV   A,[X+4]
1558: 08       PUSH  A
1559: 52 05    MOV   A,[X+5]
155B: 08       PUSH  A
155C: 7C 25 A6 LCALL _ftoa
155F: 38 FA    ADD   SP,250
1561: 10       PUSH  X
1562: 62 D0 00 MOV   REG[208],0
1565: 51 71    MOV   A,[__r0]
1567: 08       PUSH  A
1568: 51 70    MOV   A,[__r1]
156A: 5C       MOV   X,A
156B: 18       POP   A
156C: 7C 0C 72 LCALL 0x0C72
156F: 20       POP   X
(0180) void unloadConfig(int config_num);
(0181) // Initialization function for the slave module controllers.
1570: 50 00    MOV   A,0
1572: 08       PUSH  A
1573: 50 02    MOV   A,2
1575: 08       PUSH  A
1576: 96 4F    CALL  _configToggle
1578: 38 FE    ADD   SP,254
(0182) void initializeSlaves(void);
157A: 38 FA    ADD   SP,250
157C: 20       POP   X
157D: 8F FF    JMP   0x157D
(0183) // Static wait time of approximately 50 microseconds for use after starting a transmission.
(0184) void xmitWait(void);
(0185) 
(0186) // This flag is set if there is a timeout.
_pingModule:
  response             --> X+0
  module_id            --> X-5
157F: 10       PUSH  X
1580: 4F       MOV   X,SP
1581: 38 02    ADD   SP,2
(0187) int TIMEOUT;
1583: 56 01 00 MOV   [X+1],0
1586: 56 00 00 MOV   [X+0],0
(0188) 
(0189) int NUM_MODULES;			// Stores the number of modules that have been discovered.
1589: 50 00    MOV   A,0
158B: 08       PUSH  A
158C: 08       PUSH  A
158D: 96 38    CALL  _configToggle
158F: 38 FE    ADD   SP,254
(0190) char COMMAND_SOURCE;		// Stores who the current command is from.
(0191) char COMMAND_DESTINATION;	// Stores who the current command is for.
(0192) char COMMAND_TYPE;			// Stores the type of command that was just read.
1591: 10       PUSH  X
1592: 50 FC    MOV   A,252
1594: 7C 09 F4 LCALL 0x09F4
1597: 20       POP   X
(0193) char PARAM;					// Stores a parameter that accompanies the command (if any).
1598: 10       PUSH  X
1599: 50 FC    MOV   A,252
159B: 7C 09 F4 LCALL 0x09F4
159E: 20       POP   X
(0194) 
159F: 10       PUSH  X
15A0: 50 00    MOV   A,0
15A2: 7C 09 F4 LCALL 0x09F4
15A5: 20       POP   X
(0195) int STATE;					// Stores the current configuration state of the system.
15A6: 62 D0 00 MOV   REG[208],0
15A9: 52 FC    MOV   A,[X-4]
15AB: 10       PUSH  X
15AC: 7C 09 F4 LCALL 0x09F4
15AF: 20       POP   X
(0196) 
15B0: 10       PUSH  X
15B1: 50 CB    MOV   A,203
15B3: 7C 09 F4 LCALL 0x09F4
15B6: 20       POP   X
(0197) void main()
15B7: 10       PUSH  X
15B8: 50 FD    MOV   A,253
15BA: 7C 09 F4 LCALL 0x09F4
15BD: 20       POP   X
(0198) {	
15BE: 10       PUSH  X
15BF: 50 FD    MOV   A,253
15C1: 7C 09 F4 LCALL 0x09F4
15C4: 20       POP   X
(0199) 	int tempValue = 0;
(0200) 	float angle = 0;
(0201) 	
15C5: 10       PUSH  X
15C6: 7C 09 C7 LCALL 0x09C7
15C9: 62 D0 00 MOV   REG[208],0
15CC: 20       POP   X
15CD: 53 71    MOV   [__r0],A
15CF: 47 71 20 TST   [__r0],32
15D2: AF F2    JZ    0x15C5
(0202) 	NUM_MODULES = 0;
(0203) 	
15D4: 7C 1F 08 LCALL _xmitWait
(0204) 	M8C_EnableGInt;			// Turn on global interrupts for the transmission timeout timer.
(0205) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO); //activate GPIO ISR
15D7: 50 00    MOV   A,0
15D9: 08       PUSH  A
15DA: 50 01    MOV   A,1
15DC: 08       PUSH  A
15DD: 95 E8    CALL  _configToggle
15DF: 38 FE    ADD   SP,254
(0206) 	
(0207) 	unloadAllConfigs();
15E1: 10       PUSH  X
15E2: 7C 0A 85 LCALL 0x0A85
15E5: 20       POP   X
(0208) 	configToggle(RX_MODE);
15E6: 62 D0 00 MOV   REG[208],0
15E9: 55 77 00 MOV   [TIMEOUT+1],0
15EC: 55 76 00 MOV   [TIMEOUT],0
(0209) 	
15EF: 10       PUSH  X
15F0: 7C 0A 81 LCALL 0x0A81
15F3: 20       POP   X
15F4: 80 48    JMP   0x163D
(0210) 	// Sit and wait for the worst case setup time to occur.
(0211) 	while(TIMEOUT < BOOT_TIMEOUT) { }
(0212) 	
(0213) 	// Initialize all of the slave modules.
15F6: 10       PUSH  X
15F7: 7C 0B 70 LCALL 0x0B70
15FA: 62 D0 00 MOV   REG[208],0
15FD: 20       POP   X
15FE: 39 FC    CMP   A,252
1600: B0 3C    JNZ   0x163D
(0214) 	initializeSlaves();
(0215) 	
1602: 92 F9    CALL  _validTransmission
1604: 62 D0 00 MOV   REG[208],0
1607: 3C 71 00 CMP   [__r0],0
160A: B0 06    JNZ   0x1611
160C: 3C 70 00 CMP   [__r1],0
160F: A0 2D    JZ    0x163D
(0216) 	while(1)
(0217) 	{	
1611: 62 D0 00 MOV   REG[208],0
1614: 3C 7D CB CMP   [COMMAND_TYPE],203
1617: B0 25    JNZ   0x163D
(0218) 		while(!COMP_SERIAL_bCmdCheck()) { }
(0219) 		
(0220) 		decodeTransmission();
1619: 62 D0 00 MOV   REG[208],0
161C: 3C 7B 00 CMP   [COMMAND_DESTINATION],0
161F: B0 1D    JNZ   0x163D
(0221) 	}
(0222) 	{
1621: 62 D0 00 MOV   REG[208],0
1624: 51 7C    MOV   A,[COMMAND_SOURCE]
1626: 62 D0 00 MOV   REG[208],0
1629: 53 70    MOV   [__r1],A
162B: 50 00    MOV   A,0
162D: 3B FB    CMP   A,[X-5]
162F: B0 0D    JNZ   0x163D
1631: 51 70    MOV   A,[__r1]
1633: 3B FC    CMP   A,[X-4]
1635: B0 07    JNZ   0x163D
(0223) //		tempValue = 255-((NUM_MODULES + 4 + 2 + 36 + 2)%256);
(0224) //		
1637: 56 01 01 MOV   [X+1],1
163A: 56 00 00 MOV   [X+0],0
163D: 62 D0 00 MOV   REG[208],0
1640: 51 77    MOV   A,[TIMEOUT+1]
1642: 11 05    SUB   A,5
1644: 51 76    MOV   A,[TIMEOUT]
1646: 31 80    XOR   A,128
1648: 19 80    SBB   A,128
164A: D0 0B    JNC   0x1656
164C: 3D 00 00 CMP   [X+0],0
164F: B0 06    JNZ   0x1656
1651: 3D 01 00 CMP   [X+1],0
1654: AF A1    JZ    0x15F6
(0225) //		configToggle(TX_MODE);			// Toggle into TX mode.
(0226) //		
(0227) //		TRANSMIT_PutChar(255);			// Start byte one
(0228) //		TRANSMIT_PutChar(255);			// Start byte two
(0229) //		TRANSMIT_PutChar(NUM_MODULES);	// Max servo ID
(0230) //		TRANSMIT_PutChar(4);			// The instruction length.
(0231) //		TRANSMIT_PutChar(2);			// The instruction to carry out.
(0232) //		TRANSMIT_PutChar(36);			// The address to read/write from/to.
1656: 10       PUSH  X
1657: 7C 0A 85 LCALL 0x0A85
165A: 20       POP   X
(0233) //		TRANSMIT_PutChar(2);			// The value to write or number of bytes to read.
165B: 62 D0 00 MOV   REG[208],0
165E: 55 77 00 MOV   [TIMEOUT+1],0
1661: 55 76 00 MOV   [TIMEOUT],0
(0234) //		TRANSMIT_PutChar(tempValue);	// This is the checksum.
1664: 10       PUSH  X
1665: 7C 0A 81 LCALL 0x0A81
1668: 20       POP   X
(0235) //		
(0236) //		// Wait for the transmission to finish.
1669: 62 D0 00 MOV   REG[208],0
166C: 52 01    MOV   A,[X+1]
166E: 53 70    MOV   [__r1],A
1670: 52 00    MOV   A,[X+0]
1672: 53 71    MOV   [__r0],A
1674: 38 FE    ADD   SP,254
1676: 20       POP   X
1677: 7F       RET   
(0237) //		while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
(0238) //		
(0239) //		xmitWait();
(0240) 		servoInstruction(NUM_MODULES,4,2,36,2);
_assignID:
  success              --> X+0
  assigned_ID          --> X-5
1678: 10       PUSH  X
1679: 4F       MOV   X,SP
167A: 38 02    ADD   SP,2
(0241) 		
167C: 56 01 00 MOV   [X+1],0
167F: 56 00 00 MOV   [X+0],0
(0242) 		tempValue = 0;
(0243) 		
1682: 50 00    MOV   A,0
1684: 08       PUSH  A
1685: 08       PUSH  A
1686: 95 3F    CALL  _configToggle
1688: 38 FE    ADD   SP,254
(0244) 		configToggle(RX_MODE);	// Listen for the response.
(0245) 	
(0246) 		RX_TIMEOUT_Stop();
168A: 10       PUSH  X
168B: 50 FC    MOV   A,252
168D: 7C 09 F4 LCALL 0x09F4
1690: 20       POP   X
(0247) 		TIMEOUT = 0;
1691: 10       PUSH  X
1692: 50 FC    MOV   A,252
1694: 7C 09 F4 LCALL 0x09F4
1697: 20       POP   X
(0248) 		RX_TIMEOUT_Start();
1698: 10       PUSH  X
1699: 50 00    MOV   A,0
169B: 7C 09 F4 LCALL 0x09F4
169E: 20       POP   X
(0249) 		
169F: 10       PUSH  X
16A0: 50 FB    MOV   A,251
16A2: 7C 09 F4 LCALL 0x09F4
16A5: 20       POP   X
(0250) 		while(TIMEOUT < RX_TIMEOUT_DURATION)
16A6: 10       PUSH  X
16A7: 50 C9    MOV   A,201
16A9: 7C 09 F4 LCALL 0x09F4
16AC: 20       POP   X
(0251) 		{
16AD: 62 D0 00 MOV   REG[208],0
16B0: 52 FC    MOV   A,[X-4]
16B2: 10       PUSH  X
16B3: 7C 09 F4 LCALL 0x09F4
16B6: 20       POP   X
(0252) 			if(RECEIVE_cReadChar() == 255)
16B7: 10       PUSH  X
16B8: 50 FD    MOV   A,253
16BA: 7C 09 F4 LCALL 0x09F4
16BD: 20       POP   X
(0253) 			{
16BE: 10       PUSH  X
16BF: 50 FD    MOV   A,253
16C1: 7C 09 F4 LCALL 0x09F4
16C4: 20       POP   X
(0254) 				PARAM = RECEIVE_cGetChar();
(0255) 				PARAM = RECEIVE_cGetChar();
(0256) 				PARAM = RECEIVE_cGetChar();
16C5: 10       PUSH  X
16C6: 7C 09 C7 LCALL 0x09C7
16C9: 62 D0 00 MOV   REG[208],0
16CC: 20       POP   X
16CD: 53 71    MOV   [__r0],A
16CF: 47 71 20 TST   [__r0],32
16D2: AF F2    JZ    0x16C5
(0257) 				PARAM = RECEIVE_cGetChar();
(0258) 				PARAM = RECEIVE_cGetChar();
16D4: 7C 1F 08 LCALL _xmitWait
(0259) 				tempValue += PARAM;
(0260) 				PARAM = RECEIVE_cGetChar();
16D7: 50 00    MOV   A,0
16D9: 08       PUSH  A
16DA: 50 01    MOV   A,1
16DC: 08       PUSH  A
16DD: 94 E8    CALL  _configToggle
16DF: 38 FE    ADD   SP,254
(0261) 				tempValue += PARAM*256;
(0262) 				
16E1: 10       PUSH  X
16E2: 7C 0A 85 LCALL 0x0A85
16E5: 20       POP   X
(0263) 				angle = (((float)tempValue)/1023.0)*300.0;
16E6: 62 D0 00 MOV   REG[208],0
16E9: 55 77 00 MOV   [TIMEOUT+1],0
16EC: 55 76 00 MOV   [TIMEOUT],0
(0264) 				
16EF: 10       PUSH  X
16F0: 7C 0A 81 LCALL 0x0A81
16F3: 20       POP   X
16F4: 80 48    JMP   0x173D
(0265) 				TIMEOUT = RX_TIMEOUT_DURATION;
(0266) 			}
(0267) 		}
(0268) 		
16F6: 10       PUSH  X
16F7: 7C 0B 70 LCALL 0x0B70
16FA: 62 D0 00 MOV   REG[208],0
16FD: 20       POP   X
16FE: 39 FC    CMP   A,252
1700: B0 3C    JNZ   0x173D
(0269) 		RX_TIMEOUT_Stop();
(0270) 		TIMEOUT = 0;
1702: 91 F9    CALL  _validTransmission
1704: 62 D0 00 MOV   REG[208],0
1707: 3C 71 00 CMP   [__r0],0
170A: B0 06    JNZ   0x1711
170C: 3C 70 00 CMP   [__r1],0
170F: A0 2D    JZ    0x173D
(0271) 		
(0272) 		LCD_2_Start();
1711: 62 D0 00 MOV   REG[208],0
1714: 3C 7D CA CMP   [COMMAND_TYPE],202
1717: B0 25    JNZ   0x173D
(0273) 		LCD_2_Position(0,0);
(0274) 		LCD_2_PrCString("                ");
(0275) 		LCD_2_Position(0,0);
1719: 62 D0 00 MOV   REG[208],0
171C: 3C 7B 00 CMP   [COMMAND_DESTINATION],0
171F: B0 1D    JNZ   0x173D
(0276) 		LCD_2_PrCString("Angle: ");
(0277) 		LCD_2_Position(0,7);
1721: 62 D0 00 MOV   REG[208],0
1724: 51 7C    MOV   A,[COMMAND_SOURCE]
1726: 62 D0 00 MOV   REG[208],0
1729: 53 70    MOV   [__r1],A
172B: 50 00    MOV   A,0
172D: 3B FB    CMP   A,[X-5]
172F: B0 0D    JNZ   0x173D
1731: 51 70    MOV   A,[__r1]
1733: 3B FC    CMP   A,[X-4]
1735: B0 07    JNZ   0x173D
(0278) 		LCD_2_PrString(ftoa(angle,&tempValue));
(0279) 		
1737: 56 01 01 MOV   [X+1],1
173A: 56 00 00 MOV   [X+0],0
173D: 62 D0 00 MOV   REG[208],0
1740: 51 77    MOV   A,[TIMEOUT+1]
1742: 11 05    SUB   A,5
1744: 51 76    MOV   A,[TIMEOUT]
1746: 31 80    XOR   A,128
1748: 19 80    SBB   A,128
174A: D0 0B    JNC   0x1756
174C: 3D 00 00 CMP   [X+0],0
174F: B0 06    JNZ   0x1756
1751: 3D 01 00 CMP   [X+1],0
1754: AF A1    JZ    0x16F6
(0280) 		configToggle(PC_MODE);
(0281) 	}
(0282) }
(0283) 
(0284) int pingModule(int module_id)
(0285) {
(0286) 	int response = 0;
(0287) 	
1756: 10       PUSH  X
1757: 7C 0D 48 LCALL 0x0D48
175A: 20       POP   X
(0288) 	configToggle(TX_MODE);	// Toggle into TX mode.
175B: 10       PUSH  X
175C: 50 00    MOV   A,0
175E: 5C       MOV   X,A
175F: 7C 0D BB LCALL 0x0DBB
1762: 20       POP   X
(0289) 			
1763: 10       PUSH  X
1764: 62 D0 00 MOV   REG[208],0
1767: 51 72    MOV   A,[NUM_MODULES]
1769: 08       PUSH  A
176A: 51 73    MOV   A,[NUM_MODULES+1]
176C: 20       POP   X
176D: 7C 0C 6B LCALL 0x0C6B
1770: 20       POP   X
(0290) 	// Transmit a hello.
1771: 10       PUSH  X
1772: 57 05    MOV   X,5
1774: 50 00    MOV   A,0
1776: 7C 0D BB LCALL 0x0DBB
1779: 20       POP   X
(0291) 	TRANSMIT_PutChar(START_TRANSMIT);
177A: 10       PUSH  X
177B: 50 01    MOV   A,1
177D: 08       PUSH  A
177E: 50 A0    MOV   A,160
1780: 5C       MOV   X,A
1781: 18       POP   A
1782: 7C 0C 36 LCALL 0x0C36
(0292) 	TRANSMIT_PutChar(START_TRANSMIT);
(0293) 	TRANSMIT_PutChar(MASTER_ID);
1785: 7C 0A 85 LCALL 0x0A85
1788: 20       POP   X
(0294) 	TRANSMIT_PutChar(module_id);
1789: 62 D0 00 MOV   REG[208],0
178C: 55 77 00 MOV   [TIMEOUT+1],0
178F: 55 76 00 MOV   [TIMEOUT],0
(0295) 	TRANSMIT_PutChar(PING);
1792: 10       PUSH  X
1793: 7C 0A 81 LCALL 0x0A81
1796: 20       POP   X
(0296) 	TRANSMIT_PutChar(END_TRANSMIT);
(0297) 	TRANSMIT_PutChar(END_TRANSMIT);
1797: 62 D0 00 MOV   REG[208],0
179A: 52 01    MOV   A,[X+1]
179C: 53 70    MOV   [__r1],A
179E: 52 00    MOV   A,[X+0]
17A0: 53 71    MOV   [__r0],A
17A2: 38 FE    ADD   SP,254
17A4: 20       POP   X
17A5: 7F       RET   
(0298) 	
(0299) 	// Wait for the transmission to finish.
(0300) 	while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
(0301) 	
_clearConfig:
  response             --> X+0
  module_id            --> X-5
17A6: 10       PUSH  X
17A7: 4F       MOV   X,SP
17A8: 38 02    ADD   SP,2
(0302) 	xmitWait();
17AA: 56 01 00 MOV   [X+1],0
17AD: 56 00 00 MOV   [X+0],0
(0303) 	
(0304) 	configToggle(RX_MODE);	// Listen for the response.
17B0: 50 00    MOV   A,0
17B2: 08       PUSH  A
17B3: 08       PUSH  A
17B4: 94 11    CALL  _configToggle
17B6: 38 FE    ADD   SP,254
(0305) 	
(0306) 	RX_TIMEOUT_Stop();
(0307) 	TIMEOUT = 0;
17B8: 10       PUSH  X
17B9: 50 FC    MOV   A,252
17BB: 7C 09 F4 LCALL 0x09F4
17BE: 20       POP   X
(0308) 	RX_TIMEOUT_Start();
17BF: 10       PUSH  X
17C0: 50 FC    MOV   A,252
17C2: 7C 09 F4 LCALL 0x09F4
17C5: 20       POP   X
(0309) 	
17C6: 10       PUSH  X
17C7: 50 00    MOV   A,0
17C9: 7C 09 F4 LCALL 0x09F4
17CC: 20       POP   X
(0310) 	while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
17CD: 62 D0 00 MOV   REG[208],0
17D0: 52 FC    MOV   A,[X-4]
17D2: 10       PUSH  X
17D3: 7C 09 F4 LCALL 0x09F4
17D6: 20       POP   X
(0311) 	{
17D7: 10       PUSH  X
17D8: 50 CC    MOV   A,204
17DA: 7C 09 F4 LCALL 0x09F4
17DD: 20       POP   X
(0312) 		if(RECEIVE_cReadChar() == START_TRANSMIT)
17DE: 10       PUSH  X
17DF: 50 FD    MOV   A,253
17E1: 7C 09 F4 LCALL 0x09F4
17E4: 20       POP   X
(0313) 		{	
17E5: 10       PUSH  X
17E6: 50 FD    MOV   A,253
17E8: 7C 09 F4 LCALL 0x09F4
17EB: 20       POP   X
(0314) 			if(validTransmission())
(0315) 			{
(0316) 				if(COMMAND_TYPE == PING)	// This is the response we are looking for.
17EC: 10       PUSH  X
17ED: 7C 09 C7 LCALL 0x09C7
17F0: 62 D0 00 MOV   REG[208],0
17F3: 20       POP   X
17F4: 53 71    MOV   [__r0],A
17F6: 47 71 20 TST   [__r0],32
17F9: AF F2    JZ    0x17EC
(0317) 				{
(0318) 					// If this is for me, check who it was from.
17FB: 97 0B    CALL  _xmitWait
(0319) 					if(COMMAND_DESTINATION == MASTER_ID)
(0320) 					{
17FD: 50 00    MOV   A,0
17FF: 08       PUSH  A
1800: 50 01    MOV   A,1
1802: 08       PUSH  A
1803: 93 C2    CALL  _configToggle
1805: 38 FE    ADD   SP,254
(0321) 						if(COMMAND_SOURCE == module_id)
(0322) 						{
1807: 3D FB 00 CMP   [X-5],0
180A: B0 06    JNZ   0x1811
180C: 3D FC FE CMP   [X-4],254
180F: A0 89    JZ    0x1899
(0323) 							response = 1;
(0324) 						}
1811: 10       PUSH  X
1812: 7C 0A 85 LCALL 0x0A85
1815: 20       POP   X
(0325) 					}
1816: 62 D0 00 MOV   REG[208],0
1819: 55 77 00 MOV   [TIMEOUT+1],0
181C: 55 76 00 MOV   [TIMEOUT],0
(0326) 				}
181F: 10       PUSH  X
1820: 7C 0A 81 LCALL 0x0A81
1823: 20       POP   X
1824: 80 48    JMP   0x186D
(0327) 			}
(0328) 		}
(0329) 	}
(0330) 	
1826: 10       PUSH  X
1827: 7C 0B 70 LCALL 0x0B70
182A: 62 D0 00 MOV   REG[208],0
182D: 20       POP   X
182E: 39 FC    CMP   A,252
1830: B0 3C    JNZ   0x186D
(0331) 	RX_TIMEOUT_Stop();
(0332) 	TIMEOUT = 0;
1832: 90 C9    CALL  _validTransmission
1834: 62 D0 00 MOV   REG[208],0
1837: 3C 71 00 CMP   [__r0],0
183A: B0 06    JNZ   0x1841
183C: 3C 70 00 CMP   [__r1],0
183F: A0 2D    JZ    0x186D
(0333) 	RX_TIMEOUT_Start();
(0334) 	
1841: 62 D0 00 MOV   REG[208],0
1844: 3C 7D CD CMP   [COMMAND_TYPE],205
1847: B0 25    JNZ   0x186D
(0335) 	return response;
(0336) }
(0337) 
1849: 62 D0 00 MOV   REG[208],0
184C: 3C 7B 00 CMP   [COMMAND_DESTINATION],0
184F: B0 1D    JNZ   0x186D
(0338) int assignID(int assigned_ID)
(0339) {
1851: 62 D0 00 MOV   REG[208],0
1854: 51 7C    MOV   A,[COMMAND_SOURCE]
1856: 62 D0 00 MOV   REG[208],0
1859: 53 70    MOV   [__r1],A
185B: 50 00    MOV   A,0
185D: 3B FB    CMP   A,[X-5]
185F: B0 0D    JNZ   0x186D
1861: 51 70    MOV   A,[__r1]
1863: 3B FC    CMP   A,[X-4]
1865: B0 07    JNZ   0x186D
(0340) 	int success = 0;		// Stores 0 on fail, 1 on success.
(0341) 	
1867: 56 01 01 MOV   [X+1],1
186A: 56 00 00 MOV   [X+0],0
186D: 62 D0 00 MOV   REG[208],0
1870: 51 77    MOV   A,[TIMEOUT+1]
1872: 11 05    SUB   A,5
1874: 51 76    MOV   A,[TIMEOUT]
1876: 31 80    XOR   A,128
1878: 19 80    SBB   A,128
187A: D0 0B    JNC   0x1886
187C: 3D 00 00 CMP   [X+0],0
187F: B0 06    JNZ   0x1886
1881: 3D 01 00 CMP   [X+1],0
1884: AF A1    JZ    0x1826
(0342) 	configToggle(TX_MODE);	// Switch to TX mode.
(0343) 
(0344) 	// Transmit the assignment.
(0345) 	TRANSMIT_PutChar(START_TRANSMIT);
(0346) 	TRANSMIT_PutChar(START_TRANSMIT);
(0347) 	TRANSMIT_PutChar(MASTER_ID);
(0348) 	TRANSMIT_PutChar(BLANK_MODULE_ID);
(0349) 	TRANSMIT_PutChar(ID_ASSIGNMENT);
1886: 10       PUSH  X
1887: 7C 0A 85 LCALL 0x0A85
188A: 20       POP   X
(0350) 	TRANSMIT_PutChar(assigned_ID);
188B: 62 D0 00 MOV   REG[208],0
188E: 55 77 00 MOV   [TIMEOUT+1],0
1891: 55 76 00 MOV   [TIMEOUT],0
(0351) 	TRANSMIT_PutChar(END_TRANSMIT);
1894: 10       PUSH  X
1895: 7C 0A 81 LCALL 0x0A81
1898: 20       POP   X
(0352) 	TRANSMIT_PutChar(END_TRANSMIT);
(0353) 	
(0354) 	// Wait for the transmission to finish.
1899: 62 D0 00 MOV   REG[208],0
189C: 52 01    MOV   A,[X+1]
189E: 53 70    MOV   [__r1],A
18A0: 52 00    MOV   A,[X+0]
18A2: 53 71    MOV   [__r0],A
18A4: 38 FE    ADD   SP,254
18A6: 20       POP   X
18A7: 7F       RET   
(0355) 	while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
(0356) 	
(0357) 	xmitWait();
(0358) 	
(0359) 	configToggle(RX_MODE);	// Switch back to receive mode.
(0360) 	
_sayHello:
18A8: 50 00    MOV   A,0
18AA: 08       PUSH  A
18AB: 08       PUSH  A
18AC: 93 19    CALL  _configToggle
18AE: 38 FE    ADD   SP,254
(0361) 	RX_TIMEOUT_Stop();
(0362) 	TIMEOUT = 0;
(0363) 	RX_TIMEOUT_Start();
18B0: 10       PUSH  X
18B1: 50 FC    MOV   A,252
18B3: 7C 09 F4 LCALL 0x09F4
18B6: 20       POP   X
(0364) 	
18B7: 10       PUSH  X
18B8: 50 FC    MOV   A,252
18BA: 7C 09 F4 LCALL 0x09F4
18BD: 20       POP   X
(0365) 	while((TIMEOUT < RX_TIMEOUT_DURATION) && (!success))
18BE: 10       PUSH  X
18BF: 50 00    MOV   A,0
18C1: 7C 09 F4 LCALL 0x09F4
18C4: 20       POP   X
(0366) 	{
18C5: 10       PUSH  X
18C6: 50 FB    MOV   A,251
18C8: 7C 09 F4 LCALL 0x09F4
18CB: 20       POP   X
(0367) 		if(RECEIVE_cReadChar() == START_TRANSMIT)
18CC: 10       PUSH  X
18CD: 50 C8    MOV   A,200
18CF: 7C 09 F4 LCALL 0x09F4
18D2: 20       POP   X
(0368) 		{	
18D3: 10       PUSH  X
18D4: 50 FD    MOV   A,253
18D6: 7C 09 F4 LCALL 0x09F4
18D9: 20       POP   X
(0369) 			if(validTransmission())
18DA: 10       PUSH  X
18DB: 50 FD    MOV   A,253
18DD: 7C 09 F4 LCALL 0x09F4
18E0: 20       POP   X
(0370) 			{
(0371) 				if(COMMAND_TYPE == ID_ASSIGN_OK)	// This is the response we are looking for.
(0372) 				{
18E1: 10       PUSH  X
18E2: 7C 09 C7 LCALL 0x09C7
18E5: 62 D0 00 MOV   REG[208],0
18E8: 20       POP   X
18E9: 53 71    MOV   [__r0],A
18EB: 47 71 20 TST   [__r0],32
18EE: AF F2    JZ    0x18E1
(0373) 					// If this is for me, check who it was from.
(0374) 					if(COMMAND_DESTINATION == MASTER_ID)
18F0: 96 16    CALL  _xmitWait
(0375) 					{
(0376) 						if(COMMAND_SOURCE == assigned_ID)
18F2: 50 00    MOV   A,0
18F4: 08       PUSH  A
18F5: 50 01    MOV   A,1
18F7: 08       PUSH  A
18F8: 92 CD    CALL  _configToggle
18FA: 38 FE    ADD   SP,254
18FC: 7F       RET   
(0377) 						{
(0378) 							success = 1;
(0379) 						}
(0380) 					}
(0381) 				}
_validTransmission:
  valid_transmit       --> X+0
18FD: 10       PUSH  X
18FE: 4F       MOV   X,SP
18FF: 38 02    ADD   SP,2
(0382) 			}
1901: 56 01 00 MOV   [X+1],0
1904: 56 00 00 MOV   [X+0],0
(0383) 		}
(0384) 	}
1907: 10       PUSH  X
1908: 7C 0B 68 LCALL 0x0B68
190B: 62 D0 00 MOV   REG[208],0
190E: 20       POP   X
190F: 39 FC    CMP   A,252
1911: B0 2F    JNZ   0x1941
(0385) 	
(0386) 	LCD_2_Start();
1913: 10       PUSH  X
1914: 7C 0B 68 LCALL 0x0B68
1917: 20       POP   X
1918: 62 D0 00 MOV   REG[208],0
191B: 53 7C    MOV   [COMMAND_SOURCE],A
(0387) 	LCD_2_Position(0,0);
191D: 10       PUSH  X
191E: 7C 0B 68 LCALL 0x0B68
1921: 20       POP   X
1922: 62 D0 00 MOV   REG[208],0
1925: 53 7B    MOV   [COMMAND_DESTINATION],A
(0388) 	LCD_2_PrHexInt(NUM_MODULES);
1927: 10       PUSH  X
1928: 7C 0B 68 LCALL 0x0B68
192B: 20       POP   X
192C: 62 D0 00 MOV   REG[208],0
192F: 53 7D    MOV   [COMMAND_TYPE],A
(0389) 	LCD_2_Position(0,5);
1931: 10       PUSH  X
1932: 7C 0B 68 LCALL 0x0B68
1935: 20       POP   X
1936: 62 D0 00 MOV   REG[208],0
1939: 53 79    MOV   [PARAM],A
(0390) 	LCD_2_PrCString("Modules!");
(0391) 	
193B: 56 01 01 MOV   [X+1],1
193E: 56 00 00 MOV   [X+0],0
(0392) 	RX_TIMEOUT_Stop();
(0393) 	TIMEOUT = 0;
(0394) 	RX_TIMEOUT_Start();
1941: 62 D0 00 MOV   REG[208],0
1944: 52 01    MOV   A,[X+1]
1946: 53 70    MOV   [__r1],A
1948: 52 00    MOV   A,[X+0]
194A: 53 71    MOV   [__r0],A
194C: 38 FE    ADD   SP,254
194E: 20       POP   X
194F: 7F       RET   
(0395) 	
(0396) 	return success;
(0397) }
(0398) 
(0399) int clearConfig(int module_id)
_decodeTransmission:
  tempByte             --> X+7
  angle                --> X+5
  ID                   --> X+4
  total                --> X+2
  param                --> X+0
1950: 10       PUSH  X
1951: 4F       MOV   X,SP
1952: 38 08    ADD   SP,8
(0400) {
(0401) 	int response = 0;
(0402) 	
(0403) 	configToggle(TX_MODE);	// Toggle into TX mode.
(0404) 			
1954: 56 03 00 MOV   [X+3],0
1957: 56 02 00 MOV   [X+2],0
(0405) 	// Transmit a hello.
(0406) 	TRANSMIT_PutChar(START_TRANSMIT);
195A: 10       PUSH  X
195B: 7C 13 4A LCALL 0x134A
195E: 62 D0 00 MOV   REG[208],0
1961: 53 71    MOV   [__r0],A
1963: 5A 70    MOV   [__r1],X
1965: 20       POP   X
1966: 51 70    MOV   A,[__r1]
1968: 54 01    MOV   [X+1],A
196A: 51 71    MOV   A,[__r0]
196C: 54 00    MOV   [X+0],A
196E: 3C 71 00 CMP   [__r0],0
1971: B0 06    JNZ   0x1978
1973: 3C 70 00 CMP   [__r1],0
1976: A1 B5    JZ    0x1B2C
(0407) 	TRANSMIT_PutChar(START_TRANSMIT);
(0408) 	TRANSMIT_PutChar(MASTER_ID);
1978: 62 D0 00 MOV   REG[208],0
197B: 52 01    MOV   A,[X+1]
197D: 53 70    MOV   [__r1],A
197F: 52 00    MOV   A,[X+0]
1981: 60 D4    MOV   REG[212],A
1983: 3E 70    MVI   A,[__r1]
1985: 53 70    MOV   [__r1],A
1987: 55 71 00 MOV   [__r0],0
198A: 3C 71 00 CMP   [__r0],0
198D: B0 05    JNZ   0x1993
198F: 39 77    CMP   A,119
1991: A0 0E    JZ    0x19A0
1993: 62 D0 00 MOV   REG[208],0
1996: 3C 71 00 CMP   [__r0],0
1999: B0 26    JNZ   0x19C0
199B: 3C 70 57 CMP   [__r1],87
199E: B0 21    JNZ   0x19C0
(0409) 	TRANSMIT_PutChar(module_id);
(0410) 	TRANSMIT_PutChar(CLEAR_CONFIG);
19A0: 10       PUSH  X
19A1: 7C 13 4A LCALL 0x134A
19A4: 62 D0 00 MOV   REG[208],0
19A7: 53 71    MOV   [__r0],A
19A9: 5A 70    MOV   [__r1],X
19AB: 20       POP   X
19AC: 51 70    MOV   A,[__r1]
19AE: 54 01    MOV   [X+1],A
19B0: 51 71    MOV   A,[__r0]
19B2: 54 00    MOV   [X+0],A
19B4: 3C 71 00 CMP   [__r0],0
19B7: B0 06    JNZ   0x19BE
19B9: 3C 70 00 CMP   [__r1],0
19BC: A1 6F    JZ    0x1B2C
(0411) 	TRANSMIT_PutChar(END_TRANSMIT);
(0412) 	TRANSMIT_PutChar(END_TRANSMIT);
(0413) 	
(0414) 	// Wait for the transmission to finish.
19BE: 81 6D    JMP   0x1B2C
(0415) 	while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
19C0: 62 D0 00 MOV   REG[208],0
19C3: 52 01    MOV   A,[X+1]
19C5: 53 70    MOV   [__r1],A
19C7: 52 00    MOV   A,[X+0]
19C9: 60 D4    MOV   REG[212],A
19CB: 3E 70    MVI   A,[__r1]
19CD: 53 70    MOV   [__r1],A
19CF: 55 71 00 MOV   [__r0],0
19D2: 3C 71 00 CMP   [__r0],0
19D5: B0 05    JNZ   0x19DB
19D7: 39 72    CMP   A,114
19D9: A0 0E    JZ    0x19E8
19DB: 62 D0 00 MOV   REG[208],0
19DE: 3C 71 00 CMP   [__r0],0
19E1: B1 4A    JNZ   0x1B2C
19E3: 3C 70 52 CMP   [__r1],82
19E6: B1 45    JNZ   0x1B2C
(0416) 	
(0417) 	xmitWait();
19E8: 10       PUSH  X
19E9: 7C 13 4A LCALL 0x134A
19EC: 62 D0 00 MOV   REG[208],0
19EF: 53 71    MOV   [__r0],A
19F1: 5A 70    MOV   [__r1],X
19F3: 20       POP   X
19F4: 51 70    MOV   A,[__r1]
19F6: 54 01    MOV   [X+1],A
19F8: 51 71    MOV   A,[__r0]
19FA: 54 00    MOV   [X+0],A
19FC: 3C 71 00 CMP   [__r0],0
19FF: B0 06    JNZ   0x1A06
1A01: 3C 70 00 CMP   [__r1],0
1A04: A1 27    JZ    0x1B2C
(0418) 	
(0419) 	configToggle(RX_MODE);	// Listen for the response.
1A06: 52 00    MOV   A,[X+0]
1A08: 08       PUSH  A
1A09: 52 01    MOV   A,[X+1]
1A0B: 08       PUSH  A
1A0C: 7C 24 65 LCALL _atoi
1A0F: 38 FE    ADD   SP,254
1A11: 62 D0 00 MOV   REG[208],0
1A14: 51 70    MOV   A,[__r1]
1A16: 54 04    MOV   [X+4],A
(0420) 	
1A18: 10       PUSH  X
1A19: 7C 13 4A LCALL 0x134A
1A1C: 62 D0 00 MOV   REG[208],0
1A1F: 53 71    MOV   [__r0],A
1A21: 5A 70    MOV   [__r1],X
1A23: 20       POP   X
1A24: 51 70    MOV   A,[__r1]
1A26: 54 01    MOV   [X+1],A
1A28: 51 71    MOV   A,[__r0]
1A2A: 54 00    MOV   [X+0],A
1A2C: 3C 71 00 CMP   [__r0],0
1A2F: B0 06    JNZ   0x1A36
1A31: 3C 70 00 CMP   [__r1],0
1A34: A0 F7    JZ    0x1B2C
(0421) 	if(module_id != BROADCAST)
(0422) 	{
1A36: 62 D0 00 MOV   REG[208],0
1A39: 52 01    MOV   A,[X+1]
1A3B: 53 70    MOV   [__r1],A
1A3D: 52 00    MOV   A,[X+0]
1A3F: 60 D4    MOV   REG[212],A
1A41: 3E 70    MVI   A,[__r1]
1A43: 53 70    MOV   [__r1],A
1A45: 55 71 00 MOV   [__r0],0
1A48: 3C 71 00 CMP   [__r0],0
1A4B: B0 05    JNZ   0x1A51
1A4D: 39 61    CMP   A,97
1A4F: A0 0E    JZ    0x1A5E
1A51: 62 D0 00 MOV   REG[208],0
1A54: 3C 71 00 CMP   [__r0],0
1A57: B0 D4    JNZ   0x1B2C
1A59: 3C 70 41 CMP   [__r1],65
1A5C: B0 CF    JNZ   0x1B2C
(0423) 		RX_TIMEOUT_Stop();
(0424) 		TIMEOUT = 0;
(0425) 		RX_TIMEOUT_Start();
1A5E: 50 02    MOV   A,2
1A60: 08       PUSH  A
1A61: 50 24    MOV   A,36
1A63: 08       PUSH  A
1A64: 50 02    MOV   A,2
1A66: 08       PUSH  A
1A67: 50 04    MOV   A,4
1A69: 08       PUSH  A
1A6A: 52 04    MOV   A,[X+4]
1A6C: 08       PUSH  A
1A6D: 90 C1    CALL  _servoInstruction
(0426) 		
1A6F: 50 00    MOV   A,0
1A71: 08       PUSH  A
1A72: 50 01    MOV   A,1
1A74: 08       PUSH  A
1A75: 91 50    CALL  _configToggle
1A77: 38 F9    ADD   SP,249
(0427) 		while((TIMEOUT < RX_TIMEOUT_DURATION) && (!response))
(0428) 		{
1A79: 56 05 00 MOV   [X+5],0
(0429) 			if(RECEIVE_cReadChar() == START_TRANSMIT)
1A7C: 56 06 00 MOV   [X+6],0
1A7F: 80 94    JMP   0x1B14
(0430) 			{	
(0431) 				if(validTransmission())
(0432) 				{
(0433) 					if(COMMAND_TYPE == CONFIG_CLEARED)	// This is the response we are looking for.
(0434) 					{
1A81: 10       PUSH  X
1A82: 7C 0B 70 LCALL 0x0B70
1A85: 62 D0 00 MOV   REG[208],0
1A88: 20       POP   X
1A89: 39 FF    CMP   A,255
1A8B: B0 88    JNZ   0x1B14
(0435) 						// If this is for me, check who it was from.
(0436) 						if(COMMAND_DESTINATION == MASTER_ID)
1A8D: 10       PUSH  X
1A8E: 7C 0B 68 LCALL 0x0B68
1A91: 62 D0 00 MOV   REG[208],0
1A94: 20       POP   X
1A95: 39 FF    CMP   A,255
1A97: B0 7C    JNZ   0x1B14
(0437) 						{
(0438) 							if(COMMAND_SOURCE == module_id)
1A99: 10       PUSH  X
1A9A: 7C 0B 68 LCALL 0x0B68
1A9D: 62 D0 00 MOV   REG[208],0
1AA0: 20       POP   X
1AA1: 3B 04    CMP   A,[X+4]
1AA3: B0 70    JNZ   0x1B14
(0439) 							{
(0440) 								response = 1;
1AA5: 10       PUSH  X
1AA6: 7C 0B 68 LCALL 0x0B68
1AA9: 62 D0 00 MOV   REG[208],0
1AAC: 20       POP   X
1AAD: 39 04    CMP   A,4
1AAF: B0 64    JNZ   0x1B14
(0441) 							}
(0442) 						}
1AB1: 10       PUSH  X
1AB2: 7C 0B 68 LCALL 0x0B68
1AB5: 62 D0 00 MOV   REG[208],0
1AB8: 20       POP   X
1AB9: 39 00    CMP   A,0
1ABB: B0 58    JNZ   0x1B14
(0443) 					}
(0444) 				}
1ABD: 10       PUSH  X
1ABE: 7C 0B 68 LCALL 0x0B68
1AC1: 62 D0 00 MOV   REG[208],0
1AC4: 20       POP   X
1AC5: 54 05    MOV   [X+5],A
(0445) 			}
1AC7: 10       PUSH  X
1AC8: 7C 0B 68 LCALL 0x0B68
1ACB: 62 D0 00 MOV   REG[208],0
1ACE: 20       POP   X
1ACF: 54 06    MOV   [X+6],A
(0446) 		}
(0447) 		
1AD1: 50 00    MOV   A,0
1AD3: 08       PUSH  A
1AD4: 50 02    MOV   A,2
1AD6: 08       PUSH  A
1AD7: 90 EE    CALL  _configToggle
(0448) 		RX_TIMEOUT_Stop();
(0449) 		TIMEOUT = 0;
1AD9: 52 05    MOV   A,[X+5]
1ADB: 54 03    MOV   [X+3],A
1ADD: 52 06    MOV   A,[X+6]
1ADF: 54 02    MOV   [X+2],A
(0450) 		RX_TIMEOUT_Start();
1AE1: 50 00    MOV   A,0
1AE3: 08       PUSH  A
1AE4: 50 0A    MOV   A,10
1AE6: 08       PUSH  A
1AE7: 52 02    MOV   A,[X+2]
1AE9: 08       PUSH  A
1AEA: 52 03    MOV   A,[X+3]
1AEC: 08       PUSH  A
1AED: 52 00    MOV   A,[X+0]
1AEF: 08       PUSH  A
1AF0: 52 01    MOV   A,[X+1]
1AF2: 08       PUSH  A
1AF3: 7C 29 F7 LCALL _itoa
1AF6: 38 F8    ADD   SP,248
(0451) 	}
1AF8: 10       PUSH  X
1AF9: 52 00    MOV   A,[X+0]
1AFB: 08       PUSH  A
1AFC: 52 01    MOV   A,[X+1]
1AFE: 5C       MOV   X,A
1AFF: 18       POP   A
1B00: 7C 12 9A LCALL 0x129A
1B03: 20       POP   X
(0452) 	
1B04: 10       PUSH  X
1B05: 50 0A    MOV   A,10
1B07: 7C 12 5D LCALL 0x125D
1B0A: 20       POP   X
(0453) 	return response;
(0454) }
1B0B: 62 D0 00 MOV   REG[208],0
1B0E: 55 77 05 MOV   [TIMEOUT+1],5
1B11: 55 76 00 MOV   [TIMEOUT],0
1B14: 62 D0 00 MOV   REG[208],0
1B17: 51 77    MOV   A,[TIMEOUT+1]
1B19: 11 05    SUB   A,5
1B1B: 51 76    MOV   A,[TIMEOUT]
1B1D: 31 80    XOR   A,128
1B1F: 19 80    SBB   A,128
1B21: CF 5F    JC    0x1A81
(0455) 
(0456) // This function transmits a hello message.
(0457) void sayHello(void)
(0458) {
(0459) 	configToggle(TX_MODE);				// Toggle into TX mode.
(0460) 			
(0461) 	// Transmit a hello.
(0462) 	TRANSMIT_PutChar(START_TRANSMIT);
1B23: 62 D0 00 MOV   REG[208],0
1B26: 55 77 00 MOV   [TIMEOUT+1],0
1B29: 55 76 00 MOV   [TIMEOUT],0
(0463) 	TRANSMIT_PutChar(START_TRANSMIT);
(0464) 	TRANSMIT_PutChar(MASTER_ID);
(0465) 	TRANSMIT_PutChar(BLANK_MODULE_ID);
(0466) 	TRANSMIT_PutChar(HELLO_BYTE);
(0467) 	TRANSMIT_PutChar(END_TRANSMIT);
1B2C: 38 F8    ADD   SP,248
1B2E: 20       POP   X
1B2F: 7F       RET   
(0468) 	TRANSMIT_PutChar(END_TRANSMIT);
(0469) 	
(0470) 	// Wait for the transmission to finish.
(0471) 	while(!( TRANSMIT_bReadTxStatus() & TRANSMIT_TX_COMPLETE));
(0472) 	
(0473) 	xmitWait();
(0474) 	
(0475) 	configToggle(RX_MODE);				// Listen for the response.
_servoInstruction:
  checksum             --> X+0
  value                --> X-8
  address              --> X-7
  instruction          --> X-6
  length               --> X-5
  id                   --> X-4
1B30: 10       PUSH  X
1B31: 4F       MOV   X,SP
1B32: 38 01    ADD   SP,1
(0476) }
(0477) 
(0478) // This function returns whether or not a valid transmission has been received.
(0479) int validTransmission(void)
1B34: 62 D0 00 MOV   REG[208],0
1B37: 52 FB    MOV   A,[X-5]
1B39: 53 70    MOV   [__r1],A
1B3B: 55 71 00 MOV   [__r0],0
1B3E: 52 FC    MOV   A,[X-4]
1B40: 02 70    ADD   A,[__r1]
1B42: 53 70    MOV   [__r1],A
1B44: 50 00    MOV   A,0
1B46: 0A 71    ADC   A,[__r0]
1B48: 53 71    MOV   [__r0],A
1B4A: 52 FA    MOV   A,[X-6]
1B4C: 04 70    ADD   [__r1],A
1B4E: 0E 71 00 ADC   [__r0],0
1B51: 52 F9    MOV   A,[X-7]
1B53: 04 70    ADD   [__r1],A
1B55: 0E 71 00 ADC   [__r0],0
1B58: 52 F8    MOV   A,[X-8]
1B5A: 04 70    ADD   [__r1],A
1B5C: 0E 71 00 ADC   [__r0],0
1B5F: 50 01    MOV   A,1
1B61: 08       PUSH  A
1B62: 50 00    MOV   A,0
1B64: 08       PUSH  A
1B65: 51 71    MOV   A,[__r0]
1B67: 08       PUSH  A
1B68: 51 70    MOV   A,[__r1]
1B6A: 08       PUSH  A
1B6B: 7C 1F 9C LCALL __divmod_16X16_16
1B6E: 38 FE    ADD   SP,254
1B70: 18       POP   A
1B71: 53 70    MOV   [__r1],A
1B73: 18       POP   A
1B74: 50 FF    MOV   A,255
1B76: 12 70    SUB   A,[__r1]
1B78: 54 00    MOV   [X+0],A
(0480) {
(0481) 	int valid_transmit = 0;
(0482) 	
1B7A: 10       PUSH  X
1B7B: 50 FF    MOV   A,255
1B7D: 7C 09 1B LCALL 0x091B
1B80: 20       POP   X
(0483) 	if(RECEIVE_cGetChar() == START_TRANSMIT)
1B81: 10       PUSH  X
1B82: 50 FF    MOV   A,255
1B84: 7C 09 1B LCALL 0x091B
1B87: 20       POP   X
(0484) 	{
1B88: 10       PUSH  X
1B89: 52 FC    MOV   A,[X-4]
1B8B: 7C 09 1B LCALL 0x091B
1B8E: 20       POP   X
(0485) 		COMMAND_SOURCE = RECEIVE_cGetChar();
1B8F: 10       PUSH  X
1B90: 52 FB    MOV   A,[X-5]
1B92: 7C 09 1B LCALL 0x091B
1B95: 20       POP   X
(0486) 		COMMAND_DESTINATION = RECEIVE_cGetChar();
1B96: 10       PUSH  X
1B97: 52 FA    MOV   A,[X-6]
1B99: 7C 09 1B LCALL 0x091B
1B9C: 20       POP   X
(0487) 		COMMAND_TYPE = RECEIVE_cGetChar();
1B9D: 10       PUSH  X
1B9E: 52 F9    MOV   A,[X-7]
1BA0: 7C 09 1B LCALL 0x091B
1BA3: 20       POP   X
(0488) 		PARAM = RECEIVE_cGetChar();
1BA4: 10       PUSH  X
1BA5: 52 F8    MOV   A,[X-8]
1BA7: 7C 09 1B LCALL 0x091B
1BAA: 20       POP   X
(0489) 		
1BAB: 10       PUSH  X
1BAC: 52 00    MOV   A,[X+0]
1BAE: 7C 09 1B LCALL 0x091B
1BB1: 20       POP   X
(0490) 		valid_transmit = 1;
(0491) 	}
(0492) 	
1BB2: 10       PUSH  X
1BB3: 7C 08 EE LCALL 0x08EE
1BB6: 62 D0 00 MOV   REG[208],0
1BB9: 20       POP   X
1BBA: 53 71    MOV   [__r0],A
1BBC: 47 71 20 TST   [__r0],32
1BBF: AF F2    JZ    0x1BB2
(0493) 	return valid_transmit;
(0494) }
(0495) 
1BC1: 93 45    CALL  _xmitWait
1BC3: 38 FF    ADD   SP,255
1BC5: 20       POP   X
1BC6: 7F       RET   
(0496) // This function decodes the transmission and takes the correct action.
(0497) void decodeTransmission(void)
(0498) {
(0499) 	char* param;
(0500) 	char ID;
(0501) 	char tempByte;
_configToggle:
  mode                 --> X-5
1BC7: 10       PUSH  X
1BC8: 4F       MOV   X,SP
(0502) 	char angle[2];
(0503) 	int total = 0;
1BC9: 43 00 80 OR    REG[0],128
(0504) 	
1BCC: 41 02 7F AND   REG[2],127
(0505) 	if(param = COMP_SERIAL_szGetParam())
(0506) 	{
(0507) 		if((param[0] == 'w') || (param[0] == 'W'))
(0508) 		{
1BCF: 62 D0 00 MOV   REG[208],0
1BD2: 3C 74 00 CMP   [STATE],0
1BD5: B0 06    JNZ   0x1BDC
1BD7: 3C 75 00 CMP   [STATE+1],0
1BDA: A0 10    JZ    0x1BEB
(0509) 			if(param = COMP_SERIAL_szGetParam())
(0510) 			{
1BDC: 62 D0 00 MOV   REG[208],0
1BDF: 51 74    MOV   A,[STATE]
1BE1: 08       PUSH  A
1BE2: 51 75    MOV   A,[STATE+1]
1BE4: 08       PUSH  A
1BE5: 90 DF    CALL  _unloadConfig
1BE7: 38 FE    ADD   SP,254
(0511) 				
1BE9: 80 03    JMP   0x1BED
(0512) 			}
(0513) 		}
(0514) 		else if((param[0] == 'r') || (param[0] == 'R'))
1BEB: 90 CF    CALL  _unloadAllConfigs
(0515) 		{
(0516) 			if(param = COMP_SERIAL_szGetParam())
(0517) 			{
1BED: 3D FB 00 CMP   [X-5],0
1BF0: B0 33    JNZ   0x1C24
1BF2: 3D FC 02 CMP   [X-4],2
1BF5: B0 2E    JNZ   0x1C24
(0518) 				ID = atoi(param);
(0519) 				if(param = COMP_SERIAL_szGetParam())
1BF7: 7C 06 6A LCALL 0x066A
(0520) 				{
(0521) 					if((param[0] == 'a') || (param[0] == 'A'))
1BFA: 10       PUSH  X
1BFB: 7C 13 1B LCALL 0x131B
(0522) 					{
1BFE: 7C 11 C9 LCALL 0x11C9
1C01: 20       POP   X
(0523) 			
1C02: 10       PUSH  X
1C03: 50 00    MOV   A,0
1C05: 7C 11 E9 LCALL 0x11E9
1C08: 20       POP   X
(0524) 						servoInstruction(ID,4,2,36,2);
(0525) 						configToggle(RX_MODE);
1C09: 10       PUSH  X
1C0A: 50 00    MOV   A,0
1C0C: 7C 08 E2 LCALL 0x08E2
1C0F: 20       POP   X
(0526) 						
(0527) 						angle[0] = '\0';
1C10: 62 D0 00 MOV   REG[208],0
1C13: 55 77 00 MOV   [TIMEOUT+1],0
1C16: 55 76 00 MOV   [TIMEOUT],0
(0528) 						angle[1] = '\0';
1C19: 62 D0 00 MOV   REG[208],0
1C1C: 55 75 02 MOV   [STATE+1],2
1C1F: 55 74 00 MOV   [STATE],0
(0529) 						
1C22: 80 7F    JMP   0x1CA2
(0530) 						// Loop until we read a response or time out.
1C24: 3D FB 00 CMP   [X-5],0
1C27: B0 31    JNZ   0x1C59
1C29: 3D FC 01 CMP   [X-4],1
1C2C: B0 2C    JNZ   0x1C59
(0531) 						while(TIMEOUT < RX_TIMEOUT_DURATION)
(0532) 						{					
1C2E: 7C 07 24 LCALL 0x0724
(0533) 							if(RECEIVE_cReadChar() == SERVO_START)
(0534) 							{
(0535) 								if(RECEIVE_cGetChar() == SERVO_START)
1C31: 10       PUSH  X
1C32: 7C 0B 9D LCALL 0x0B9D
1C35: 20       POP   X
(0536) 								{
(0537) 									if(RECEIVE_cGetChar() == ID)
1C36: 10       PUSH  X
1C37: 50 00    MOV   A,0
1C39: 7C 0B 59 LCALL 0x0B59
1C3C: 20       POP   X
(0538) 									{
(0539) 										if(RECEIVE_cGetChar() == 4)
(0540) 										{
1C3D: 62 D0 00 MOV   REG[208],0
1C40: 55 77 00 MOV   [TIMEOUT+1],0
1C43: 55 76 00 MOV   [TIMEOUT],0
(0541) 											if(RECEIVE_cGetChar() == 0)
1C46: 10       PUSH  X
1C47: 7C 0A 79 LCALL 0x0A79
(0542) 											{
1C4A: 7C 0A 81 LCALL 0x0A81
1C4D: 20       POP   X
(0543) 												angle[0] = RECEIVE_cGetChar();
(0544) 												angle[1] = RECEIVE_cGetChar();
1C4E: 62 D0 00 MOV   REG[208],0
1C51: 55 75 01 MOV   [STATE+1],1
1C54: 55 74 00 MOV   [STATE],0
(0545) 												
1C57: 80 4A    JMP   0x1CA2
(0546) 												configToggle(PC_MODE);
1C59: 3D FB 00 CMP   [X-5],0
1C5C: B0 45    JNZ   0x1CA2
1C5E: 3D FC 00 CMP   [X-4],0
1C61: B0 40    JNZ   0x1CA2
(0547) 												
(0548) 												total = ((angle[1])*256) + angle[0];
1C63: 7C 06 01 LCALL 0x0601
(0549) 												itoa(param,total,10);
(0550) 												COMP_SERIAL_PutString(param);
1C66: 10       PUSH  X
1C67: 50 00    MOV   A,0
1C69: 7C 09 BB LCALL 0x09BB
1C6C: 20       POP   X
(0551) 												COMP_SERIAL_PutChar('\n');
(0552) 
1C6D: 62 D0 00 MOV   REG[208],0
1C70: 55 77 00 MOV   [TIMEOUT+1],0
1C73: 55 76 00 MOV   [TIMEOUT],0
(0553) 												TIMEOUT = RX_TIMEOUT_DURATION;
1C76: 10       PUSH  X
1C77: 7C 08 67 LCALL 0x0867
(0554) 											}
1C7A: 7C 08 6F LCALL 0x086F
1C7D: 20       POP   X
(0555) 										}
(0556) 									}
1C7E: 62 D0 00 MOV   REG[208],0
1C81: 3C 76 00 CMP   [TIMEOUT],0
1C84: B0 06    JNZ   0x1C8B
1C86: 3C 77 00 CMP   [TIMEOUT+1],0
1C89: AF F4    JZ    0x1C7E
(0557) 								}
(0558) 							}
(0559) 						}
(0560) 						
(0561) 						TIMEOUT = 0;
(0562) 					}
1C8B: 10       PUSH  X
1C8C: 7C 08 73 LCALL 0x0873
1C8F: 20       POP   X
(0563) 				}
1C90: 62 D0 00 MOV   REG[208],0
1C93: 55 77 00 MOV   [TIMEOUT+1],0
1C96: 55 76 00 MOV   [TIMEOUT],0
(0564) 			}
(0565) 		}
1C99: 62 D0 00 MOV   REG[208],0
1C9C: 55 75 00 MOV   [STATE+1],0
1C9F: 55 74 00 MOV   [STATE],0
(0566) 	}
(0567) 	
(0568) //	COMP_SERIAL_CmdReset();
(0569) }
(0570) 
(0571) // This function receives a destination, command length, instruction type, address, and value.
1CA2: 62 D0 00 MOV   REG[208],0
1CA5: 3C 74 00 CMP   [STATE],0
1CA8: B0 0B    JNZ   0x1CB4
1CAA: 3C 75 00 CMP   [STATE+1],0
1CAD: B0 06    JNZ   0x1CB4
(0572) // With these parameters, the function sends a packet to the communication bus.
(0573) void servoInstruction(char id, char length, char instruction, char address, char value)
1CAF: 43 04 01 OR    REG[4],1
(0574) {
1CB2: 80 04    JMP   0x1CB7
(0575) 	char checksum;
(0576) 	
(0577) 	// Calculate the checksum value for our servo communication.
1CB4: 41 04 FE AND   REG[4],254
(0578) 	checksum = 255-((id + length + instruction + address + value)%256);
(0579) 	
(0580) 	// Talk to the servo.
(0581) 	TX_REPEATER_PutChar(SERVO_START);	// Start byte one
(0582) 	TX_REPEATER_PutChar(SERVO_START);	// Start byte two
1CB7: 43 02 80 OR    REG[2],128
1CBA: 20       POP   X
1CBB: 7F       RET   
(0583) 	TX_REPEATER_PutChar(id);			// Servo ID
(0584) 	TX_REPEATER_PutChar(length);		// The instruction length.
(0585) 	TX_REPEATER_PutChar(instruction);	// The instruction to carry out.
(0586) 	TX_REPEATER_PutChar(address);		// The address to read/write from/to.
(0587) 	TX_REPEATER_PutChar(value);			// The value to write or number of bytes to read.
(0588) 	TX_REPEATER_PutChar(checksum);		// This is the checksum.
(0589) 	
_unloadAllConfigs:
1CBC: 7C 06 C4 LCALL 0x06C4
(0590) 	// Wait for the transmission to finish.
1CBF: 7C 07 90 LCALL 0x0790
(0591) 	while(!(TX_REPEATER_bReadTxStatus() & TX_REPEATER_TX_COMPLETE));
1CC2: 7C 06 45 LCALL 0x0645
1CC5: 7F       RET   
(0592) 	
(0593) 	// Make completely sure we're done.
(0594) 	xmitWait();
(0595) }
(0596) 
(0597) // This function allows the program to pass an RX or TX mode flag for switching between modes on the
_unloadConfig:
  config_num           --> X-5
1CC6: 10       PUSH  X
1CC7: 4F       MOV   X,SP
(0598) // half duplex UART serial communication line.
1CC8: 3D FB 00 CMP   [X-5],0
1CCB: B0 0B    JNZ   0x1CD7
1CCD: 3D FC 02 CMP   [X-4],2
1CD0: B0 06    JNZ   0x1CD7
(0599) void configToggle(int mode)
(0600) {
1CD2: 7C 06 C4 LCALL 0x06C4
(0601) 	// Disconnect from the global bus and leave the pin high.
1CD5: 80 1D    JMP   0x1CF3
(0602) 	PRT0DR |= 0b10000000;
1CD7: 3D FB 00 CMP   [X-5],0
1CDA: B0 0B    JNZ   0x1CE6
1CDC: 3D FC 01 CMP   [X-4],1
1CDF: B0 06    JNZ   0x1CE6
(0603) 	PRT0GS &= 0b01111111;
(0604) 
1CE1: 7C 07 90 LCALL 0x0790
(0605) 	// Unload the configuration of the current state.
1CE4: 80 0E    JMP   0x1CF3
(0606) 	// If there is no state, blindly wipe all configurations.
1CE6: 3D FB 00 CMP   [X-5],0
1CE9: B0 09    JNZ   0x1CF3
1CEB: 3D FC 00 CMP   [X-4],0
1CEE: B0 04    JNZ   0x1CF3
(0607) 	if(STATE)
(0608) 	{
1CF0: 7C 06 45 LCALL 0x0645
(0609) 		unloadConfig(STATE);
1CF3: 20       POP   X
1CF4: 7F       RET   
(0610) 	}
(0611) 	else
(0612) 	{
(0613) 		unloadAllConfigs();
_moveMotor:
  value                --> X+5
  checksum             --> X+4
  address              --> X+3
  instruction          --> X+2
  length               --> X+1
  motor                --> X+0
  motor_id             --> X-5
1CF5: 10       PUSH  X
1CF6: 4F       MOV   X,SP
1CF7: 38 06    ADD   SP,6
(0614) 	}
(0615) 	
1CF9: 56 01 07 MOV   [X+1],7
(0616) 	if(mode == PC_MODE)
1CFC: 56 02 03 MOV   [X+2],3
(0617) 	{
1CFF: 56 03 1E MOV   [X+3],30
(0618) 		LoadConfig_pc_listener();
1D02: 56 05 06 MOV   [X+5],6
(0619) 		
1D05: 62 D0 00 MOV   REG[208],0
1D08: 52 FC    MOV   A,[X-4]
1D0A: 54 00    MOV   [X+0],A
(0620) 		COMP_SERIAL_CmdReset(); 						// Initializes the RX buffer
(0621) 		COMP_SERIAL_EnableInt(); // Enable RX interrupts  
(0622) 		COMP_SERIAL_Start(UART_PARITY_NONE);			// Starts the UART.
1D0C: 52 01    MOV   A,[X+1]
1D0E: 53 70    MOV   [__r1],A
1D10: 55 71 00 MOV   [__r0],0
1D13: 52 00    MOV   A,[X+0]
1D15: 02 70    ADD   A,[__r1]
1D17: 53 70    MOV   [__r1],A
1D19: 50 00    MOV   A,0
1D1B: 0A 71    ADC   A,[__r0]
1D1D: 53 71    MOV   [__r0],A
1D1F: 52 02    MOV   A,[X+2]
1D21: 04 70    ADD   [__r1],A
1D23: 0E 71 00 ADC   [__r0],0
1D26: 52 03    MOV   A,[X+3]
1D28: 04 70    ADD   [__r1],A
1D2A: 0E 71 00 ADC   [__r0],0
1D2D: 52 05    MOV   A,[X+5]
1D2F: 04 70    ADD   [__r1],A
1D31: 0E 71 00 ADC   [__r0],0
1D34: 50 01    MOV   A,1
1D36: 08       PUSH  A
1D37: 50 00    MOV   A,0
1D39: 08       PUSH  A
1D3A: 51 71    MOV   A,[__r0]
1D3C: 08       PUSH  A
1D3D: 51 70    MOV   A,[__r1]
1D3F: 08       PUSH  A
1D40: 7C 1F 9C LCALL __divmod_16X16_16
1D43: 38 FE    ADD   SP,254
1D45: 18       POP   A
1D46: 53 70    MOV   [__r1],A
1D48: 18       POP   A
1D49: 50 FF    MOV   A,255
1D4B: 12 70    SUB   A,[__r1]
1D4D: 54 04    MOV   [X+4],A
(0623) 		
(0624) 		TX_REPEATER_Start(TX_REPEATER_PARITY_NONE);		// Start the TX repeater.
1D4F: 10       PUSH  X
1D50: 7C 0F D7 LCALL 0x0FD7
1D53: 20       POP   X
(0625) 		
1D54: 10       PUSH  X
1D55: 50 00    MOV   A,0
1D57: 5C       MOV   X,A
1D58: 7C 10 4A LCALL 0x104A
1D5B: 20       POP   X
(0626) 		TIMEOUT = 0;
1D5C: 10       PUSH  X
1D5D: 52 00    MOV   A,[X+0]
1D5F: 7C 0E E7 LCALL 0x0EE7
1D62: 20       POP   X
(0627) 		STATE = PC_MODE;
(0628) 	}
(0629) 	else if(mode == RX_MODE)
1D63: 50 00    MOV   A,0
1D65: 08       PUSH  A
1D66: 08       PUSH  A
1D67: 9E 5E    CALL  _configToggle
1D69: 38 FE    ADD   SP,254
(0630) 	{
(0631) 		LoadConfig_receiver_config();
(0632) 		
1D6B: 41 02 E1 AND   REG[2],225
(0633) 		// Clear the buffer.
(0634) 		RECEIVE_CmdReset();
1D6E: 10       PUSH  X
1D6F: 50 FF    MOV   A,255
1D71: 7C 09 F4 LCALL 0x09F4
1D74: 20       POP   X
(0635) 		// Start the receiver.
1D75: 10       PUSH  X
1D76: 50 FF    MOV   A,255
1D78: 7C 09 F4 LCALL 0x09F4
1D7B: 20       POP   X
(0636) 		RECEIVE_Start(RECEIVE_PARITY_NONE);
1D7C: 10       PUSH  X
1D7D: 52 00    MOV   A,[X+0]
1D7F: 7C 09 F4 LCALL 0x09F4
1D82: 20       POP   X
(0637) 		
1D83: 10       PUSH  X
1D84: 52 01    MOV   A,[X+1]
1D86: 7C 09 F4 LCALL 0x09F4
1D89: 20       POP   X
(0638) 		// Start response timeout timer and enable its interrupt routine.
1D8A: 10       PUSH  X
1D8B: 52 02    MOV   A,[X+2]
1D8D: 7C 09 F4 LCALL 0x09F4
1D90: 20       POP   X
(0639) 		TIMEOUT = 0;
1D91: 10       PUSH  X
1D92: 52 03    MOV   A,[X+3]
1D94: 7C 09 F4 LCALL 0x09F4
1D97: 20       POP   X
(0640) 		RX_TIMEOUT_EnableInt();
1D98: 10       PUSH  X
1D99: 50 00    MOV   A,0
1D9B: 7C 09 F4 LCALL 0x09F4
1D9E: 20       POP   X
(0641) 		RX_TIMEOUT_Start();
1D9F: 10       PUSH  X
1DA0: 50 03    MOV   A,3
1DA2: 7C 09 F4 LCALL 0x09F4
1DA5: 20       POP   X
(0642) 		
1DA6: 10       PUSH  X
1DA7: 50 00    MOV   A,0
1DA9: 7C 09 F4 LCALL 0x09F4
1DAC: 20       POP   X
(0643) 		STATE = RX_MODE;
1DAD: 10       PUSH  X
1DAE: 50 03    MOV   A,3
1DB0: 7C 09 F4 LCALL 0x09F4
1DB3: 20       POP   X
(0644) 	}
1DB4: 10       PUSH  X
1DB5: 52 04    MOV   A,[X+4]
1DB7: 7C 09 F4 LCALL 0x09F4
1DBA: 20       POP   X
(0645) 	else if(mode == TX_MODE)
(0646) 	{
(0647) 		LoadConfig_transmitter_config();
1DBB: 10       PUSH  X
1DBC: 7C 09 C7 LCALL 0x09C7
1DBF: 62 D0 00 MOV   REG[208],0
1DC2: 20       POP   X
1DC3: 53 71    MOV   [__r0],A
1DC5: 47 71 20 TST   [__r0],32
1DC8: AF F2    JZ    0x1DBB
(0648) 		// Start the transmitter.
(0649) 		TRANSMIT_Start(TRANSMIT_PARITY_NONE);
1DCA: 91 3C    CALL  _xmitWait
(0650) 		
(0651) 		TIMEOUT = 0;
1DCC: 50 00    MOV   A,0
1DCE: 08       PUSH  A
1DCF: 50 02    MOV   A,2
1DD1: 08       PUSH  A
1DD2: 9D F3    CALL  _configToggle
1DD4: 38 FE    ADD   SP,254
1DD6: 38 FA    ADD   SP,250
1DD8: 20       POP   X
1DD9: 7F       RET   
(0652) 		TX_TIMEOUT_EnableInt();	// Make sure interrupts are enabled.
(0653) 		TX_TIMEOUT_Start();		// Start the timer.
(0654) 		
(0655) 		while(!TIMEOUT)
_initializeSlaves:
  num_timeouts         --> X+0
1DDA: 10       PUSH  X
1DDB: 4F       MOV   X,SP
1DDC: 38 02    ADD   SP,2
(0656) 		{
1DDE: 56 01 00 MOV   [X+1],0
1DE1: 56 00 00 MOV   [X+0],0
(0657) 			// Do nothing while we wait for one timeout period.
(0658) 			// This is to allow everyone to get in the right configuration.
1DE4: 9A C2    CALL  _sayHello
1DE6: 81 07    JMP   0x1EEE
(0659) 		}
(0660) 		
(0661) 		TX_TIMEOUT_Stop();		// Stop the timer.
(0662) 		TIMEOUT = 0;			// Reset the timeout flag.
(0663) 		
(0664) 		STATE = TX_MODE;
1DE8: 10       PUSH  X
1DE9: 7C 0B 70 LCALL 0x0B70
1DEC: 62 D0 00 MOV   REG[208],0
1DEF: 20       POP   X
1DF0: 39 FC    CMP   A,252
1DF2: B0 D6    JNZ   0x1EC9
(0665) 	}
(0666) 	
1DF4: 9B 07    CALL  _validTransmission
1DF6: 62 D0 00 MOV   REG[208],0
1DF9: 3C 71 00 CMP   [__r0],0
1DFC: B0 06    JNZ   0x1E03
1DFE: 3C 70 00 CMP   [__r1],0
1E01: A0 EC    JZ    0x1EEE
(0667) 	// Make sure to keep the LED on (active low).
(0668) 	//PRT2DR &= 0b11111110;
1E03: 62 D0 00 MOV   REG[208],0
1E06: 3C 7D C8 CMP   [COMMAND_TYPE],200
1E09: B0 E4    JNZ   0x1EEE
(0669) 	
(0670) 	if(STATE == TX_MODE)
(0671) 	{
1E0B: 62 D0 00 MOV   REG[208],0
1E0E: 3C 7B 00 CMP   [COMMAND_DESTINATION],0
1E11: B0 DC    JNZ   0x1EEE
(0672) 		PRT1DR |= 0b00000001;
(0673) 	}
1E13: 62 D0 00 MOV   REG[208],0
1E16: 76 73    INC   [NUM_MODULES+1]
1E18: 0E 72 00 ADC   [NUM_MODULES],0
(0674) 	else
1E1B: 56 01 00 MOV   [X+1],0
1E1E: 56 00 00 MOV   [X+0],0
(0675) 	{
(0676) 		PRT1DR &= 0b11111110;
1E21: 51 72    MOV   A,[NUM_MODULES]
1E23: 08       PUSH  A
1E24: 51 73    MOV   A,[NUM_MODULES+1]
1E26: 08       PUSH  A
1E27: 98 4F    CALL  _assignID
1E29: 38 FE    ADD   SP,254
1E2B: 62 D0 00 MOV   REG[208],0
1E2E: 3C 71 00 CMP   [__r0],0
1E31: B0 BC    JNZ   0x1EEE
1E33: 3C 70 00 CMP   [__r1],0
1E36: B0 B7    JNZ   0x1EEE
(0677) 		
(0678) 	}
(0679) 	
(0680) 	// Reconnect to the global bus.
(0681) 	PRT0GS |= 0b10000000;
1E38: 62 D0 00 MOV   REG[208],0
1E3B: 51 72    MOV   A,[NUM_MODULES]
1E3D: 08       PUSH  A
1E3E: 51 73    MOV   A,[NUM_MODULES+1]
1E40: 08       PUSH  A
1E41: 7C 15 7F LCALL _pingModule
1E44: 38 FE    ADD   SP,254
1E46: 62 D0 00 MOV   REG[208],0
1E49: 3C 71 00 CMP   [__r0],0
1E4C: B0 A1    JNZ   0x1EEE
1E4E: 3C 70 00 CMP   [__r1],0
1E51: B0 9C    JNZ   0x1EEE
(0682) }
(0683) 
1E53: 62 D0 00 MOV   REG[208],0
1E56: 51 72    MOV   A,[NUM_MODULES]
1E58: 08       PUSH  A
1E59: 51 73    MOV   A,[NUM_MODULES+1]
1E5B: 08       PUSH  A
1E5C: 7C 15 7F LCALL _pingModule
1E5F: 38 FE    ADD   SP,254
1E61: 62 D0 00 MOV   REG[208],0
1E64: 3C 71 00 CMP   [__r0],0
1E67: B0 86    JNZ   0x1EEE
1E69: 3C 70 00 CMP   [__r1],0
1E6C: B0 81    JNZ   0x1EEE
(0684) // This function blindly unloads all user configurations. This will be called once,
(0685) // when the system initially has no known state.
1E6E: 62 D0 00 MOV   REG[208],0
1E71: 51 72    MOV   A,[NUM_MODULES]
1E73: 08       PUSH  A
1E74: 51 73    MOV   A,[NUM_MODULES+1]
1E76: 08       PUSH  A
1E77: 7C 15 7F LCALL _pingModule
1E7A: 38 FE    ADD   SP,254
1E7C: 62 D0 00 MOV   REG[208],0
1E7F: 3C 71 00 CMP   [__r0],0
1E82: B0 6B    JNZ   0x1EEE
1E84: 3C 70 00 CMP   [__r1],0
1E87: B0 66    JNZ   0x1EEE
(0686) void unloadAllConfigs(void)
(0687) {
1E89: 62 D0 00 MOV   REG[208],0
1E8C: 51 72    MOV   A,[NUM_MODULES]
1E8E: 08       PUSH  A
1E8F: 51 73    MOV   A,[NUM_MODULES+1]
1E91: 08       PUSH  A
1E92: 7C 15 7F LCALL _pingModule
1E95: 38 FE    ADD   SP,254
1E97: 62 D0 00 MOV   REG[208],0
1E9A: 3C 71 00 CMP   [__r0],0
1E9D: B0 50    JNZ   0x1EEE
1E9F: 3C 70 00 CMP   [__r1],0
1EA2: B0 4B    JNZ   0x1EEE
(0688) 	UnloadConfig_pc_listener();
(0689) 	UnloadConfig_receiver_config();
1EA4: 62 D0 00 MOV   REG[208],0
1EA7: 51 72    MOV   A,[NUM_MODULES]
1EA9: 08       PUSH  A
1EAA: 51 73    MOV   A,[NUM_MODULES+1]
1EAC: 08       PUSH  A
1EAD: 7C 15 7F LCALL _pingModule
1EB0: 38 FE    ADD   SP,254
1EB2: 62 D0 00 MOV   REG[208],0
1EB5: 3C 71 00 CMP   [__r0],0
1EB8: B0 35    JNZ   0x1EEE
1EBA: 3C 70 00 CMP   [__r1],0
1EBD: B0 30    JNZ   0x1EEE
(0690) 	UnloadConfig_transmitter_config();
(0691) }
1EBF: 62 D0 00 MOV   REG[208],0
1EC2: 7A 73    DEC   [NUM_MODULES+1]
1EC4: 1E 72 00 SBB   [NUM_MODULES],0
(0692) 
(0693) // This function unloads the configuration corresponding to the config number passed to it.
(0694) // We do this instead of unloadAllConfigs to cut down on set up time.
(0695) void unloadConfig(int config_num)
(0696) {
(0697) 	if(config_num == PC_MODE)
(0698) 	{
(0699) 		UnloadConfig_pc_listener();
(0700) 	}
(0701) 	else if(config_num == RX_MODE)
1EC7: 80 26    JMP   0x1EEE
(0702) 	{
1EC9: 62 D0 00 MOV   REG[208],0
1ECC: 51 77    MOV   A,[TIMEOUT+1]
1ECE: 11 05    SUB   A,5
1ED0: 51 76    MOV   A,[TIMEOUT]
1ED2: 31 80    XOR   A,128
1ED4: 19 80    SBB   A,128
1ED6: C0 17    JC    0x1EEE
(0703) 		UnloadConfig_receiver_config();
(0704) 	}
1ED8: 77 01    INC   [X+1]
1EDA: 0F 00 00 ADC   [X+0],0
(0705) 	else if(config_num == TX_MODE)
(0706) 	{
(0707) 		UnloadConfig_transmitter_config();
1EDD: 62 D0 00 MOV   REG[208],0
1EE0: 51 73    MOV   A,[NUM_MODULES+1]
1EE2: 11 FA    SUB   A,250
1EE4: 51 72    MOV   A,[NUM_MODULES]
1EE6: 31 80    XOR   A,128
1EE8: 19 80    SBB   A,128
1EEA: D0 03    JNC   0x1EEE
(0708) 	}
(0709) }
1EEC: 99 BA    CALL  _sayHello
1EEE: 52 01    MOV   A,[X+1]
1EF0: 11 0A    SUB   A,10
1EF2: 52 00    MOV   A,[X+0]
1EF4: 31 80    XOR   A,128
1EF6: 19 80    SBB   A,128
1EF8: CE EF    JC    0x1DE8
(0710) 
(0711) void moveMotor(int motor_id)
(0712) {
(0713) 	char checksum;
(0714) 	char length = 7;
(0715) 	char instruction = 3;
1EFA: 50 00    MOV   A,0
1EFC: 08       PUSH  A
1EFD: 50 02    MOV   A,2
1EFF: 08       PUSH  A
1F00: 9C C5    CALL  _configToggle
1F02: 38 FE    ADD   SP,254
1F04: 38 FE    ADD   SP,254
1F06: 20       POP   X
1F07: 7F       RET   
(0716) 	char address = 30;
(0717) 	char value = 6;
(0718) 	char motor = motor_id;
(0719) 	
_xmitWait:
  i                    --> X+0
1F08: 10       PUSH  X
1F09: 4F       MOV   X,SP
1F0A: 38 02    ADD   SP,2
(0720) 	// Calculate the checksum value for our servo communication.
(0721) 	checksum = 255-((motor + length + instruction + address + value)%256);
(0722) 	
1F0C: 56 01 00 MOV   [X+1],0
1F0F: 56 00 00 MOV   [X+0],0
1F12: 77 01    INC   [X+1]
1F14: 0F 00 00 ADC   [X+0],0
1F17: 52 01    MOV   A,[X+1]
1F19: 11 19    SUB   A,25
1F1B: 52 00    MOV   A,[X+0]
1F1D: 31 80    XOR   A,128
1F1F: 19 80    SBB   A,128
1F21: CF F0    JC    0x1F12
1F23: 38 FE    ADD   SP,254
1F25: 20       POP   X
1F26: 7F       RET   
(0723) 	LCD_1_Start();
(0724) 	LCD_1_Position(0,0);
(0725) 	LCD_1_PrHexByte(motor);
(0726) 	
(0727) 	// Toggle into transmit mode.
(0728) 	configToggle(TX_MODE);
(0729) 	
_TX_TIMEOUT_ISR:
1F27: 71 C0    OR    F,192
1F29: 08       PUSH  A
1F2A: 5D D0    MOV   A,REG[208]
1F2C: 08       PUSH  A
(0730) 	// Disconnect your children from the global bus, just in case.
1F2D: 62 D0 00 MOV   REG[208],0
1F30: 76 77    INC   [TIMEOUT+1]
1F32: 0E 76 00 ADC   [TIMEOUT],0
(0731) 	PRT0GS &= 0b11100001;
(0732) 	
1F35: 62 DA FD MOV   REG[218],253
1F38: 18       POP   A
1F39: 60 D0    MOV   REG[208],A
1F3B: 18       POP   A
1F3C: 7E       RETI  
(0733) 	TRANSMIT_PutChar(255);			// Start byte one
(0734) 	TRANSMIT_PutChar(255);			// Start byte two
(0735) 	TRANSMIT_PutChar(motor);		// Servo ID
(0736) 	TRANSMIT_PutChar(length);		// The instruction length.
_RX_TIMEOUT_ISR:
1F3D: 71 C0    OR    F,192
1F3F: 08       PUSH  A
1F40: 5D D0    MOV   A,REG[208]
1F42: 08       PUSH  A
(0737) 	TRANSMIT_PutChar(instruction);	// The instruction to carry out.
1F43: 62 D0 00 MOV   REG[208],0
1F46: 76 77    INC   [TIMEOUT+1]
1F48: 0E 76 00 ADC   [TIMEOUT],0
(0738) 	TRANSMIT_PutChar(address);		// The address to read/write from/to.
(0739) 	TRANSMIT_PutChar(0);			// LSB of goal position
1F4B: 62 DA FD MOV   REG[218],253
1F4E: 18       POP   A
1F4F: 60 D0    MOV   REG[208],A
1F51: 18       POP   A
1F52: 7E       RETI  

FILE: lib\psocdynamicint.asm
                                   (0001) ; Generated by PSoC Designer 5.0.985.0
                                   (0002) ;
                                   (0003) ;
                                   (0004) ;  fakemasterINT.asm
                                   (0005) ;
                                   (0006) ;  Data: 29 October, 2001
                                   (0007) ;  Copyright Cypress MicroSystems 2001
                                   (0008) ;
                                   (0009) ;  This file is generated by the Device Editor on Application Generation.
                                   (0010) ;  It contains dispatch code that ensures that interrupt vectors are 
                                   (0011) ;  serviced by the appropriate ISR depending on the currently active
                                   (0012) ;  configuration.
                                   (0013) ;  
                                   (0014) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0015) ;  Edits to this file will not be preserved.
                                   (0016) ;
                                   (0017) include "PSoCDynamic.inc"
                                   (0018) include "m8c.inc"
                                   (0019) export	Dispatch_INTERRUPT_10
                                   (0020) export	Dispatch_INTERRUPT_9
                                   (0021) 
                                   (0022) 
                                   (0023) Dispatch_INTERRUPT_10:
1F53: 08       PUSH  A             (0024) 	push	a
1F54: 50 00    MOV   A,0           (0025) 	mov		a,0
1F56: 47 02 02 TST   [2],2         (0026) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
1F59: B0 13    JNZ   0x1F6D        (0027) 	jnz		Dispatch_INTERRUPT_10_END
1F5B: 50 04    MOV   A,4           (0028) 	mov		a,4
1F5D: 47 02 04 TST   [2],4         (0029) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
1F60: B0 0C    JNZ   0x1F6D        (0030) 	jnz		Dispatch_INTERRUPT_10_END
1F62: 50 08    MOV   A,8           (0031) 	mov		a,8
1F64: 47 02 01 TST   [2],1         (0032) 	tst		[ACTIVE_CONFIG_STATUS+transmitter_config_ADDR_OFF], transmitter_config_BIT
1F67: B0 05    JNZ   0x1F6D        (0033) 	jnz		Dispatch_INTERRUPT_10_END
1F69: 18       POP   A             (0034) 	pop		a
1F6A: 7E       RETI                (0035) 	reti
                                   (0036) ; Stop Code Compressor from breaking table alignment
                                   (0037) ; The next instruction does not get executed.
1F6B: 71 00    OR    F,0           (0038) 	Suspend_CodeCompressor
                                   (0039) Dispatch_INTERRUPT_10_END:
1F6D: E0 01    JACC  0x1F6F        (0040) 	jacc	Dispatch_INTERRUPT_10_TBL
                                   (0041) Dispatch_INTERRUPT_10_TBL:
1F6F: 18       POP   A             (0042) 	pop		a
1F70: 7D 08 C7 LJMP  0x08C7        (0043) 	ljmp	_TX_REPEATER_ISR
1F73: 18       POP   A             (0044) 	pop		a
1F74: 7D 0A D9 LJMP  0x0AD9        (0045) 	ljmp	_RECEIVE_ISR
1F77: 18       POP   A             (0046) 	pop		a
1F78: 7D 09 A0 LJMP  0x09A0        (0047) 	ljmp	_TRANSMIT_ISR
                                   (0048) ; Resume Code Compressor.
                                   (0049) ; The next instruction does not get executed.
1F7B: 38 00    ADD   SP,0          (0050) 	Resume_CodeCompressor
                                   (0051) 
                                   (0052) Dispatch_INTERRUPT_9:
1F7D: 08       PUSH  A             (0053) 	push	a
1F7E: 50 00    MOV   A,0           (0054) 	mov		a,0
1F80: 47 02 04 TST   [2],4         (0055) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
1F83: B0 0C    JNZ   0x1F90        (0056) 	jnz		Dispatch_INTERRUPT_9_END
1F85: 50 04    MOV   A,4           (0057) 	mov		a,4
1F87: 47 02 01 TST   [2],1         (0058) 	tst		[ACTIVE_CONFIG_STATUS+transmitter_config_ADDR_OFF], transmitter_config_BIT
1F8A: B0 05    JNZ   0x1F90        (0059) 	jnz		Dispatch_INTERRUPT_9_END
1F8C: 18       POP   A             (0060) 	pop		a
1F8D: 7E       RETI                (0061) 	reti
                                   (0062) ; Stop Code Compressor from breaking table alignment
                                   (0063) ; The next instruction does not get executed.
1F8E: 71 00    OR    F,0           (0064) 	Suspend_CodeCompressor
                                   (0065) Dispatch_INTERRUPT_9_END:
1F90: E0 01    JACC  0x1F92        (0066) 	jacc	Dispatch_INTERRUPT_9_TBL
                                   (0067) Dispatch_INTERRUPT_9_TBL:
1F92: 18       POP   A             (0068) 	pop		a
1F93: 7D 1F 3D LJMP  _RX_TIMEOUT_ISR(0069) 	ljmp	_RX_TIMEOUT_ISR
1F96: 18       POP   A             (0070) 	pop		a
1F97: 7D 1F 27 LJMP  _TX_TIMEOUT_ISR(0071) 	ljmp	_TX_TIMEOUT_ISR
                                   (0072) ; Resume Code Compressor.
                                   (0073) ; The next instruction does not get executed.
                                   (0074) 	Resume_CodeCompressor

FILE: <library>
--------------------------------------------------------------------------------


PSoC Designer Version: 5.0.985.0

Copyright (C) 1994 - 2009 ImageCraft Creations Inc.
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Release version 7.01
