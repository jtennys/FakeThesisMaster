0000: 80 67    JMP   0x0068
0002: 30       HALT  
0003: 30       HALT  

FILE: .\boot.asm
                                   (0116) ; Generated by PSoC Designer 5.0.985.0
                                   (0117) ;
                                   (0118) ;@Id: boot.tpl#895 @
0004: 30       HALT                (0119) ;=============================================================================
0005: 30       HALT  
0006: 30       HALT  
0007: 30       HALT  
                                   (0120) ;  FILENAME:   boot.asm
                                   (0121) ;  VERSION:    4.18
                                   (0122) ;  DATE:       28 June 2007
0008: 7E       RETI                (0123) ;
0009: 30       HALT  
000A: 30       HALT  
000B: 30       HALT  
                                   (0124) ;  DESCRIPTION:
                                   (0125) ;  M8C Boot Code for CY8C29xxx microcontroller family.
                                   (0126) ;
000C: 7E       RETI                (0127) ;  Copyright (C) Cypress Semiconductor 2000-2005. All rights reserved.
000D: 30       HALT  
000E: 30       HALT  
000F: 30       HALT  
                                   (0128) ;
                                   (0129) ; NOTES:
                                   (0130) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
0010: 7E       RETI                (0131) ; the project's root directory to create BOOT.ASM. Any changes made to
0011: 30       HALT  
0012: 30       HALT  
0013: 30       HALT  
                                   (0132) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                   (0133) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                   (0134) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
0014: 7E       RETI                (0135) ; are not accidentally modified.
0015: 30       HALT  
0016: 30       HALT  
0017: 30       HALT  
                                   (0136) ;
                                   (0137) ;=============================================================================
                                   (0138) 
0018: 7E       RETI                (0139) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
0019: 30       HALT  
001A: 30       HALT  
001B: 30       HALT  
                                   (0140) include "m8c.inc"			;Part specific file
                                   (0141) include "m8ssc.inc"			;Part specific file
                                   (0142) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
001C: 7E       RETI                (0143) 
001D: 30       HALT  
001E: 30       HALT  
001F: 30       HALT  
                                   (0144) ;--------------------------------------
                                   (0145) ; Export Declarations
                                   (0146) ;--------------------------------------
0020: 7E       RETI                (0147) 
0021: 30       HALT  
0022: 30       HALT  
0023: 30       HALT  
                                   (0148) export __Start
                                   (0149) IF	(TOOLCHAIN & HITECH)
0024: 7D 23 42 LJMP  Dispatch_INTERRUPT_9(0150) ELSE
0027: 7E       RETI                (0151) export __bss_start
                                   (0152) export __data_start
                                   (0153) export __idata_start
0028: 7D 22 C6 LJMP  Dispatch_INTERRUPT_10(0154) export __func_lit_start
002B: 7E       RETI                (0155) export __text_start
                                   (0156) ENDIF
                                   (0157) export  _bGetPowerSetting
002C: 7D 22 E5 LJMP  Dispatch_INTERRUPT_11(0158) export   bGetPowerSetting
002F: 7E       RETI                (0159) 
                                   (0160) 
                                   (0161) ;--------------------------------------
                                   (0162) ; Optimization flags
0030: 7E       RETI                (0163) ;--------------------------------------
0031: 30       HALT  
0032: 30       HALT  
0033: 30       HALT  
                                   (0164) ;
                                   (0165) ; To change the value of these flags, modify the file boot.tpl, not
                                   (0166) ; boot.asm. See the notes in the banner comment at the beginning of
0034: 7E       RETI                (0167) ; this file.
0035: 30       HALT  
0036: 30       HALT  
0037: 30       HALT  
                                   (0168) 
                                   (0169) ; Optimization for Assembly language (only) projects and C-language projects
0038: 7D 23 04 LJMP  Dispatch_INTERRUPT_14(0170) ; that do not depend on the C compiler to initialize the values of RAM variables.
003B: 7E       RETI                (0171) ;   Set to 1: Support for C Run-time Environment initialization
                                   (0172) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                   (0173) ;
003C: 7D 23 23 LJMP  Dispatch_INTERRUPT_15(0174) IF	(TOOLCHAIN & HITECH)
003F: 7E       RETI                (0175) ; The C compiler will customize the startup code - it's not required here
                                   (0176) 
                                   (0177) C_LANGUAGE_SUPPORT:              equ 0
                                   (0178) ELSE
0040: 7E       RETI                (0179) C_LANGUAGE_SUPPORT:              equ 1
0041: 30       HALT  
0042: 30       HALT  
0043: 30       HALT  
                                   (0180) ENDIF
                                   (0181) 
                                   (0182) 
0044: 7E       RETI                (0183) ; The following equate is required for proper operation. Reseting its value
0045: 30       HALT  
0046: 30       HALT  
0047: 30       HALT  
                                   (0184) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                   (0185) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                   (0186) ; and PLL_Lock must take place within user code. See the family data sheet for
0048: 7E       RETI                (0187) ; the requirements of starting the ECO and PLL lock mode.
0049: 30       HALT  
004A: 30       HALT  
004B: 30       HALT  
                                   (0188) ;
                                   (0189) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                   (0190) ;                invoking main
004C: 7E       RETI                (0191) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
004D: 30       HALT  
004E: 30       HALT  
004F: 30       HALT  
                                   (0192) ;               the time code in main starts executing.
                                   (0193) ;
                                   (0194) WAIT_FOR_32K:                    equ 1
0050: 7E       RETI                (0195) 
0051: 30       HALT  
0052: 30       HALT  
0053: 30       HALT  
                                   (0196) 
                                   (0197) ; For historical reasons, by default the boot code uses an lcall instruction
                                   (0198) ; to invoke the user's _main code. If _main executes a return instruction,
0054: 7E       RETI                (0199) ; boot provides an infinite loop. By changing the following equate from zero
0055: 30       HALT  
0056: 30       HALT  
0057: 30       HALT  
                                   (0200) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                   (0201) ; bytes on the stack which are otherwise required for the return address. If
                                   (0202) ; this option is enabled, _main must not return. (Beginning with the 4.2
0058: 7E       RETI                (0203) ; release, the C compiler automatically places an infinite loop at the end
0059: 30       HALT  
005A: 30       HALT  
005B: 30       HALT  
                                   (0204) ; of main, rather than a return instruction.)
                                   (0205) ;
                                   (0206) ENABLE_LJMP_TO_MAIN:             equ 0
005C: 7E       RETI                (0207) 
005D: 30       HALT  
005E: 30       HALT  
005F: 30       HALT  
                                   (0208) 
                                   (0209) ;-----------------------------------------------------------------------------
                                   (0210) ; Interrupt Vector Table
0060: 7E       RETI                (0211) ;-----------------------------------------------------------------------------
0061: 30       HALT  
0062: 30       HALT  
0063: 30       HALT  
                                   (0212) ;
                                   (0213) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                   (0214) ; a jump instruction to an ISR (Interrupt Service Routine), although
0064: 7E       RETI                (0215) ; very short ISRs could be encoded within the table itself. Normally,
0065: 30       HALT  
0066: 30       HALT  
0067: 30       HALT  
                                   (0216) ; vector jump targets are modified automatically according to the user
                                   (0217) ; modules selected. This occurs when the 'Generate Application' opera-
                                   (0218) ; tion is run causing PSoC Designer to create boot.asm and the other
                                   (0219) ; configuration files. If you need to hard code a vector, update the
                                   (0220) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                   (0221) ; of this file.
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) 
                                   (0224)     AREA TOP (ROM, ABS, CON)
                                   (0225) 
                                   (0226)     org   0                        ;Reset Interrupt Vector
                                   (0227) IF	(TOOLCHAIN & HITECH)
                                   (0228) ;   jmp   __Start                  ;C compiler fills in this vector
                                   (0229) ELSE
                                   (0230)     jmp   __Start                  ;First instruction executed following a Reset
                                   (0231) ENDIF
                                   (0232) 
                                   (0233)     org   04h                      ;Supply Monitor Interrupt Vector
                                   (0234)     halt                           ;Stop execution if power falls too low
0068: 71 10    OR    F,16          (0235) 
006A: 62 FA 00 MOV   REG[250],0    (0236)     org   08h                      ;Analog Column 0 Interrupt Vector
006D: 62 E3 87 MOV   REG[227],135  (0237)     // call	void_handler
0070: 70 EF    AND   F,239         (0238)     reti
                                   (0239) 
                                   (0240)     org   0Ch                      ;Analog Column 1 Interrupt Vector
0072: 50 20    MOV   A,32          (0241)     // call	void_handler
0074: 28       ROMX                (0242)     reti
0075: 50 40    MOV   A,64          (0243) 
0077: 28       ROMX                (0244)     org   10h                      ;Analog Column 2 Interrupt Vector
0078: 50 60    MOV   A,96          (0245)     // call	void_handler
007A: 28       ROMX                (0246)     reti
                                   (0247) 
                                   (0248)     org   14h                      ;Analog Column 3 Interrupt Vector
                                   (0249)     // call	void_handler
                                   (0250)     reti
                                   (0251) 
                                   (0252)     org   18h                      ;VC3 Interrupt Vector
                                   (0253)     // call	void_handler
                                   (0254)     reti
                                   (0255) 
007B: 41 FE FB AND   REG[254],251  (0256)     org   1Ch                      ;GPIO Interrupt Vector
                                   (0257)     // call	void_handler
                                   (0258)     reti
                                   (0259) 
                                   (0260)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
                                   (0261)     // call	void_handler
                                   (0262)     reti
                                   (0263) 
                                   (0264)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                   (0265)     ljmp	Dispatch_INTERRUPT_9
007E: 50 80    MOV   A,128         (0266)     reti
0080: 4E       SWAP  SP,A          (0267) 
                                   (0268)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                   (0269)     ljmp	Dispatch_INTERRUPT_10
                                   (0270)     reti
                                   (0271) 
                                   (0272)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                   (0273)     ljmp	Dispatch_INTERRUPT_11
                                   (0274)     reti
                                   (0275) 
                                   (0276)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
                                   (0277)     // call	void_handler
                                   (0278)     reti
                                   (0279) 
                                   (0280)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
                                   (0281)     // call	void_handler
                                   (0282)     reti
                                   (0283) 
                                   (0284)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
                                   (0285)     ljmp	Dispatch_INTERRUPT_14
                                   (0286)     reti
                                   (0287) 
                                   (0288)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
                                   (0289)     ljmp	Dispatch_INTERRUPT_15
                                   (0290)     reti
                                   (0291) 
                                   (0292)     org   40h                      ;PSoC Block DBB20 Interrupt Vector
                                   (0293)     // call	void_handler
                                   (0294)     reti
                                   (0295) 
                                   (0296)     org   44h                      ;PSoC Block DBB21 Interrupt Vector
                                   (0297)     // call	void_handler
0081: 55 F8 00 MOV   [248],0       (0298)     reti
0084: 55 F9 00 MOV   [249],0       (0299) 
                                   (0300)     org   48h                      ;PSoC Block DCB22 Interrupt Vector
                                   (0301)     // call	void_handler
                                   (0302)     reti
                                   (0303) 
                                   (0304)     org   4Ch                      ;PSoC Block DCB23 Interrupt Vector
                                   (0305)     // call	void_handler
                                   (0306)     reti
                                   (0307) 
                                   (0308)     org   50h                      ;PSoC Block DBB30 Interrupt Vector
                                   (0309)     // call	void_handler
                                   (0310)     reti
                                   (0311) 
                                   (0312)     org   54h                      ;PSoC Block DBB31 Interrupt Vector
                                   (0313)     // call	void_handler
                                   (0314)     reti
                                   (0315) 
                                   (0316)     org   58h                      ;PSoC Block DCB32 Interrupt Vector
                                   (0317)     // call	void_handler
                                   (0318)     reti
                                   (0319) 
                                   (0320)     org   5Ch                      ;PSoC Block DCB33 Interrupt Vector
                                   (0321)     // call	void_handler
                                   (0322)     reti
0087: 71 10    OR    F,16          (0323) 
0089: 62 E0 1A MOV   REG[224],26   (0324)     org   60h                      ;PSoC I2C Interrupt Vector
008C: 70 EF    AND   F,239         (0325)     // call	void_handler
008E: 62 E3 38 MOV   REG[227],56   (0326)     reti
                                   (0327) 
                                   (0328)     org   64h                      ;Sleep Timer Interrupt Vector
                                   (0329)     // call	void_handler
                                   (0330)     reti
                                   (0331) 
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;  Start of Execution.
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  The Supervisory ROM SWBootReset function has already completed the
                                   (0336) ;  calibrate1 process, loading trim values for 5 volt operation.
                                   (0337) ;
                                   (0338) 
                                   (0339) IF	(TOOLCHAIN & HITECH)
                                   (0340)  	AREA PD_startup(CODE, REL, CON)
                                   (0341) ELSE
                                   (0342)     org 68h
                                   (0343) ENDIF
                                   (0344) __Start:
                                   (0345) 
                                   (0346)     ; initialize SMP values for voltage stabilization, if required,
                                   (0347)     ; leaving power-on reset (POR) level at the default (low) level, at
                                   (0348)     ; least for now. 
                                   (0349)     ;
                                   (0350)     M8C_SetBank1
                                   (0351)     mov reg[0FAh], 0				;Reset flash location
                                   (0352)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
                                   (0353)     M8C_SetBank0
                                   (0354) 
                                   (0355)     ; %53%20%46%46% Apply Erratum 001-05137 workaround
                                   (0356)     mov   A, 20h
0091: 62 71 05 MOV   REG[113],5    (0357)     romx
0094: 62 75 05 MOV   REG[117],5    (0358)     mov   A, 40h
0097: 62 79 05 MOV   REG[121],5    (0359)     romx
009A: 62 7D 05 MOV   REG[125],5    (0360)     mov   A, 60h
                                   (0361)     romx
                                   (0362)     ; %45%20%46%46% End workaround
                                   (0363) 
                                   (0364) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                   (0365)     M8C_EnableWatchDog
                                   (0366) ENDIF
                                   (0367) 
                                   (0368) IF ( SELECT_32K )
                                   (0369)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                   (0370) ELSE
                                   (0371)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                   (0372) ENDIF
                                   (0373) 
                                   (0374)     ;---------------------------
                                   (0375)     ; Set up the Temporary stack
                                   (0376)     ;---------------------------
                                   (0377)     ; A temporary stack is set up for the SSC instructions.
                                   (0378)     ; The real stack start will be assigned later.
                                   (0379)     ;
                                   (0380) _stack_start:          equ 80h
                                   (0381)     mov   A, _stack_start          ; Set top of stack to end of used RAM
                                   (0382)     swap  SP, A                    ; This is only temporary if going to LMM
                                   (0383) 
                                   (0384)     ;-----------------------------------------------
                                   (0385)     ; Set Power-related Trim & the AGND Bypass bit.
                                   (0386)     ;-----------------------------------------------
                                   (0387) 
009D: 62 D1 07 MOV   REG[209],7    (0388) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
00A0: 50 00    MOV   A,0           (0389)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
00A2: 4E       SWAP  SP,A          (0390)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
00A3: 62 D3 07 MOV   REG[211],7    (0391)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
00A6: 62 D0 00 MOV   REG[208],0    (0392)  ELSE                                          ; *** 12MHZ Main Oscillator ***
00A9: 62 D5 00 MOV   REG[213],0    (0393)   IF ( AGND_BYPASS )
00AC: 62 D4 00 MOV   REG[212],0    (0394)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0395)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                   (0396)     ; bit in the write-only BDG_TR register. Recalculate the register
00AF: 71 C0    OR    F,192         (0397)     ; value using the proper trim values.
                                   (0398)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                   (0399)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                   (0400)   ENDIF
                                   (0401)  ENDIF
                                   (0402) ENDIF ; 5.0 V Operation
                                   (0403) 
                                   (0404) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                   (0405)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                   (0406)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                   (0407)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0408)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                   (0409)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                   (0410)  ENDIF
                                   (0411) ENDIF ; 3.3 Volt Operation
                                   (0412) 
                                   (0413)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
                                   (0414)     mov  [bSSC_KEYSP], 0
00B1: 7C 06 24 LCALL 0x0624        (0415) 
                                   (0416)     ;---------------------------------------
                                   (0417)     ; Initialize Crystal Oscillator and PLL
                                   (0418)     ;---------------------------------------
                                   (0419) 
                                   (0420) IF ( SELECT_32K & WAIT_FOR_32K )
                                   (0421)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                   (0422)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                   (0423)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                   (0424)     ; the ECO to stabilize.
                                   (0425)     ;
                                   (0426)     M8C_SetBank1
                                   (0427)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                   (0428)     M8C_SetBank0
                                   (0429)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                   (0430)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                   (0431)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                   (0432) .WaitFor1s:
                                   (0433)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                   (0434)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                   (0435)                                           ;   since interrupts are not globally enabled
                                   (0436) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                   (0437)     ; Either no ECO, or waiting for stable clock is to be done in main
                                   (0438)     M8C_SetBank1
                                   (0439)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
                                   (0440)     M8C_SetBank0
                                   (0441)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                   (0442) 
                                   (0443) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                   (0444) 
                                   (0445) IF ( PLL_MODE )
                                   (0446)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
00B4: 62 D0 00 MOV   REG[208],0    (0447)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                   (0448)     ;
                                   (0449)     M8C_SetBank1
                                   (0450)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                   (0451)     M8C_SetBank0
                                   (0452)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                   (0453)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
00B7: 50 06    MOV   A,6           (0454) 
00B9: 57 22    MOV   X,34          (0455) .WaitFor16ms:
00BB: 08       PUSH  A             (0456)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
00BC: 28       ROMX                (0457)     jz   .WaitFor16ms
00BD: 53 9D    MOV   [__r0],A      (0458)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
00BF: 18       POP   A             (0459)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
00C0: 75       INC   X             (0460)     M8C_SetBank0
00C1: 09 00    ADC   A,0           (0461) 
00C3: 28       ROMX                (0462) IF      ( WAIT_FOR_32K )
00C4: 4B       SWAP  A,X           (0463) ELSE ; !( WAIT_FOR_32K )
00C5: 51 9D    MOV   A,[157]       (0464)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                   (0465)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
00C7: 80 04    JMP   0x00CC        (0466) ENDIF ;(WAIT_FOR_32K)
                                   (0467) ENDIF ;(PLL_MODE)
                                   (0468) 
                                   (0469)     ;------------------------
                                   (0470)     ; Close CT leakage path.
                                   (0471)     ;------------------------
                                   (0472)     mov   reg[ACB00CR0], 05h
                                   (0473)     mov   reg[ACB01CR0], 05h
                                   (0474)     mov   reg[ACB02CR0], 05h
                                   (0475)     mov   reg[ACB03CR0], 05h
                                   (0476) 
                                   (0477) 
                                   (0478) IF	(TOOLCHAIN & HITECH)
                                   (0479)     ;---------------------------------------------
                                   (0480)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                   (0481)     ;---------------------------------------------
                                   (0482) 	global		__Lstackps
                                   (0483) 	mov     a,low __Lstackps
00C9: 75       INC   X             (0484) 	swap    a,sp
00CA: 09 00    ADC   A,0           (0485) 
                                   (0486) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0487)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                   (0488)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                   (0489)     RAM_SETPAGE_CUR 0
00CC: 62 E3 00 MOV   REG[227],0    (0490)     RAM_SETPAGE_MVW 0
00CF: 08       PUSH  A             (0491)     RAM_SETPAGE_MVR 0
00D0: 28       ROMX                (0492)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00D1: 60 D5    MOV   REG[213],A    (0493)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
00D3: 74       INC   A             (0494)     ELSE
00D4: A0 4B    JZ    0x0120        (0495)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
00D6: 18       POP   A             (0496)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
00D7: 75       INC   X             (0497) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00D8: 09 00    ADC   A,0           (0498) ELSE
00DA: 08       PUSH  A             (0499)     ;---------------------------------------------
00DB: 28       ROMX                (0500)     ; ImageCraft Enter the Large Memory Model, if applicable
00DC: 53 9D    MOV   [__r0],A      (0501)     ;---------------------------------------------
00DE: 18       POP   A             (0502) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00DF: 75       INC   X             (0503)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00E0: 09 00    ADC   A,0           (0504)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00E2: 08       PUSH  A             (0505)     swap  A, SP
00E3: 28       ROMX                (0506)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
00E4: A0 1C    JZ    0x0101        (0507)     RAM_SETPAGE_CUR 0
00E6: 53 9C    MOV   [__r1],A      (0508)     RAM_SETPAGE_MVW 0
00E8: 18       POP   A             (0509)     RAM_SETPAGE_MVR 0
                                   (0510) 
                                   (0511)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                   (0512)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                   (0513)   ELSE
                                   (0514)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                   (0515)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                   (0516) ELSE
00E9: 75       INC   X             (0517)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
00EA: 09 00    ADC   A,0           (0518)     swap  SP, A
00EC: 08       PUSH  A             (0519) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
00ED: 28       ROMX                (0520) ENDIF ;	TOOLCHAIN
00EE: 3F 9D    MVI   [__r0],A      (0521) 
00F0: 47 9D FF TST   [157],255     (0522)     ;-------------------------
00F3: B0 06    JNZ   0x00FA        (0523)     ; Load Base Configuration
00F5: 5D D5    MOV   A,REG[213]    (0524)     ;-------------------------
00F7: 74       INC   A             (0525)     ; Load global parameter settings and load the user modules in the
00F8: 60 D5    MOV   REG[213],A    (0526)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                   (0527)     ; to minimize start up time; (2) We may still need to play with the
00FA: 18       POP   A             (0528)     ; Sleep Timer.
00FB: 7A 9C    DEC   [__r1]        (0529)     ;
00FD: BF EB    JNZ   0x00E9        (0530)     lcall LoadConfigInit
00FF: 8F C9    JMP   0x00C9        (0531) 
                                   (0532)     ;-----------------------------------
                                   (0533)     ; Initialize C Run-Time Environment
0101: 18       POP   A             (0534)     ;-----------------------------------
0102: 75       INC   X             (0535) IF ( C_LANGUAGE_SUPPORT )
0103: 09 00    ADC   A,0           (0536) IF ( SYSTEM_SMALL_MEMORY_MODEL )
0105: 08       PUSH  A             (0537)     mov  A,0                           ; clear the 'bss' segment to zero
0106: 28       ROMX                (0538)     mov  [__r0],<__bss_start
0107: 53 9C    MOV   [__r1],A      (0539) BssLoop:
0109: 50 00    MOV   A,0           (0540)     cmp  [__r0],<__bss_end
                                   (0541)     jz   BssDone
                                   (0542)     mvi  [__r0],A
                                   (0543)     jmp  BssLoop
                                   (0544) BssDone:
                                   (0545)     mov  A,>__idata_start              ; copy idata to data segment
010B: 3F 9D    MVI   [__r0],A      (0546)     mov  X,<__idata_start
010D: 47 9D FF TST   [157],255     (0547)     mov  [__r0],<__data_start
0110: B0 08    JNZ   0x0119        (0548) IDataLoop:
0112: 5D D5    MOV   A,REG[213]    (0549)     cmp  [__r0],<__data_end
0114: 74       INC   A             (0550)     jz   C_RTE_Done
0115: 60 D5    MOV   REG[213],A    (0551)     push A
0117: 50 00    MOV   A,0           (0552)     romx
                                   (0553)     mvi  [__r0],A
0119: 7A 9C    DEC   [__r1]        (0554)     pop  A
011B: BF EF    JNZ   0x010B        (0555)     inc  X
011D: 18       POP   A             (0556)     adc  A,0
011E: 8F AA    JMP   0x00C9        (0557)     jmp  IDataLoop
                                   (0558) 
                                   (0559) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
0120: 18       POP   A             (0560) 
                                   (0561) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                   (0562)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                   (0563)                                        ; to use the Virtual Register page.
                                   (0564) 
                                   (0565)     ; Dereference the constant (flash) pointer pXIData to access the start
                                   (0566)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                   (0567)     ; text segment and may have been relocated by the Code Compressor.
                                   (0568)     ;
                                   (0569)     mov   A, >__pXIData                ; Get the address of the flash
                                   (0570)     mov   X, <__pXIData                ;   pointer to the xidata area.
                                   (0571)     push  A
                                   (0572)     romx                               ; get the MSB of xidata's address
                                   (0573)     mov   [__r0], A
                                   (0574)     pop   A
                                   (0575)     inc   X
                                   (0576)     adc   A, 0
                                   (0577)     romx                               ; get the LSB of xidata's address
                                   (0578)     swap  A, X
                                   (0579)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                   (0580)                                        ;   XIData structure list in flash
                                   (0581)     jmp   .AccessStruct
                                   (0582) 
                                   (0583)     ; Unpack one element in the xidata "structure list" that specifies the
                                   (0584)     ; values of C variables. Each structure contains 3 member elements.
                                   (0585)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                   (0586)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                   (0587)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                   (0588)     ; contains 0xFF. There are two formats for the struct depending on the
                                   (0589)     ; value in the second member element, an unsigned byte:
                                   (0590)     ; (1) If the value of the second element is non-zero, it represents
                                   (0591)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                   (0592)     ; third member of the struct is an array of bytes of length 'size' and
                                   (0593)     ; the bytes are copied to the block of RAM.
                                   (0594)     ; (2) If the value of the second element is zero, the block of RAM is
                                   (0595)     ; to be cleared to zero. In this case, the third member of the struct
                                   (0596)     ; is an unsigned byte containing the number of bytes to clear.
                                   (0597) 
                                   (0598) .AccessNextStructLoop:
                                   (0599)     inc   X                            ; pXIData++
                                   (0600)     adc   A, 0
0121: 71 10    OR    F,16          (0601) .AccessStruct:                         ; Entry point for first block
                                   (0602)     ;
                                   (0603)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                   (0604)     ;
                                   (0605)     M8C_ClearWDT                       ; Clear the watchdog for long inits
                                   (0606)     push  A
                                   (0607)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
                                   (0608)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
0123: 43 E3 20 OR    REG[227],32   (0609)     inc   A                            ; End of Struct List? (MSB==0xFF?)
                                   (0610)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
                                   (0611)     pop   A                            ; restore pXIData to [A,X]
                                   (0612)     inc   X                            ; pXIData++
                                   (0613)     adc   A, 0
0126: 70 EF    AND   F,239         (0614)     push  A
                                   (0615)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
                                   (0616)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
                                   (0617)     pop   A                            ; restore pXIData to [A,X]
                                   (0618)     inc   X                            ; pXIData++ (point to size)
                                   (0619)     adc   A, 0
                                   (0620)     push  A
                                   (0621)     romx                               ; Get the size (CPU.A <- *pXIData)
                                   (0622)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
0128: 62 E0 00 MOV   REG[224],0    (0623)     mov   [__r1], A                    ;             else downcount in __r1
                                   (0624)     pop   A                            ; restore pXIData to [A,X]
                                   (0625) 
                                   (0626) .CopyNextByteLoop:
                                   (0627)     ; For each byte in the structure's array member, copy from flash to RAM.
012B: 71 10    OR    F,16          (0628)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
012D: 62 E0 1B MOV   REG[224],27   (0629)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
0130: 43 E7 80 OR    REG[231],128  (0630)     ;         __r1 holds a non-zero count of the number of bytes remaining.
0133: 70 EF    AND   F,239         (0631)     ;
                                   (0632)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0633)     adc   A, 0
                                   (0634)     push  A
                                   (0635)     romx                               ; Get the data value (CPU.A <- *pXIData)
                                   (0636)     mvi   [__r0], A                    ; Transfer the data to RAM
0135: 62 E2 00 MOV   REG[226],0    (0637)     tst   [__r0], 0xff                 ; Check for page crossing
                                   (0638)     jnz   .CopyLoopTail                ;   No crossing, keep going
                                   (0639)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
                                   (0640)     inc   A
                                   (0641)     mov   reg[ MVW_PP], A
                                   (0642) .CopyLoopTail:
                                   (0643)     pop   A                            ; restore pXIData to [A,X]
                                   (0644)     dec   [__r1]                       ; End of this array in flash?
0138: 7C 12 1E LCALL __text_start  (0645)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
                                   (0646)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
013B: 8F FF    JMP   0x013B        (0647) 
                                   (0648) .ClearRAMBlockToZero:
                                   (0649)     pop   A                            ; restore pXIData to [A,X]
                                   (0650)     inc   X                            ; pXIData++ (point to next data byte)
                                   (0651)     adc   A, 0
                                   (0652)     push  A
                                   (0653)     romx                               ; Get the run length (CPU.A <- *pXIData)
                                   (0654)     mov   [__r1], A                    ; Initialize downcounter
                                   (0655)     mov   A, 0                         ; Initialize source data
                                   (0656) 
                                   (0657) .ClearRAMBlockLoop:
                                   (0658)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                   (0659)     ;         __r1 holds a non-zero count of the number of bytes remaining.
013D: 50 10    MOV   A,16          (0660)     ;
02D9: 71 10    OR    F,16          (0661)     mvi   [__r0], A                    ; Clear a byte

FILE: lib\psocconfigtbl.asm
02DB: 62 00 01 MOV   REG[0],1      (0263) ; Generated by PSoC Designer 5.0.985.0
02DE: 62 01 FE MOV   REG[1],254    (0264) ;
02E1: 70 EF    AND   F,239         (0265) include "m8c.inc"
02E3: 62 03 E0 MOV   REG[3],224    (0266) ;  Personalization tables 
02E6: 62 02 1E MOV   REG[2],30     (0267) export LoadConfigTBL_receiver_config_Bank1
02E9: 71 10    OR    F,16          (0268) export LoadConfigTBL_receiver_config_Bank0
02EB: 62 02 00 MOV   REG[2],0      (0269) export LoadConfigTBL_receiver_config_Ordered
02EE: 62 03 00 MOV   REG[3],0      (0270) export UnloadConfigTBL_receiver_config_Bank1
02F1: 70 EF    AND   F,239         (0271) export UnloadConfigTBL_receiver_config_Bank0
02F3: 62 01 00 MOV   REG[1],0      (0272) export ReloadConfigTBL_receiver_config_Bank1
02F6: 71 10    OR    F,16          (0273) export ReloadConfigTBL_receiver_config_Bank0
02F8: 62 04 01 MOV   REG[4],1      (0274) export LoadConfigTBL_pc_listener_Bank1
02FB: 62 05 FE MOV   REG[5],254    (0275) export LoadConfigTBL_pc_listener_Bank0
02FE: 70 EF    AND   F,239         (0276) export UnloadConfigTBL_pc_listener_Bank1
0300: 62 07 FE MOV   REG[7],254    (0277) export UnloadConfigTBL_pc_listener_Bank0
0303: 62 06 00 MOV   REG[6],0      (0278) export UnloadConfigTBL_Total_Bank1
0306: 71 10    OR    F,16          (0279) export UnloadConfigTBL_Total_Bank0
0308: 62 06 00 MOV   REG[6],0      (0280) AREA lit(rom, rel)
030B: 62 07 00 MOV   REG[7],0      (0281) LoadConfigTBL_pc_listener_Bank0:
030E: 70 EF    AND   F,239         (0282) ;  Instance name COMP_SERIAL, User Module UART
0310: 62 05 00 MOV   REG[5],0      (0283) ;       Instance name COMP_SERIAL, Block Name RX(DCB13)
0313: 71 10    OR    F,16          (0284) 	db		3fh, 00h		;COMP_SERIAL_RX_CONTROL_REG(DCB13CR0)
0315: 62 08 00 MOV   REG[8],0      (0285) 	db		3dh, 00h		;COMP_SERIAL_(DCB13DR1)
0318: 62 09 FF MOV   REG[9],255    (0286) 	db		3eh, 00h		;COMP_SERIAL_RX_BUFFER_REG (DCB13DR2)
031B: 70 EF    AND   F,239         (0287) ;       Instance name COMP_SERIAL, Block Name TX(DCB12)
031D: 62 0B FF MOV   REG[11],255   (0288) 	db		3bh, 00h		;COMP_SERIAL_TX_CONTROL_REG(DCB12CR0)
0320: 62 0A 00 MOV   REG[10],0     (0289) 	db		39h, 00h		;COMP_SERIAL_TX_BUFFER_REG (DCB12DR1)
0323: 71 10    OR    F,16          (0290) 	db		3ah, 00h		;COMP_SERIAL_(DCB12DR2)
0325: 62 0A 00 MOV   REG[10],0     (0291) ;  Instance name TX_REPEATER_14, User Module TX8
0328: 62 0B 00 MOV   REG[11],0     (0292) ;       Instance name TX_REPEATER_14, Block Name TX8(DCB02)
032B: 70 EF    AND   F,239         (0293) 	db		2bh, 00h		;TX_REPEATER_14_CONTROL_REG  (DCB02CR0)
032D: 62 09 00 MOV   REG[9],0      (0294) 	db		29h, 00h		;TX_REPEATER_14_TX_BUFFER_REG(DCB02DR1)
0330: 71 10    OR    F,16          (0295) 	db		2ah, 00h		;TX_REPEATER_14_(DCB02DR2)
0332: 62 0C 00 MOV   REG[12],0     (0296) ;  Instance name TX_REPEATER_23, User Module TX8
0335: 62 0D 00 MOV   REG[13],0     (0297) ;       Instance name TX_REPEATER_23, Block Name TX8(DCB03)
0338: 70 EF    AND   F,239         (0298) 	db		2fh, 00h		;TX_REPEATER_23_CONTROL_REG  (DCB03CR0)
033A: 62 0F 00 MOV   REG[15],0     (0299) 	db		2dh, 00h		;TX_REPEATER_23_TX_BUFFER_REG(DCB03DR1)
033D: 62 0E 00 MOV   REG[14],0     (0300) 	db		2eh, 00h		;TX_REPEATER_23_(DCB03DR2)
0340: 71 10    OR    F,16          (0301) ;  Instance name TX_TIMEOUT, User Module Timer16
0342: 62 0E 00 MOV   REG[14],0     (0302) ;       Instance name TX_TIMEOUT, Block Name TIMER16_LSB(DBB00)
0345: 62 0F 00 MOV   REG[15],0     (0303) 	db		23h, 00h		;TX_TIMEOUT_CONTROL_LSB_REG(DBB00CR0)
0348: 70 EF    AND   F,239         (0304) 	db		21h, 40h		;TX_TIMEOUT_PERIOD_LSB_REG(DBB00DR1)
034A: 62 0D 00 MOV   REG[13],0     (0305) 	db		22h, 00h		;TX_TIMEOUT_COMPARE_LSB_REG(DBB00DR2)
034D: 71 10    OR    F,16          (0306) ;       Instance name TX_TIMEOUT, Block Name TIMER16_MSB(DBB01)
034F: 62 10 00 MOV   REG[16],0     (0307) 	db		27h, 04h		;TX_TIMEOUT_CONTROL_MSB_REG(DBB01CR0)
0352: 62 11 00 MOV   REG[17],0     (0308) 	db		25h, 1fh		;TX_TIMEOUT_PERIOD_MSB_REG(DBB01DR1)
0355: 70 EF    AND   F,239         (0309) 	db		26h, 00h		;TX_TIMEOUT_COMPARE_MSB_REG(DBB01DR2)
0357: 62 13 00 MOV   REG[19],0     (0310) 	db		ffh
035A: 62 12 00 MOV   REG[18],0     (0311) LoadConfigTBL_pc_listener_Bank1:
035D: 71 10    OR    F,16          (0312) ;  Instance name COMP_SERIAL, User Module UART
035F: 62 12 00 MOV   REG[18],0     (0313) ;       Instance name COMP_SERIAL, Block Name RX(DCB13)
0362: 62 13 00 MOV   REG[19],0     (0314) 	db		3ch, 05h		;COMP_SERIAL_RX_FUNC_REG   (DCB13FN)
0365: 70 EF    AND   F,239         (0315) 	db		3dh, f6h		;COMP_SERIAL_RX_INPUT_REG  (DCB13IN)
0367: 62 11 00 MOV   REG[17],0     (0316) 	db		3eh, 80h		;COMP_SERIAL_RX_OUTPUT_REG (DCB13OU)
036A: 71 10    OR    F,16          (0317) ;       Instance name COMP_SERIAL, Block Name TX(DCB12)
036C: 62 14 00 MOV   REG[20],0     (0318) 	db		38h, 1dh		;COMP_SERIAL_TX_FUNC_REG   (DCB12FN)
036F: 62 15 00 MOV   REG[21],0     (0319) 	db		39h, 06h		;COMP_SERIAL_TX_INPUT_REG  (DCB12IN)
0372: 70 EF    AND   F,239         (0320) 	db		3ah, 85h		;COMP_SERIAL_TX_OUTPUT_REG (DCB12OU)
0374: 62 17 00 MOV   REG[23],0     (0321) ;  Instance name TX_REPEATER_14, User Module TX8
0377: 62 16 00 MOV   REG[22],0     (0322) ;       Instance name TX_REPEATER_14, Block Name TX8(DCB02)
037A: 71 10    OR    F,16          (0323) 	db		28h, 1dh		;TX_REPEATER_14_FUNC_REG     (DCB02FN)
037C: 62 16 00 MOV   REG[22],0     (0324) 	db		29h, 01h		;TX_REPEATER_14_INPUT_REG    (DCB02IN)
037F: 62 17 00 MOV   REG[23],0     (0325) 	db		2ah, 85h		;TX_REPEATER_14_OUTPUT_REG   (DCB02OU)
0382: 70 EF    AND   F,239         (0326) ;  Instance name TX_REPEATER_23, User Module TX8
0384: 62 15 00 MOV   REG[21],0     (0327) ;       Instance name TX_REPEATER_23, Block Name TX8(DCB03)
0387: 71 10    OR    F,16          (0328) 	db		2ch, 1dh		;TX_REPEATER_23_FUNC_REG     (DCB03FN)
0389: 62 18 00 MOV   REG[24],0     (0329) 	db		2dh, 01h		;TX_REPEATER_23_INPUT_REG    (DCB03IN)
038C: 62 19 00 MOV   REG[25],0     (0330) 	db		2eh, 87h		;TX_REPEATER_23_OUTPUT_REG   (DCB03OU)
038F: 70 EF    AND   F,239         (0331) ;  Instance name TX_TIMEOUT, User Module Timer16
0391: 62 1B 00 MOV   REG[27],0     (0332) ;       Instance name TX_TIMEOUT, Block Name TIMER16_LSB(DBB00)
0394: 62 1A 00 MOV   REG[26],0     (0333) 	db		20h, 00h		;TX_TIMEOUT_FUNC_LSB_REG(DBB00FN)
0397: 71 10    OR    F,16          (0334) 	db		21h, 01h		;TX_TIMEOUT_INPUT_LSB_REG(DBB00IN)
0399: 62 1A 00 MOV   REG[26],0     (0335) 	db		22h, 80h		;TX_TIMEOUT_OUTPUT_LSB_REG(DBB00OU)
039C: 62 1B 00 MOV   REG[27],0     (0336) ;       Instance name TX_TIMEOUT, Block Name TIMER16_MSB(DBB01)
039F: 70 EF    AND   F,239         (0337) 	db		24h, 20h		;TX_TIMEOUT_FUNC_MSB_REG(DBB01FN)
03A1: 62 19 00 MOV   REG[25],0     (0338) 	db		25h, 31h		;TX_TIMEOUT_INPUT_MSB_REG(DBB01IN)
03A4: 71 10    OR    F,16          (0339) 	db		26h, 80h		;TX_TIMEOUT_OUTPUT_MSB_REG(DBB01OU)
03A6: 62 1C 00 MOV   REG[28],0     (0340) 	db		ffh
03A9: 62 1D 00 MOV   REG[29],0     (0341) UnloadConfigTBL_pc_listener_Bank0:
03AC: 70 EF    AND   F,239         (0342) ;  Instance name COMP_SERIAL, User Module UART
03AE: 62 1F 00 MOV   REG[31],0     (0343) ;       Instance name COMP_SERIAL, Block Name RX(DCB13)
03B1: 62 1E 00 MOV   REG[30],0     (0344) 	db		3fh, 00h		;COMP_SERIAL_CONTROL_0 (DCB13CR0)
03B4: 71 10    OR    F,16          (0345) ;       Instance name COMP_SERIAL, Block Name TX(DCB12)
03B6: 62 1E 00 MOV   REG[30],0     (0346) 	db		3bh, 00h		;COMP_SERIAL_CONTROL_0 (DCB12CR0)
03B9: 62 1F 00 MOV   REG[31],0     (0347) ;  Instance name TX_REPEATER_14, User Module TX8
03BC: 70 EF    AND   F,239         (0348) ;       Instance name TX_REPEATER_14, Block Name TX8(DCB02)
03BE: 62 1D 00 MOV   REG[29],0     (0349) 	db		2bh, 00h		;TX_REPEATER_14_CONTROL_0 (DCB02CR0)
0624: 62 D0 00 MOV   REG[208],0    (0350) ;  Instance name TX_REPEATER_23, User Module TX8

FILE: lib\psocconfig.asm
0627: 55 08 00 MOV   [8],0         (0070) ; Generated by PSoC Designer 5.0.985.0
                                   (0071) ;
062A: 7C 06 31 LCALL 0x0631        (0072) INCLUDE "PSoCDynamic.inc"
062D: 7C 02 D9 LCALL 0x02D9        (0073) ;==========================================================================
                                   (0074) ;  PSoCConfig.asm
                                   (0075) ;  @PSOC_VERSION
                                   (0076) ;
0630: 7F       RET                 (0077) ;  Version: 0.85
                                   (0078) ;  Revised: June 22, 2004
                                   (0079) ;  Copyright Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0080) ;
                                   (0081) ;  This file is generated by the Device Editor on Application Generation.
                                   (0082) ;  It contains code which loads the configuration data table generated in
                                   (0083) ;  the file PSoCConfigTBL.asm
                                   (0084) ;
                                   (0085) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0086) ;  Edits to this file will not be preserved.
                                   (0087) ;==========================================================================
                                   (0088) ;
                                   (0089) include "m8c.inc"
                                   (0090) include "memory.inc"
                                   (0091) include "GlobalParams.inc"
                                   (0092) 
                                   (0093) export LoadConfigInit
                                   (0094) export _LoadConfigInit
                                   (0095) export LoadConfig_receiver_config
                                   (0096) export _LoadConfig_receiver_config
                                   (0097) export UnloadConfig_receiver_config
                                   (0098) export _UnloadConfig_receiver_config
                                   (0099) export ReloadConfig_receiver_config
                                   (0100) export _ReloadConfig_receiver_config
0631: 71 10    OR    F,16          (0101) export LoadConfig_pc_listener
                                   (0102) export _LoadConfig_pc_listener
0633: 10       PUSH  X             (0103) export UnloadConfig_pc_listener
0634: 70 EF    AND   F,239         (0104) export _UnloadConfig_pc_listener
0636: 50 00    MOV   A,0           (0105) export UnloadConfig_Total
0638: 67       ASR   A             (0106) export _UnloadConfig_Total
                                   (0107) export ACTIVE_CONFIG_STATUS
0639: 50 02    MOV   A,2           (0108) 
063B: 57 1D    MOV   X,29          (0109) export NO_SHADOW
063D: 7C 07 A8 LCALL 0x07A8        (0110) export _NO_SHADOW
                                   (0111) 
0640: 50 01    MOV   A,1           (0112) FLAG_CFG_MASK:      equ 10h         ;M8C flag register REG address bit mask
0642: 67       ASR   A             (0113) END_CONFIG_TABLE:   equ ffh         ;end of config table indicator
                                   (0114) 
0643: 50 02    MOV   A,2           (0115) AREA psoc_config(rom, rel)
0645: 57 90    MOV   X,144         (0116) 
0647: 7C 07 A8 LCALL 0x07A8        (0117) ;---------------------------------------------------------------------------
                                   (0118) ; LoadConfigInit - Establish the start-up configuration (except for a few
064A: 62 D0 00 MOV   REG[208],0    (0119) ;                  parameters handled by boot code, like CPU speed). This
                                   (0120) ;                  function can be called from user code, but typically it
064D: 2E 08 01 OR    [8],1         (0121) ;                  is only called from boot.
0650: 70 EF    AND   F,239         (0122) ;
0652: 20       POP   X             (0123) ;       INPUTS: None.
                                   (0124) ;      RETURNS: Nothing.
                                   (0125) ; SIDE EFFECTS: Registers are volatile: the A and X registers can be modified!
0653: 7F       RET                 (0126) ;               In the large memory model currently only the page
                                   (0127) ;               pointer registers listed below are modified.  This does
                                   (0128) ;               not guarantee that in future implementations of this
                                   (0129) ;               function other page pointer registers will not be
                                   (0130) ;               modified.
                                   (0131) ;          
                                   (0132) ;               Page Pointer Registers Modified: 
                                   (0133) ;               CUR_PP
                                   (0134) ;
                                   (0135) _LoadConfigInit:
                                   (0136)  LoadConfigInit:
                                   (0137)     RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0138)     RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0139) 	mov		[ACTIVE_CONFIG_STATUS], 0
                                   (0140) 
                                   (0141) 	lcall	LoadConfig_receiver_config
                                   (0142) 	lcall	LoadConfigTBL_receiver_config_Ordered
                                   (0143) 
                                   (0144) 
                                   (0145)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0146)     ret
                                   (0147) 
                                   (0148) ;---------------------------------------------------------------------------
                                   (0149) ; Load Configuration receiver_config
                                   (0150) ;
0654: 10       PUSH  X             (0151) ;    Load configuration registers for receiver_config.
0655: 70 EF    AND   F,239         (0152) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0657: 50 00    MOV   A,0           (0153) ;
0659: 67       ASR   A             (0154) ;       INPUTS: None.
                                   (0155) ;      RETURNS: Nothing.
065A: 50 03    MOV   A,3           (0156) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
065C: 57 C2    MOV   X,194         (0157) ;               modified as may the Page Pointer registers!
065E: 7C 07 A8 LCALL 0x07A8        (0158) ;               In the large memory model currently only the page
                                   (0159) ;               pointer registers listed below are modified.  This does
0661: 50 01    MOV   A,1           (0160) ;               not guarantee that in future implementations of this
0663: 67       ASR   A             (0161) ;               function other page pointer registers will not be
                                   (0162) ;               modified.
0664: 50 03    MOV   A,3           (0163) ;          
0666: 57 E7    MOV   X,231         (0164) ;               Page Pointer Registers Modified: 
0668: 7C 07 A8 LCALL 0x07A8        (0165) ;               CUR_PP
                                   (0166) ;
                                   (0167) _LoadConfig_receiver_config:
066B: 62 D0 00 MOV   REG[208],0    (0168)  LoadConfig_receiver_config:
066E: 2E 08 01 OR    [8],1         (0169)     RAM_PROLOGUE RAM_USE_CLASS_4
0671: 70 EF    AND   F,239         (0170) 	M8C_SetBank1
0673: 20       POP   X             (0171) 
                                   (0172) 	push	x
                                   (0173)     M8C_SetBank0                    ; Force bank 0
0674: 7F       RET                 (0174)     mov     a, 0                    ; Specify bank 0
                                   (0175)     asr     a                       ; Store in carry flag
                                   (0176)                                     ; Load bank 0 table:
                                   (0177)     mov     A, >LoadConfigTBL_receiver_config_Bank0
                                   (0178)     mov     X, <LoadConfigTBL_receiver_config_Bank0
                                   (0179)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0180) 
                                   (0181)     mov     a, 1                    ; Specify bank 1
                                   (0182)     asr     a                       ; Store in carry flag
                                   (0183)                                     ; Load bank 1 table:
                                   (0184)     mov     A, >LoadConfigTBL_receiver_config_Bank1
                                   (0185)     mov     X, <LoadConfigTBL_receiver_config_Bank1
                                   (0186)     lcall   LoadConfig              ; Load the bank 1 values
                                   (0187) 
                                   (0188) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0189) ; set config active bit
                                   (0190) 	or		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
                                   (0191)     M8C_SetBank0                    ; Force return to bank 0
                                   (0192) 	pop		x
                                   (0193) 
                                   (0194)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0195)     ret
                                   (0196) 
                                   (0197) ;---------------------------------------------------------------------------
                                   (0198) ; Reload Configuration receiver_config
                                   (0199) ;
0675: 10       PUSH  X             (0200) ;    Reload configuration registers for receiver_config.
0676: 70 EF    AND   F,239         (0201) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
0678: 50 00    MOV   A,0           (0202) ;
067A: 67       ASR   A             (0203) ;       INPUTS: None.
                                   (0204) ;      RETURNS: Nothing.
067B: 50 04    MOV   A,4           (0205) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
067D: 57 0C    MOV   X,12          (0206) ;               modified as may the Page Pointer registers!
067F: 7C 07 A8 LCALL 0x07A8        (0207) ;               In the large memory model currently only the page
                                   (0208) ;               pointer registers listed below are modified.  This does
0682: 50 01    MOV   A,1           (0209) ;               not guarantee that in future implementations of this
0684: 67       ASR   A             (0210) ;               function other page pointer registers will not be
                                   (0211) ;               modified.
0685: 50 04    MOV   A,4           (0212) ;          
0687: 57 19    MOV   X,25          (0213) ;               Page Pointer Registers Modified: 
0689: 7C 07 A8 LCALL 0x07A8        (0214) ;               CUR_PP
                                   (0215) ;
068C: 70 EF    AND   F,239         (0216) _ReloadConfig_receiver_config:
                                   (0217)  ReloadConfig_receiver_config:
068E: 62 D0 00 MOV   REG[208],0    (0218)     RAM_PROLOGUE RAM_USE_CLASS_4
0691: 26 08 FE AND   [8],254       (0219) 
0694: 70 EF    AND   F,239         (0220) 	push	x
0696: 20       POP   X             (0221)     M8C_SetBank0                    ; Force bank 0
                                   (0222)     mov     a, 0                    ; Specify bank 0
                                   (0223)     asr     a                       ; Store in carry flag
0697: 7F       RET                 (0224)                                     ; Bank 0 table address:
                                   (0225)     mov     A, >ReloadConfigTBL_receiver_config_Bank0
                                   (0226)     mov     X, <ReloadConfigTBL_receiver_config_Bank0
                                   (0227)     lcall   LoadConfig              ; Reload the bank 0 values
                                   (0228) 
                                   (0229)     mov     a, 1                    ; Specify bank 1
                                   (0230)     asr     a                       ; Store in carry flag
                                   (0231)                                     ; Bank 1 table address:
                                   (0232)     mov     A, >ReloadConfigTBL_receiver_config_Bank1
                                   (0233)     mov     X, <ReloadConfigTBL_receiver_config_Bank1
                                   (0234)     lcall   LoadConfig              ; Reload the bank 1 values
                                   (0235) 
                                   (0236) ; set config active bit
                                   (0237) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0238) 	or		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
                                   (0239)     M8C_SetBank0                    ; Force return to bank 0
                                   (0240) 	pop		x
                                   (0241) 
                                   (0242)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0243)     ret
                                   (0244) 
                                   (0245) ;---------------------------------------------------------------------------
                                   (0246) ; Unload Configuration receiver_config
                                   (0247) ;
0698: 71 10    OR    F,16          (0248) ;    Reset configuration registers for receiver_config
                                   (0249) ;    to their values as initially configured.
069A: 41 00 C1 AND   REG[0],193    (0250) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
069D: 43 00 3E OR    REG[0],62     (0251) ;
                                   (0252) ;       INPUTS: None.
06A0: 41 01 C1 AND   REG[1],193    (0253) ;      RETURNS: Nothing.
                                   (0254) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
06A3: 70 EF    AND   F,239         (0255) ;               modified as may the Page Pointer registers!
06A5: 41 03 5F AND   REG[3],95     (0256) ;               In the large memory model currently only the page
                                   (0257) ;               pointer registers listed below are modified.  This does
06A8: 41 02 5F AND   REG[2],95     (0258) ;               not guarantee that in future implementations of this
06AB: 43 02 A0 OR    REG[2],160    (0259) ;               function other page pointer registers will not be
                                   (0260) ;               modified.
06AE: 41 60 F3 AND   REG[96],243   (0261) ;          
06B1: 43 60 0C OR    REG[96],12    (0262) ;               Page Pointer Registers Modified: 
                                   (0263) ;               CUR_PP
06B4: 71 10    OR    F,16          (0264) ;
06B6: 41 E1 00 AND   REG[225],0    (0265) _UnloadConfig_receiver_config:
06B9: 43 E1 C1 OR    REG[225],193  (0266)  UnloadConfig_receiver_config:
                                   (0267)     RAM_PROLOGUE RAM_USE_CLASS_4
06BC: 70 EF    AND   F,239         (0268) 
06BE: 41 B0 3F AND   REG[176],63   (0269) 	push	x
                                   (0270)     M8C_SetBank0                    ; Force bank 0
06C1: 41 B3 F0 AND   REG[179],240  (0271)     mov     a, 0                    ; Specify bank 0
06C4: 43 B3 05 OR    REG[179],5    (0272)     asr     a                       ; Store in carry flag
                                   (0273)                                     ; Bank 0 table address:
06C7: 41 B4 F0 AND   REG[180],240  (0274)     mov     A, >UnloadConfigTBL_receiver_config_Bank0
06CA: 43 B4 05 OR    REG[180],5    (0275)     mov     X, <UnloadConfigTBL_receiver_config_Bank0
                                   (0276)     lcall   LoadConfig              ; Unload the bank 0 values
06CD: 41 B5 ED AND   REG[181],237  (0277) 
06D0: 43 B5 12 OR    REG[181],18   (0278)     mov     a, 1                    ; Specify bank 1
                                   (0279)     asr     a                       ; Store in carry flag
06D3: 41 B6 EE AND   REG[182],238  (0280)                                     ; Bank 1 table address:
06D6: 43 B6 11 OR    REG[182],17   (0281)     mov     A, >UnloadConfigTBL_receiver_config_Bank1
                                   (0282)     mov     X, <UnloadConfigTBL_receiver_config_Bank1
06D9: 41 B8 0F AND   REG[184],15   (0283)     lcall   LoadConfig              ; Unload the bank 1 values
06DC: 43 B8 50 OR    REG[184],80   (0284) 
                                   (0285) 	M8C_SetBank0
06DF: 41 BD DF AND   REG[189],223  (0286) ; clear config active bit
06E2: 43 BD 20 OR    REG[189],32   (0287) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0288) 	and		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], ~receiver_config_BIT
06E5: 41 C0 00 AND   REG[192],0    (0289)     M8C_SetBank0                    ; Force return to bank 0
                                   (0290) 	pop		x
06E8: 41 C8 FC AND   REG[200],252  (0291) 
06EB: 43 C8 01 OR    REG[200],1    (0292)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0293)     ret
06EE: 10       PUSH  X             (0294) 
06EF: 70 EF    AND   F,239         (0295) ;---------------------------------------------------------------------------
06F1: 50 00    MOV   A,0           (0296) ; Load Configuration pc_listener
06F3: 67       ASR   A             (0297) ;
                                   (0298) ;    Load configuration registers for pc_listener.
06F4: 50 01    MOV   A,1           (0299) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
06F6: 57 A0    MOV   X,160         (0300) ;
06F8: 7C 07 A8 LCALL 0x07A8        (0301) ;       INPUTS: None.
                                   (0302) ;      RETURNS: Nothing.
06FB: 50 01    MOV   A,1           (0303) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
06FD: 67       ASR   A             (0304) ;               modified as may the Page Pointer registers!
                                   (0305) ;               In the large memory model currently only the page
06FE: 50 01    MOV   A,1           (0306) ;               pointer registers listed below are modified.  This does
0700: 57 C5    MOV   X,197         (0307) ;               not guarantee that in future implementations of this
0702: 7C 07 A8 LCALL 0x07A8        (0308) ;               function other page pointer registers will not be
                                   (0309) ;               modified.
0705: 62 D0 00 MOV   REG[208],0    (0310) ;          
                                   (0311) ;               Page Pointer Registers Modified: 
0708: 2E 08 02 OR    [8],2         (0312) ;               CUR_PP
070B: 70 EF    AND   F,239         (0313) ;
070D: 20       POP   X             (0314) _LoadConfig_pc_listener:
                                   (0315)  LoadConfig_pc_listener:
                                   (0316)     RAM_PROLOGUE RAM_USE_CLASS_4
070E: 7F       RET                 (0317) 	M8C_SetBank1
                                   (0318) ; writing Port_0_DriveMode_0 register
                                   (0319) 	and		reg[ 0h], ~3eh
                                   (0320) 	or		reg[ 0h], 3eh
                                   (0321) ; writing Port_0_DriveMode_1 register
                                   (0322) 	and		reg[ 1h], ~3eh
                                   (0323) ; writing Port_0_DriveMode_2 register
                                   (0324) 	M8C_SetBank0
                                   (0325) 	and		reg[ 3h], ~a0h
                                   (0326) ; writing Port_0_GlobalSelect register
                                   (0327) 	and		reg[ 2h], ~a0h
                                   (0328) 	or		reg[ 2h], a0h
                                   (0329) ; writing AnalogColumnInputSelect register
                                   (0330) 	and		reg[60h], ~ ch
                                   (0331) 	or		reg[60h],  ch
                                   (0332) ; writing OscillatorControl_1 register
                                   (0333) 	M8C_SetBank1
                                   (0334) 	and		reg[e1h], ~ffh
                                   (0335) 	or		reg[e1h], c1h
                                   (0336) ; writing Row_0_InputMux register
                                   (0337) 	M8C_SetBank0
                                   (0338) 	and		reg[b0h], ~c0h
                                   (0339) ; writing Row_0_LogicSelect_0 register
                                   (0340) 	and		reg[b3h], ~ fh
                                   (0341) 	or		reg[b3h],  5h
                                   (0342) ; writing Row_0_LogicSelect_1 register
070F: 10       PUSH  X             (0343) 	and		reg[b4h], ~ fh
0710: 70 EF    AND   F,239         (0344) 	or		reg[b4h],  5h
0712: 50 00    MOV   A,0           (0345) ; writing Row_0_OutputDrive_0 register
0714: 67       ASR   A             (0346) 	and		reg[b5h], ~12h
                                   (0347) 	or		reg[b5h], 12h
0715: 50 01    MOV   A,1           (0348) ; writing Row_0_OutputDrive_1 register
0717: 57 EA    MOV   X,234         (0349) 	and		reg[b6h], ~11h
0719: 7C 07 A8 LCALL 0x07A8        (0350) 	or		reg[b6h], 11h
                                   (0351) ; writing Row_1_InputMux register
071C: 50 01    MOV   A,1           (0352) 	and		reg[b8h], ~f0h
071E: 67       ASR   A             (0353) 	or		reg[b8h], 50h
                                   (0354) ; writing Row_1_OutputDrive_0 register
071F: 50 01    MOV   A,1           (0355) 	and		reg[bdh], ~20h
0721: 57 F7    MOV   X,247         (0356) 	or		reg[bdh], 20h
0723: 7C 07 A8 LCALL 0x07A8        (0357) ; writing Row_2_InputMux register
                                   (0358) 	and		reg[c0h], ~ffh
0726: 70 EF    AND   F,239         (0359) ; writing Row_3_InputMux register
                                   (0360) 	and		reg[c8h], ~ 3h
0728: 41 60 F3 AND   REG[96],243   (0361) 	or		reg[c8h],  1h
072B: 43 60 08 OR    REG[96],8     (0362) 
                                   (0363) 	push	x
072E: 71 10    OR    F,16          (0364)     M8C_SetBank0                    ; Force bank 0
0730: 41 E1 00 AND   REG[225],0    (0365)     mov     a, 0                    ; Specify bank 0
0733: 43 E1 99 OR    REG[225],153  (0366)     asr     a                       ; Store in carry flag
                                   (0367)                                     ; Load bank 0 table:
0736: 70 EF    AND   F,239         (0368)     mov     A, >LoadConfigTBL_pc_listener_Bank0
0738: 41 B0 3F AND   REG[176],63   (0369)     mov     X, <LoadConfigTBL_pc_listener_Bank0
073B: 43 B0 40 OR    REG[176],64   (0370)     lcall   LoadConfig              ; Load the bank 0 values
                                   (0371) 
073E: 41 B3 F0 AND   REG[179],240  (0372)     mov     a, 1                    ; Specify bank 1
0741: 43 B3 03 OR    REG[179],3    (0373)     asr     a                       ; Store in carry flag
                                   (0374)                                     ; Load bank 1 table:
0744: 41 B4 F0 AND   REG[180],240  (0375)     mov     A, >LoadConfigTBL_pc_listener_Bank1
0747: 43 B4 03 OR    REG[180],3    (0376)     mov     X, <LoadConfigTBL_pc_listener_Bank1
                                   (0377)     lcall   LoadConfig              ; Load the bank 1 values
074A: 41 B5 ED AND   REG[181],237  (0378) 
                                   (0379) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
074D: 41 B6 EE AND   REG[182],238  (0380) ; set config active bit
                                   (0381) 	or		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
0750: 41 B8 0F AND   REG[184],15   (0382)     M8C_SetBank0                    ; Force return to bank 0
0753: 43 B8 20 OR    REG[184],32   (0383) 	pop		x
                                   (0384) 
0756: 41 BD DF AND   REG[189],223  (0385)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0386)     ret
0759: 41 C0 00 AND   REG[192],0    (0387) 
075C: 43 C0 FF OR    REG[192],255  (0388) ;---------------------------------------------------------------------------
                                   (0389) ; Unload Configuration pc_listener
075F: 41 C8 FC AND   REG[200],252  (0390) ;
0762: 43 C8 02 OR    REG[200],2    (0391) ;    Reset configuration registers for pc_listener
                                   (0392) ;    to their values as initially configured.
0765: 41 02 5F AND   REG[2],95     (0393) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
                                   (0394) ;
0768: 41 03 5F AND   REG[3],95     (0395) ;       INPUTS: None.
076B: 43 03 A0 OR    REG[3],160    (0396) ;      RETURNS: Nothing.
                                   (0397) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
076E: 71 10    OR    F,16          (0398) ;               modified as may the Page Pointer registers!
0770: 41 01 C1 AND   REG[1],193    (0399) ;               In the large memory model currently only the page
0773: 43 01 3E OR    REG[1],62     (0400) ;               pointer registers listed below are modified.  This does
                                   (0401) ;               not guarantee that in future implementations of this
0776: 41 00 C1 AND   REG[0],193    (0402) ;               function other page pointer registers will not be
0779: 70 EF    AND   F,239         (0403) ;               modified.
                                   (0404) ;          
077B: 62 D0 00 MOV   REG[208],0    (0405) ;               Page Pointer Registers Modified: 
077E: 26 08 FD AND   [8],253       (0406) ;               CUR_PP
0781: 70 EF    AND   F,239         (0407) ;
0783: 20       POP   X             (0408) _UnloadConfig_pc_listener:
                                   (0409)  UnloadConfig_pc_listener:
                                   (0410)     RAM_PROLOGUE RAM_USE_CLASS_4
0784: 7F       RET                 (0411) 
                                   (0412) 	push	x
                                   (0413)     M8C_SetBank0                    ; Force bank 0
                                   (0414)     mov     a, 0                    ; Specify bank 0
                                   (0415)     asr     a                       ; Store in carry flag
                                   (0416)                                     ; Bank 0 table address:
                                   (0417)     mov     A, >UnloadConfigTBL_pc_listener_Bank0
                                   (0418)     mov     X, <UnloadConfigTBL_pc_listener_Bank0
                                   (0419)     lcall   LoadConfig              ; Unload the bank 0 values
                                   (0420) 
                                   (0421)     mov     a, 1                    ; Specify bank 1
                                   (0422)     asr     a                       ; Store in carry flag
                                   (0423)                                     ; Bank 1 table address:
                                   (0424)     mov     A, >UnloadConfigTBL_pc_listener_Bank1
                                   (0425)     mov     X, <UnloadConfigTBL_pc_listener_Bank1
                                   (0426)     lcall   LoadConfig              ; Unload the bank 1 values
                                   (0427) 
                                   (0428) 	M8C_SetBank0
                                   (0429) ; writing AnalogColumnInputSelect register
                                   (0430) 	and		reg[60h], ~ ch
                                   (0431) 	or		reg[60h],  8h
                                   (0432) ; writing OscillatorControl_1 register
                                   (0433) 	M8C_SetBank1
                                   (0434) 	and		reg[e1h], ~ffh
                                   (0435) 	or		reg[e1h], 99h
                                   (0436) ; writing Row_0_InputMux register
0785: 10       PUSH  X             (0437) 	M8C_SetBank0
0786: 70 EF    AND   F,239         (0438) 	and		reg[b0h], ~c0h
0788: 50 00    MOV   A,0           (0439) 	or		reg[b0h], 40h
078A: 67       ASR   A             (0440) ; writing Row_0_LogicSelect_0 register
                                   (0441) 	and		reg[b3h], ~ fh
078B: 50 04    MOV   A,4           (0442) 	or		reg[b3h],  3h
078D: 57 3F    MOV   X,63          (0443) ; writing Row_0_LogicSelect_1 register
078F: 7C 07 A8 LCALL 0x07A8        (0444) 	and		reg[b4h], ~ fh
                                   (0445) 	or		reg[b4h],  3h
0792: 50 01    MOV   A,1           (0446) ; writing Row_0_OutputDrive_0 register
0794: 67       ASR   A             (0447) 	and		reg[b5h], ~12h
                                   (0448) ; writing Row_0_OutputDrive_1 register
0795: 50 04    MOV   A,4           (0449) 	and		reg[b6h], ~11h
0797: 57 C0    MOV   X,192         (0450) ; writing Row_1_InputMux register
0799: 7C 07 A8 LCALL 0x07A8        (0451) 	and		reg[b8h], ~f0h
                                   (0452) 	or		reg[b8h], 20h
079C: 70 EF    AND   F,239         (0453) ; writing Row_1_OutputDrive_0 register
                                   (0454) 	and		reg[bdh], ~20h
079E: 62 D0 00 MOV   REG[208],0    (0455) ; writing Row_2_InputMux register
07A1: 55 08 00 MOV   [8],0         (0456) 	and		reg[c0h], ~ffh
07A4: 70 EF    AND   F,239         (0457) 	or		reg[c0h], ffh
07A6: 20       POP   X             (0458) ; writing Row_3_InputMux register
                                   (0459) 	and		reg[c8h], ~ 3h
                                   (0460) 	or		reg[c8h],  2h
07A7: 7F       RET                 (0461) ; writing Port_0_GlobalSelect register
                                   (0462) 	and		reg[ 2h], ~a0h
                                   (0463) ; writing Port_0_DriveMode_2 register
                                   (0464) 	and		reg[ 3h], ~a0h
                                   (0465) 	or		reg[ 3h], a0h
                                   (0466) ; writing Port_0_DriveMode_1 register
                                   (0467) 	M8C_SetBank1
                                   (0468) 	and		reg[ 1h], ~3eh
                                   (0469) 	or		reg[ 1h], 3eh
                                   (0470) ; writing Port_0_DriveMode_0 register
                                   (0471) 	and		reg[ 0h], ~3eh
                                   (0472) 	M8C_SetBank0
                                   (0473) ; clear config active bit
                                   (0474) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
                                   (0475) 	and		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], ~pc_listener_BIT
                                   (0476)     M8C_SetBank0                    ; Force return to bank 0
                                   (0477) 	pop		x
                                   (0478) 
                                   (0479)     RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0480)     ret
                                   (0481) 
                                   (0482) ;---------------------------------------------------------------------------
07A8: 38 02    ADD   SP,2          (0483) ; Unload Configuration Total
07AA: 10       PUSH  X             (0484) ;
07AB: 08       PUSH  A             (0485) ;    Reset configuration registers for Total
07AC: 4F       MOV   X,SP          (0486) ;    to their values as initially configured.
07AD: 56 FC 00 MOV   [X-4],0       (0487) ;    IO Bank 0 registers a loaded first,then those in IO Bank 1.
07B0: D0 04    JNC   0x07B5        (0488) ;
07B2: 56 FC 01 MOV   [X-4],1       (0489) ;       INPUTS: None.
                                   (0490) ;      RETURNS: Nothing.
07B5: 18       POP   A             (0491) ; SIDE EFFECTS: Registers are volatile: the CPU A and X registers may be
07B6: 20       POP   X             (0492) ;               modified as may the Page Pointer registers!
                                   (0493) ;               In the large memory model currently only the page
                                   (0494) ;               pointer registers listed below are modified.  This does
07B7: 70 EF    AND   F,239         (0495) ;               not guarantee that in future implementations of this
07B9: 62 E3 00 MOV   REG[227],0    (0496) ;               function other page pointer registers will not be
07BC: 10       PUSH  X             (0497) ;               modified.
07BD: 08       PUSH  A             (0498) ;          
07BE: 28       ROMX                (0499) ;               Page Pointer Registers Modified: 
07BF: 39 FF    CMP   A,255         (0500) ;               CUR_PP
07C1: A0 1F    JZ    0x07E1        (0501) ;
07C3: 4F       MOV   X,SP          (0502) _UnloadConfig_Total:
07C4: 48 FC 01 TST   [X-4],1       (0503)  UnloadConfig_Total:
07C7: A0 03    JZ    0x07CB        (0504)     RAM_PROLOGUE RAM_USE_CLASS_4
07C9: 71 10    OR    F,16          (0505) 
                                   (0506) 	push	x
07CB: 54 FD    MOV   [X-3],A       (0507)     M8C_SetBank0                    ; Force bank 0
07CD: 18       POP   A             (0508)     mov     a, 0                    ; Specify bank 0
07CE: 20       POP   X             (0509)     asr     a                       ; Store in carry flag
07CF: 75       INC   X             (0510)                                     ; Bank 0 table address:
07D0: 09 00    ADC   A,0           (0511)     mov     A, >UnloadConfigTBL_Total_Bank0
07D2: 10       PUSH  X             (0512)     mov     X, <UnloadConfigTBL_Total_Bank0
07D3: 08       PUSH  A             (0513)     lcall   LoadConfig              ; Unload the bank 0 values
07D4: 28       ROMX                (0514) 
07D5: 4F       MOV   X,SP          (0515)     mov     a, 1                    ; Specify bank 1
07D6: 59 FD    MOV   X,[X-3]       (0516)     asr     a                       ; Store in carry flag
07D8: 61 00    MOV   REG[X+0],A    (0517)                                     ; Bank 1 table address:
07DA: 18       POP   A             (0518)     mov     A, >UnloadConfigTBL_Total_Bank1
07DB: 20       POP   X             (0519)     mov     X, <UnloadConfigTBL_Total_Bank1
07DC: 75       INC   X             (0520)     lcall   LoadConfig              ; Unload the bank 1 values
07DD: 09 00    ADC   A,0           (0521) 
07DF: 8F D7    JMP   0x07B7        (0522) 	M8C_SetBank0
                                   (0523) ; clear config active bit
07E1: 38 FC    ADD   SP,252        (0524) 	RAM_SETPAGE_CUR >ACTIVE_CONFIG_STATUS
07E3: 70 3F    AND   F,63
07E5: 71 C0    OR    F,192         (0525) 	mov		[ACTIVE_CONFIG_STATUS+0], 0
07E8: 43 E1 02 OR    REG[225],2    (0526)     M8C_SetBank0                    ; Force return to bank 0

FILE: lib\tx_timeout.asm
                                   (0102) ;;*****************************************************************************
07EB: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: TX_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "TX_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
07EC: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
07EF: 7F       RET                 (0131) export  TX_TIMEOUT_EnableInt
                                   (0132) export _TX_TIMEOUT_EnableInt
                                   (0133) export  TX_TIMEOUT_DisableInt
                                   (0134) export _TX_TIMEOUT_DisableInt
                                   (0135) export  TX_TIMEOUT_Start
                                   (0136) export _TX_TIMEOUT_Start
                                   (0137) export  TX_TIMEOUT_Stop
                                   (0138) export _TX_TIMEOUT_Stop
                                   (0139) export  TX_TIMEOUT_WritePeriod
                                   (0140) export _TX_TIMEOUT_WritePeriod
                                   (0141) export  TX_TIMEOUT_WriteCompareValue
                                   (0142) export _TX_TIMEOUT_WriteCompareValue
                                   (0143) export  TX_TIMEOUT_wReadCompareValue
                                   (0144) export _TX_TIMEOUT_wReadCompareValue
                                   (0145) export  TX_TIMEOUT_wReadTimer
                                   (0146) export _TX_TIMEOUT_wReadTimer
                                   (0147) export  TX_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _TX_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wTX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wTX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wTX_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wTX_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wTX_TIMEOUT_ReadTimerSaveCV   ; deprecated
07F0: 43 23 01 OR    REG[35],1     (0157) export _wTX_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
07F3: 7F       RET                 (0159) export  wTX_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wTX_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wTX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wTX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA pc_listener_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: TX_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
07F4: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
07F7: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  TX_TIMEOUT_EnableInt:
                                   (0200) _TX_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    TX_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: TX_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
07F8: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
07FA: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
07FB: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
07FD: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  TX_TIMEOUT_DisableInt:
                                   (0228) _TX_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    TX_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: TX_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
07FE: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
0800: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
0801: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
0803: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  TX_TIMEOUT_Start:
                                   (0256) _TX_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    TX_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: TX_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
0804: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
0806: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
0807: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
0809: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  TX_TIMEOUT_Stop:
                                   (0284) _TX_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    TX_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  TX_TIMEOUT_WritePeriod:
                                   (0313) _TX_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[TX_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[TX_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: TX_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call TX_TIMEOUT_Stop to disable).
080A: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
080B: 38 03    ADD   SP,3          (0334) ;
080D: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
080F: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
0810: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
0812: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
0813: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
0815: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
0816: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
0818: 5D 26    MOV   A,REG[38]     (0343) ;
081A: 54 01    MOV   [X+1],A       (0344)  TX_TIMEOUT_WriteCompareValue:
081C: 5D 22    MOV   A,REG[34]     (0345) _TX_TIMEOUT_WriteCompareValue:
081E: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
0820: 50 00    MOV   A,0           (0347)    mov   reg[TX_TIMEOUT_COMPARE_LSB_REG], A
0822: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
0825: A0 03    JZ    0x0829        (0349)    mov   reg[TX_TIMEOUT_COMPARE_MSB_REG], A
0827: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
0829: 54 00    MOV   [X+0],A       (0352) 
082B: 70 FE    AND   F,254         (0353) .ENDSECTION
082D: 41 23 FE AND   REG[35],254   (0354) 
0830: 18       POP   A             (0355) 
0831: 60 26    MOV   REG[38],A     (0356) .SECTION
0833: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
0834: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: TX_TIMEOUT_wReadCompareValue
0836: 18       POP   A             (0359) ;
0837: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
0839: 18       POP   A             (0361) ;     Reads the Compare registers.
083A: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
083B: 70 3F    AND   F,63
083D: 71 C0    OR    F,192         (0363) ;
083F: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  TX_TIMEOUT_wReadCompareValue:
                                   (0374) _TX_TIMEOUT_wReadCompareValue:
                                   (0375)  wTX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0376) _wTX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[TX_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[TX_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: TX_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
0840: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
0842: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
0844: 5C       MOV   X,A           (0409) ;
0845: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
0849: 43 E1 08 OR    REG[225],8    (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\tx_repeater_23.asm
                                   (0109) ;;*****************************************************************************
084C: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_REPEATER_23.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_REPEATER_23.inc"
084D: 41 E1 F7 AND   REG[225],247  (0137) 
                                   (0138) area UserModules (ROM, REL)
0850: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_REPEATER_23_SetTxIntMode
                                   (0143) export  _TX_REPEATER_23_SetTxIntMode
                                   (0144) export   TX_REPEATER_23_EnableInt
                                   (0145) export  _TX_REPEATER_23_EnableInt
                                   (0146) export   TX_REPEATER_23_DisableInt
                                   (0147) export  _TX_REPEATER_23_DisableInt
                                   (0148) export   TX_REPEATER_23_Start
                                   (0149) export  _TX_REPEATER_23_Start
                                   (0150) export   TX_REPEATER_23_Stop
                                   (0151) export  _TX_REPEATER_23_Stop
                                   (0152) export   TX_REPEATER_23_SendData
                                   (0153) export  _TX_REPEATER_23_SendData
                                   (0154) export   TX_REPEATER_23_bReadTxStatus
                                   (0155) export  _TX_REPEATER_23_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_REPEATER_23_ReadTxStatus
                                   (0160) export  _bTX_REPEATER_23_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_REPEATER_23_PutSHexByte
                                   (0166) export _TX_REPEATER_23_PutSHexByte
                                   (0167) export  TX_REPEATER_23_PutSHexInt
                                   (0168) export _TX_REPEATER_23_PutSHexInt
                                   (0169) 
0851: 71 10    OR    F,16          (0170) export  TX_REPEATER_23_CPutString
0853: 21 01    AND   A,1           (0171) export _TX_REPEATER_23_CPutString
0855: A0 07    JZ    0x085D        (0172) export  TX_REPEATER_23_PutString
0857: 43 2C 10 OR    REG[44],16    (0173) export _TX_REPEATER_23_PutString
085A: 70 EF    AND   F,239         (0174) export  TX_REPEATER_23_PutChar
                                   (0175) export _TX_REPEATER_23_PutChar
085C: 7F       RET                 (0176) export  TX_REPEATER_23_Write
                                   (0177) export _TX_REPEATER_23_Write
                                   (0178) export  TX_REPEATER_23_CWrite
085D: 41 2C EF AND   REG[44],239   (0179) export _TX_REPEATER_23_CWrite
0860: 70 EF    AND   F,239         (0180) export  TX_REPEATER_23_PutCRLF
                                   (0181) export _TX_REPEATER_23_PutCRLF 
0862: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_REPEATER_23_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
0863: 29 01    OR    A,1           (0211) ;    functions.
0865: 60 2F    MOV   REG[47],A     (0212) ;
                                   (0213)  TX_REPEATER_23_EnableInt:
0867: 7F       RET                 (0214) _TX_REPEATER_23_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_REPEATER_23_INT_REG, TX_REPEATER_23_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_REPEATER_23_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0868: 41 2F FE AND   REG[47],254   (0240) ;    functions.
                                   (0241) ;
086B: 7F       RET                 (0242)  TX_REPEATER_23_DisableInt:
                                   (0243) _TX_REPEATER_23_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_REPEATER_23_INT_REG, TX_REPEATER_23_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_REPEATER_23_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
086C: 60 2D    MOV   REG[45],A     (0269) ;    functions.
                                   (0270) ;
086E: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_REPEATER_23_SetTxIntMode:
                                   (0276) _TX_REPEATER_23_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_REPEATER_23_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_REPEATER_23_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_REPEATER_23_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_REPEATER_23_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
086F: 5D 2F    MOV   A,REG[47]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
0871: 7F       RET                 (0303) ;
0872: 30       HALT  
0873: 31 32    XOR   A,50
0875: 33 34    XOR   A,[X+52]
0877: 35 36    XOR   [X+54],A
0879: 37 38 39 XOR   [X+56],57
087C: 41 42 43 AND   REG[66],67
087F: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_REPEATER_23_Start:
                                   (0317) _TX_REPEATER_23_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_REPEATER_23_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_REPEATER_23_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
0882: 08       PUSH  A             (0335) ;
0883: 67       ASR   A             (0336) ;  RETURNS:  none
0884: 67       ASR   A             (0337) ;
0885: 67       ASR   A             (0338) ;  SIDE EFFECTS:
0886: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0887: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0889: FF E7    INDEX 0x0872        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
088B: 90 0F    CALL  0x089C        (0342) ;    responsibility to perserve their values across calls to fastcall16 
088D: 18       POP   A             (0343) ;    functions.
088E: 21 0F    AND   A,15          (0344) ;
0890: FF E0    INDEX 0x0872        (0345)  TX_REPEATER_23_Stop:
0892: 90 08    CALL  0x089C        (0346) _TX_REPEATER_23_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
0894: 7F       RET                 (0348)    and   REG[TX_REPEATER_23_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_REPEATER_23_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_REPEATER_23_SendData:
                                   (0375) _TX_REPEATER_23_SendData:
0895: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
0896: 9F EA    CALL  0x0882        (0377)    mov REG[TX_REPEATER_23_TX_BUFFER_REG], A
0898: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0899: 9F E7    CALL  0x0882        (0379)    ret
                                   (0380) .ENDSECTION
089B: 7F       RET                 (0381) 
089C: 49 2F 10 TST   REG[47],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_REPEATER_23_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_REPEATER_23_bReadTxStatus:
                                   (0405) _TX_REPEATER_23_bReadTxStatus:
                                   (0406)  bTX_REPEATER_23_ReadTxStatus:
                                   (0407) _bTX_REPEATER_23_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_REPEATER_23_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
089F: AF FC    JZ    0x089C        (0416) ;  FUNCTION NAME: TX_REPEATER_23_PutSHexByte
08A1: 60 2D    MOV   REG[45],A
                                   (0417) ;
08A3: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_REPEATER_23_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_REPEATER_23_PutSHexByte:
                                   (0441) _TX_REPEATER_23_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_REPEATER_23_HEX_STR       ; Get Hex value
                                   (0450)     call  TX_REPEATER_23_PutChar       ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_REPEATER_23_HEX_STR       ; Get Hex value
                                   (0454)     call  TX_REPEATER_23_PutChar       ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
08A4: 70 BF    AND   F,191         (0456)     ret
08A6: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
08A8: 52 00    MOV   A,[X+0]       (0459) .SECTION
08AA: A0 06    JZ    0x08B1        (0460) ;-----------------------------------------------------------------------------
08AC: 9F EE    CALL  0x089C        (0461) ;  FUNCTION NAME: TX_REPEATER_23_PutSHexInt
08AE: 75       INC   X             (0462) ;
08AF: 8F F8    JMP   0x08A8        (0463) ;  DESCRIPTION:
08B1: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
08B3: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
08B5: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_REPEATER_23_PutSHexInt:
                                   (0482) _TX_REPEATER_23_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_REPEATER_23_PutSHexByte   ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_REPEATER_23_PutSHexByte   ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_REPEATER_23_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
08B6: 70 BF    AND   F,191         (0503) ;  RETURNS:
08B8: 62 D3 07 MOV   REG[211],7    (0504) ;     none
08BB: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
08BC: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
08BE: A0 1A    JZ    0x08D9        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
08C0: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
08C2: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_REPEATER_23_CONTROL_REG], TX_REPEATER_23_TX_BUFFER_EMPTY    ; Check Tx Status
08C4: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
08C6: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_REPEATER_23_TX_BUFFER_REG], @Source    ; Write data to Tx Port
08C8: 52 00    MOV   A,[X+0]       (0518)    endm
08CA: 49 2F 10 TST   REG[47],16
08CD: AF FC    JZ    0x08CA        (0519) 
08CF: 60 2D    MOV   REG[45],A
08D1: 4F       MOV   X,SP          (0520) 
08D2: 62 D3 07 MOV   REG[211],7    (0521)  TX_REPEATER_23_PutChar:
08D5: 77 FD    INC   [X-3]         (0522) _TX_REPEATER_23_PutChar:
08D7: 8F E4    JMP   0x08BC        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
08D9: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
08DB: 71 C0    OR    F,192         (0526)    ret
08DD: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_REPEATER_23_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_REPEATER_23_PutString:
                                   (0563) _TX_REPEATER_23_PutString:
08DE: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
08DF: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
08E2: B0 06    JNZ   0x08E9        (0569)    call  TX_REPEATER_23_PutChar             ; Send character to Tx port
08E4: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
08E7: A0 1D    JZ    0x0905        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
08E9: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
08EA: 52 FC    MOV   A,[X-4]       (0575)    ret
08EC: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
08EE: 28       ROMX                (0577) 
08EF: 49 2F 10 TST   REG[47],16
08F2: AF FC    JZ    0x08EF        (0578) .SECTION
08F4: 60 2D    MOV   REG[45],A
08F6: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_REPEATER_23_Write
08F7: 07 FD 01 ADD   [X-3],1       (0581) ;
08FA: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
08FD: 17 FB 01 SUB   [X-5],1       (0585) ;
0900: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
0903: 8F DB    JMP   0x08DF        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
0905: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_REPEATER_23_Write:
                                   (0610) _TX_REPEATER_23_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
0906: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
0907: 10       PUSH  X             (0622)    ENDIF
0908: 28       ROMX                (0623) 
0909: A0 0B    JZ    0x0915        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
090B: 9F 8F    CALL  0x089C        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
090D: 20       POP   X             (0626)    mov   A,[X]
090E: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
090F: 75       INC   X             (0628)    mov   X, SP
0910: DF F5    JNC   0x0906        (0629)    RAM_SETPAGE_IDX2STK
0912: 74       INC   A             (0630)    inc   [X+STR_LSB]
0913: 8F F2    JMP   0x0906        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
0915: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
0917: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_REPEATER_23_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
0918: 50 0D    MOV   A,13          (0663) ;
091A: 9F 80    CALL  0x089C        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
091C: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
091E: 9F 7C    CALL  0x089C        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
0922: 43 E1 04 OR    REG[225],4    (0668) 

FILE: lib\tx_repeater_14.asm
                                   (0109) ;;*****************************************************************************
0925: 7F       RET                 (0110) ;;*****************************************************************************
                                   (0111) ;;  FILENAME: TX_REPEATER_14.asm
                                   (0112) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:51
                                   (0113) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0114) ;;
                                   (0115) ;;  DESCRIPTION: TX8 User Module software implementation file
                                   (0116) ;;               for 22/24/25/26/27xxx PSoc family of devices.
                                   (0117) ;;
                                   (0118) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0119) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0120) ;;        This means it is the caller's responsibility to preserve any values
                                   (0121) ;;        in the X and A registers that are still needed after the API functions
                                   (0122) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0123) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0124) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0125) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0126) ;;-----------------------------------------------------------------------------
                                   (0127) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0128) ;;*****************************************************************************
                                   (0129) ;;*****************************************************************************
                                   (0130) 
                                   (0131) ;-----------------------------------------------
                                   (0132) ; include instance specific register definitions
                                   (0133) ;-----------------------------------------------
                                   (0134) include "m8c.inc"
                                   (0135) include "memory.inc"
                                   (0136) include "TX_REPEATER_14.inc"
0926: 41 E1 FB AND   REG[225],251  (0137) 
                                   (0138) area UserModules (ROM, REL)
0929: 7F       RET                 (0139) ;-----------------------------------------------
                                   (0140) ;  Global Symbols
                                   (0141) ;-----------------------------------------------
                                   (0142) export   TX_REPEATER_14_SetTxIntMode
                                   (0143) export  _TX_REPEATER_14_SetTxIntMode
                                   (0144) export   TX_REPEATER_14_EnableInt
                                   (0145) export  _TX_REPEATER_14_EnableInt
                                   (0146) export   TX_REPEATER_14_DisableInt
                                   (0147) export  _TX_REPEATER_14_DisableInt
                                   (0148) export   TX_REPEATER_14_Start
                                   (0149) export  _TX_REPEATER_14_Start
                                   (0150) export   TX_REPEATER_14_Stop
                                   (0151) export  _TX_REPEATER_14_Stop
                                   (0152) export   TX_REPEATER_14_SendData
                                   (0153) export  _TX_REPEATER_14_SendData
                                   (0154) export   TX_REPEATER_14_bReadTxStatus
                                   (0155) export  _TX_REPEATER_14_bReadTxStatus
                                   (0156) 
                                   (0157) // Old labels, will be removed in future release
                                   (0158) // Do Not Use.
                                   (0159) export   bTX_REPEATER_14_ReadTxStatus
                                   (0160) export  _bTX_REPEATER_14_ReadTxStatus
                                   (0161) 
                                   (0162) ;-----------------------------------------------
                                   (0163) ;  High Level TX functions
                                   (0164) ;-----------------------------------------------
                                   (0165) export  TX_REPEATER_14_PutSHexByte
                                   (0166) export _TX_REPEATER_14_PutSHexByte
                                   (0167) export  TX_REPEATER_14_PutSHexInt
                                   (0168) export _TX_REPEATER_14_PutSHexInt
                                   (0169) 
092A: 71 10    OR    F,16          (0170) export  TX_REPEATER_14_CPutString
092C: 21 01    AND   A,1           (0171) export _TX_REPEATER_14_CPutString
092E: A0 07    JZ    0x0936        (0172) export  TX_REPEATER_14_PutString
0930: 43 28 10 OR    REG[40],16    (0173) export _TX_REPEATER_14_PutString
0933: 70 EF    AND   F,239         (0174) export  TX_REPEATER_14_PutChar
                                   (0175) export _TX_REPEATER_14_PutChar
0935: 7F       RET                 (0176) export  TX_REPEATER_14_Write
                                   (0177) export _TX_REPEATER_14_Write
                                   (0178) export  TX_REPEATER_14_CWrite
0936: 41 28 EF AND   REG[40],239   (0179) export _TX_REPEATER_14_CWrite
0939: 70 EF    AND   F,239         (0180) export  TX_REPEATER_14_PutCRLF
                                   (0181) export _TX_REPEATER_14_PutCRLF 
093B: 7F       RET                 (0182) 
                                   (0183) ;-----------------------------------------------
                                   (0184) ;  EQUATES
                                   (0185) ;-----------------------------------------------
                                   (0186) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0187) bfFUNCTION_REG_TX_INT_MODE_BIT:	equ 0x10	; the TX Int Mode bit
                                   (0188) 
                                   (0189) AREA UserModules (ROM, REL)
                                   (0190) 
                                   (0191) .SECTION
                                   (0192) ;-----------------------------------------------------------------------------
                                   (0193) ;  FUNCTION NAME: TX_REPEATER_14_EnableInt
                                   (0194) ;
                                   (0195) ;  DESCRIPTION:
                                   (0196) ;     Enables this Transmitter's interrupt by setting the interrupt enable mask
                                   (0197) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0198) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0199) ;
                                   (0200) ;-----------------------------------------------------------------------------
                                   (0201) ;
                                   (0202) ;  ARGUMENTS: none
                                   (0203) ;
                                   (0204) ;  RETURNS: none
                                   (0205) ;
                                   (0206) ;  SIDE EFFECTS:
                                   (0207) ;    The A and X registers may be modified by this or future implementations
                                   (0208) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0209) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0210) ;    responsibility to perserve their values across calls to fastcall16 
093C: 29 01    OR    A,1           (0211) ;    functions.
093E: 60 2B    MOV   REG[43],A     (0212) ;
                                   (0213)  TX_REPEATER_14_EnableInt:
0940: 7F       RET                 (0214) _TX_REPEATER_14_EnableInt:
                                   (0215)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0216)    M8C_EnableIntMask  TX_REPEATER_14_INT_REG, TX_REPEATER_14_bINT_MASK
                                   (0217)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0218)    ret
                                   (0219) .ENDSECTION
                                   (0220) 
                                   (0221) .SECTION
                                   (0222) ;-----------------------------------------------------------------------------
                                   (0223) ;  FUNCTION NAME: TX_REPEATER_14_DisableInt
                                   (0224) ;
                                   (0225) ;  DESCRIPTION:
                                   (0226) ;     Disables this TX8's interrupt by clearing the interrupt enable mask bit
                                   (0227) ;     associated with this User Module.
                                   (0228) ;
                                   (0229) ;-----------------------------------------------------------------------------
                                   (0230) ;
                                   (0231) ;  ARGUMENTS:  none
                                   (0232) ;
                                   (0233) ;  RETURNS:  none
                                   (0234) ;
                                   (0235) ;  SIDE EFFECTS:
                                   (0236) ;    The A and X registers may be modified by this or future implementations
                                   (0237) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0238) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0239) ;    responsibility to perserve their values across calls to fastcall16 
0941: 41 2B FE AND   REG[43],254   (0240) ;    functions.
                                   (0241) ;
0944: 7F       RET                 (0242)  TX_REPEATER_14_DisableInt:
                                   (0243) _TX_REPEATER_14_DisableInt:
                                   (0244)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0245)    M8C_DisableIntMask TX_REPEATER_14_INT_REG, TX_REPEATER_14_bINT_MASK
                                   (0246)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0247)    ret
                                   (0248) .ENDSECTION
                                   (0249) 
                                   (0250) .SECTION
                                   (0251) ;-----------------------------------------------------------------------------
                                   (0252) ;  FUNCTION NAME: TX_REPEATER_14_SetTxIntMode(BYTE bTxIntMode)
                                   (0253) ;
                                   (0254) ;  DESCRIPTION:
                                   (0255) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0256) ;
                                   (0257) ;  ARGUMENTS:
                                   (0258) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0259) ;        Passed in the A register
                                   (0260) ;
                                   (0261) ;  RETURNS:
                                   (0262) ;     none.
                                   (0263) ;
                                   (0264) ;  SIDE EFFECTS:
                                   (0265) ;    The A and X registers may be modified by this or future implementations
                                   (0266) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0267) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0268) ;    responsibility to perserve their values across calls to fastcall16 
0945: 60 29    MOV   REG[41],A     (0269) ;    functions.
                                   (0270) ;
0947: 7F       RET                 (0271) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0272) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0273) ;     on TX register empty or TX transmit complete
                                   (0274) ;
                                   (0275)  TX_REPEATER_14_SetTxIntMode:
                                   (0276) _TX_REPEATER_14_SetTxIntMode:
                                   (0277)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0278)    M8C_SetBank1
                                   (0279)    and   A, TX_REPEATER_14_INT_MODE_TX_COMPLETE
                                   (0280)    jz    .SetModeRegEmpty
                                   (0281)    or    REG[TX_REPEATER_14_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0282)    M8C_SetBank0
                                   (0283)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0284)    ret
                                   (0285) 
                                   (0286) .SetModeRegEmpty:
                                   (0287)    and   REG[TX_REPEATER_14_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0288)    M8C_SetBank0
                                   (0289)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0290)    ret
                                   (0291) .ENDSECTION
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: TX_REPEATER_14_Start(BYTE bParity)
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0299) ;     The transmitter will begin transmitting if a byte has been written into the
                                   (0300) ;     transmit buffer.
0948: 5D 2B    MOV   A,REG[43]     (0301) ;
                                   (0302) ;-----------------------------------------------------------------------------
094A: 7F       RET                 (0303) ;
094B: 30       HALT  
094C: 31 32    XOR   A,50
094E: 33 34    XOR   A,[X+52]
0950: 35 36    XOR   [X+54],A
0952: 37 38 39 XOR   [X+56],57
0955: 41 42 43 AND   REG[66],67
0958: 44 45 46 OR    REG[X+69],70
                                   (0304) ;  ARGUMENTS:
                                   (0305) ;    BYTE bParity - parity of transmitted data.  Use defined masks.
                                   (0306) ;
                                   (0307) ;  RETURNS:  none
                                   (0308) ;
                                   (0309) ;  SIDE EFFECTS:
                                   (0310) ;    The A and X registers may be modified by this or future implementations
                                   (0311) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0312) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0313) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0314) ;    functions.
                                   (0315) ;
                                   (0316)  TX_REPEATER_14_Start:
                                   (0317) _TX_REPEATER_14_Start:
                                   (0318)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0319)    or    A, bfCONTROL_REG_START_BIT
                                   (0320)    mov   REG[TX_REPEATER_14_CONTROL_REG], A
                                   (0321)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0322)    ret
                                   (0323) .ENDSECTION
                                   (0324) 
                                   (0325) .SECTION
                                   (0326) ;-----------------------------------------------------------------------------
                                   (0327) ;  FUNCTION NAME: TX_REPEATER_14_Stop
                                   (0328) ;
                                   (0329) ;  DESCRIPTION:
                                   (0330) ;     Disables TX8 operation.
                                   (0331) ;
                                   (0332) ;-----------------------------------------------------------------------------
                                   (0333) ;
                                   (0334) ;  ARGUMENTS:  none
095B: 08       PUSH  A             (0335) ;
095C: 67       ASR   A             (0336) ;  RETURNS:  none
095D: 67       ASR   A             (0337) ;
095E: 67       ASR   A             (0338) ;  SIDE EFFECTS:
095F: 67       ASR   A             (0339) ;    The A and X registers may be modified by this or future implementations
0960: 21 0F    AND   A,15          (0340) ;    of this function.  The same is true for all RAM page pointer registers in
0962: FF E7    INDEX 0x094B        (0341) ;    the Large Memory Model.  When necessary, it is the calling function's
0964: 90 0F    CALL  0x0975        (0342) ;    responsibility to perserve their values across calls to fastcall16 
0966: 18       POP   A             (0343) ;    functions.
0967: 21 0F    AND   A,15          (0344) ;
0969: FF E0    INDEX 0x094B        (0345)  TX_REPEATER_14_Stop:
096B: 90 08    CALL  0x0975        (0346) _TX_REPEATER_14_Stop:
                                   (0347)    RAM_PROLOGUE RAM_USE_CLASS_1
096D: 7F       RET                 (0348)    and   REG[TX_REPEATER_14_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0349)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0350)    ret
                                   (0351) .ENDSECTION
                                   (0352) 
                                   (0353) .SECTION
                                   (0354) ;-----------------------------------------------------------------------------
                                   (0355) ;  FUNCTION NAME: TX_REPEATER_14_SendData
                                   (0356) ;
                                   (0357) ;  DESCRIPTION:
                                   (0358) ;     Sends one byte through serial port.
                                   (0359) ;
                                   (0360) ;-----------------------------------------------------------------------------
                                   (0361) ;
                                   (0362) ;  ARGUMENTS:
                                   (0363) ;     BYTE  TxData - data to transmit.
                                   (0364) ;
                                   (0365) ;  RETURNS:
                                   (0366) ;
                                   (0367) ;  SIDE EFFECTS:
                                   (0368) ;    The A and X registers may be modified by this or future implementations
                                   (0369) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0370) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0371) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0372) ;    functions.
                                   (0373) ;
                                   (0374)  TX_REPEATER_14_SendData:
                                   (0375) _TX_REPEATER_14_SendData:
096E: 4B       SWAP  A,X           (0376)    RAM_PROLOGUE RAM_USE_CLASS_1
096F: 9F EA    CALL  0x095B        (0377)    mov REG[TX_REPEATER_14_TX_BUFFER_REG], A
0971: 5B       MOV   A,X           (0378)    RAM_EPILOGUE RAM_USE_CLASS_1
0972: 9F E7    CALL  0x095B        (0379)    ret
                                   (0380) .ENDSECTION
0974: 7F       RET                 (0381) 
0975: 49 2B 10 TST   REG[43],16
                                   (0382) .SECTION
                                   (0383) ;-----------------------------------------------------------------------------
                                   (0384) ;  FUNCTION NAME: TX_REPEATER_14_bReadTxStatus
                                   (0385) ;
                                   (0386) ;  DESCRIPTION:
                                   (0387) ;     Reads the Tx Status bits in the Control/Status register.
                                   (0388) ;
                                   (0389) ;-----------------------------------------------------------------------------
                                   (0390) ;
                                   (0391) ;  ARGUMENTS:
                                   (0392) ;
                                   (0393) ;  RETURNS:
                                   (0394) ;     BYTE  bTxStatus - transmit status data.  Use the following defined bits
                                   (0395) ;                       masks: TX_COMPLETE and TX_BUFFER_EMPTY
                                   (0396) ;
                                   (0397) ;  SIDE EFFECTS:
                                   (0398) ;    The A and X registers may be modified by this or future implementations
                                   (0399) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0400) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0401) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0402) ;    functions.
                                   (0403) ;
                                   (0404)  TX_REPEATER_14_bReadTxStatus:
                                   (0405) _TX_REPEATER_14_bReadTxStatus:
                                   (0406)  bTX_REPEATER_14_ReadTxStatus:
                                   (0407) _bTX_REPEATER_14_ReadTxStatus:
                                   (0408)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0409)    mov A,  REG[TX_REPEATER_14_CONTROL_REG]
                                   (0410)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0411)    ret
                                   (0412) 
                                   (0413) .ENDSECTION
                                   (0414) 
                                   (0415) ;-----------------------------------------------------------------------------
0978: AF FC    JZ    0x0975        (0416) ;  FUNCTION NAME: TX_REPEATER_14_PutSHexByte
097A: 60 29    MOV   REG[41],A
                                   (0417) ;
097C: 7F       RET                 (0418) ;  DESCRIPTION:
                                   (0419) ;     Print a byte in Hex (two characters) to the UART Tx
                                   (0420) ;
                                   (0421) ;  ARGUMENTS:
                                   (0422) ;     A  => (BYTE) Data/char to be printed
                                   (0423) ;
                                   (0424) ;  RETURNS:
                                   (0425) ;     none.
                                   (0426) ;
                                   (0427) ;  SIDE EFFECTS:
                                   (0428) ;    The A and X registers may be modified by this or future implementations
                                   (0429) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0430) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0431) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0432) ;    functions.
                                   (0433) ;
                                   (0434) .LITERAL
                                   (0435) TX_REPEATER_14_HEX_STR:
                                   (0436)      DS    "0123456789ABCDEF"
                                   (0437) .ENDLITERAL
                                   (0438) 
                                   (0439) .SECTION
                                   (0440)  TX_REPEATER_14_PutSHexByte:
                                   (0441) _TX_REPEATER_14_PutSHexByte:
                                   (0442)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0443)     push  A                            ; Save lower nibble
                                   (0444)     asr   A                            ; Shift high nibble to right
                                   (0445)     asr   A
                                   (0446)     asr   A
                                   (0447)     asr   A
                                   (0448)     and   A,0Fh                        ; Mask off nibble
                                   (0449)     index TX_REPEATER_14_HEX_STR       ; Get Hex value
                                   (0450)     call  TX_REPEATER_14_PutChar       ; Write data to screen
                                   (0451)     pop   A                            ; Restore value
                                   (0452)     and   A,0Fh                        ; Mask off lower nibble
                                   (0453)     index TX_REPEATER_14_HEX_STR       ; Get Hex value
                                   (0454)     call  TX_REPEATER_14_PutChar       ; Write data to screen
                                   (0455)     RAM_EPILOGUE RAM_USE_CLASS_1
097D: 70 BF    AND   F,191         (0456)     ret
097F: 60 D3    MOV   REG[211],A    (0457) .ENDSECTION
                                   (0458) 
0981: 52 00    MOV   A,[X+0]       (0459) .SECTION
0983: A0 06    JZ    0x098A        (0460) ;-----------------------------------------------------------------------------
0985: 9F EE    CALL  0x0975        (0461) ;  FUNCTION NAME: TX_REPEATER_14_PutSHexInt
0987: 75       INC   X             (0462) ;
0988: 8F F8    JMP   0x0981        (0463) ;  DESCRIPTION:
098A: 70 3F    AND   F,63
                                   (0464) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0465) ;
098C: 71 C0    OR    F,192         (0466) ;  ARGUMENTS:
098E: 7F       RET                 (0467) ;     Pointer to string
                                   (0468) ;     A  => ASB of Int
                                   (0469) ;     X  => MSB of Int
                                   (0470) ;
                                   (0471) ;  RETURNS:
                                   (0472) ;     none.
                                   (0473) ;
                                   (0474) ;  SIDE EFFECTS:
                                   (0475) ;    The A and X registers may be modified by this or future implementations
                                   (0476) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0477) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0478) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0479) ;    functions.
                                   (0480) ;
                                   (0481)  TX_REPEATER_14_PutSHexInt:
                                   (0482) _TX_REPEATER_14_PutSHexInt:
                                   (0483)     RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0484)     swap  A,X
                                   (0485)     call  TX_REPEATER_14_PutSHexByte   ; Print MSB
                                   (0486)     mov   A,X                          ; Move LSB into position
                                   (0487)     call  TX_REPEATER_14_PutSHexByte   ; Print LSB
                                   (0488)     RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)     ret
                                   (0490) .ENDSECTION
                                   (0491) 
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: TX_REPEATER_14_PutChar
                                   (0495) ;
                                   (0496) ;  DESCRIPTION:
                                   (0497) ;     Send character out through UART TX port.
                                   (0498) ;
                                   (0499) ;
                                   (0500) ;  ARGUMENTS:
                                   (0501) ;     A has Character to send to UART Tx Port
                                   (0502) ;
098F: 70 BF    AND   F,191         (0503) ;  RETURNS:
0991: 62 D3 07 MOV   REG[211],7    (0504) ;     none
0994: 4F       MOV   X,SP          (0505) ;
                                   (0506) ;  SIDE EFFECTS:
                                   (0507) ;    The A and X registers may be modified by this or future implementations
0995: 52 FB    MOV   A,[X-5]       (0508) ;    of this function.  The same is true for all RAM page pointer registers in
0997: A0 1A    JZ    0x09B2        (0509) ;    the Large Memory Model.  When necessary, it is the calling function's
0999: 7B FB    DEC   [X-5]         (0510) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0511) ;    functions.
                                   (0512) ;
099B: 52 FC    MOV   A,[X-4]       (0513)    macro InLinePutChar( Source )
                                   (0514) .BufEmptyWaitLoop:
                                   (0515)    tst REG[TX_REPEATER_14_CONTROL_REG], TX_REPEATER_14_TX_BUFFER_EMPTY    ; Check Tx Status
099D: 59 FD    MOV   X,[X-3]       (0516)    jz  .BufEmptyWaitLoop
099F: 60 D3    MOV   REG[211],A    (0517)    mov REG[TX_REPEATER_14_TX_BUFFER_REG], @Source    ; Write data to Tx Port
09A1: 52 00    MOV   A,[X+0]       (0518)    endm
09A3: 49 2B 10 TST   REG[43],16
09A6: AF FC    JZ    0x09A3        (0519) 
09A8: 60 29    MOV   REG[41],A
09AA: 4F       MOV   X,SP          (0520) 
09AB: 62 D3 07 MOV   REG[211],7    (0521)  TX_REPEATER_14_PutChar:
09AE: 77 FD    INC   [X-3]         (0522) _TX_REPEATER_14_PutChar:
09B0: 8F E4    JMP   0x0995        (0523)    RAM_PROLOGUE RAM_USE_CLASS_1
09B2: 70 3F    AND   F,63
                                   (0524)    InLinePutChar A
                                   (0525)    RAM_EPILOGUE RAM_USE_CLASS_1
09B4: 71 C0    OR    F,192         (0526)    ret
09B6: 7F       RET                 (0527) 
                                   (0528) .ENDSECTION
                                   (0529) 
                                   (0530) 
                                   (0531) ;-----------------------------------------------
                                   (0532) ;  High Level TX functions
                                   (0533) ;-----------------------------------------------
                                   (0534) 
                                   (0535) 
                                   (0536) .SECTION
                                   (0537) ;-----------------------------------------------------------------------------
                                   (0538) ;  FUNCTION NAME: TX_REPEATER_14_PutString
                                   (0539) ;
                                   (0540) ;  DESCRIPTION:
                                   (0541) ;     Send String out through UART TX port.
                                   (0542) ;
                                   (0543) ;
                                   (0544) ;  ARGUMENTS:
                                   (0545) ;     Pointer to String
                                   (0546) ;     A has MSB of string address
                                   (0547) ;     X has LSB of string address
                                   (0548) ;
                                   (0549) ;  RETURNS:
                                   (0550) ;     none
                                   (0551) ;
                                   (0552) ;  SIDE EFFECTS:
                                   (0553) ;    The A and X registers may be modified by this or future implementations
                                   (0554) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0555) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0556) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0557) ;    functions.
                                   (0558) ;          
                                   (0559) ;    Currently only the page pointer registers listed below are modified: 
                                   (0560) ;          IDX_PP
                                   (0561) ;
                                   (0562)  TX_REPEATER_14_PutString:
                                   (0563) _TX_REPEATER_14_PutString:
09B7: 4F       MOV   X,SP          (0564)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0565)    RAM_SETPAGE_IDX A
                                   (0566) .PutStringLoop:
                                   (0567)    mov   A,[X]                             ; Get value pointed to by X
09B8: 3D FA 00 CMP   [X-6],0       (0568)    jz    End_PutString                     ; Check for end of string
09BB: B0 06    JNZ   0x09C2        (0569)    call  TX_REPEATER_14_PutChar             ; Send character to Tx port
09BD: 3D FB 00 CMP   [X-5],0       (0570)    inc   X                                 ; Advance pointer to next character
09C0: A0 1D    JZ    0x09DE        (0571)    jmp   .PutStringLoop                     ; Get next character
                                   (0572) 
                                   (0573) End_PutString:
09C2: 10       PUSH  X             (0574)    RAM_EPILOGUE RAM_USE_CLASS_3
09C3: 52 FC    MOV   A,[X-4]       (0575)    ret
09C5: 59 FD    MOV   X,[X-3]       (0576) .ENDSECTION
09C7: 28       ROMX                (0577) 
09C8: 49 2B 10 TST   REG[43],16
09CB: AF FC    JZ    0x09C8        (0578) .SECTION
09CD: 60 29    MOV   REG[41],A
09CF: 20       POP   X             (0579) ;-----------------------------------------------------------------------------
                                   (0580) ;  FUNCTION NAME: TX_REPEATER_14_Write
09D0: 07 FD 01 ADD   [X-3],1       (0581) ;
09D3: 0F FC 00 ADC   [X-4],0       (0582) ;  DESCRIPTION:
                                   (0583) ;     Send String of length X to serial port
                                   (0584) ;
09D6: 17 FB 01 SUB   [X-5],1       (0585) ;
09D9: 1F FA 00 SBB   [X-6],0       (0586) ;  ARGUMENTS:
                                   (0587) ;     Pointer to String
09DC: 8F DB    JMP   0x09B8        (0588) ;     [SP-5] Count of characters to send
                                   (0589) ;     [SP-4] has MSB of string address
                                   (0590) ;     [SP-3] has LSB of string address
                                   (0591) ;
09DE: 7F       RET                 (0592) ;  RETURNS:
                                   (0593) ;     none
                                   (0594) ;
                                   (0595) ;  SIDE EFFECTS:
                                   (0596) ;    The A and X registers may be modified by this or future implementations
                                   (0597) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0598) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0599) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0600) ;    functions.
                                   (0601) ;          
                                   (0602) ;    Currently only the page pointer registers listed below are modified: 
                                   (0603) ;          IDX_PP
                                   (0604) ;
                                   (0605) CNT_LEN:    equ -5           ; Length of data to send
                                   (0606) STR_MSB:    equ -4           ; MSB pointer of string
                                   (0607) STR_LSB:    equ -3           ; LSB pointer of string
                                   (0608) 
                                   (0609)  TX_REPEATER_14_Write:
                                   (0610) _TX_REPEATER_14_Write:
                                   (0611)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (0612)    RAM_SETPAGE_IDX2STK
                                   (0613)    mov   X, SP
                                   (0614) 
                                   (0615) .NextByteLoop:
                                   (0616)    mov   A,[X+CNT_LEN]                     ; Get length of string to send
                                   (0617)    jz    .End_Write
                                   (0618)    dec   [X+CNT_LEN]                       ; Decrement counter
                                   (0619) 
                                   (0620)    IF SYSTEM_LARGE_MEMORY_MODEL
09DF: 08       PUSH  A             (0621)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
09E0: 10       PUSH  X             (0622)    ENDIF
09E1: 28       ROMX                (0623) 
09E2: A0 0B    JZ    0x09EE        (0624)    mov   X,[X+STR_LSB]                     ; Get character to send
09E4: 9F 8F    CALL  0x0975        (0625)    RAM_SETPAGE_IDX A                        ; switch index pages
09E6: 20       POP   X             (0626)    mov   A,[X]
09E7: 18       POP   A             (0627)    InLinePutChar A                          ; Send character to UART
09E8: 75       INC   X             (0628)    mov   X, SP
09E9: DF F5    JNC   0x09DF        (0629)    RAM_SETPAGE_IDX2STK
09EB: 74       INC   A             (0630)    inc   [X+STR_LSB]
09EC: 8F F2    JMP   0x09DF        (0631)    jmp   .NextByteLoop
                                   (0632) 
                                   (0633) .End_Write:
                                   (0634)    RAM_EPILOGUE RAM_USE_CLASS_3
09EE: 38 FE    ADD   SP,254        (0635)    ret
                                   (0636) .ENDSECTION
09F0: 7F       RET                 (0637) 
                                   (0638) .SECTION
                                   (0639) ;-----------------------------------------------------------------------------
                                   (0640) ;  FUNCTION NAME: TX_REPEATER_14_CWrite
                                   (0641) ;
                                   (0642) ;             WARNING WARNING NOT COMPLETE
                                   (0643) ;
                                   (0644) ;  DESCRIPTION:
                                   (0645) ;     Send String of length X to serial port
                                   (0646) ;
                                   (0647) ;  ARGUMENTS:
                                   (0648) ;     Pointer to String
                                   (0649) ;     [SP-6] MSB of Count of character to send
                                   (0650) ;     [SP-5] LSB of Count of character to send
                                   (0651) ;     [SP-4] has MSB of string address
                                   (0652) ;     [SP-3] has LSB of string address
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
09F1: 50 0D    MOV   A,13          (0663) ;
09F3: 9F 80    CALL  0x0975        (0664) CLEN_MSB:   equ -6           ; MSB Length of data to send
09F5: 50 0A    MOV   A,10          (0665) CLEN_LSB:   equ -5           ; LSB Length of data to send
09F7: 9F 7C    CALL  0x0975        (0666) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (0667) CSTR_LSB:   equ -3           ; LSB pointer of string
09FA: 43 E1 02 OR    REG[225],2    (0668) 

FILE: lib\rx_timeout.asm
                                   (0102) ;;*****************************************************************************
09FD: 7F       RET                 (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME: RX_TIMEOUT.asm
                                   (0105) ;;   Version: 2.6, Updated on 2009/7/10 at 10:46:29
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION: Timer16 User Module software implementation file
                                   (0109) ;;               for the 22/24/27/29xxx PSoC family of devices
                                   (0110) ;;
                                   (0111) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0112) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0113) ;;        This means it is the caller's responsibility to preserve any values
                                   (0114) ;;        in the X and A registers that are still needed after the API functions
                                   (0115) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0116) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0117) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0118) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0119) ;;-----------------------------------------------------------------------------
                                   (0120) ;;  Copyright (c) Cypress MicroSystems 2000-2004. All Rights Reserved.
                                   (0121) ;;*****************************************************************************
                                   (0122) ;;*****************************************************************************
                                   (0123) 
                                   (0124) include "m8c.inc"
                                   (0125) include "memory.inc"
                                   (0126) include "RX_TIMEOUT.inc"
                                   (0127) 
                                   (0128) ;-----------------------------------------------
09FE: 41 E1 FD AND   REG[225],253  (0129) ;  Global Symbols
                                   (0130) ;-----------------------------------------------
0A01: 7F       RET                 (0131) export  RX_TIMEOUT_EnableInt
                                   (0132) export _RX_TIMEOUT_EnableInt
                                   (0133) export  RX_TIMEOUT_DisableInt
                                   (0134) export _RX_TIMEOUT_DisableInt
                                   (0135) export  RX_TIMEOUT_Start
                                   (0136) export _RX_TIMEOUT_Start
                                   (0137) export  RX_TIMEOUT_Stop
                                   (0138) export _RX_TIMEOUT_Stop
                                   (0139) export  RX_TIMEOUT_WritePeriod
                                   (0140) export _RX_TIMEOUT_WritePeriod
                                   (0141) export  RX_TIMEOUT_WriteCompareValue
                                   (0142) export _RX_TIMEOUT_WriteCompareValue
                                   (0143) export  RX_TIMEOUT_wReadCompareValue
                                   (0144) export _RX_TIMEOUT_wReadCompareValue
                                   (0145) export  RX_TIMEOUT_wReadTimer
                                   (0146) export _RX_TIMEOUT_wReadTimer
                                   (0147) export  RX_TIMEOUT_wReadTimerSaveCV
                                   (0148) export _RX_TIMEOUT_wReadTimerSaveCV
                                   (0149) 
                                   (0150) ; The following functions are deprecated and subject to omission in future releases
                                   (0151) ;
                                   (0152) export  wRX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0153) export _wRX_TIMEOUT_ReadCompareValue  ; deprecated
                                   (0154) export  wRX_TIMEOUT_ReadTimer         ; deprecated
                                   (0155) export _wRX_TIMEOUT_ReadTimer         ; deprecated
                                   (0156) export  wRX_TIMEOUT_ReadTimerSaveCV   ; deprecated
0A02: 43 23 01 OR    REG[35],1     (0157) export _wRX_TIMEOUT_ReadTimerSaveCV   ; deprecated
                                   (0158) 
0A05: 7F       RET                 (0159) export  wRX_TIMEOUT_ReadCounter       ; obsolete
                                   (0160) export _wRX_TIMEOUT_ReadCounter       ; obsolete
                                   (0161) export  wRX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0162) export _wRX_TIMEOUT_CaptureCounter    ; obsolete
                                   (0163) 
                                   (0164) 
                                   (0165) AREA receiver_config_RAM (RAM,REL)
                                   (0166) 
                                   (0167) ;-----------------------------------------------
                                   (0168) ;  Constant Definitions
                                   (0169) ;-----------------------------------------------
                                   (0170) 
                                   (0171) 
                                   (0172) ;-----------------------------------------------
                                   (0173) ; Variable Allocation
                                   (0174) ;-----------------------------------------------
                                   (0175) 
                                   (0176) 
                                   (0177) AREA UserModules (ROM, REL)
                                   (0178) 
                                   (0179) .SECTION
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: RX_TIMEOUT_EnableInt
                                   (0182) ;
                                   (0183) ;  DESCRIPTION:
                                   (0184) ;     Enables this timer's interrupt by setting the interrupt enable mask bit
0A06: 41 23 FE AND   REG[35],254   (0185) ;     associated with this User Module. This function has no effect until and
                                   (0186) ;     unless the global interrupts are enabled (for example by using the
0A09: 7F       RET                 (0187) ;     macro M8C_EnableGInt).
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) ;  ARGUMENTS:    None.
                                   (0191) ;  RETURNS:      Nothing.
                                   (0192) ;  SIDE EFFECTS: 
                                   (0193) ;    The A and X registers may be modified by this or future implementations
                                   (0194) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0195) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0196) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0197) ;    functions.
                                   (0198) ;
                                   (0199)  RX_TIMEOUT_EnableInt:
                                   (0200) _RX_TIMEOUT_EnableInt:
                                   (0201)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0202)    RX_TIMEOUT_EnableInt_M
                                   (0203)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0204)    ret
                                   (0205) 
                                   (0206) .ENDSECTION
                                   (0207) 
                                   (0208) 
                                   (0209) .SECTION
                                   (0210) ;-----------------------------------------------------------------------------
                                   (0211) ;  FUNCTION NAME: RX_TIMEOUT_DisableInt
                                   (0212) ;
                                   (0213) ;  DESCRIPTION:
0A0A: 60 21    MOV   REG[33],A     (0214) ;     Disables this timer's interrupt by clearing the interrupt enable
0A0C: 5B       MOV   A,X           (0215) ;     mask bit associated with this User Module.
0A0D: 60 25    MOV   REG[37],A     (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;
0A0F: 7F       RET                 (0218) ;  ARGUMENTS:    None
                                   (0219) ;  RETURNS:      Nothing
                                   (0220) ;  SIDE EFFECTS: 
                                   (0221) ;    The A and X registers may be modified by this or future implementations
                                   (0222) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0223) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0224) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0225) ;    functions.
                                   (0226) ;
                                   (0227)  RX_TIMEOUT_DisableInt:
                                   (0228) _RX_TIMEOUT_DisableInt:
                                   (0229)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0230)    RX_TIMEOUT_DisableInt_M
                                   (0231)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0232)    ret
                                   (0233) 
                                   (0234) .ENDSECTION
                                   (0235) 
                                   (0236) 
                                   (0237) .SECTION
                                   (0238) ;-----------------------------------------------------------------------------
                                   (0239) ;  FUNCTION NAME: RX_TIMEOUT_Start
                                   (0240) ;
                                   (0241) ;  DESCRIPTION:
                                   (0242) ;     Sets the start bit in the Control register of this user module.  The
                                   (0243) ;     timer will begin counting on the next input clock.
                                   (0244) ;-----------------------------------------------------------------------------
                                   (0245) ;
0A10: 60 22    MOV   REG[34],A     (0246) ;  ARGUMENTS:    None
0A12: 5B       MOV   A,X           (0247) ;  RETURNS:      Nothing
0A13: 60 26    MOV   REG[38],A     (0248) ;  SIDE EFFECTS: 
                                   (0249) ;    The A and X registers may be modified by this or future implementations
0A15: 7F       RET                 (0250) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0251) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0252) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0253) ;    functions.
                                   (0254) ;
                                   (0255)  RX_TIMEOUT_Start:
                                   (0256) _RX_TIMEOUT_Start:
                                   (0257)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0258)    RX_TIMEOUT_Start_M
                                   (0259)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0260)    ret
                                   (0261) 
                                   (0262) .ENDSECTION
                                   (0263) 
                                   (0264) 
                                   (0265) .SECTION
                                   (0266) ;-----------------------------------------------------------------------------
                                   (0267) ;  FUNCTION NAME: RX_TIMEOUT_Stop
                                   (0268) ;
                                   (0269) ;  DESCRIPTION:
                                   (0270) ;     Disables timer operation by clearing the start bit in the Control
                                   (0271) ;     register of the LSB block.
                                   (0272) ;-----------------------------------------------------------------------------
                                   (0273) ;
                                   (0274) ;  ARGUMENTS:    None
                                   (0275) ;  RETURNS:      Nothing
                                   (0276) ;  SIDE EFFECTS: 
0A16: 5D 26    MOV   A,REG[38]     (0277) ;    The A and X registers may be modified by this or future implementations
0A18: 5C       MOV   X,A           (0278) ;    of this function.  The same is true for all RAM page pointer registers in
0A19: 5D 22    MOV   A,REG[34]     (0279) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0280) ;    responsibility to perserve their values across calls to fastcall16 
0A1B: 7F       RET                 (0281) ;    functions.
                                   (0282) ;
                                   (0283)  RX_TIMEOUT_Stop:
                                   (0284) _RX_TIMEOUT_Stop:
                                   (0285)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0286)    RX_TIMEOUT_Stop_M
                                   (0287)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0288)    ret
                                   (0289) 
                                   (0290) .ENDSECTION
                                   (0291) 
                                   (0292) 
                                   (0293) .SECTION
                                   (0294) ;-----------------------------------------------------------------------------
                                   (0295) ;  FUNCTION NAME: RX_TIMEOUT_WritePeriod
                                   (0296) ;
                                   (0297) ;  DESCRIPTION:
                                   (0298) ;     Write the 16-bit period value into the Period register (DR1). If the
                                   (0299) ;     Timer user module is stopped, then this value will also be latched
                                   (0300) ;     into the Count register (DR0).
                                   (0301) ;-----------------------------------------------------------------------------
                                   (0302) ;
                                   (0303) ;  ARGUMENTS: fastcall16 WORD wPeriodValue (LSB in A, MSB in X)
                                   (0304) ;  RETURNS:   Nothing
                                   (0305) ;  SIDE EFFECTS:
                                   (0306) ;    The A and X registers may be modified by this or future implementations
                                   (0307) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0308) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0309) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0310) ;    functions.
                                   (0311) ;
                                   (0312)  RX_TIMEOUT_WritePeriod:
                                   (0313) _RX_TIMEOUT_WritePeriod:
                                   (0314)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0315)    mov   reg[RX_TIMEOUT_PERIOD_LSB_REG], A
                                   (0316)    mov   A, X
                                   (0317)    mov   reg[RX_TIMEOUT_PERIOD_MSB_REG], A
                                   (0318)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0319)    ret
                                   (0320) 
                                   (0321) .ENDSECTION
                                   (0322) 
                                   (0323) 
                                   (0324) .SECTION
                                   (0325) ;-----------------------------------------------------------------------------
                                   (0326) ;  FUNCTION NAME: RX_TIMEOUT_WriteCompareValue
                                   (0327) ;
                                   (0328) ;  DESCRIPTION:
                                   (0329) ;     Writes compare value into the Compare register (DR2).
                                   (0330) ;
                                   (0331) ;     NOTE! The Timer user module must be STOPPED in order to write the
                                   (0332) ;           Compare register. (Call RX_TIMEOUT_Stop to disable).
0A1C: 4F       MOV   X,SP          (0333) ;-----------------------------------------------------------------------------
0A1D: 38 03    ADD   SP,3          (0334) ;
0A1F: 5D 23    MOV   A,REG[35]     (0335) ;  ARGUMENTS:    fastcall16 WORD wCompareValue (LSB in A, MSB in X)
0A21: 08       PUSH  A             (0336) ;  RETURNS:      Nothing
0A22: 5D 22    MOV   A,REG[34]     (0337) ;  SIDE EFFECTS: 
0A24: 08       PUSH  A             (0338) ;    The A and X registers may be modified by this or future implementations
0A25: 5D 26    MOV   A,REG[38]     (0339) ;    of this function.  The same is true for all RAM page pointer registers in
0A27: 08       PUSH  A             (0340) ;    the Large Memory Model.  When necessary, it is the calling function's
0A28: 5D 20    MOV   A,REG[32]     (0341) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0342) ;    functions.
0A2A: 5D 26    MOV   A,REG[38]     (0343) ;
0A2C: 54 01    MOV   [X+1],A       (0344)  RX_TIMEOUT_WriteCompareValue:
0A2E: 5D 22    MOV   A,REG[34]     (0345) _RX_TIMEOUT_WriteCompareValue:
0A30: 54 02    MOV   [X+2],A       (0346)    RAM_PROLOGUE RAM_USE_CLASS_1
0A32: 50 00    MOV   A,0           (0347)    mov   reg[RX_TIMEOUT_COMPARE_LSB_REG], A
0A34: 49 F7 01 TST   REG[247],1    (0348)    mov   A, X
0A37: A0 03    JZ    0x0A3B        (0349)    mov   reg[RX_TIMEOUT_COMPARE_MSB_REG], A
0A39: 50 01    MOV   A,1           (0350)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0351)    ret
0A3B: 54 00    MOV   [X+0],A       (0352) 
0A3D: 70 FE    AND   F,254         (0353) .ENDSECTION
0A3F: 41 23 FE AND   REG[35],254   (0354) 
0A42: 18       POP   A             (0355) 
0A43: 60 26    MOV   REG[38],A     (0356) .SECTION
0A45: 18       POP   A             (0357) ;-----------------------------------------------------------------------------
0A46: 60 22    MOV   REG[34],A     (0358) ;  FUNCTION NAME: RX_TIMEOUT_wReadCompareValue
0A48: 18       POP   A             (0359) ;
0A49: 60 23    MOV   REG[35],A     (0360) ;  DESCRIPTION:
0A4B: 18       POP   A             (0361) ;     Reads the Compare registers.
0A4C: 20       POP   X             (0362) ;-----------------------------------------------------------------------------
0A4D: 70 3F    AND   F,63
0A4F: 71 C0    OR    F,192         (0363) ;
0A51: 7E       RETI                (0364) ;  ARGUMENTS:    None
                                   (0365) ;  RETURNS:      fastcall16 WORD wCompareValue (value of DR2 in the X & A registers)
                                   (0366) ;  SIDE EFFECTS: 
                                   (0367) ;    The A and X registers may be modified by this or future implementations
                                   (0368) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0369) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0370) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0371) ;    functions.
                                   (0372) ;
                                   (0373)  RX_TIMEOUT_wReadCompareValue:
                                   (0374) _RX_TIMEOUT_wReadCompareValue:
                                   (0375)  wRX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0376) _wRX_TIMEOUT_ReadCompareValue:                   ; this name deprecated
                                   (0377)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0378)    mov   A, reg[RX_TIMEOUT_COMPARE_MSB_REG]
                                   (0379)    mov   X, A
                                   (0380)    mov   A, reg[RX_TIMEOUT_COMPARE_LSB_REG]
                                   (0381)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0382)    ret
                                   (0383) 
                                   (0384) .ENDSECTION
                                   (0385) 
                                   (0386) 
                                   (0387) .SECTION
                                   (0388) ;-----------------------------------------------------------------------------
                                   (0389) ;  FUNCTION NAME: RX_TIMEOUT_wReadTimerSaveCV
                                   (0390) ;
                                   (0391) ;  DESCRIPTION:
                                   (0392) ;     Returns the value in the Count register (DR0), preserving the
                                   (0393) ;     value in the compare register (DR2).
                                   (0394) ;-----------------------------------------------------------------------------
                                   (0395) ;
                                   (0396) ;  ARGUMENTS: None
                                   (0397) ;  RETURNS:   fastcall16 WORD wCount (value of DR0 in the X & A registers)
                                   (0398) ;  SIDE EFFECTS:
                                   (0399) ;     1) May cause an interrupt, if interrupt on Compare is enabled.
                                   (0400) ;     2) If enabled, Global interrupts are momentarily disabled.
                                   (0401) ;     3) The user module is stopped momentarily while the compare value is
                                   (0402) ;        restored.  This may cause the Count register to miss one or more
                                   (0403) ;        counts depending on the input clock speed.
                                   (0404) ;     4) The A and X registers may be modified by this or future implementations
0A52: 5D 20    MOV   A,REG[32]     (0405) ;        of this function.  The same is true for all RAM page pointer registers in
                                   (0406) ;        the Large Memory Model.  When necessary, it is the calling function's
                                   (0407) ;        responsibility to perserve their values across calls to fastcall16 
0A54: 5D 26    MOV   A,REG[38]     (0408) ;        functions.
0A56: 5C       MOV   X,A           (0409) ;
0A57: 5D 22    MOV   A,REG[34]     (0410) ;  THEORY of OPERATION:
                                   (0411) ;     1) Read and save the Compare register.
0A5A: 08       PUSH  A             (0412) ;     2) Read the Count register, causing its data to be latched into

FILE: lib\receive_4int.asm
0A5B: 10       PUSH  X             (0104) ;;*****************************************************************************
0A5C: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RECEIVE_4INT.asm
0A5E: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0A5F: 58 01    MOV   X,[1]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0A61: 5D 3F    MOV   A,REG[63]     (0111) ;;-----------------------------------------------------------------------------
0A63: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0A64: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0A66: B0 04    JNZ   0x0A6B        (0115) 
0A68: 18       POP   A             (0116) include "m8c.inc"
0A69: 80 5E    JMP   0x0AC8        (0117) include "memory.inc"
                                   (0118) include "RECEIVE_4.inc"
                                   (0119) 
                                   (0120) 
0A6B: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0A6C: 21 E0    AND   A,224         (0124) export  _RECEIVE_4_ISR
0A6E: A0 12    JZ    0x0A81        (0125) 
                                   (0126) 
0A70: 2C 00    OR    [0],A         (0127) IF (RECEIVE_4_RXBUF_ENABLE)
                                   (0128) export  RECEIVE_4_aRxBuffer
0A72: 49 3E 00 TST   REG[62],0     (0129) export _RECEIVE_4_aRxBuffer
                                   (0130) export  RECEIVE_4_bRxCnt
0A75: 21 20    AND   A,32          (0131) export _RECEIVE_4_bRxCnt
0A77: A0 50    JZ    0x0AC8        (0132) export  RECEIVE_4_fStatus
                                   (0133) export _RECEIVE_4_fStatus
                                   (0134) ENDIF
                                   (0135) 
0A79: 41 3F FE AND   REG[63],254   (0136) 
0A7C: 43 3F 01 OR    REG[63],1     (0137) ;-----------------------------------------------
0A7F: 80 48    JMP   0x0AC8        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RECEIVE_4_RXBUF_ENABLE)
0A81: 5D 3E    MOV   A,REG[62]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RECEIVE_4_fStatus:
                                   (0144) _RECEIVE_4_fStatus:      BLK  1
0A83: 47 00 01 TST   [0],1         (0145)  RECEIVE_4_bRxCnt:
0A86: B0 41    JNZ   0x0AC8        (0146) _RECEIVE_4_bRxCnt:       BLK  1
                                   (0147) AREA RECEIVE_4_RAM(RAM,REL,CON)
0A88: 39 00    CMP   A,0           (0148)  RECEIVE_4_aRxBuffer:    
0A8A: B0 14    JNZ   0x0A9F        (0149) _RECEIVE_4_aRxBuffer:    BLK RECEIVE_4_RX_BUFFER_SIZE
0A8C: 2E 00 01 OR    [0],1         (0150) ENDIF
                                   (0151) 
0A8F: 62 D3 00 MOV   REG[211],0    (0152) 
0A92: 70 3F    AND   F,63
0A94: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0A96: 56 7B 00 MOV   [X+123],0     (0154) 
0A99: 70 3F    AND   F,63
0A9B: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0A9D: 80 2A    JMP   0x0AC8        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0A9F: 3C 01 0F CMP   [1],15        (0167) ;------------------------
0AA2: C0 14    JC    0x0AB7        (0168) 
0AA4: 2E 00 10 OR    [0],16        (0169) 
                                   (0170) ;------------------------
0AA7: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0AAA: 70 3F    AND   F,63
0AAC: 71 80    OR    F,128         (0172) ;------------------------
0AAE: 56 7B 00 MOV   [X+123],0     (0173) 
0AB1: 70 3F    AND   F,63
0AB3: 71 00    OR    F,0           (0174) 
0AB5: 80 12    JMP   0x0AC8        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0AB7: 75       INC   X             (0179) 
0AB8: 5A 01    MOV   [1],X         (0180) 
0ABA: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0ABB: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0ABE: 70 3F    AND   F,63
0AC0: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RECEIVE_4_ISR
0AC2: 54 7B    MOV   [X+123],A     (0185) ;
0AC4: 70 3F    AND   F,63
0AC6: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0AC8: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0AC9: 60 D3    MOV   REG[211],A    (0191) _RECEIVE_4_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0ACB: 20       POP   X             (0195)    ; Insert your custom code below this banner
0ACC: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0ACE: 43 E1 80 OR    REG[225],128  (0201)    ; Insert your custom code above this banner

FILE: lib\receive_4.asm
                                   (0121) ;;*****************************************************************************
0AD1: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RECEIVE_4.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RECEIVE_4.inc"
0AD2: 41 E1 7F AND   REG[225],127  (0149) 
                                   (0150) 
0AD5: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RECEIVE_4_EnableInt
                                   (0155) export  _RECEIVE_4_EnableInt
                                   (0156) export   RECEIVE_4_DisableInt
                                   (0157) export  _RECEIVE_4_DisableInt
                                   (0158) export   RECEIVE_4_Start
                                   (0159) export  _RECEIVE_4_Start
                                   (0160) export   RECEIVE_4_Stop
                                   (0161) export  _RECEIVE_4_Stop
                                   (0162) export   RECEIVE_4_bReadRxData
                                   (0163) export  _RECEIVE_4_bReadRxData
                                   (0164) export   RECEIVE_4_bReadRxStatus
                                   (0165) export  _RECEIVE_4_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRECEIVE_4_ReadRxData
                                   (0170) export _bRECEIVE_4_ReadRxData
                                   (0171) export  bRECEIVE_4_ReadRxStatus
                                   (0172) export _bRECEIVE_4_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RECEIVE_4_cGetChar
0AD6: 29 01    OR    A,1           (0179) export _RECEIVE_4_cGetChar
0AD8: 60 3F    MOV   REG[63],A     (0180) export  RECEIVE_4_cReadChar
                                   (0181) export _RECEIVE_4_cReadChar
0ADA: 7F       RET                 (0182) export  RECEIVE_4_iReadChar
                                   (0183) export _RECEIVE_4_iReadChar
                                   (0184) 
                                   (0185) IF (RECEIVE_4_RXBUF_ENABLE)
                                   (0186) export  RECEIVE_4_CmdReset
                                   (0187) export _RECEIVE_4_CmdReset
                                   (0188) export  RECEIVE_4_bCmdCheck
                                   (0189) export _RECEIVE_4_bCmdCheck
                                   (0190) export  RECEIVE_4_bCmdLength
                                   (0191) export _RECEIVE_4_bCmdLength
                                   (0192) export  RECEIVE_4_bErrCheck
                                   (0193) export _RECEIVE_4_bErrCheck
                                   (0194) 
                                   (0195) export  RECEIVE_4_szGetParam
                                   (0196) export _RECEIVE_4_szGetParam
                                   (0197) export  RECEIVE_4_szGetRestOfParams
                                   (0198) export _RECEIVE_4_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RECEIVE_4_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0ADB: 41 3F FE AND   REG[63],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0ADE: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RECEIVE_4_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RECEIVE_4_EnableInt:
                                   (0238) _RECEIVE_4_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0ADF: 5D 3E    MOV   A,REG[62]     (0240)    M8C_EnableIntMask RECEIVE_4_INT_REG, RECEIVE_4_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0AE1: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RECEIVE_4_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RECEIVE_4_DisableInt:
                                   (0267) _RECEIVE_4_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RECEIVE_4_INT_REG, RECEIVE_4_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0AE2: 5D 3F    MOV   A,REG[63]     (0272) .ENDSECTION
                                   (0273) 
0AE4: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RECEIVE_4_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RECEIVE_4_Start:
                                   (0297) _RECEIVE_4_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RECEIVE_4_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RECEIVE_4_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0AE5: 49 3F 08 TST   REG[63],8     (0311) ;
0AE8: AF FC    JZ    0x0AE5        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0AEA: 5D 3E    MOV   A,REG[62]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0AEC: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RECEIVE_4_Stop:
                                   (0326) _RECEIVE_4_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RECEIVE_4_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RECEIVE_4_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0AED: 5D 3F    MOV   A,REG[63]     (0346) ;    bRxData - returned in A.
0AEF: 08       PUSH  A             (0347) ;
0AF0: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0AF2: B0 04    JNZ   0x0AF7        (0349) ;    The A and X registers may be modified by this or future implementations
0AF4: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0AF5: 80 0B    JMP   0x0B01        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0AF7: 5D 3E    MOV   A,REG[62]     (0354) ;
0AF9: 4B       SWAP  A,X           (0355)  RECEIVE_4_bReadRxData:
                                   (0356) _RECEIVE_4_bReadRxData:
0AFA: 18       POP   A             (0357)  bRECEIVE_4_ReadRxData:
0AFB: 21 A0    AND   A,160         (0358) _bRECEIVE_4_ReadRxData:
0AFD: B0 03    JNZ   0x0B01        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0AFF: 4B       SWAP  A,X           (0360)    mov A, REG[RECEIVE_4_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0B00: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0B01: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RECEIVE_4_bReadRxStatus
                                   (0368) ;
0B03: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RECEIVE_4_bReadRxStatus:
                                   (0388) _RECEIVE_4_bReadRxStatus:
                                   (0389)  bRECEIVE_4_ReadRxStatus:
                                   (0390) _bRECEIVE_4_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RECEIVE_4_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RECEIVE_4_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0B04: 5D 3F    MOV   A,REG[63]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0B06: 21 E8    AND   A,232         (0408) ;
0B08: 08       PUSH  A             (0409) ;  ARGUMENTS:
0B09: 21 08    AND   A,8           (0410) ;      none
0B0B: B0 07    JNZ   0x0B13        (0411) ;
0B0D: 18       POP   A             (0412) ;  RETURNS:
0B0E: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0B10: 4B       SWAP  A,X           (0414) ;
0B11: 80 07    JMP   0x0B19        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0B13: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0B14: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0B16: 4B       SWAP  A,X           (0420) ;    functions.
0B17: 5D 3E    MOV   A,REG[62]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0B19: 7F       RET                 (0426)  RECEIVE_4_cGetChar:
                                   (0427) _RECEIVE_4_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RECEIVE_4_CONTROL_REG],RECEIVE_4_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RECEIVE_4_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RECEIVE_4_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RECEIVE_4_cReadChar:
                                   (0463) _RECEIVE_4_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RECEIVE_4_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RECEIVE_4_RX_COMPLETE                            ; Check if a character is ready
0B1A: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0B1D: 55 7B 00 MOV   [123],0       (0470)    pop  A
0B20: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0B23: 55 A4 00 MOV   [NUM_MODULES+2],0(0472) 
0B26: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0B29: 55 01 00 MOV   [1],0         (0474)    mov  A,REG[RECEIVE_4_RX_BUFFER_REG]                     ; Read data first, then
0B2C: 26 00 00 AND   [0],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0B2F: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RECEIVE_4_RX_PARITY_ERROR | RECEIVE_4_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RECEIVE_4_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RECEIVE_4_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0B30: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0B33: 51 00    MOV   A,[0]         (0511) ;        0x40CC    Overrun Error
0B35: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0B37: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RECEIVE_4_iReadChar:
                                   (0523) _RECEIVE_4_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RECEIVE_4_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RECEIVE_4_RX_ERROR|RECEIVE_4_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RECEIVE_4_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RECEIVE_4_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RECEIVE_4_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RECEIVE_4_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RECEIVE_4_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RECEIVE_4_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RECEIVE_4_RXBUF_ENABLE)
                                   (0552) .SECTION
0B38: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0B3B: 51 00    MOV   A,[0]         (0554) ;-----------------------------------------------------------------------------
0B3D: 21 F0    AND   A,240         (0555) ;
0B3F: 26 00 0F AND   [0],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0B42: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RECEIVE_4_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RECEIVE_4_CmdReset:
0B43: 62 D0 00 MOV   REG[208],0    (0587) _RECEIVE_4_CmdReset:
0B46: 51 01    MOV   A,[1]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RECEIVE_4_aRxBuffer
0B48: 7F       RET                 (0590)    mov [RECEIVE_4_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RECEIVE_4_bRxCnt
                                   (0594)    mov [RECEIVE_4_bRxCnt], 0x00
                                   (0595)    and [RECEIVE_4_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RECEIVE_4_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RECEIVE_4_bCmdCheck:
                                   (0628) _RECEIVE_4_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RECEIVE_4_fStatus
                                   (0631)    mov A,  [RECEIVE_4_fStatus]
                                   (0632)    and A, RECEIVE_4_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RECEIVE_4_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0B49: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0B4B: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0B4E: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0B51: 50 7B    MOV   A,123         (0648) ;     BYTE  fStatus - Status of command receive buffer.
0B53: 02 A4    ADD   A,[NUM_MODULES+2](0649) ;                     Returns non-zero value in A if command is valid.
0B55: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0B56: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0B58: B0 04    JNZ   0x0B5D        (0653) ;           0x10 => Software Buffer OverRun
0B5A: 10       PUSH  X             (0654) ;
0B5B: 80 33    JMP   0x0B8F        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0B5D: 39 00    CMP   A,0           (0660) ;    functions.
0B5F: B0 11    JNZ   0x0B71        (0661) ;          
0B61: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0B62: 76 A4    INC   [NUM_MODULES+2](0663) ;          CUR_PP
0B64: 52 00    MOV   A,[X+0]       (0664) ;
0B66: 3C A4 0F CMP   [NUM_MODULES+2],15(0665) ;     Error Status is clear when read.
0B69: BF F3    JNZ   0x0B5D        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0B6B: 10       PUSH  X             (0669) ;
                                   (0670)  RECEIVE_4_bErrCheck:
0B6C: 56 00 00 MOV   [X+0],0       (0671) _RECEIVE_4_bErrCheck:
0B6F: 80 1F    JMP   0x0B8F        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RECEIVE_4_fStatus
                                   (0674)    mov A,  [RECEIVE_4_fStatus]
0B71: 10       PUSH  X             (0675)    and A, RECEIVE_4_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [RECEIVE_4_fStatus], ~RECEIVE_4_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0B72: 75       INC   X             (0679) .ENDSECTION
0B73: 76 A4    INC   [NUM_MODULES+2](0680) 
0B75: 3C A4 0F CMP   [NUM_MODULES+2],15(0681) .SECTION
0B78: AF F3    JZ    0x0B6C        (0682) ;-----------------------------------------------------------------------------
0B7A: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RECEIVE_4_bCmdLength
0B7C: A0 12    JZ    0x0B8F        (0684) ;
0B7E: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0B80: BF F1    JNZ   0x0B72        (0686) ;     Get length of command string
                                   (0687) ;
0B82: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0B85: 76 A4    INC   [NUM_MODULES+2](0689) ;     none.
0B87: 3C A4 0F CMP   [NUM_MODULES+2],15(0690) ;
0B8A: B0 04    JNZ   0x0B8F        (0691) ;  RETURNS:
0B8C: 55 A4 0F MOV   [NUM_MODULES+2],15(0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0B8F: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0B90: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0B91: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0B94: B0 0B    JNZ   0x0BA0        (0699) ;    functions.
0B96: 20       POP   X             (0700) ;          
0B97: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0B99: 50 00    MOV   A,0           (0702) ;          CUR_PP
0B9B: 70 3F    AND   F,63
0B9D: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RECEIVE_4_bCmdLength:
0B9F: 7F       RET                 (0705) _RECEIVE_4_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RECEIVE_4_bRxCnt
0BA0: 20       POP   X             (0708)    mov A,  [RECEIVE_4_bRxCnt]
0BA1: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0BA3: 70 3F    AND   F,63
0BA5: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0BA7: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RECEIVE_4_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0BA8: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0BAB: 50 7B    MOV   A,123         (0744) ;     each lexically distinct element into a null-terminated string by replacing
0BAD: 02 A4    ADD   A,[NUM_MODULES+2](0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0BAF: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0BB0: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RECEIVE_4_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RECEIVE_4_szGetParam, is
0BB3: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\receive_3int.asm
0BB4: 10       PUSH  X             (0104) ;;*****************************************************************************
0BB5: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RECEIVE_3INT.asm
0BB7: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0BB8: 58 03    MOV   X,[3]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0BBA: 5D 3B    MOV   A,REG[59]     (0111) ;;-----------------------------------------------------------------------------
0BBC: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0BBD: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0BBF: B0 04    JNZ   0x0BC4        (0115) 
0BC1: 18       POP   A             (0116) include "m8c.inc"
0BC2: 80 5E    JMP   0x0C21        (0117) include "memory.inc"
                                   (0118) include "RECEIVE_3.inc"
                                   (0119) 
                                   (0120) 
0BC4: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0BC5: 21 E0    AND   A,224         (0124) export  _RECEIVE_3_ISR
0BC7: A0 12    JZ    0x0BDA        (0125) 
                                   (0126) 
0BC9: 2C 02    OR    [2],A         (0127) IF (RECEIVE_3_RXBUF_ENABLE)
                                   (0128) export  RECEIVE_3_aRxBuffer
0BCB: 49 3A 00 TST   REG[58],0     (0129) export _RECEIVE_3_aRxBuffer
                                   (0130) export  RECEIVE_3_bRxCnt
0BCE: 21 20    AND   A,32          (0131) export _RECEIVE_3_bRxCnt
0BD0: A0 50    JZ    0x0C21        (0132) export  RECEIVE_3_fStatus
                                   (0133) export _RECEIVE_3_fStatus
                                   (0134) ENDIF
                                   (0135) 
0BD2: 41 3B FE AND   REG[59],254   (0136) 
0BD5: 43 3B 01 OR    REG[59],1     (0137) ;-----------------------------------------------
0BD8: 80 48    JMP   0x0C21        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RECEIVE_3_RXBUF_ENABLE)
0BDA: 5D 3A    MOV   A,REG[58]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RECEIVE_3_fStatus:
                                   (0144) _RECEIVE_3_fStatus:      BLK  1
0BDC: 47 02 01 TST   [2],1         (0145)  RECEIVE_3_bRxCnt:
0BDF: B0 41    JNZ   0x0C21        (0146) _RECEIVE_3_bRxCnt:       BLK  1
                                   (0147) AREA RECEIVE_3_RAM(RAM,REL,CON)
0BE1: 39 00    CMP   A,0           (0148)  RECEIVE_3_aRxBuffer:    
0BE3: B0 14    JNZ   0x0BF8        (0149) _RECEIVE_3_aRxBuffer:    BLK RECEIVE_3_RX_BUFFER_SIZE
0BE5: 2E 02 01 OR    [2],1         (0150) ENDIF
                                   (0151) 
0BE8: 62 D3 00 MOV   REG[211],0    (0152) 
0BEB: 70 3F    AND   F,63
0BED: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0BEF: 56 6B 00 MOV   [X+107],0     (0154) 
0BF2: 70 3F    AND   F,63
0BF4: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0BF6: 80 2A    JMP   0x0C21        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0BF8: 3C 03 0F CMP   [3],15        (0167) ;------------------------
0BFB: C0 14    JC    0x0C10        (0168) 
0BFD: 2E 02 10 OR    [2],16        (0169) 
                                   (0170) ;------------------------
0C00: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0C03: 70 3F    AND   F,63
0C05: 71 80    OR    F,128         (0172) ;------------------------
0C07: 56 6B 00 MOV   [X+107],0     (0173) 
0C0A: 70 3F    AND   F,63
0C0C: 71 00    OR    F,0           (0174) 
0C0E: 80 12    JMP   0x0C21        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0C10: 75       INC   X             (0179) 
0C11: 5A 03    MOV   [3],X         (0180) 
0C13: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0C14: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0C17: 70 3F    AND   F,63
0C19: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RECEIVE_3_ISR
0C1B: 54 6B    MOV   [X+107],A     (0185) ;
0C1D: 70 3F    AND   F,63
0C1F: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0C21: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0C22: 60 D3    MOV   REG[211],A    (0191) _RECEIVE_3_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0C24: 20       POP   X             (0195)    ; Insert your custom code below this banner
0C25: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0C27: 43 E1 40 OR    REG[225],64   (0201)    ; Insert your custom code above this banner

FILE: lib\receive_3.asm
                                   (0121) ;;*****************************************************************************
0C2A: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RECEIVE_3.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RECEIVE_3.inc"
0C2B: 41 E1 BF AND   REG[225],191  (0149) 
                                   (0150) 
0C2E: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RECEIVE_3_EnableInt
                                   (0155) export  _RECEIVE_3_EnableInt
                                   (0156) export   RECEIVE_3_DisableInt
                                   (0157) export  _RECEIVE_3_DisableInt
                                   (0158) export   RECEIVE_3_Start
                                   (0159) export  _RECEIVE_3_Start
                                   (0160) export   RECEIVE_3_Stop
                                   (0161) export  _RECEIVE_3_Stop
                                   (0162) export   RECEIVE_3_bReadRxData
                                   (0163) export  _RECEIVE_3_bReadRxData
                                   (0164) export   RECEIVE_3_bReadRxStatus
                                   (0165) export  _RECEIVE_3_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRECEIVE_3_ReadRxData
                                   (0170) export _bRECEIVE_3_ReadRxData
                                   (0171) export  bRECEIVE_3_ReadRxStatus
                                   (0172) export _bRECEIVE_3_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RECEIVE_3_cGetChar
0C2F: 29 01    OR    A,1           (0179) export _RECEIVE_3_cGetChar
0C31: 60 3B    MOV   REG[59],A     (0180) export  RECEIVE_3_cReadChar
                                   (0181) export _RECEIVE_3_cReadChar
0C33: 7F       RET                 (0182) export  RECEIVE_3_iReadChar
                                   (0183) export _RECEIVE_3_iReadChar
                                   (0184) 
                                   (0185) IF (RECEIVE_3_RXBUF_ENABLE)
                                   (0186) export  RECEIVE_3_CmdReset
                                   (0187) export _RECEIVE_3_CmdReset
                                   (0188) export  RECEIVE_3_bCmdCheck
                                   (0189) export _RECEIVE_3_bCmdCheck
                                   (0190) export  RECEIVE_3_bCmdLength
                                   (0191) export _RECEIVE_3_bCmdLength
                                   (0192) export  RECEIVE_3_bErrCheck
                                   (0193) export _RECEIVE_3_bErrCheck
                                   (0194) 
                                   (0195) export  RECEIVE_3_szGetParam
                                   (0196) export _RECEIVE_3_szGetParam
                                   (0197) export  RECEIVE_3_szGetRestOfParams
                                   (0198) export _RECEIVE_3_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RECEIVE_3_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0C34: 41 3B FE AND   REG[59],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0C37: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RECEIVE_3_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RECEIVE_3_EnableInt:
                                   (0238) _RECEIVE_3_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0C38: 5D 3A    MOV   A,REG[58]     (0240)    M8C_EnableIntMask RECEIVE_3_INT_REG, RECEIVE_3_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0C3A: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RECEIVE_3_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RECEIVE_3_DisableInt:
                                   (0267) _RECEIVE_3_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RECEIVE_3_INT_REG, RECEIVE_3_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0C3B: 5D 3B    MOV   A,REG[59]     (0272) .ENDSECTION
                                   (0273) 
0C3D: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RECEIVE_3_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RECEIVE_3_Start:
                                   (0297) _RECEIVE_3_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RECEIVE_3_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RECEIVE_3_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0C3E: 49 3B 08 TST   REG[59],8     (0311) ;
0C41: AF FC    JZ    0x0C3E        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0C43: 5D 3A    MOV   A,REG[58]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0C45: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RECEIVE_3_Stop:
                                   (0326) _RECEIVE_3_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RECEIVE_3_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RECEIVE_3_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0C46: 5D 3B    MOV   A,REG[59]     (0346) ;    bRxData - returned in A.
0C48: 08       PUSH  A             (0347) ;
0C49: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0C4B: B0 04    JNZ   0x0C50        (0349) ;    The A and X registers may be modified by this or future implementations
0C4D: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0C4E: 80 0B    JMP   0x0C5A        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0C50: 5D 3A    MOV   A,REG[58]     (0354) ;
0C52: 4B       SWAP  A,X           (0355)  RECEIVE_3_bReadRxData:
                                   (0356) _RECEIVE_3_bReadRxData:
0C53: 18       POP   A             (0357)  bRECEIVE_3_ReadRxData:
0C54: 21 A0    AND   A,160         (0358) _bRECEIVE_3_ReadRxData:
0C56: B0 03    JNZ   0x0C5A        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0C58: 4B       SWAP  A,X           (0360)    mov A, REG[RECEIVE_3_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0C59: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0C5A: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RECEIVE_3_bReadRxStatus
                                   (0368) ;
0C5C: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RECEIVE_3_bReadRxStatus:
                                   (0388) _RECEIVE_3_bReadRxStatus:
                                   (0389)  bRECEIVE_3_ReadRxStatus:
                                   (0390) _bRECEIVE_3_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RECEIVE_3_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RECEIVE_3_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0C5D: 5D 3B    MOV   A,REG[59]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0C5F: 21 E8    AND   A,232         (0408) ;
0C61: 08       PUSH  A             (0409) ;  ARGUMENTS:
0C62: 21 08    AND   A,8           (0410) ;      none
0C64: B0 07    JNZ   0x0C6C        (0411) ;
0C66: 18       POP   A             (0412) ;  RETURNS:
0C67: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0C69: 4B       SWAP  A,X           (0414) ;
0C6A: 80 07    JMP   0x0C72        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0C6C: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0C6D: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0C6F: 4B       SWAP  A,X           (0420) ;    functions.
0C70: 5D 3A    MOV   A,REG[58]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0C72: 7F       RET                 (0426)  RECEIVE_3_cGetChar:
                                   (0427) _RECEIVE_3_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RECEIVE_3_CONTROL_REG],RECEIVE_3_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RECEIVE_3_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RECEIVE_3_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RECEIVE_3_cReadChar:
                                   (0463) _RECEIVE_3_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RECEIVE_3_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RECEIVE_3_RX_COMPLETE                            ; Check if a character is ready
0C73: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0C76: 55 6B 00 MOV   [107],0       (0470)    pop  A
0C79: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0C7C: 55 A7 00 MOV   [167],0       (0472) 
0C7F: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0C82: 55 03 00 MOV   [3],0         (0474)    mov  A,REG[RECEIVE_3_RX_BUFFER_REG]                     ; Read data first, then
0C85: 26 02 00 AND   [2],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0C88: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RECEIVE_3_RX_PARITY_ERROR | RECEIVE_3_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RECEIVE_3_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RECEIVE_3_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0C89: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0C8C: 51 02    MOV   A,[2]         (0511) ;        0x40CC    Overrun Error
0C8E: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0C90: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RECEIVE_3_iReadChar:
                                   (0523) _RECEIVE_3_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RECEIVE_3_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RECEIVE_3_RX_ERROR|RECEIVE_3_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RECEIVE_3_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RECEIVE_3_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RECEIVE_3_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RECEIVE_3_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RECEIVE_3_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RECEIVE_3_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RECEIVE_3_RXBUF_ENABLE)
                                   (0552) .SECTION
0C91: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0C94: 51 02    MOV   A,[2]         (0554) ;-----------------------------------------------------------------------------
0C96: 21 F0    AND   A,240         (0555) ;
0C98: 26 02 0F AND   [2],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0C9B: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RECEIVE_3_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RECEIVE_3_CmdReset:
0C9C: 62 D0 00 MOV   REG[208],0    (0587) _RECEIVE_3_CmdReset:
0C9F: 51 03    MOV   A,[3]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RECEIVE_3_aRxBuffer
0CA1: 7F       RET                 (0590)    mov [RECEIVE_3_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RECEIVE_3_bRxCnt
                                   (0594)    mov [RECEIVE_3_bRxCnt], 0x00
                                   (0595)    and [RECEIVE_3_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RECEIVE_3_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RECEIVE_3_bCmdCheck:
                                   (0628) _RECEIVE_3_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RECEIVE_3_fStatus
                                   (0631)    mov A,  [RECEIVE_3_fStatus]
                                   (0632)    and A, RECEIVE_3_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RECEIVE_3_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0CA2: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0CA4: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0CA7: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0CAA: 50 6B    MOV   A,107         (0648) ;     BYTE  fStatus - Status of command receive buffer.
0CAC: 02 A7    ADD   A,[167]       (0649) ;                     Returns non-zero value in A if command is valid.
0CAE: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0CAF: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0CB1: B0 04    JNZ   0x0CB6        (0653) ;           0x10 => Software Buffer OverRun
0CB3: 10       PUSH  X             (0654) ;
0CB4: 80 33    JMP   0x0CE8        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0CB6: 39 00    CMP   A,0           (0660) ;    functions.
0CB8: B0 11    JNZ   0x0CCA        (0661) ;          
0CBA: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0CBB: 76 A7    INC   [167]         (0663) ;          CUR_PP
0CBD: 52 00    MOV   A,[X+0]       (0664) ;
0CBF: 3C A7 0F CMP   [167],15      (0665) ;     Error Status is clear when read.
0CC2: BF F3    JNZ   0x0CB6        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0CC4: 10       PUSH  X             (0669) ;
                                   (0670)  RECEIVE_3_bErrCheck:
0CC5: 56 00 00 MOV   [X+0],0       (0671) _RECEIVE_3_bErrCheck:
0CC8: 80 1F    JMP   0x0CE8        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RECEIVE_3_fStatus
                                   (0674)    mov A,  [RECEIVE_3_fStatus]
0CCA: 10       PUSH  X             (0675)    and A, RECEIVE_3_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [RECEIVE_3_fStatus], ~RECEIVE_3_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0CCB: 75       INC   X             (0679) .ENDSECTION
0CCC: 76 A7    INC   [167]         (0680) 
0CCE: 3C A7 0F CMP   [167],15      (0681) .SECTION
0CD1: AF F3    JZ    0x0CC5        (0682) ;-----------------------------------------------------------------------------
0CD3: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RECEIVE_3_bCmdLength
0CD5: A0 12    JZ    0x0CE8        (0684) ;
0CD7: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0CD9: BF F1    JNZ   0x0CCB        (0686) ;     Get length of command string
                                   (0687) ;
0CDB: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0CDE: 76 A7    INC   [167]         (0689) ;     none.
0CE0: 3C A7 0F CMP   [167],15      (0690) ;
0CE3: B0 04    JNZ   0x0CE8        (0691) ;  RETURNS:
0CE5: 55 A7 0F MOV   [167],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0CE8: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0CE9: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0CEA: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0CED: B0 0B    JNZ   0x0CF9        (0699) ;    functions.
0CEF: 20       POP   X             (0700) ;          
0CF0: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0CF2: 50 00    MOV   A,0           (0702) ;          CUR_PP
0CF4: 70 3F    AND   F,63
0CF6: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RECEIVE_3_bCmdLength:
0CF8: 7F       RET                 (0705) _RECEIVE_3_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RECEIVE_3_bRxCnt
0CF9: 20       POP   X             (0708)    mov A,  [RECEIVE_3_bRxCnt]
0CFA: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0CFC: 70 3F    AND   F,63
0CFE: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0D00: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RECEIVE_3_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0D01: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0D04: 50 6B    MOV   A,107         (0744) ;     each lexically distinct element into a null-terminated string by replacing
0D06: 02 A7    ADD   A,[167]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0D08: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0D09: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RECEIVE_3_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RECEIVE_3_szGetParam, is
0D0C: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\receive_2int.asm
0D0D: 10       PUSH  X             (0104) ;;*****************************************************************************
0D0E: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RECEIVE_2INT.asm
0D10: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0D11: 58 05    MOV   X,[5]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0D13: 5D 2F    MOV   A,REG[47]     (0111) ;;-----------------------------------------------------------------------------
0D15: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0D16: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0D18: B0 04    JNZ   0x0D1D        (0115) 
0D1A: 18       POP   A             (0116) include "m8c.inc"
0D1B: 80 5E    JMP   0x0D7A        (0117) include "memory.inc"
                                   (0118) include "RECEIVE_2.inc"
                                   (0119) 
                                   (0120) 
0D1D: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0D1E: 21 E0    AND   A,224         (0124) export  _RECEIVE_2_ISR
0D20: A0 12    JZ    0x0D33        (0125) 
                                   (0126) 
0D22: 2C 04    OR    [4],A         (0127) IF (RECEIVE_2_RXBUF_ENABLE)
                                   (0128) export  RECEIVE_2_aRxBuffer
0D24: 49 2E 00 TST   REG[46],0     (0129) export _RECEIVE_2_aRxBuffer
                                   (0130) export  RECEIVE_2_bRxCnt
0D27: 21 20    AND   A,32          (0131) export _RECEIVE_2_bRxCnt
0D29: A0 50    JZ    0x0D7A        (0132) export  RECEIVE_2_fStatus
                                   (0133) export _RECEIVE_2_fStatus
                                   (0134) ENDIF
                                   (0135) 
0D2B: 41 2F FE AND   REG[47],254   (0136) 
0D2E: 43 2F 01 OR    REG[47],1     (0137) ;-----------------------------------------------
0D31: 80 48    JMP   0x0D7A        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RECEIVE_2_RXBUF_ENABLE)
0D33: 5D 2E    MOV   A,REG[46]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RECEIVE_2_fStatus:
                                   (0144) _RECEIVE_2_fStatus:      BLK  1
0D35: 47 04 01 TST   [4],1         (0145)  RECEIVE_2_bRxCnt:
0D38: B0 41    JNZ   0x0D7A        (0146) _RECEIVE_2_bRxCnt:       BLK  1
                                   (0147) AREA RECEIVE_2_RAM(RAM,REL,CON)
0D3A: 39 00    CMP   A,0           (0148)  RECEIVE_2_aRxBuffer:    
0D3C: B0 14    JNZ   0x0D51        (0149) _RECEIVE_2_aRxBuffer:    BLK RECEIVE_2_RX_BUFFER_SIZE
0D3E: 2E 04 01 OR    [4],1         (0150) ENDIF
                                   (0151) 
0D41: 62 D3 00 MOV   REG[211],0    (0152) 
0D44: 70 3F    AND   F,63
0D46: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0D48: 56 4B 00 MOV   [X+75],0      (0154) 
0D4B: 70 3F    AND   F,63
0D4D: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0D4F: 80 2A    JMP   0x0D7A        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0D51: 3C 05 0F CMP   [5],15        (0167) ;------------------------
0D54: C0 14    JC    0x0D69        (0168) 
0D56: 2E 04 10 OR    [4],16        (0169) 
                                   (0170) ;------------------------
0D59: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0D5C: 70 3F    AND   F,63
0D5E: 71 80    OR    F,128         (0172) ;------------------------
0D60: 56 4B 00 MOV   [X+75],0      (0173) 
0D63: 70 3F    AND   F,63
0D65: 71 00    OR    F,0           (0174) 
0D67: 80 12    JMP   0x0D7A        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0D69: 75       INC   X             (0179) 
0D6A: 5A 05    MOV   [5],X         (0180) 
0D6C: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0D6D: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0D70: 70 3F    AND   F,63
0D72: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RECEIVE_2_ISR
0D74: 54 4B    MOV   [X+75],A      (0185) ;
0D76: 70 3F    AND   F,63
0D78: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0D7A: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0D7B: 60 D3    MOV   REG[211],A    (0191) _RECEIVE_2_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0D7D: 20       POP   X             (0195)    ; Insert your custom code below this banner
0D7E: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0D80: 43 E1 08 OR    REG[225],8    (0201)    ; Insert your custom code above this banner

FILE: lib\receive_2.asm
                                   (0121) ;;*****************************************************************************
0D83: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RECEIVE_2.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RECEIVE_2.inc"
0D84: 41 E1 F7 AND   REG[225],247  (0149) 
                                   (0150) 
0D87: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RECEIVE_2_EnableInt
                                   (0155) export  _RECEIVE_2_EnableInt
                                   (0156) export   RECEIVE_2_DisableInt
                                   (0157) export  _RECEIVE_2_DisableInt
                                   (0158) export   RECEIVE_2_Start
                                   (0159) export  _RECEIVE_2_Start
                                   (0160) export   RECEIVE_2_Stop
                                   (0161) export  _RECEIVE_2_Stop
                                   (0162) export   RECEIVE_2_bReadRxData
                                   (0163) export  _RECEIVE_2_bReadRxData
                                   (0164) export   RECEIVE_2_bReadRxStatus
                                   (0165) export  _RECEIVE_2_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRECEIVE_2_ReadRxData
                                   (0170) export _bRECEIVE_2_ReadRxData
                                   (0171) export  bRECEIVE_2_ReadRxStatus
                                   (0172) export _bRECEIVE_2_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RECEIVE_2_cGetChar
0D88: 29 01    OR    A,1           (0179) export _RECEIVE_2_cGetChar
0D8A: 60 2F    MOV   REG[47],A     (0180) export  RECEIVE_2_cReadChar
                                   (0181) export _RECEIVE_2_cReadChar
0D8C: 7F       RET                 (0182) export  RECEIVE_2_iReadChar
                                   (0183) export _RECEIVE_2_iReadChar
                                   (0184) 
                                   (0185) IF (RECEIVE_2_RXBUF_ENABLE)
                                   (0186) export  RECEIVE_2_CmdReset
                                   (0187) export _RECEIVE_2_CmdReset
                                   (0188) export  RECEIVE_2_bCmdCheck
                                   (0189) export _RECEIVE_2_bCmdCheck
                                   (0190) export  RECEIVE_2_bCmdLength
                                   (0191) export _RECEIVE_2_bCmdLength
                                   (0192) export  RECEIVE_2_bErrCheck
                                   (0193) export _RECEIVE_2_bErrCheck
                                   (0194) 
                                   (0195) export  RECEIVE_2_szGetParam
                                   (0196) export _RECEIVE_2_szGetParam
                                   (0197) export  RECEIVE_2_szGetRestOfParams
                                   (0198) export _RECEIVE_2_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RECEIVE_2_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0D8D: 41 2F FE AND   REG[47],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0D90: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RECEIVE_2_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RECEIVE_2_EnableInt:
                                   (0238) _RECEIVE_2_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0D91: 5D 2E    MOV   A,REG[46]     (0240)    M8C_EnableIntMask RECEIVE_2_INT_REG, RECEIVE_2_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0D93: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RECEIVE_2_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RECEIVE_2_DisableInt:
                                   (0267) _RECEIVE_2_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RECEIVE_2_INT_REG, RECEIVE_2_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0D94: 5D 2F    MOV   A,REG[47]     (0272) .ENDSECTION
                                   (0273) 
0D96: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RECEIVE_2_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RECEIVE_2_Start:
                                   (0297) _RECEIVE_2_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RECEIVE_2_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RECEIVE_2_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0D97: 49 2F 08 TST   REG[47],8     (0311) ;
0D9A: AF FC    JZ    0x0D97        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0D9C: 5D 2E    MOV   A,REG[46]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0D9E: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RECEIVE_2_Stop:
                                   (0326) _RECEIVE_2_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RECEIVE_2_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RECEIVE_2_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0D9F: 5D 2F    MOV   A,REG[47]     (0346) ;    bRxData - returned in A.
0DA1: 08       PUSH  A             (0347) ;
0DA2: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0DA4: B0 04    JNZ   0x0DA9        (0349) ;    The A and X registers may be modified by this or future implementations
0DA6: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0DA7: 80 0B    JMP   0x0DB3        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0DA9: 5D 2E    MOV   A,REG[46]     (0354) ;
0DAB: 4B       SWAP  A,X           (0355)  RECEIVE_2_bReadRxData:
                                   (0356) _RECEIVE_2_bReadRxData:
0DAC: 18       POP   A             (0357)  bRECEIVE_2_ReadRxData:
0DAD: 21 A0    AND   A,160         (0358) _bRECEIVE_2_ReadRxData:
0DAF: B0 03    JNZ   0x0DB3        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0DB1: 4B       SWAP  A,X           (0360)    mov A, REG[RECEIVE_2_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0DB2: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0DB3: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RECEIVE_2_bReadRxStatus
                                   (0368) ;
0DB5: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RECEIVE_2_bReadRxStatus:
                                   (0388) _RECEIVE_2_bReadRxStatus:
                                   (0389)  bRECEIVE_2_ReadRxStatus:
                                   (0390) _bRECEIVE_2_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RECEIVE_2_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RECEIVE_2_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0DB6: 5D 2F    MOV   A,REG[47]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0DB8: 21 E8    AND   A,232         (0408) ;
0DBA: 08       PUSH  A             (0409) ;  ARGUMENTS:
0DBB: 21 08    AND   A,8           (0410) ;      none
0DBD: B0 07    JNZ   0x0DC5        (0411) ;
0DBF: 18       POP   A             (0412) ;  RETURNS:
0DC0: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0DC2: 4B       SWAP  A,X           (0414) ;
0DC3: 80 07    JMP   0x0DCB        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0DC5: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0DC6: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0DC8: 4B       SWAP  A,X           (0420) ;    functions.
0DC9: 5D 2E    MOV   A,REG[46]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0DCB: 7F       RET                 (0426)  RECEIVE_2_cGetChar:
                                   (0427) _RECEIVE_2_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RECEIVE_2_CONTROL_REG],RECEIVE_2_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RECEIVE_2_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RECEIVE_2_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RECEIVE_2_cReadChar:
                                   (0463) _RECEIVE_2_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RECEIVE_2_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RECEIVE_2_RX_COMPLETE                            ; Check if a character is ready
0DCC: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0DCF: 55 4B 00 MOV   [75],0        (0470)    pop  A
0DD2: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0DD5: 55 A6 00 MOV   [166],0       (0472) 
0DD8: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0DDB: 55 05 00 MOV   [5],0         (0474)    mov  A,REG[RECEIVE_2_RX_BUFFER_REG]                     ; Read data first, then
0DDE: 26 04 00 AND   [4],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0DE1: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RECEIVE_2_RX_PARITY_ERROR | RECEIVE_2_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RECEIVE_2_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RECEIVE_2_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0DE2: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0DE5: 51 04    MOV   A,[4]         (0511) ;        0x40CC    Overrun Error
0DE7: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0DE9: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RECEIVE_2_iReadChar:
                                   (0523) _RECEIVE_2_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RECEIVE_2_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RECEIVE_2_RX_ERROR|RECEIVE_2_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RECEIVE_2_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RECEIVE_2_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RECEIVE_2_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RECEIVE_2_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RECEIVE_2_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RECEIVE_2_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RECEIVE_2_RXBUF_ENABLE)
                                   (0552) .SECTION
0DEA: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0DED: 51 04    MOV   A,[4]         (0554) ;-----------------------------------------------------------------------------
0DEF: 21 F0    AND   A,240         (0555) ;
0DF1: 26 04 0F AND   [4],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0DF4: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RECEIVE_2_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RECEIVE_2_CmdReset:
0DF5: 62 D0 00 MOV   REG[208],0    (0587) _RECEIVE_2_CmdReset:
0DF8: 51 05    MOV   A,[5]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RECEIVE_2_aRxBuffer
0DFA: 7F       RET                 (0590)    mov [RECEIVE_2_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RECEIVE_2_bRxCnt
                                   (0594)    mov [RECEIVE_2_bRxCnt], 0x00
                                   (0595)    and [RECEIVE_2_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RECEIVE_2_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RECEIVE_2_bCmdCheck:
                                   (0628) _RECEIVE_2_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RECEIVE_2_fStatus
                                   (0631)    mov A,  [RECEIVE_2_fStatus]
                                   (0632)    and A, RECEIVE_2_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RECEIVE_2_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0DFB: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0DFD: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0E00: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0E03: 50 4B    MOV   A,75          (0648) ;     BYTE  fStatus - Status of command receive buffer.
0E05: 02 A6    ADD   A,[166]       (0649) ;                     Returns non-zero value in A if command is valid.
0E07: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0E08: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0E0A: B0 04    JNZ   0x0E0F        (0653) ;           0x10 => Software Buffer OverRun
0E0C: 10       PUSH  X             (0654) ;
0E0D: 80 33    JMP   0x0E41        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0E0F: 39 00    CMP   A,0           (0660) ;    functions.
0E11: B0 11    JNZ   0x0E23        (0661) ;          
0E13: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0E14: 76 A6    INC   [166]         (0663) ;          CUR_PP
0E16: 52 00    MOV   A,[X+0]       (0664) ;
0E18: 3C A6 0F CMP   [166],15      (0665) ;     Error Status is clear when read.
0E1B: BF F3    JNZ   0x0E0F        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0E1D: 10       PUSH  X             (0669) ;
                                   (0670)  RECEIVE_2_bErrCheck:
0E1E: 56 00 00 MOV   [X+0],0       (0671) _RECEIVE_2_bErrCheck:
0E21: 80 1F    JMP   0x0E41        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RECEIVE_2_fStatus
                                   (0674)    mov A,  [RECEIVE_2_fStatus]
0E23: 10       PUSH  X             (0675)    and A, RECEIVE_2_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [RECEIVE_2_fStatus], ~RECEIVE_2_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0E24: 75       INC   X             (0679) .ENDSECTION
0E25: 76 A6    INC   [166]         (0680) 
0E27: 3C A6 0F CMP   [166],15      (0681) .SECTION
0E2A: AF F3    JZ    0x0E1E        (0682) ;-----------------------------------------------------------------------------
0E2C: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RECEIVE_2_bCmdLength
0E2E: A0 12    JZ    0x0E41        (0684) ;
0E30: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0E32: BF F1    JNZ   0x0E24        (0686) ;     Get length of command string
                                   (0687) ;
0E34: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0E37: 76 A6    INC   [166]         (0689) ;     none.
0E39: 3C A6 0F CMP   [166],15      (0690) ;
0E3C: B0 04    JNZ   0x0E41        (0691) ;  RETURNS:
0E3E: 55 A6 0F MOV   [166],15      (0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0E41: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0E42: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0E43: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0E46: B0 0B    JNZ   0x0E52        (0699) ;    functions.
0E48: 20       POP   X             (0700) ;          
0E49: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0E4B: 50 00    MOV   A,0           (0702) ;          CUR_PP
0E4D: 70 3F    AND   F,63
0E4F: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RECEIVE_2_bCmdLength:
0E51: 7F       RET                 (0705) _RECEIVE_2_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RECEIVE_2_bRxCnt
0E52: 20       POP   X             (0708)    mov A,  [RECEIVE_2_bRxCnt]
0E53: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0E55: 70 3F    AND   F,63
0E57: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0E59: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RECEIVE_2_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0E5A: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0E5D: 50 4B    MOV   A,75          (0744) ;     each lexically distinct element into a null-terminated string by replacing
0E5F: 02 A6    ADD   A,[166]       (0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0E61: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0E62: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RECEIVE_2_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RECEIVE_2_szGetParam, is
0E65: 08       PUSH  A             (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\receive_1int.asm
0E66: 10       PUSH  X             (0104) ;;*****************************************************************************
0E67: 5D D3    MOV   A,REG[211]
                                   (0105) ;;*****************************************************************************
                                   (0106) ;;  FILENAME: RECEIVE_1INT.asm
0E69: 08       PUSH  A             (0107) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0108) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0109) ;;
0E6A: 58 07    MOV   X,[7]         (0110) ;;  DESCRIPTION: RX8 Interrupt Service Routine.
0E6C: 5D 2B    MOV   A,REG[43]     (0111) ;;-----------------------------------------------------------------------------
0E6E: 08       PUSH  A             (0112) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0113) ;;*****************************************************************************
0E6F: 21 08    AND   A,8           (0114) ;;*****************************************************************************
0E71: B0 04    JNZ   0x0E76        (0115) 
0E73: 18       POP   A             (0116) include "m8c.inc"
0E74: 80 5E    JMP   0x0ED3        (0117) include "memory.inc"
                                   (0118) include "RECEIVE_1.inc"
                                   (0119) 
                                   (0120) 
0E76: 18       POP   A             (0121) ;-----------------------------------------------
                                   (0122) ;  Global Symbols
                                   (0123) ;-----------------------------------------------
0E77: 21 E0    AND   A,224         (0124) export  _RECEIVE_1_ISR
0E79: A0 12    JZ    0x0E8C        (0125) 
                                   (0126) 
0E7B: 2C 06    OR    [6],A         (0127) IF (RECEIVE_1_RXBUF_ENABLE)
                                   (0128) export  RECEIVE_1_aRxBuffer
0E7D: 49 2A 00 TST   REG[42],0     (0129) export _RECEIVE_1_aRxBuffer
                                   (0130) export  RECEIVE_1_bRxCnt
0E80: 21 20    AND   A,32          (0131) export _RECEIVE_1_bRxCnt
0E82: A0 50    JZ    0x0ED3        (0132) export  RECEIVE_1_fStatus
                                   (0133) export _RECEIVE_1_fStatus
                                   (0134) ENDIF
                                   (0135) 
0E84: 41 2B FE AND   REG[43],254   (0136) 
0E87: 43 2B 01 OR    REG[43],1     (0137) ;-----------------------------------------------
0E8A: 80 48    JMP   0x0ED3        (0138) ; Variable Allocation
                                   (0139) ;-----------------------------------------------
                                   (0140) 
                                   (0141) IF (RECEIVE_1_RXBUF_ENABLE)
0E8C: 5D 2A    MOV   A,REG[42]     (0142) AREA InterruptRAM(RAM,REL,CON)
                                   (0143)  RECEIVE_1_fStatus:
                                   (0144) _RECEIVE_1_fStatus:      BLK  1
0E8E: 47 06 01 TST   [6],1         (0145)  RECEIVE_1_bRxCnt:
0E91: B0 41    JNZ   0x0ED3        (0146) _RECEIVE_1_bRxCnt:       BLK  1
                                   (0147) AREA RECEIVE_1_RAM(RAM,REL,CON)
0E93: 39 00    CMP   A,0           (0148)  RECEIVE_1_aRxBuffer:    
0E95: B0 14    JNZ   0x0EAA        (0149) _RECEIVE_1_aRxBuffer:    BLK RECEIVE_1_RX_BUFFER_SIZE
0E97: 2E 06 01 OR    [6],1         (0150) ENDIF
                                   (0151) 
0E9A: 62 D3 00 MOV   REG[211],0    (0152) 
0E9D: 70 3F    AND   F,63
0E9F: 71 80    OR    F,128         (0153) AREA InterruptRAM(RAM,REL,CON)
0EA1: 56 5B 00 MOV   [X+91],0      (0154) 
0EA4: 70 3F    AND   F,63
0EA6: 71 00    OR    F,0           (0155) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0EA8: 80 2A    JMP   0x0ED3        (0156) ;---------------------------------------------------
                                   (0157) ; Insert your custom declarations below this banner
                                   (0158) ;---------------------------------------------------
                                   (0159) 
                                   (0160) ;------------------------
                                   (0161) ; Includes
                                   (0162) ;------------------------
                                   (0163) 
                                   (0164) 	
                                   (0165) ;------------------------
                                   (0166) ;  Constant Definitions
0EAA: 3C 07 0F CMP   [7],15        (0167) ;------------------------
0EAD: C0 14    JC    0x0EC2        (0168) 
0EAF: 2E 06 10 OR    [6],16        (0169) 
                                   (0170) ;------------------------
0EB2: 62 D3 00 MOV   REG[211],0    (0171) ; Variable Allocation
0EB5: 70 3F    AND   F,63
0EB7: 71 80    OR    F,128         (0172) ;------------------------
0EB9: 56 5B 00 MOV   [X+91],0      (0173) 
0EBC: 70 3F    AND   F,63
0EBE: 71 00    OR    F,0           (0174) 
0EC0: 80 12    JMP   0x0ED3        (0175) ;---------------------------------------------------
                                   (0176) ; Insert your custom declarations above this banner
                                   (0177) ;---------------------------------------------------
                                   (0178) ;@PSoC_UserCode_END@ (Do not change this line.)
0EC2: 75       INC   X             (0179) 
0EC3: 5A 07    MOV   [7],X         (0180) 
0EC5: 79       DEC   X             (0181) AREA UserModules (ROM, REL)
                                   (0182) 
0EC6: 62 D3 00 MOV   REG[211],0    (0183) ;-----------------------------------------------------------------------------
0EC9: 70 3F    AND   F,63
0ECB: 71 80    OR    F,128         (0184) ;  FUNCTION NAME: _RECEIVE_1_ISR
0ECD: 54 5B    MOV   [X+91],A      (0185) ;
0ECF: 70 3F    AND   F,63
0ED1: 71 00    OR    F,0           (0186) ;  DESCRIPTION: Unless modified, this implements only a null handler stub.
0ED3: 18       POP   A
                                   (0187) ;
                                   (0188) ;-----------------------------------------------------------------------------
                                   (0189) ;
                                   (0190) 
0ED4: 60 D3    MOV   REG[211],A    (0191) _RECEIVE_1_ISR:
                                   (0192) 
                                   (0193)    ;@PSoC_UserCode_BODY@ (Do not change this line.)
                                   (0194)    ;---------------------------------------------------
0ED6: 20       POP   X             (0195)    ; Insert your custom code below this banner
0ED7: 18       POP   A             (0196)    ;---------------------------------------------------
                                   (0197)    ;   NOTE: interrupt service routines must preserve
                                   (0198)    ;   the values of the A and X CPU registers.
                                   (0199) 
                                   (0200)    ;---------------------------------------------------
0ED9: 43 E1 04 OR    REG[225],4    (0201)    ; Insert your custom code above this banner

FILE: lib\receive_1.asm
                                   (0121) ;;*****************************************************************************
0EDC: 7F       RET                 (0122) ;;*****************************************************************************
                                   (0123) ;;  FILENAME: RECEIVE_1.asm
                                   (0124) ;;   Version: 3.3, Updated on 2009/7/10 at 10:46:15
                                   (0125) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0126) ;;
                                   (0127) ;;  DESCRIPTION: RX8 User Module software implementation file
                                   (0128) ;;               for 22/24/25/26/27xxx PSoC family of devices.
                                   (0129) ;;
                                   (0130) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0131) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0132) ;;        This means it is the caller's responsibility to preserve any values
                                   (0133) ;;        in the X and A registers that are still needed after the API functions
                                   (0134) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0135) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0136) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0137) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0138) ;;-----------------------------------------------------------------------------
                                   (0139) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0140) ;;*****************************************************************************
                                   (0141) ;;*****************************************************************************
                                   (0142) 
                                   (0143) ;-----------------------------------------------
                                   (0144) ; include instance specific register definitions
                                   (0145) ;-----------------------------------------------
                                   (0146) include "m8c.inc"
                                   (0147) include "memory.inc"
                                   (0148) include "RECEIVE_1.inc"
0EDD: 41 E1 FB AND   REG[225],251  (0149) 
                                   (0150) 
0EE0: 7F       RET                 (0151) ;-----------------------------------------------
                                   (0152) ;  Global Symbols
                                   (0153) ;-----------------------------------------------
                                   (0154) export   RECEIVE_1_EnableInt
                                   (0155) export  _RECEIVE_1_EnableInt
                                   (0156) export   RECEIVE_1_DisableInt
                                   (0157) export  _RECEIVE_1_DisableInt
                                   (0158) export   RECEIVE_1_Start
                                   (0159) export  _RECEIVE_1_Start
                                   (0160) export   RECEIVE_1_Stop
                                   (0161) export  _RECEIVE_1_Stop
                                   (0162) export   RECEIVE_1_bReadRxData
                                   (0163) export  _RECEIVE_1_bReadRxData
                                   (0164) export   RECEIVE_1_bReadRxStatus
                                   (0165) export  _RECEIVE_1_bReadRxStatus
                                   (0166) 
                                   (0167) ; Old function name convension, do not use.
                                   (0168) ; These will be removed in a future release.
                                   (0169) export  bRECEIVE_1_ReadRxData
                                   (0170) export _bRECEIVE_1_ReadRxData
                                   (0171) export  bRECEIVE_1_ReadRxStatus
                                   (0172) export _bRECEIVE_1_ReadRxStatus
                                   (0173) 
                                   (0174) ;-----------------------------------------------
                                   (0175) ; High Level RX functions
                                   (0176) ;-----------------------------------------------
                                   (0177) 
                                   (0178) export  RECEIVE_1_cGetChar
0EE1: 29 01    OR    A,1           (0179) export _RECEIVE_1_cGetChar
0EE3: 60 2B    MOV   REG[43],A     (0180) export  RECEIVE_1_cReadChar
                                   (0181) export _RECEIVE_1_cReadChar
0EE5: 7F       RET                 (0182) export  RECEIVE_1_iReadChar
                                   (0183) export _RECEIVE_1_iReadChar
                                   (0184) 
                                   (0185) IF (RECEIVE_1_RXBUF_ENABLE)
                                   (0186) export  RECEIVE_1_CmdReset
                                   (0187) export _RECEIVE_1_CmdReset
                                   (0188) export  RECEIVE_1_bCmdCheck
                                   (0189) export _RECEIVE_1_bCmdCheck
                                   (0190) export  RECEIVE_1_bCmdLength
                                   (0191) export _RECEIVE_1_bCmdLength
                                   (0192) export  RECEIVE_1_bErrCheck
                                   (0193) export _RECEIVE_1_bErrCheck
                                   (0194) 
                                   (0195) export  RECEIVE_1_szGetParam
                                   (0196) export _RECEIVE_1_szGetParam
                                   (0197) export  RECEIVE_1_szGetRestOfParams
                                   (0198) export _RECEIVE_1_szGetRestOfParams
                                   (0199) 
                                   (0200) ;-----------------------------------------------
                                   (0201) ;  Variables
                                   (0202) ;-----------------------------------------------
                                   (0203) 
                                   (0204) AREA RECEIVE_1_RAM(RAM,REL,CON)
                                   (0205)  ptrParam:   			BLK  1
                                   (0206) 
                                   (0207) ENDIF
0EE6: 41 2B FE AND   REG[43],254   (0208) ;-----------------------------------------------
                                   (0209) ;  EQUATES
0EE9: 7F       RET                 (0210) ;-----------------------------------------------
                                   (0211) bfCONTROL_REG_START_BIT:   equ   1     ; Control register start bit
                                   (0212) 
                                   (0213) area UserModules (ROM, REL)
                                   (0214) 
                                   (0215) .SECTION
                                   (0216) ;-----------------------------------------------------------------------------
                                   (0217) ;  FUNCTION NAME: RECEIVE_1_EnableInt
                                   (0218) ;
                                   (0219) ;  DESCRIPTION:
                                   (0220) ;     Enables this receiver's interrupt by setting the interrupt enable mask
                                   (0221) ;     bit associated with this User Module. Remember to call the global interrupt
                                   (0222) ;     enable function by using the macro: M8C_EnableGInt.
                                   (0223) ;
                                   (0224) ;-----------------------------------------------------------------------------
                                   (0225) ;
                                   (0226) ;  ARGUMENTS: none
                                   (0227) ;
                                   (0228) ;  RETURNS: none
                                   (0229) ;
                                   (0230) ;  SIDE EFFECTS:
                                   (0231) ;    The A and X registers may be modified by this or future implementations
                                   (0232) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0233) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0234) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0235) ;    functions.
                                   (0236) ;
                                   (0237)  RECEIVE_1_EnableInt:
                                   (0238) _RECEIVE_1_EnableInt:
                                   (0239)    RAM_PROLOGUE RAM_USE_CLASS_1
0EEA: 5D 2A    MOV   A,REG[42]     (0240)    M8C_EnableIntMask RECEIVE_1_INT_REG, RECEIVE_1_bINT_MASK
                                   (0241)    RAM_EPILOGUE RAM_USE_CLASS_1
0EEC: 7F       RET                 (0242)    ret
                                   (0243) .ENDSECTION
                                   (0244) 
                                   (0245) .SECTION
                                   (0246) ;-----------------------------------------------------------------------------
                                   (0247) ;  FUNCTION NAME: RECEIVE_1_DisableInt
                                   (0248) ;
                                   (0249) ;  DESCRIPTION:
                                   (0250) ;     Disables this RX8's interrupt by clearing the interrupt enable mask bit
                                   (0251) ;     associated with this User Module.
                                   (0252) ;
                                   (0253) ;-----------------------------------------------------------------------------
                                   (0254) ;
                                   (0255) ;  ARGUMENTS:  none
                                   (0256) ;
                                   (0257) ;  RETURNS:  none
                                   (0258) ;
                                   (0259) ;  SIDE EFFECTS:
                                   (0260) ;    The A and X registers may be modified by this or future implementations
                                   (0261) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0262) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0263) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0264) ;    functions.
                                   (0265) ;
                                   (0266)  RECEIVE_1_DisableInt:
                                   (0267) _RECEIVE_1_DisableInt:
                                   (0268)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0269)    M8C_DisableIntMask RECEIVE_1_INT_REG, RECEIVE_1_bINT_MASK
                                   (0270)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0271)    ret
0EED: 5D 2B    MOV   A,REG[43]     (0272) .ENDSECTION
                                   (0273) 
0EEF: 7F       RET                 (0274) .SECTION
                                   (0275) ;-----------------------------------------------------------------------------
                                   (0276) ;  FUNCTION NAME: RECEIVE_1_Start(BYTE bParity)
                                   (0277) ;
                                   (0278) ;  DESCRIPTION:
                                   (0279) ;    Sets the start bit and parity in the Control register of this user module.
                                   (0280) ;
                                   (0281) ;-----------------------------------------------------------------------------
                                   (0282) ;
                                   (0283) ;  ARGUMENTS:
                                   (0284) ;    BYTE bParity - parity of received data.  Use defined masks.
                                   (0285) ;    passed in A register.
                                   (0286) ;
                                   (0287) ;  RETURNS: none
                                   (0288) ;
                                   (0289) ;  SIDE EFFECTS:
                                   (0290) ;    The A and X registers may be modified by this or future implementations
                                   (0291) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0292) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0293) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0294) ;    functions.
                                   (0295) ;
                                   (0296)  RECEIVE_1_Start:
                                   (0297) _RECEIVE_1_Start:
                                   (0298)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0299)    or    A, bfCONTROL_REG_START_BIT
                                   (0300)    mov   REG[RECEIVE_1_CONTROL_REG], A
                                   (0301)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0302)    ret
                                   (0303) .ENDSECTION
                                   (0304) 
                                   (0305) .SECTION
                                   (0306) ;-----------------------------------------------------------------------------
                                   (0307) ;  FUNCTION NAME: RECEIVE_1_Stop
                                   (0308) ;
                                   (0309) ;  DESCRIPTION:
                                   (0310) ;     Disables RX8 operation.
0EF0: 49 2B 08 TST   REG[43],8     (0311) ;
0EF3: AF FC    JZ    0x0EF0        (0312) ;-----------------------------------------------------------------------------
                                   (0313) ;
0EF5: 5D 2A    MOV   A,REG[42]     (0314) ;  ARGUMENTS: none
                                   (0315) ;
0EF7: 7F       RET                 (0316) ;  RETURNS: none
                                   (0317) ;
                                   (0318) ;  SIDE EFFECTS:
                                   (0319) ;    The A and X registers may be modified by this or future implementations
                                   (0320) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0321) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0322) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0323) ;    functions.
                                   (0324) ;
                                   (0325)  RECEIVE_1_Stop:
                                   (0326) _RECEIVE_1_Stop:
                                   (0327)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0328)    and   REG[RECEIVE_1_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0329)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0330)    ret
                                   (0331) .ENDSECTION
                                   (0332) 
                                   (0333) .SECTION
                                   (0334) ;-----------------------------------------------------------------------------
                                   (0335) ;  FUNCTION NAME: RECEIVE_1_bReadRxData
                                   (0336) ;
                                   (0337) ;  DESCRIPTION:
                                   (0338) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0339) ;     sure data is valid.
                                   (0340) ;
                                   (0341) ;-----------------------------------------------------------------------------
                                   (0342) ;
                                   (0343) ;  ARGUMENTS:  none
                                   (0344) ;
                                   (0345) ;  RETURNS:
0EF8: 5D 2B    MOV   A,REG[43]     (0346) ;    bRxData - returned in A.
0EFA: 08       PUSH  A             (0347) ;
0EFB: 21 08    AND   A,8           (0348) ;  SIDE EFFECTS:
0EFD: B0 04    JNZ   0x0F02        (0349) ;    The A and X registers may be modified by this or future implementations
0EFF: 18       POP   A             (0350) ;    of this function.  The same is true for all RAM page pointer registers in
0F00: 80 0B    JMP   0x0F0C        (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
0F02: 5D 2A    MOV   A,REG[42]     (0354) ;
0F04: 4B       SWAP  A,X           (0355)  RECEIVE_1_bReadRxData:
                                   (0356) _RECEIVE_1_bReadRxData:
0F05: 18       POP   A             (0357)  bRECEIVE_1_ReadRxData:
0F06: 21 A0    AND   A,160         (0358) _bRECEIVE_1_ReadRxData:
0F08: B0 03    JNZ   0x0F0C        (0359)    RAM_PROLOGUE RAM_USE_CLASS_1
0F0A: 4B       SWAP  A,X           (0360)    mov A, REG[RECEIVE_1_RX_BUFFER_REG]
                                   (0361)    RAM_EPILOGUE RAM_USE_CLASS_1
0F0B: 7F       RET                 (0362)    ret
                                   (0363) .ENDSECTION
                                   (0364) 
0F0C: 50 00    MOV   A,0           (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: RECEIVE_1_bReadRxStatus
                                   (0368) ;
0F0E: 7F       RET                 (0369) ;  DESCRIPTION:
                                   (0370) ;    Reads the RX Status bits in the Control/Status register.
                                   (0371) ;
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:  none
                                   (0375) ;
                                   (0376) ;  RETURNS:
                                   (0377) ;     BYTE  bRXStatus - transmit status data.  Use the following defined bits
                                   (0378) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  RECEIVE_1_bReadRxStatus:
                                   (0388) _RECEIVE_1_bReadRxStatus:
                                   (0389)  bRECEIVE_1_ReadRxStatus:
                                   (0390) _bRECEIVE_1_ReadRxStatus:
                                   (0391)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0392)    mov A,  REG[RECEIVE_1_CONTROL_REG]
                                   (0393)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0394)    ret
                                   (0395) .ENDSECTION
                                   (0396) 
                                   (0397) ;-----------------------------------------------
                                   (0398) ; High Level RX functions
                                   (0399) ;-----------------------------------------------
                                   (0400) 
                                   (0401) .SECTION
                                   (0402) ;-----------------------------------------------------------------------------
                                   (0403) ;  FUNCTION NAME: RECEIVE_1_cGetChar
                                   (0404) ;
                                   (0405) ;  DESCRIPTION:
0F0F: 5D 2B    MOV   A,REG[43]     (0406) ;     Read character from UART RX port.
                                   (0407) ;
0F11: 21 E8    AND   A,232         (0408) ;
0F13: 08       PUSH  A             (0409) ;  ARGUMENTS:
0F14: 21 08    AND   A,8           (0410) ;      none
0F16: B0 07    JNZ   0x0F1E        (0411) ;
0F18: 18       POP   A             (0412) ;  RETURNS:
0F19: 29 01    OR    A,1           (0413) ;     char that is returned from UART
0F1B: 4B       SWAP  A,X           (0414) ;
0F1C: 80 07    JMP   0x0F24        (0415) ;  SIDE EFFECTS:
                                   (0416) ;    The A and X registers may be modified by this or future implementations
                                   (0417) ;    of this function.  The same is true for all RAM page pointer registers in
0F1E: 18       POP   A             (0418) ;    the Large Memory Model.  When necessary, it is the calling function's
0F1F: 21 E0    AND   A,224         (0419) ;    responsibility to perserve their values across calls to fastcall16 
0F21: 4B       SWAP  A,X           (0420) ;    functions.
0F22: 5D 2A    MOV   A,REG[42]     (0421) ;    
                                   (0422) ;    Program flow will stay in this function until a character is received.
                                   (0423) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0424) ;    the delay between characters is less than the watchdog timeout.
                                   (0425) ;
0F24: 7F       RET                 (0426)  RECEIVE_1_cGetChar:
                                   (0427) _RECEIVE_1_cGetChar:
                                   (0428)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0429) 
                                   (0430) .getChar_Loop:
                                   (0431)    tst REG[RECEIVE_1_CONTROL_REG],RECEIVE_1_RX_REG_FULL   ; Check if a character is ready
                                   (0432)    jz  .getChar_Loop                                        ; If not loop
                                   (0433) 
                                   (0434)    mov A, REG[RECEIVE_1_RX_BUFFER_REG]           ; Get character
                                   (0435)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0436)    ret
                                   (0437) .ENDSECTION
                                   (0438) 
                                   (0439) .SECTION
                                   (0440) ;-----------------------------------------------------------------------------
                                   (0441) ;  FUNCTION NAME: RECEIVE_1_cReadChar
                                   (0442) ;
                                   (0443) ;  DESCRIPTION:
                                   (0444) ;     Read character from UART RX port.
                                   (0445) ;
                                   (0446) ;  ARGUMENTS:
                                   (0447) ;      none
                                   (0448) ;
                                   (0449) ;  RETURNS:
                                   (0450) ;     char that is returned from UART
                                   (0451) ;
                                   (0452) ;  SIDE EFFECTS:
                                   (0453) ;    The A and X registers may be modified by this or future implementations
                                   (0454) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0455) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0456) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0457) ;    functions.
                                   (0458) ;
                                   (0459) ;    A valid 0x00 character will be ignored, since a 0x00 return value
                                   (0460) ;    implies a valid character or an error condition occured.
                                   (0461) ;
                                   (0462)  RECEIVE_1_cReadChar:
                                   (0463) _RECEIVE_1_cReadChar:
                                   (0464)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0465) 
                                   (0466)    mov  A,REG[RECEIVE_1_CONTROL_REG]                       ; Get Status of RX
                                   (0467)    push A
                                   (0468)    and  A,RECEIVE_1_RX_COMPLETE                            ; Check if a character is ready
0F25: 62 D0 00 MOV   REG[208],0    (0469)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
0F28: 55 5B 00 MOV   [91],0        (0470)    pop  A
0F2B: 62 D0 00 MOV   REG[208],0    (0471)    jmp  .RX_NO_VALID_CHAR
0F2E: 55 A5 00 MOV   [NUM_MODULES+3],0(0472) 
0F31: 62 D0 00 MOV   REG[208],0    (0473) .RX_DATA_RDY:
0F34: 55 07 00 MOV   [7],0         (0474)    mov  A,REG[RECEIVE_1_RX_BUFFER_REG]                     ; Read data first, then
0F37: 26 06 00 AND   [6],0         (0475)    swap A,X                                                ; determine if data is valid
                                   (0476) 
0F3A: 7F       RET                 (0477)    pop  A                                                  ; Check for errors
                                   (0478)    and  A,(RECEIVE_1_RX_PARITY_ERROR | RECEIVE_1_RX_FRAMING_ERROR)
                                   (0479)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0480)    swap A,X                                                ; Put data in A and exit
                                   (0481)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0482)    ret
                                   (0483) 
                                   (0484) .RX_NO_VALID_CHAR:
                                   (0485)    mov A,0x00                                              ; Zero out character
                                   (0486) 
                                   (0487)  End_RECEIVE_1_cReadChar:
                                   (0488)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0489)    ret
                                   (0490) .ENDSECTION
                                   (0491) 																			
                                   (0492) .SECTION
                                   (0493) ;-----------------------------------------------------------------------------
                                   (0494) ;  FUNCTION NAME: RECEIVE_1_iReadChar
                                   (0495) ;
                                   (0496) ; WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0497) ; to just set a value in the upper byte if error conditions exists.
                                   (0498) ;
                                   (0499) ;  DESCRIPTION:
                                   (0500) ;     Read character from UART RX port.
                                   (0501) ;
                                   (0502) ;  ARGUMENTS:
                                   (0503) ;      none
                                   (0504) ;
                                   (0505) ;  RETURNS:
                                   (0506) ;     An integer value is returned.  A negative value inplies and error
                                   (0507) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0508) ;
                                   (0509) ;     Error Codes:
0F3B: 62 D0 00 MOV   REG[208],0    (0510) ;        0x80CC    Parity Error
0F3E: 51 06    MOV   A,[6]         (0511) ;        0x40CC    Overrun Error
0F40: 21 01    AND   A,1           (0512) ;        0x20CC    Framing Error
                                   (0513) ;        0x01CC    No Data available
0F42: 7F       RET                 (0514) ;
                                   (0515) ;  SIDE EFFECTS:
                                   (0516) ;    The A and X registers may be modified by this or future implementations
                                   (0517) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0518) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0519) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0520) ;    functions.
                                   (0521) ;
                                   (0522)  RECEIVE_1_iReadChar:
                                   (0523) _RECEIVE_1_iReadChar:
                                   (0524)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0525) 
                                   (0526)    mov  A,REG[RECEIVE_1_CONTROL_REG]                       ; Get Status of RX
                                   (0527)                                                            ; Mask only errors and data ready
                                   (0528)    and  A,(RECEIVE_1_RX_ERROR|RECEIVE_1_RX_REG_FULL)
                                   (0529)    push A
                                   (0530)    and  A,RECEIVE_1_RX_COMPLETE                            ; Check if a character is ready
                                   (0531)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (0532)    pop  A
                                   (0533)    or   A,RECEIVE_1_RX_NO_DATA                             ; Add no data flag
                                   (0534)    swap A,X
                                   (0535)    jmp  End_RECEIVE_1_iReadChar
                                   (0536) 
                                   (0537) .RX_GET_DATA:
                                   (0538)    pop  A
                                   (0539)    and  A,RECEIVE_1_RX_ERROR
                                   (0540)    swap A,X
                                   (0541)    mov  A,REG[RECEIVE_1_RX_BUFFER_REG]                     ; Read data first, then
                                   (0542)                                                            ; determine if data is valid
                                   (0543) 
                                   (0544)  End_RECEIVE_1_iReadChar:
                                   (0545)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0546)    ret
                                   (0547) .ENDSECTION
                                   (0548) 
                                   (0549) 
                                   (0550) 
                                   (0551) IF (RECEIVE_1_RXBUF_ENABLE)
                                   (0552) .SECTION
0F43: 62 D0 00 MOV   REG[208],0    (0553) ;-----------------------------------------------------------------------------
0F46: 51 06    MOV   A,[6]         (0554) ;-----------------------------------------------------------------------------
0F48: 21 F0    AND   A,240         (0555) ;
0F4A: 26 06 0F AND   [6],15        (0556) ;     Command Buffer commands
                                   (0557) ;
0F4D: 7F       RET                 (0558) ;-----------------------------------------------------------------------------
                                   (0559) ;-----------------------------------------------------------------------------
                                   (0560) 
                                   (0561) ;-----------------------------------------------------------------------------
                                   (0562) ;  FUNCTION NAME: RECEIVE_1_CmdReset
                                   (0563) ;
                                   (0564) ;  DESCRIPTION:
                                   (0565) ;     Reset command string and status flags
                                   (0566) ;
                                   (0567) ;  ARGUMENTS:
                                   (0568) ;     none.
                                   (0569) ;
                                   (0570) ;  RETURNS:
                                   (0571) ;     none.
                                   (0572) ;
                                   (0573) ;  SIDE EFFECTS:
                                   (0574) ;    The A and X registers may be modified by this or future implementations
                                   (0575) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0576) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0577) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0578) ;    functions.
                                   (0579) ;          
                                   (0580) ;    Currently only the page pointer registers listed below are modified: 
                                   (0581) ;          CUR_PP
                                   (0582) ;
                                   (0583) ;  THEORY of OPERATION or PROCEDURE:
                                   (0584) ;     Clear the command buffer, command counter, and flag.
                                   (0585) ;
                                   (0586)  RECEIVE_1_CmdReset:
0F4E: 62 D0 00 MOV   REG[208],0    (0587) _RECEIVE_1_CmdReset:
0F51: 51 07    MOV   A,[7]         (0588)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0589)    RAM_SETPAGE_CUR >RECEIVE_1_aRxBuffer
0F53: 7F       RET                 (0590)    mov [RECEIVE_1_aRxBuffer], 0x00
                                   (0591)    RAM_SETPAGE_CUR >ptrParam
                                   (0592)    mov [ptrParam],0x00
                                   (0593)    RAM_SETPAGE_CUR >RECEIVE_1_bRxCnt
                                   (0594)    mov [RECEIVE_1_bRxCnt], 0x00
                                   (0595)    and [RECEIVE_1_fStatus], 0x00
                                   (0596)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0597)    ret
                                   (0598) .ENDSECTION
                                   (0599) 
                                   (0600) .SECTION
                                   (0601) ;-----------------------------------------------------------------------------
                                   (0602) ;  FUNCTION NAME: RECEIVE_1_bCmdCheck
                                   (0603) ;
                                   (0604) ;  DESCRIPTION:
                                   (0605) ;     Check to see if valid command in buffer.
                                   (0606) ;
                                   (0607) ;  ARGUMENTS:
                                   (0608) ;     none.
                                   (0609) ;
                                   (0610) ;  RETURNS:
                                   (0611) ;     BYTE  fStatus - Status of command receive buffer.
                                   (0612) ;                     Returns non-zero value in A if command is valid.
                                   (0613) ;
                                   (0614) ;  SIDE EFFECTS:
                                   (0615) ;    The A and X registers may be modified by this or future implementations
                                   (0616) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0617) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0618) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0619) ;    functions.
                                   (0620) ;          
                                   (0621) ;    Currently only the page pointer registers listed below are modified: 
                                   (0622) ;          CUR_PP
                                   (0623) ;
                                   (0624) ;  THEORY of OPERATION or PROCEDURE:
                                   (0625) ;     Read the status and control register.
                                   (0626) ;
                                   (0627)  RECEIVE_1_bCmdCheck:
                                   (0628) _RECEIVE_1_bCmdCheck:
                                   (0629)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0630)    RAM_SETPAGE_CUR >RECEIVE_1_fStatus
                                   (0631)    mov A,  [RECEIVE_1_fStatus]
                                   (0632)    and A, RECEIVE_1_RX_BUF_CMDTERM               ; Mask off Command status
                                   (0633)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0634)    ret
                                   (0635) .ENDSECTION
                                   (0636) 
                                   (0637) .SECTION
                                   (0638) ;-----------------------------------------------------------------------------
                                   (0639) ;  FUNCTION NAME: RECEIVE_1_bErrCheck
                                   (0640) ;
                                   (0641) ;  DESCRIPTION:
                                   (0642) ;     Check to see if an error has occured since last CmdReset
                                   (0643) ;
0F54: 70 BF    AND   F,191         (0644) ;  ARGUMENTS:
0F56: 62 D0 00 MOV   REG[208],0    (0645) ;     none.
0F59: 62 D3 00 MOV   REG[211],0    (0646) ;
                                   (0647) ;  RETURNS:
0F5C: 50 5B    MOV   A,91          (0648) ;     BYTE  fStatus - Status of command receive buffer.
0F5E: 02 A5    ADD   A,[NUM_MODULES+3](0649) ;                     Returns non-zero value in A if command is valid.
0F60: 5C       MOV   X,A           (0650) ;           0x80 => Parity Error
                                   (0651) ;           0x40 => OverRun Error
0F61: 52 00    MOV   A,[X+0]       (0652) ;           0x20 => Framing Error
0F63: B0 04    JNZ   0x0F68        (0653) ;           0x10 => Software Buffer OverRun
0F65: 10       PUSH  X             (0654) ;
0F66: 80 33    JMP   0x0F9A        (0655) ;  SIDE EFFECTS:
                                   (0656) ;    The A and X registers may be modified by this or future implementations
                                   (0657) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0658) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0659) ;    responsibility to perserve their values across calls to fastcall16 
0F68: 39 00    CMP   A,0           (0660) ;    functions.
0F6A: B0 11    JNZ   0x0F7C        (0661) ;          
0F6C: 75       INC   X             (0662) ;    Currently only the page pointer registers listed below are modified: 
0F6D: 76 A5    INC   [NUM_MODULES+3](0663) ;          CUR_PP
0F6F: 52 00    MOV   A,[X+0]       (0664) ;
0F71: 3C A5 0F CMP   [NUM_MODULES+3],15(0665) ;     Error Status is clear when read.
0F74: BF F3    JNZ   0x0F68        (0666) ;
                                   (0667) ;  THEORY of OPERATION or PROCEDURE:
                                   (0668) ;     Read RX buffer error status and clear status
0F76: 10       PUSH  X             (0669) ;
                                   (0670)  RECEIVE_1_bErrCheck:
0F77: 56 00 00 MOV   [X+0],0       (0671) _RECEIVE_1_bErrCheck:
0F7A: 80 1F    JMP   0x0F9A        (0672)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0673)    RAM_SETPAGE_CUR >RECEIVE_1_fStatus
                                   (0674)    mov A,  [RECEIVE_1_fStatus]
0F7C: 10       PUSH  X             (0675)    and A, RECEIVE_1_RX_BUF_ERROR                 ; Mask off Error status
                                   (0676)    and [RECEIVE_1_fStatus], ~RECEIVE_1_RX_BUF_ERROR
                                   (0677)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (0678)    ret
0F7D: 75       INC   X             (0679) .ENDSECTION
0F7E: 76 A5    INC   [NUM_MODULES+3](0680) 
0F80: 3C A5 0F CMP   [NUM_MODULES+3],15(0681) .SECTION
0F83: AF F3    JZ    0x0F77        (0682) ;-----------------------------------------------------------------------------
0F85: 52 00    MOV   A,[X+0]       (0683) ;  FUNCTION NAME: RECEIVE_1_bCmdLength
0F87: A0 12    JZ    0x0F9A        (0684) ;
0F89: 39 00    CMP   A,0           (0685) ;  DESCRIPTION:
0F8B: BF F1    JNZ   0x0F7D        (0686) ;     Get length of command string
                                   (0687) ;
0F8D: 56 00 00 MOV   [X+0],0       (0688) ;  ARGUMENTS:
0F90: 76 A5    INC   [NUM_MODULES+3](0689) ;     none.
0F92: 3C A5 0F CMP   [NUM_MODULES+3],15(0690) ;
0F95: B0 04    JNZ   0x0F9A        (0691) ;  RETURNS:
0F97: 55 A5 0F MOV   [NUM_MODULES+3],15(0692) ;     BYTE  bRxCnt    Returns the command length in A.
                                   (0693) ;
                                   (0694) ;  SIDE EFFECTS:
                                   (0695) ;    The A and X registers may be modified by this or future implementations
0F9A: 20       POP   X             (0696) ;    of this function.  The same is true for all RAM page pointer registers in
0F9B: 10       PUSH  X             (0697) ;    the Large Memory Model.  When necessary, it is the calling function's
0F9C: 3D 00 00 CMP   [X+0],0       (0698) ;    responsibility to perserve their values across calls to fastcall16 
0F9F: B0 0B    JNZ   0x0FAB        (0699) ;    functions.
0FA1: 20       POP   X             (0700) ;          
0FA2: 57 00    MOV   X,0           (0701) ;    Currently only the page pointer registers listed below are modified: 
0FA4: 50 00    MOV   A,0           (0702) ;          CUR_PP
0FA6: 70 3F    AND   F,63
0FA8: 71 C0    OR    F,192         (0703) ;
                                   (0704)  RECEIVE_1_bCmdLength:
0FAA: 7F       RET                 (0705) _RECEIVE_1_bCmdLength:
                                   (0706)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (0707)    RAM_SETPAGE_CUR >RECEIVE_1_bRxCnt
0FAB: 20       POP   X             (0708)    mov A,  [RECEIVE_1_bRxCnt]
0FAC: 50 00    MOV   A,0           (0709)    RAM_EPILOGUE RAM_USE_CLASS_4
0FAE: 70 3F    AND   F,63
0FB0: 71 C0    OR    F,192         (0710)    ret
                                   (0711) .ENDSECTION
0FB2: 7F       RET                 (0712) 
                                   (0713) .SECTION
                                   (0714) ;-----------------------------------------------------------------------------
                                   (0715) ;  FUNCTION NAME: RECEIVE_1_szGetParam
                                   (0716) ;
                                   (0717) ;  DESCRIPTION:
                                   (0718) ;      Return next parameter from UART Rx buffer
                                   (0719) ;
                                   (0720) ;
                                   (0721) ;  ARGUMENTS:  none
                                   (0722) ;
                                   (0723) ;  RETURNS:
                                   (0724) ;     A => MSB of parameter address
                                   (0725) ;     X => LSB of parameter address
                                   (0726) ;
                                   (0727) ;  SIDE EFFECTS:
                                   (0728) ;    The A and X registers may be modified by this or future implementations
                                   (0729) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0730) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0731) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0732) ;    functions.
                                   (0733) ;          
                                   (0734) ;    Currently only the page pointer registers listed below are modified:
                                   (0735) ;          CUR_PP
                                   (0736) ;          IDX_PP
                                   (0737) ;
                                   (0738) ;     The receive string is modified by placing Null characters at the end
                                   (0739) ;     of each parameter as they are recovered.
                                   (0740) ;
                                   (0741) ;  THEORY OF OPERATION:
0FB3: 62 D0 00 MOV   REG[208],0    (0742) ;     This function is a stateful generator of addresses to the "parameters"
                                   (0743) ;     of an input "Command". It scans the (optional) input buffer and breaks
0FB6: 50 5B    MOV   A,91          (0744) ;     each lexically distinct element into a null-terminated string by replacing
0FB8: 02 A5    ADD   A,[NUM_MODULES+3](0745) ;     delimiters with nulls, as appropriate. The state of the generator is 
0FBA: 5C       MOV   X,A           (0746) ;     maintained by the private variable ptrParam, which is a buffer-relative
0FBB: 50 00    MOV   A,0           (0747) ;     offset. The generator is initialized by a call to the function
                                   (0748) ;     RECEIVE_1_CmdReset which resets the entire buffer to the 'empty'
                                   (0749) ;     state. Typically this function, RECEIVE_1_szGetParam, is
0FBE: 7E       RETI                (0750) ;     not called until the buffer has been loaded with an entire command

FILE: lib\comp_serialint.asm
                                   (0102) ;;*****************************************************************************
                                   (0103) ;;*****************************************************************************
                                   (0104) ;;  FILENAME:   COMP_SERIALINT.asm
                                   (0105) ;;  Version: 5.2, Updated on 2009/7/10 at 10:46:57
                                   (0106) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0107) ;;
                                   (0108) ;;  DESCRIPTION:  UART Interrupt Service Routine.
                                   (0109) ;;-----------------------------------------------------------------------------
                                   (0110) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0111) ;;*****************************************************************************
                                   (0112) ;;*****************************************************************************
                                   (0113) 
                                   (0114) 
                                   (0115) include "COMP_SERIAL.inc"
                                   (0116) include "memory.inc"
                                   (0117) include "m8c.inc"
                                   (0118) 
                                   (0119) ;-----------------------------------------------
                                   (0120) ;  Global Symbols
                                   (0121) ;-----------------------------------------------
                                   (0122) export  _COMP_SERIAL_TX_ISR
                                   (0123) export  _COMP_SERIAL_RX_ISR
                                   (0124) 
                                   (0125) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0126) export  COMP_SERIAL_aRxBuffer
                                   (0127) export _COMP_SERIAL_aRxBuffer
                                   (0128) export  COMP_SERIAL_bRxCnt
                                   (0129) export _COMP_SERIAL_bRxCnt
                                   (0130) export  COMP_SERIAL_fStatus
                                   (0131) export _COMP_SERIAL_fStatus
                                   (0132) ENDIF
                                   (0133) 
                                   (0134) 
                                   (0135) ;-----------------------------------------------
                                   (0136) ; Variable Allocation
                                   (0137) ;-----------------------------------------------
                                   (0138) AREA InterruptRAM (RAM, REL, CON)
                                   (0139) 
                                   (0140) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0141)  COMP_SERIAL_fStatus:
                                   (0142) _COMP_SERIAL_fStatus:      BLK  1
                                   (0143)  COMP_SERIAL_bRxCnt:
                                   (0144) _COMP_SERIAL_bRxCnt:       BLK  1
                                   (0145) AREA COMP_SERIAL_RAM (RAM, REL, CON)
                                   (0146)  COMP_SERIAL_aRxBuffer:
                                   (0147) _COMP_SERIAL_aRxBuffer:    BLK COMP_SERIAL_RX_BUFFER_SIZE
                                   (0148) ENDIF
                                   (0149) 
                                   (0150) AREA InterruptRAM (RAM, REL, CON)
                                   (0151) 
0FBF: 08       PUSH  A             (0152) ;@PSoC_UserCode_INIT@ (Do not change this line.)
0FC0: 10       PUSH  X             (0153) ;---------------------------------------------------
0FC1: 5D D3    MOV   A,REG[211]
                                   (0154) ; Insert your custom declarations below this banner
                                   (0155) ;---------------------------------------------------
0FC3: 08       PUSH  A             (0156) 
                                   (0157) ;------------------------
                                   (0158) ;  Includes
0FC4: 58 0A    MOV   X,[10]        (0159) ;------------------------
0FC6: 5D 3F    MOV   A,REG[63]     (0160) 
0FC8: 08       PUSH  A             (0161) 
                                   (0162) ;------------------------
0FC9: 21 08    AND   A,8           (0163) ;  Constant Definitions
0FCB: B0 04    JNZ   0x0FD0        (0164) ;------------------------
0FCD: 18       POP   A             (0165) 
0FCE: 80 5E    JMP   0x102D        (0166) 
                                   (0167) ;------------------------
                                   (0168) ; Variable Allocation
0FD0: 18       POP   A             (0169) ;------------------------
                                   (0170) 
                                   (0171) 
0FD1: 21 E0    AND   A,224         (0172) ;---------------------------------------------------
0FD3: A0 12    JZ    0x0FE6        (0173) ; Insert your custom declarations above this banner
                                   (0174) ;---------------------------------------------------
0FD5: 2C 09    OR    [9],A         (0175) ;@PSoC_UserCode_END@ (Do not change this line.)
0FD7: 49 3E 00 TST   REG[62],0     (0176) 
0FDA: 21 20    AND   A,32          (0177) 
0FDC: A0 50    JZ    0x102D        (0178) AREA UserModules (ROM, REL, CON)
                                   (0179) 
                                   (0180) ;-----------------------------------------------------------------------------
                                   (0181) ;  FUNCTION NAME: _COMP_SERIAL_TX_ISR
0FDE: 41 3F FE AND   REG[63],254   (0182) ;
0FE1: 43 3F 01 OR    REG[63],1     (0183) ;  DESCRIPTION:
0FE4: 80 48    JMP   0x102D        (0184) ;     UART TX interrupt handler for instance COMP_SERIAL.
                                   (0185) ;
                                   (0186) ;     This is a place holder function.  If the user requires use of an interrupt
                                   (0187) ;     handler for this function, then place code where specified.
0FE6: 5D 3E    MOV   A,REG[62]     (0188) ;-----------------------------------------------------------------------------
                                   (0189) 
                                   (0190) _COMP_SERIAL_TX_ISR:
0FE8: 47 09 01 TST   [9],1         (0191)    ;@PSoC_UserCode_BODY_1@ (Do not change this line.)
0FEB: B0 41    JNZ   0x102D        (0192)    ;---------------------------------------------------
                                   (0193)    ; Insert your custom code below this banner
0FED: 39 3B    CMP   A,59          (0194)    ;---------------------------------------------------
0FEF: B0 14    JNZ   0x1004        (0195)    ;   NOTE: interrupt service routines must preserve
0FF1: 2E 09 01 OR    [9],1         (0196)    ;   the values of the A and X CPU registers.
                                   (0197)    
                                   (0198)    ;---------------------------------------------------
                                   (0199)    ; Insert your custom code above this banner
0FF4: 62 D3 00 MOV   REG[211],0    (0200)    ;---------------------------------------------------
0FF7: 70 3F    AND   F,63
0FF9: 71 80    OR    F,128         (0201)    ;@PSoC_UserCode_END@ (Do not change this line.)
0FFB: 56 0B 00 MOV   [X+11],0      (0202)    reti
0FFE: 70 3F    AND   F,63
1000: 71 00    OR    F,0           (0203) 
1002: 80 2A    JMP   0x102D        (0204) 
                                   (0205) ;-----------------------------------------------------------------------------
                                   (0206) ;  FUNCTION NAME: _COMP_SERIAL_RX_ISR
                                   (0207) ;
                                   (0208) ;  DESCRIPTION:
                                   (0209) ;     UART RX interrupt handler for instance COMP_SERIAL.
                                   (0210) ;     This ISR handles the background processing of received characters if
                                   (0211) ;     the buffer is enabled.
                                   (0212) ;
                                   (0213) ;
                                   (0214) ;  The following assumes that the RX buffer feature has been enabled.
                                   (0215) ;
                                   (0216) ;  SIDE EFFECTS:
                                   (0217) ;     There are 3 posible errors that may occur with the serial port.
1004: 39 20    CMP   A,32          (0218) ;      1) Parity Error
1006: C0 26    JC    0x102D        (0219) ;      2) Framing Error
                                   (0220) ;      3) OverRun Error
                                   (0221) ;
                                   (0222) ;  This user module check for parity and framing error.  If either of these
                                   (0223) ;  two errors are detected, the data is read and ignored.  When an overRun
1008: 62 D3 00 MOV   REG[211],0    (0224) ;  error occurs, the last byte was lost, but the current byte is valid.  For
100B: 3C 0A 3F CMP   [10],63       (0225) ;  this reason this error is ignored at this time.  Code could be added to
100E: C0 11    JC    0x1020        (0226) ;  this ISR to set a flag if an error condition occurs.
1010: 70 3F    AND   F,63
1012: 71 80    OR    F,128         (0227) ;
1014: 56 0B 00 MOV   [X+11],0      (0228) ;  THEORY of OPERATION:
1017: 70 3F    AND   F,63
1019: 71 00    OR    F,0           (0229) ;     When using the RX buffer feature, the ISR collects received characters
101B: 2E 09 10 OR    [9],16        (0230) ;     in a buffer until the user defined command terminator is detected.  After
101E: 80 0E    JMP   0x102D        (0231) ;     the command terminator is detected, the command bit is set and all other
1020: 70 3F    AND   F,63
                                   (0232) ;     characters will be ignored until the command bit is reset.  Up to
                                   (0233) ;     buffer_size - 1 characters will be collected waiting for a command
                                   (0234) ;     terminator.  After that, the characters will be discarded, although
1022: 71 80    OR    F,128         (0235) ;     a command determinator will still cause the command bit to be set.
1024: 54 0B    MOV   [X+11],A      (0236) ;
1026: 70 3F    AND   F,63
1028: 71 00    OR    F,0           (0237) ;-----------------------------------------------------------------------------
102A: 75       INC   X             (0238) _COMP_SERIAL_RX_ISR:
102B: 5A 0A    MOV   [10],X        (0239) 
102D: 18       POP   A
                                   (0240)    ;@PSoC_UserCode_BODY_2@ (Do not change this line.)
                                   (0241)    ;---------------------------------------------------
                                   (0242)    ; Insert your custom code below this banner
102E: 60 D3    MOV   REG[211],A    (0243)    ;---------------------------------------------------
                                   (0244)    ;   NOTE: interrupt service routines must preserve
                                   (0245)    ;   the values of the A and X CPU registers.
                                   (0246) 
1030: 20       POP   X             (0247)    ;---------------------------------------------------
1031: 18       POP   A             (0248)    ; Insert your custom code above this banner
                                   (0249)    ;---------------------------------------------------
                                   (0250)    ;@PSoC_UserCode_END@ (Do not change this line.)
                                   (0251) 
                                   (0252) IF (COMP_SERIAL_RXBUF_ENABLE)
1033: 43 E1 40 OR    REG[225],64   (0253)    push A

FILE: lib\comp_serial.asm
1036: 43 E1 80 OR    REG[225],128  (0180) ;;*****************************************************************************
                                   (0181) ;;*****************************************************************************
1039: 7F       RET                 (0182) ;;  Filename:   COMP_SERIAL.asm
                                   (0183) ;;  Version: 5.2, Updated on 2009/7/10 at 10:46:57
                                   (0184) ;;  Generated by PSoC Designer 5.0.985.0
                                   (0185) ;;
                                   (0186) ;;  DESCRIPTION:  UART User Module software implementation file for the
                                   (0187) ;;                22/24/25/26/27xxx families.
                                   (0188) ;;
                                   (0189) ;;
                                   (0190) ;;  NOTE: User Module APIs conform to the fastcall16 convention for marshalling
                                   (0191) ;;        arguments and observe the associated "Registers are volatile" policy.
                                   (0192) ;;        This means it is the caller's responsibility to preserve any values
                                   (0193) ;;        in the X and A registers that are still needed after the API functions
                                   (0194) ;;        returns. For Large Memory Model devices it is also the caller's 
                                   (0195) ;;        responsibility to perserve any value in the CUR_PP, IDX_PP, MVR_PP and 
                                   (0196) ;;        MVW_PP registers. Even though some of these registers may not be modified
                                   (0197) ;;        now, there is no guarantee that will remain the case in future releases.
                                   (0198) ;;-----------------------------------------------------------------------------
                                   (0199) ;;  Copyright (c) Cypress MicroSystems 2000-2003. All Rights Reserved.
                                   (0200) ;;*****************************************************************************
                                   (0201) ;;*****************************************************************************
                                   (0202) 
                                   (0203) 
                                   (0204) include "m8c.inc"
                                   (0205) include "memory.inc"
                                   (0206) include "COMP_SERIAL.inc"
                                   (0207) 
                                   (0208) ;-----------------------------------------------
                                   (0209) ;  Global Symbols
                                   (0210) ;-----------------------------------------------
103A: 41 E1 BF AND   REG[225],191  (0211) ;-------------------------------------------------------------------
103D: 41 E1 7F AND   REG[225],127  (0212) ;  Declare the functions global for both assembler and C compiler.
                                   (0213) ;
1040: 7F       RET                 (0214) ;  Note that there are two names for each API. First name is
                                   (0215) ;  assembler reference. Name with underscore is name refence for
                                   (0216) ;  C compiler.  Calling function in C source code does not require
                                   (0217) ;  the underscore.
                                   (0218) ;-------------------------------------------------------------------
                                   (0219) export  COMP_SERIAL_SetTxIntMode
                                   (0220) export _COMP_SERIAL_SetTxIntMode
                                   (0221) export  COMP_SERIAL_EnableInt
                                   (0222) export _COMP_SERIAL_EnableInt
                                   (0223) export  COMP_SERIAL_DisableInt
                                   (0224) export _COMP_SERIAL_DisableInt
                                   (0225) 
                                   (0226) export  COMP_SERIAL_Start
                                   (0227) export _COMP_SERIAL_Start
                                   (0228) export  COMP_SERIAL_Stop
                                   (0229) export _COMP_SERIAL_Stop
                                   (0230) export  COMP_SERIAL_SendData
                                   (0231) export _COMP_SERIAL_SendData
                                   (0232) export  COMP_SERIAL_bReadTxStatus
                                   (0233) export _COMP_SERIAL_bReadTxStatus
                                   (0234) export  COMP_SERIAL_bReadRxData
                                   (0235) export _COMP_SERIAL_bReadRxData
                                   (0236) export  COMP_SERIAL_bReadRxStatus
                                   (0237) export _COMP_SERIAL_bReadRxStatus
                                   (0238) 
                                   (0239) export  COMP_SERIAL_IntCntl
                                   (0240) export _COMP_SERIAL_IntCntl
                                   (0241) 
                                   (0242) export  COMP_SERIAL_TxIntMode
                                   (0243) export _COMP_SERIAL_TxIntMode
                                   (0244) 
                                   (0245) export  COMP_SERIAL_PutSHexByte
                                   (0246) export _COMP_SERIAL_PutSHexByte
1041: 71 10    OR    F,16          (0247) export  COMP_SERIAL_PutSHexInt
1043: 21 01    AND   A,1           (0248) export _COMP_SERIAL_PutSHexInt
1045: A0 07    JZ    0x104D        (0249) 
1047: 43 38 10 OR    REG[56],16    (0250) export  COMP_SERIAL_CPutString
104A: 70 EF    AND   F,239         (0251) export _COMP_SERIAL_CPutString
                                   (0252) export  COMP_SERIAL_PutString
104C: 7F       RET                 (0253) export _COMP_SERIAL_PutString
                                   (0254) export  COMP_SERIAL_PutChar
                                   (0255) export _COMP_SERIAL_PutChar
104D: 41 38 EF AND   REG[56],239   (0256) export  COMP_SERIAL_Write
1050: 70 EF    AND   F,239         (0257) export _COMP_SERIAL_Write
                                   (0258) export  COMP_SERIAL_CWrite
1052: 7F       RET                 (0259) export _COMP_SERIAL_CWrite
                                   (0260) 
                                   (0261) export  COMP_SERIAL_cGetChar
                                   (0262) export _COMP_SERIAL_cGetChar
                                   (0263) export  COMP_SERIAL_cReadChar
                                   (0264) export _COMP_SERIAL_cReadChar
                                   (0265) export  COMP_SERIAL_iReadChar
                                   (0266) export _COMP_SERIAL_iReadChar
                                   (0267) export  COMP_SERIAL_PutCRLF
                                   (0268) export _COMP_SERIAL_PutCRLF
                                   (0269) 
                                   (0270) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0271) export  COMP_SERIAL_CmdReset
                                   (0272) export _COMP_SERIAL_CmdReset
                                   (0273) export  COMP_SERIAL_bCmdCheck
                                   (0274) export _COMP_SERIAL_bCmdCheck
                                   (0275) export  COMP_SERIAL_bCmdLength
                                   (0276) export _COMP_SERIAL_bCmdLength
                                   (0277) export  COMP_SERIAL_bErrCheck
                                   (0278) export _COMP_SERIAL_bErrCheck
                                   (0279) 
                                   (0280) export  COMP_SERIAL_szGetParam
                                   (0281) export _COMP_SERIAL_szGetParam
                                   (0282) export  COMP_SERIAL_szGetRestOfParams
                                   (0283) export _COMP_SERIAL_szGetRestOfParams
                                   (0284) ENDIF
                                   (0285) 
                                   (0286) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0287) ; WARNING WARNING WARNING
                                   (0288) ; The following exports are for backwards compatibility only and should
                                   (0289) ; not be used for new designs. They may be eliminated in a future release.
1053: 29 01    OR    A,1           (0290) ; Their status is "NO FURTHER MAINTENANCE". 
1055: 60 3B    MOV   REG[59],A     (0291) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
1057: 60 3F    MOV   REG[63],A     (0292) export  bCOMP_SERIAL_ReadTxStatus
                                   (0293) export _bCOMP_SERIAL_ReadTxStatus
1059: 91 2A    CALL  0x1185        (0294) export  bCOMP_SERIAL_ReadRxData
                                   (0295) export _bCOMP_SERIAL_ReadRxData
                                   (0296) export  bCOMP_SERIAL_ReadRxStatus
105B: 7F       RET                 (0297) export _bCOMP_SERIAL_ReadRxStatus
                                   (0298) 	
                                   (0299) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0300) ;             END WARNING
                                   (0301) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   (0302) 
                                   (0303) ;-----------------------------------------------
                                   (0304) ; Variable Allocation
                                   (0305) ;-----------------------------------------------
                                   (0306) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (0307)     
                                   (0308) area COMP_SERIAL_RAM (RAM, REL, CON)
                                   (0309)     
                                   (0310)  ptrParam:   BLK  1
                                   (0311) 
                                   (0312) ENDIF
                                   (0313) 
                                   (0314) area text (ROM,REL)
                                   (0315) 
                                   (0316) ;-----------------------------------------------
                                   (0317) ;  EQUATES
                                   (0318) ;-----------------------------------------------
                                   (0319) bfCONTROL_REG_START_BIT:        equ    1    ; Control register start bit
                                   (0320) bfFUNCTION_REG_TX_INT_MODE_BIT: equ 0x10    ; the TX Int Mode bit
                                   (0321) 
                                   (0322) area UserModules (ROM, REL, CON)
                                   (0323) 
                                   (0324) ;=============================================================================
105C: 41 3B FE AND   REG[59],254   (0325) ;=============================================================================
105F: 41 3F FE AND   REG[63],254   (0326) ;
                                   (0327) ;     Low-Level Commands
1062: 7F       RET                 (0328) ;
                                   (0329) ;=============================================================================
                                   (0330) ;=============================================================================
                                   (0331) 
                                   (0332) .SECTION
                                   (0333) ;-----------------------------------------------------------------------------
                                   (0334) ;  FUNCTION NAME: COMP_SERIAL_EnableInt
                                   (0335) ;
                                   (0336) ;  DESCRIPTION:
                                   (0337) ;     Enables this UART's interrupt by setting the interrupt enable mask
                                   (0338) ;     bit associated with this User Module. Remember to call the global
                                   (0339) ;     interrupt enable function by using the macro: M8C_EnableGInt.
                                   (0340) ;-----------------------------------------------------------------------------
                                   (0341) ;
                                   (0342) ;  ARGUMENTS:
                                   (0343) ;     none.
                                   (0344) ;
                                   (0345) ;  RETURNS:
                                   (0346) ;     none.
                                   (0347) ;
                                   (0348) ;  SIDE EFFECTS:
                                   (0349) ;    The A and X registers may be modified by this or future implementations
                                   (0350) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0351) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0352) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0353) ;    functions.
                                   (0354) ;
                                   (0355)  COMP_SERIAL_EnableInt:
1063: 60 39    MOV   REG[57],A     (0356) _COMP_SERIAL_EnableInt:
                                   (0357)    RAM_PROLOGUE RAM_USE_CLASS_1
1065: 7F       RET                 (0358)    M8C_EnableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0359)    M8C_EnableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
                                   (0360)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0361)    ret
                                   (0362) .ENDSECTION
                                   (0363) 
                                   (0364)     
                                   (0365) .SECTION
                                   (0366) ;-----------------------------------------------------------------------------
                                   (0367) ;  FUNCTION NAME: COMP_SERIAL_DisableInt
                                   (0368) ;
                                   (0369) ;  DESCRIPTION:
                                   (0370) ;     Disables this UART's interrupt by clearing the interrupt enable mask bit
                                   (0371) ;     associated with this User Module.
                                   (0372) ;-----------------------------------------------------------------------------
                                   (0373) ;
                                   (0374) ;  ARGUMENTS:
                                   (0375) ;     none.
                                   (0376) ;
                                   (0377) ;  RETURNS:
                                   (0378) ;     none.
                                   (0379) ;
                                   (0380) ;  SIDE EFFECTS:
                                   (0381) ;    The A and X registers may be modified by this or future implementations
                                   (0382) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0383) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0384) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0385) ;    functions.
                                   (0386) ;
                                   (0387)  COMP_SERIAL_DisableInt:
                                   (0388) _COMP_SERIAL_DisableInt:
1066: 5D 3B    MOV   A,REG[59]     (0389)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0390)    M8C_DisableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
1068: 7F       RET                 (0391)    M8C_DisableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
                                   (0392)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0393)    ret
                                   (0394) .ENDSECTION
                                   (0395) 
                                   (0396) 
                                   (0397) .SECTION
                                   (0398) ;-----------------------------------------------------------------------------
                                   (0399) ;  FUNCTION NAME: COMP_SERIAL_SetTxIntMode(BYTE bTxIntMode)
                                   (0400) ;
                                   (0401) ;  DESCRIPTION:
                                   (0402) ;     Sets the Tx Interrupt Mode bit in the Function Register.
                                   (0403) ;-----------------------------------------------------------------------------
                                   (0404) ;
                                   (0405) ;  ARGUMENTS:
                                   (0406) ;     BYTE bTxIntMode - The TX Interrupt mode setting. Use defined masks.
                                   (0407) ;        Passed in the A register
                                   (0408) ;
                                   (0409) ;  RETURNS:
                                   (0410) ;     none.
                                   (0411) ;
                                   (0412) ;  SIDE EFFECTS:
                                   (0413) ;    The A and X registers may be modified by this or future implementations
                                   (0414) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0415) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0416) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0417) ;    functions.
                                   (0418) ;
                                   (0419) ;  THEORY of OPERATION OR PROCEDURE:
                                   (0420) ;     Sets the TX interrupt mode bit to define whether the interrupt occurs
                                   (0421) ;     on TX register empty or TX transmit complete
1069: 5D 3E    MOV   A,REG[62]     (0422) ;
                                   (0423)  COMP_SERIAL_SetTxIntMode:
106B: 7F       RET                 (0424) _COMP_SERIAL_SetTxIntMode:
                                   (0425)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0426)    M8C_SetBank1
                                   (0427)    and   A, COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0428)    jz    .SetModeRegEmpty
                                   (0429)    or    REG[COMP_SERIAL_TX_FUNC_REG], bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0430)    M8C_SetBank0
                                   (0431)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0432)    ret
                                   (0433) 
                                   (0434) .SetModeRegEmpty:
                                   (0435)    and   REG[COMP_SERIAL_TX_FUNC_REG], ~bfFUNCTION_REG_TX_INT_MODE_BIT
                                   (0436)    M8C_SetBank0
                                   (0437)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0438)    ret
                                   (0439) .ENDSECTION
                                   (0440) 
                                   (0441) 
                                   (0442) .SECTION
                                   (0443) ;-----------------------------------------------------------------------------
                                   (0444) ;  FUNCTION NAME: COMP_SERIAL_Start(BYTE bParity)
                                   (0445) ;
                                   (0446) ;  DESCRIPTION:
                                   (0447) ;     Sets the start bit and parity in the Control register of this user module.
                                   (0448) ;-----------------------------------------------------------------------------
                                   (0449) ;
                                   (0450) ;  ARGUMENTS:
                                   (0451) ;     BYTE bParity - parity setting for the Transmitter and receiver. Use defined masks.
                                   (0452) ;        Passed in the A register.
                                   (0453) ;
                                   (0454) ;  RETURNS:
                                   (0455) ;     none.
106C: 5D 3F    MOV   A,REG[63]     (0456) ;
                                   (0457) ;  SIDE EFFECTS:
106E: 7F       RET                 (0458) ;    The A and X registers may be modified by this or future implementations
                                   (0459) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0460) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0461) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0462) ;    functions.
                                   (0463) ;
                                   (0464)  COMP_SERIAL_Start:
                                   (0465) _COMP_SERIAL_Start:
                                   (0466)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0467)    ; Note, Proxy Class 4 only if receive buffer used; otherwise Proxy Class 1.
                                   (0468) 
                                   (0469)    or    A, bfCONTROL_REG_START_BIT
                                   (0470)    mov   REG[COMP_SERIAL_TX_CONTROL_REG], A
                                   (0471)    mov   REG[COMP_SERIAL_RX_CONTROL_REG], A
                                   (0472) IF ( COMP_SERIAL_RXBUF_ENABLE )
                                   (0473)    call  _COMP_SERIAL_CmdReset
                                   (0474) ENDIF
                                   (0475)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0476)    ret
                                   (0477) .ENDSECTION
                                   (0478) 
                                   (0479) 
                                   (0480) .SECTION
                                   (0481) ;-----------------------------------------------------------------------------
                                   (0482) ;  FUNCTION NAME: COMP_SERIAL_Stop
                                   (0483) ;
                                   (0484) ;  DESCRIPTION:
                                   (0485) ;     Disables UART operation.
                                   (0486) ;-----------------------------------------------------------------------------
                                   (0487) ;
                                   (0488) ;  ARGUMENTS:
106F: 21 01    AND   A,1           (0489) ;     none.
1071: 71 10    OR    F,16          (0490) ;
1073: 39 01    CMP   A,1           (0491) ;  RETURNS:
1075: A0 06    JZ    0x107C        (0492) ;     none.
                                   (0493) ;
1077: 41 38 EF AND   REG[56],239   (0494) ;  SIDE EFFECTS:
107A: 80 04    JMP   0x107F        (0495) ;    The A and X registers may be modified by this or future implementations
                                   (0496) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0497) ;    the Large Memory Model.  When necessary, it is the calling function's
107C: 43 38 10 OR    REG[56],16    (0498) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0499) ;    functions.
                                   (0500) ;
107F: 70 EF    AND   F,239         (0501)  COMP_SERIAL_Stop:
                                   (0502) _COMP_SERIAL_Stop:
1081: 7F       RET                 (0503)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0504)    and   REG[COMP_SERIAL_TX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0505)    and   REG[COMP_SERIAL_RX_CONTROL_REG], ~bfCONTROL_REG_START_BIT
                                   (0506)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0507)    ret
                                   (0508) .ENDSECTION
                                   (0509) 
                                   (0510) 
                                   (0511) .SECTION
                                   (0512) ;-----------------------------------------------------------------------------
                                   (0513) ;  FUNCTION NAME: COMP_SERIAL_SendData
                                   (0514) ;
                                   (0515) ;  DESCRIPTION:
                                   (0516) ;     Initiates a transmission of data.
                                   (0517) ;-----------------------------------------------------------------------------
                                   (0518) ;
                                   (0519) ;  ARGUMENTS:
                                   (0520) ;     BYTE  TxData - data to transmit. PASSED in A register.
                                   (0521) ;
                                   (0522) ;  RETURNS:
                                   (0523) ;     none.
                                   (0524) ;
                                   (0525) ;  SIDE EFFECTS:
                                   (0526) ;    The A and X registers may be modified by this or future implementations
                                   (0527) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0528) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0529) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0530) ;    functions.
                                   (0531) ;
                                   (0532)  COMP_SERIAL_SendData:
                                   (0533) _COMP_SERIAL_SendData:
                                   (0534)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0535)    mov REG[COMP_SERIAL_TX_BUFFER_REG], A
1082: 08       PUSH  A             (0536)    RAM_EPILOGUE RAM_USE_CLASS_1
1083: 21 01    AND   A,1           (0537)    ret
1085: A0 06    JZ    0x108C        (0538) .ENDSECTION
                                   (0539) 
1087: 43 E1 80 OR    REG[225],128  (0540) 
108A: 80 04    JMP   0x108F        (0541) .SECTION
                                   (0542) ;-----------------------------------------------------------------------------
                                   (0543) ;  FUNCTION NAME: COMP_SERIAL_bReadTxStatus
108C: 41 E1 7F AND   REG[225],127  (0544) ;
                                   (0545) ;  DESCRIPTION:
                                   (0546) ;     Reads the Tx Status bits in the Control/Status register.
108F: 18       POP   A             (0547) ;-----------------------------------------------------------------------------
1090: 21 02    AND   A,2           (0548) ;
1092: A0 06    JZ    0x1099        (0549) ;  ARGUMENTS:
                                   (0550) ;     none.
1094: 43 E1 40 OR    REG[225],64   (0551) ;
1097: 80 04    JMP   0x109C        (0552) ;  RETURNS:
                                   (0553) ;     BYTE  bTxStatus - transmit status data.  Use defined masks for detecting
                                   (0554) ;           status bits (returned in A)
1099: 41 E1 BF AND   REG[225],191  (0555) ;
                                   (0556) ;  SIDE EFFECTS:
                                   (0557) ;    The A and X registers may be modified by this or future implementations
                                   (0558) ;    of this function.  The same is true for all RAM page pointer registers in
109C: 7F       RET                 (0559) ;    the Large Memory Model.  When necessary, it is the calling function's
109D: 30       HALT  
109E: 31 32    XOR   A,50
10A0: 33 34    XOR   A,[X+52]
10A2: 35 36    XOR   [X+54],A
10A4: 37 38 39 XOR   [X+56],57
10A7: 41 42 43 AND   REG[66],67
10AA: 44 45 46 OR    REG[X+69],70
                                   (0560) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0561) ;    functions.
                                   (0562) ;
                                   (0563)  COMP_SERIAL_bReadTxStatus:
                                   (0564) _COMP_SERIAL_bReadTxStatus:
                                   (0565)  bCOMP_SERIAL_ReadTxStatus:                      ; For backwards compatibility only
                                   (0566) _bCOMP_SERIAL_ReadTxStatus:                      ; For backwards compatibility only
                                   (0567)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0568)    mov A,  REG[COMP_SERIAL_TX_CONTROL_REG]
                                   (0569)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0570)    ret
                                   (0571) .ENDSECTION
                                   (0572) 
                                   (0573) 
                                   (0574) .SECTION
                                   (0575) ;-----------------------------------------------------------------------------
                                   (0576) ;  FUNCTION NAME: COMP_SERIAL_bReadRxData
                                   (0577) ;
                                   (0578) ;  DESCRIPTION:
                                   (0579) ;     Reads the RX buffer register.  Should check the status regiser to make
                                   (0580) ;     sure data is valid.
                                   (0581) ;-----------------------------------------------------------------------------
                                   (0582) ;
                                   (0583) ;  ARGUMENTS:
                                   (0584) ;     none.
                                   (0585) ;
                                   (0586) ;  RETURNS:
                                   (0587) ;     bRxData - returned in A.
                                   (0588) ;
                                   (0589) ;  SIDE EFFECTS:
                                   (0590) ;    The A and X registers may be modified by this or future implementations
                                   (0591) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0592) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0593) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0594) ;    functions.
                                   (0595) ;
                                   (0596)  COMP_SERIAL_bReadRxData:
                                   (0597) _COMP_SERIAL_bReadRxData:
                                   (0598)  bCOMP_SERIAL_ReadRxData:                        ; For backwards compatibility only
                                   (0599) _bCOMP_SERIAL_ReadRxData:                        ; For backwards compatibility only
                                   (0600)    RAM_PROLOGUE RAM_USE_CLASS_1
10AD: 08       PUSH  A             (0601)    mov A, REG[COMP_SERIAL_RX_BUFFER_REG]
10AE: 67       ASR   A             (0602)    RAM_EPILOGUE RAM_USE_CLASS_1
10AF: 67       ASR   A             (0603)    ret
10B0: 67       ASR   A             (0604) .ENDSECTION
10B1: 67       ASR   A             (0605) 
10B2: 21 0F    AND   A,15          (0606) 
10B4: FF E7    INDEX 0x109D        (0607) .SECTION
10B6: 90 0F    CALL  0x10C7        (0608) ;-----------------------------------------------------------------------------
10B8: 18       POP   A             (0609) ;  FUNCTION NAME: COMP_SERIAL_bReadRxStatus
10B9: 21 0F    AND   A,15          (0610) ;
10BB: FF E0    INDEX 0x109D        (0611) ;  DESCRIPTION:
10BD: 90 08    CALL  0x10C7        (0612) ;     Reads the RX Status bits in the Control/Status register.
                                   (0613) ;-----------------------------------------------------------------------------
10BF: 7F       RET                 (0614) ;
                                   (0615) ;  ARGUMENTS:
                                   (0616) ;     none.
                                   (0617) ;
                                   (0618) ;  RETURNS:
                                   (0619) ;     BYTE  bRXStatus - receive status data.  Use the following defined bits
                                   (0620) ;                       masks: RX_COMPLETE and RX_BUFFER_EMPTY
                                   (0621) ;           returned in A.
                                   (0622) ;
                                   (0623) ;  SIDE EFFECTS:
                                   (0624) ;    The A and X registers may be modified by this or future implementations
                                   (0625) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0626) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0627) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0628) ;    functions.
                                   (0629) ;
                                   (0630)  COMP_SERIAL_bReadRxStatus:
                                   (0631) _COMP_SERIAL_bReadRxStatus:
                                   (0632)  bCOMP_SERIAL_ReadRxStatus:                      ; For backwards compatibility only
                                   (0633) _bCOMP_SERIAL_ReadRxStatus:                      ; For backwards compatibility only
                                   (0634)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0635)    mov A,  REG[COMP_SERIAL_RX_CONTROL_REG]
                                   (0636)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0637)    ret
                                   (0638) .ENDSECTION
                                   (0639) 
                                   (0640) 
                                   (0641) .SECTION
                                   (0642) ;-----------------------------------------------------------------------------
                                   (0643) ;  FUNCTION NAME: COMP_SERIAL_TxIntMode
                                   (0644) ;
10C0: 4B       SWAP  A,X           (0645) ;  DESCRIPTION:
10C1: 9F EA    CALL  0x10AD        (0646) ;     This function is used to change the TX Interrupt mode.
10C3: 5B       MOV   A,X           (0647) ;-----------------------------------------------------------------------------
10C4: 9F E7    CALL  0x10AD        (0648) ;
                                   (0649) ;  ARGUMENTS:
10C6: 7F       RET                 (0650) ;     A => Tx Interrupt mode
10C7: 49 3B 10 TST   REG[59],16
                                   (0651) ;             0 => Interrupt on TX_Reg_Empty  (Default)
                                   (0652) ;             1 => Interrupt on TX Complete
                                   (0653) ;
                                   (0654) ;  RETURNS:
                                   (0655) ;     none.
                                   (0656) ;
                                   (0657) ;  SIDE EFFECTS:
                                   (0658) ;    The A and X registers may be modified by this or future implementations
                                   (0659) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0660) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0661) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0662) ;    functions.
                                   (0663) ;
                                   (0664)  COMP_SERIAL_TxIntMode:
                                   (0665) _COMP_SERIAL_TxIntMode:
                                   (0666)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0667) 
                                   (0668)    and  A,COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0669)    M8C_SetBank1
                                   (0670)    cmp  A,COMP_SERIAL_INT_MODE_TX_COMPLETE
                                   (0671)    jz   .SetTxCmpMode
                                   (0672) 
                                   (0673)    and  reg[COMP_SERIAL_TX_FUNC_REG],0xEF        ; Set Interrupt on Tx_Reg_Empty
                                   (0674)    jmp  .TxIntMode_End
                                   (0675) 
                                   (0676) .SetTxCmpMode:                                       ; Set Interrupt on TX Complete
                                   (0677)    or   reg[COMP_SERIAL_TX_FUNC_REG],0x10
                                   (0678) 
                                   (0679) .TxIntMode_End:
                                   (0680)    M8C_SetBank0
                                   (0681)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0682)    ret
                                   (0683) .ENDSECTION
                                   (0684) 
                                   (0685)     
10CA: AF FC    JZ    0x10C7        (0686) .SECTION
10CC: 60 39    MOV   REG[57],A
                                   (0687) ;-----------------------------------------------------------------------------
10CE: 7F       RET                 (0688) ;  FUNCTION NAME: COMP_SERIAL_IntCntl
                                   (0689) ;
                                   (0690) ;  DESCRIPTION:
                                   (0691) ;     This function is used to enable/disable the Rx and Tx interrupt.
                                   (0692) ;-----------------------------------------------------------------------------
                                   (0693) ;
                                   (0694) ;  ARGUMENTS:
                                   (0695) ;     A => Interrupt mask
                                   (0696) ;
                                   (0697) ;  RETURNS:
                                   (0698) ;     none.
                                   (0699) ;
                                   (0700) ;  SIDE EFFECTS:
                                   (0701) ;    The A and X registers may be modified by this or future implementations
                                   (0702) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0703) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0704) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0705) ;    functions.
                                   (0706) ;
                                   (0707) ;  THEORY of OPERATION or PROCEDURE:
                                   (0708) ;     Set or Clears the Tx/Rx user module interrupt enable mask bit in the TX
                                   (0709) ;     and RX block.
                                   (0710) ;
                                   (0711)  COMP_SERIAL_IntCntl:
                                   (0712) _COMP_SERIAL_IntCntl:
                                   (0713)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0714) 
                                   (0715)    push A
                                   (0716)    and  A,COMP_SERIAL_ENABLE_RX_INT
                                   (0717)    jz   .DisRxInt
                                   (0718)      ; Enable Rx Interrupt
                                   (0719)    M8C_EnableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
10CF: 49 3F 08 TST   REG[63],8     (0720)    jmp  .CheckTxInt
10D2: AF FC    JZ    0x10CF        (0721) .DisRxInt:
10D4: 5D 3E    MOV   A,REG[62]     (0722)      ; Disable Rx Interrupt
                                   (0723)    M8C_DisableIntMask COMP_SERIAL_RX_INT_REG, COMP_SERIAL_RX_INT_MASK
10D6: 7F       RET                 (0724) 
                                   (0725) .CheckTxInt:
                                   (0726)    pop  A
                                   (0727)    and  A,COMP_SERIAL_ENABLE_TX_INT
                                   (0728)    jz   .DisTxInt
                                   (0729)      ; Enable Tx Interrupt
                                   (0730)    M8C_EnableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0731)    jmp  .End_IntCntl
                                   (0732) .DisTxInt:
                                   (0733)      ; Disable Tx Interrupt
                                   (0734)    M8C_DisableIntMask COMP_SERIAL_TX_INT_REG, COMP_SERIAL_TX_INT_MASK
                                   (0735) 
                                   (0736) .End_IntCntl:
                                   (0737)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0738)    ret
                                   (0739) .ENDSECTION
                                   (0740) 
                                   (0741) 
                                   (0742) ;=============================================================================
                                   (0743) ;=============================================================================
                                   (0744) ;
                                   (0745) ;     High-Level Commands
                                   (0746) ;
                                   (0747) ;=============================================================================
                                   (0748) ;=============================================================================
                                   (0749) 
                                   (0750) 
                                   (0751) ;-----------------------------------------------------------------------------
                                   (0752) ;  FUNCTION NAME: COMP_SERIAL_PutSHexByte
                                   (0753) ;
                                   (0754) ;  DESCRIPTION:
10D7: 5D 3F    MOV   A,REG[63]     (0755) ;     Print a byte in Hex (two characters) to the UART Tx
10D9: 08       PUSH  A             (0756) ;-----------------------------------------------------------------------------
10DA: 21 08    AND   A,8           (0757) ;
10DC: B0 04    JNZ   0x10E1        (0758) ;  ARGUMENTS:
10DE: 18       POP   A             (0759) ;     A  => (BYTE) Data/char to be printed
10DF: 80 0B    JMP   0x10EB        (0760) ;
                                   (0761) ;  RETURNS:
                                   (0762) ;     none.
10E1: 5D 3E    MOV   A,REG[62]     (0763) ;
10E3: 4B       SWAP  A,X           (0764) ;  SIDE EFFECTS:
                                   (0765) ;    The A and X registers may be modified by this or future implementations
10E4: 18       POP   A             (0766) ;    of this function.  The same is true for all RAM page pointer registers in
10E5: 21 A0    AND   A,160         (0767) ;    the Large Memory Model.  When necessary, it is the calling function's
10E7: B0 03    JNZ   0x10EB        (0768) ;    responsibility to perserve their values across calls to fastcall16 
10E9: 4B       SWAP  A,X           (0769) ;    functions.
                                   (0770) ;
10EA: 7F       RET                 (0771) .LITERAL
                                   (0772) COMP_SERIAL_HEX_STR:
                                   (0773)      DS    "0123456789ABCDEF"
10EB: 50 00    MOV   A,0           (0774) .ENDLITERAL
                                   (0775) 
                                   (0776) .SECTION
                                   (0777)  COMP_SERIAL_PutSHexByte:
10ED: 7F       RET                 (0778) _COMP_SERIAL_PutSHexByte:
                                   (0779)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0780)    push  A                             ; Save lower nibble
                                   (0781)    asr   A                             ; Shift high nibble to right
                                   (0782)    asr   A
                                   (0783)    asr   A
                                   (0784)    asr   A
                                   (0785)    and   A,0Fh                         ; Mask off nibble
                                   (0786)    index COMP_SERIAL_HEX_STR           ; Get Hex value
                                   (0787)    call  COMP_SERIAL_PutChar           ; Write data to screen
                                   (0788)    pop   A                             ; Restore value
                                   (0789)    and   A,0Fh                         ; Mask off lower nibble
                                   (0790)    index COMP_SERIAL_HEX_STR           ; Get Hex value
                                   (0791)    call  COMP_SERIAL_PutChar           ; Write data to screen
                                   (0792)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0793)    ret
                                   (0794) .ENDSECTION
                                   (0795) 
                                   (0796) 
                                   (0797) .SECTION
                                   (0798) ;-----------------------------------------------------------------------------
                                   (0799) ;  FUNCTION NAME: COMP_SERIAL_PutSHexInt
                                   (0800) ;
                                   (0801) ;  DESCRIPTION:
                                   (0802) ;     Print an Int in Hex (four characters) to UART Tx
                                   (0803) ;-----------------------------------------------------------------------------
                                   (0804) ;
                                   (0805) ;  ARGUMENTS:
                                   (0806) ;     Pointer to string
                                   (0807) ;     A  => ASB of Int
                                   (0808) ;     X  => MSB of Int
                                   (0809) ;
                                   (0810) ;  RETURNS:
                                   (0811) ;     none.
                                   (0812) ;
                                   (0813) ;  SIDE EFFECTS:
                                   (0814) ;    The A and X registers may be modified by this or future implementations
                                   (0815) ;    of this function.  The same is true for all RAM page pointer registers in
10EE: 5D 3F    MOV   A,REG[63]     (0816) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0817) ;    responsibility to perserve their values across calls to fastcall16 
10F0: 21 E8    AND   A,232         (0818) ;    functions.
10F2: 08       PUSH  A             (0819) ;
10F3: 21 08    AND   A,8           (0820) 
10F5: B0 07    JNZ   0x10FD        (0821)  COMP_SERIAL_PutSHexInt:
10F7: 18       POP   A             (0822) _COMP_SERIAL_PutSHexInt:
10F8: 29 01    OR    A,1           (0823)    RAM_PROLOGUE RAM_USE_CLASS_1
10FA: 4B       SWAP  A,X           (0824)    swap  A,X
10FB: 80 07    JMP   0x1103        (0825)    call  COMP_SERIAL_PutSHexByte       ; Print MSB
                                   (0826)    mov   A,X                           ; Move LSB into position
                                   (0827)    call  COMP_SERIAL_PutSHexByte       ; Print LSB
10FD: 18       POP   A             (0828)    RAM_EPILOGUE RAM_USE_CLASS_1
10FE: 21 E0    AND   A,224         (0829)    ret
1100: 4B       SWAP  A,X           (0830) .ENDSECTION
1101: 5D 3E    MOV   A,REG[62]     (0831) 
                                   (0832) 
                                   (0833) .SECTION
                                   (0834) ;-----------------------------------------------------------------------------
                                   (0835) ;  FUNCTION NAME: COMP_SERIAL_PutChar
1103: 7F       RET                 (0836) ;
                                   (0837) ;  DESCRIPTION:
                                   (0838) ;     Send character out through UART TX port.
                                   (0839) ;-----------------------------------------------------------------------------
                                   (0840) ;
                                   (0841) ;  ARGUMENTS:
                                   (0842) ;     A has Character to send to UART Tx Port
                                   (0843) ;
                                   (0844) ;  RETURNS:
                                   (0845) ;     none
                                   (0846) ;
                                   (0847) ;  SIDE EFFECTS:
                                   (0848) ;    The A and X registers may be modified by this or future implementations
                                   (0849) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0850) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0851) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0852) ;    functions.
                                   (0853) ;
                                   (0854) 
                                   (0855)    macro InLinePutChar( Source )
                                   (0856) .BufEmptyWaitLoop:
                                   (0857)    tst REG[COMP_SERIAL_TX_CONTROL_REG], COMP_SERIAL_TX_BUFFER_EMPTY     ; Check Tx Status
                                   (0858)    jz  .BufEmptyWaitLoop
                                   (0859)    mov REG[COMP_SERIAL_TX_BUFFER_REG], @Source     ; Write data to Tx Port
                                   (0860)    endm
                                   (0861) 
                                   (0862)  COMP_SERIAL_PutChar:
                                   (0863) _COMP_SERIAL_PutChar:
                                   (0864)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0865)    InLinePutChar A
                                   (0866)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0867)    ret
1104: 70 BF    AND   F,191         (0868) .ENDSECTION
1106: 60 D3    MOV   REG[211],A    (0869) 
                                   (0870) 
1108: 52 00    MOV   A,[X+0]       (0871) .SECTION
110A: A0 06    JZ    0x1111        (0872) ;-----------------------------------------------------------------------------
110C: 9F B9    CALL  0x10C7        (0873) ;  FUNCTION NAME: COMP_SERIAL_cGetChar
110E: 75       INC   X             (0874) ;
110F: 8F F8    JMP   0x1108        (0875) ;  DESCRIPTION:
1111: 70 3F    AND   F,63
                                   (0876) ;     Read character from UART RX port.
                                   (0877) ;-----------------------------------------------------------------------------
1113: 71 C0    OR    F,192         (0878) ;
1115: 7F       RET                 (0879) ;  ARGUMENTS:
                                   (0880) ;      none
                                   (0881) ;
                                   (0882) ;  RETURNS:
                                   (0883) ;     char that is returned from UART
                                   (0884) ;
                                   (0885) ;  SIDE EFFECTS:
                                   (0886) ;    The A and X registers may be modified by this or future implementations
                                   (0887) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0888) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (0889) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0890) ;    functions.
                                   (0891) ;
                                   (0892) ;    Program flow will stay in this function until a character is received.
                                   (0893) ;    If the watchdog timer is used, care must be taken to make sure that
                                   (0894) ;    the delay between characters is less than the watchdog timeout.
                                   (0895) ;
                                   (0896)  COMP_SERIAL_cGetChar:
                                   (0897) _COMP_SERIAL_cGetChar:
                                   (0898)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (0899)    tst REG[COMP_SERIAL_RX_CONTROL_REG],COMP_SERIAL_RX_REG_FULL    ; Check if a character is ready
                                   (0900)    jz  COMP_SERIAL_cGetChar                              ; If not loop
                                   (0901)    mov A, REG[COMP_SERIAL_RX_BUFFER_REG]                 ; Get character
                                   (0902)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0903)    ret
                                   (0904) .ENDSECTION
                                   (0905) 
                                   (0906) 
                                   (0907) .SECTION
                                   (0908) ;-----------------------------------------------------------------------------
                                   (0909) ;  FUNCTION NAME: COMP_SERIAL_cReadChar
                                   (0910) ;
                                   (0911) ;  DESCRIPTION:
                                   (0912) ;     Read character from UART RX port.
                                   (0913) ;-----------------------------------------------------------------------------
                                   (0914) ;
1116: 70 BF    AND   F,191         (0915) ;  ARGUMENTS:
1118: 62 D3 07 MOV   REG[211],7    (0916) ;      none
111B: 4F       MOV   X,SP          (0917) ;
                                   (0918) ;  RETURNS:
                                   (0919) ;     char that is returned from UART
111C: 52 FB    MOV   A,[X-5]       (0920) ;
111E: A0 1A    JZ    0x1139        (0921) ;  SIDE EFFECTS:
1120: 7B FB    DEC   [X-5]         (0922) ;    The A and X registers may be modified by this or future implementations
                                   (0923) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (0924) ;    the Large Memory Model.  When necessary, it is the calling function's
1122: 52 FC    MOV   A,[X-4]       (0925) ;    responsibility to perserve their values across calls to fastcall16 
                                   (0926) ;    functions.
                                   (0927) ;
1124: 59 FD    MOV   X,[X-3]       (0928) ;    A valid 0x00 character will be ignored, since a 0x00 return value
1126: 60 D3    MOV   REG[211],A    (0929) ;    implies a valid character or an error condition occured.
1128: 52 00    MOV   A,[X+0]       (0930) ;
112A: 49 3B 10 TST   REG[59],16
112D: AF FC    JZ    0x112A        (0931)  COMP_SERIAL_cReadChar:
112F: 60 39    MOV   REG[57],A
1131: 4F       MOV   X,SP          (0932) _COMP_SERIAL_cReadChar:
1132: 62 D3 07 MOV   REG[211],7    (0933)    RAM_PROLOGUE RAM_USE_CLASS_1
1135: 77 FD    INC   [X-3]         (0934)    mov  A,REG[COMP_SERIAL_RX_CONTROL_REG]                  ; Get Status of RX
1137: 8F E4    JMP   0x111C        (0935)    push A
1139: 70 3F    AND   F,63
                                   (0936)    and  A,COMP_SERIAL_RX_COMPLETE                          ; Check if a character is ready
                                   (0937)    jnz  .RX_DATA_RDY                                       ; Data Ready go read it.
113B: 71 C0    OR    F,192         (0938)    pop  A
113D: 7F       RET                 (0939)    jmp  .RX_NO_VALID_CHAR
                                   (0940) 
                                   (0941) .RX_DATA_RDY:
                                   (0942)    mov  A,REG[COMP_SERIAL_RX_BUFFER_REG ]          
                                   (0943)    swap A,X                                                ; determine if data is valid
                                   (0944) 
                                   (0945)    pop  A                                                  ; Check for errors
                                   (0946)    and  A,(COMP_SERIAL_RX_PARITY_ERROR | COMP_SERIAL_RX_FRAMING_ERROR)
                                   (0947)    jnz  .RX_NO_VALID_CHAR                                  ; No character, exit
                                   (0948)    swap A,X                                                ; Put data in A and exit
                                   (0949)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0950)    ret
                                   (0951) 
                                   (0952) .RX_NO_VALID_CHAR:
                                   (0953)    mov A,0x00                                              ; Zero out character
                                   (0954) 
                                   (0955)  End_COMP_SERIAL_cReadChar:
                                   (0956)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (0957)    ret
                                   (0958) .ENDSECTION
                                   (0959) 
                                   (0960) 
                                   (0961) .SECTION
                                   (0962) ;-----------------------------------------------------------------------------
                                   (0963) ;  FUNCTION NAME: COMP_SERIAL_iReadChar
                                   (0964) ;
                                   (0965) ;  WARNING WARNING WARNING  Negative return value not correct!!!!  We may want
                                   (0966) ;  to just set a value in the upper byte if error conditions exists.
                                   (0967) ;
                                   (0968) ;  DESCRIPTION:
                                   (0969) ;     Read character from UART RX port.
                                   (0970) ;-----------------------------------------------------------------------------
                                   (0971) ;
                                   (0972) ;  ARGUMENTS:
                                   (0973) ;      none
                                   (0974) ;
                                   (0975) ;  RETURNS:
                                   (0976) ;     An integer value is returned.  A negative value inplies and error
113E: 4F       MOV   X,SP          (0977) ;     condition, a positive value between 0 and 255 is the return character.
                                   (0978) ;
113F: 3D FA 00 CMP   [X-6],0       (0979) ;     Error Codes:
1142: B0 06    JNZ   0x1149        (0980) ;        0x80CC    Parity Error
1144: 3D FB 00 CMP   [X-5],0       (0981) ;        0x40CC    Overrun Error
1147: A0 1D    JZ    0x1165        (0982) ;        0x20CC    Framing Error
                                   (0983) ;        0x01CC    No Data available
                                   (0984) ;
1149: 10       PUSH  X             (0985) ;  SIDE EFFECTS:
114A: 52 FC    MOV   A,[X-4]       (0986) ;    The A and X registers may be modified by this or future implementations
114C: 59 FD    MOV   X,[X-3]       (0987) ;    of this function.  The same is true for all RAM page pointer registers in
114E: 28       ROMX                (0988) ;    the Large Memory Model.  When necessary, it is the calling function's
114F: 49 3B 10 TST   REG[59],16
1152: AF FC    JZ    0x114F        (0989) ;    responsibility to perserve their values across calls to fastcall16 
1154: 60 39    MOV   REG[57],A
1156: 20       POP   X             (0990) ;    functions.
1157: 07 FD 01 ADD   [X-3],1       (0991) ;
115A: 0F FC 00 ADC   [X-4],0       (0992)  COMP_SERIAL_iReadChar:
115D: 17 FB 01 SUB   [X-5],1       (0993) _COMP_SERIAL_iReadChar:
1160: 1F FA 00 SBB   [X-6],0       (0994)    RAM_PROLOGUE RAM_USE_CLASS_1
1163: 8F DB    JMP   0x113F        (0995)    mov  A,REG[COMP_SERIAL_RX_CONTROL_REG]                  ; Get Status of RX
1165: 70 3F    AND   F,63
                                   (0996)                                                            ; Mask only errors and data ready
                                   (0997)    and  A,(COMP_SERIAL_RX_ERROR|COMP_SERIAL_RX_REG_FULL)
1167: 71 C0    OR    F,192         (0998)    push A
1169: 7F       RET                 (0999)    and  A,COMP_SERIAL_RX_COMPLETE                          ; Check if a character is ready
                                   (1000)    jnz  .RX_GET_DATA                                       ; Data Ready go read it.
                                   (1001)    pop  A
                                   (1002)    or   A,COMP_SERIAL_RX_NO_DATA                           ; Add no data flag
                                   (1003)    swap A,X
                                   (1004)    jmp  End_COMP_SERIAL_iReadChar
                                   (1005) 
                                   (1006) .RX_GET_DATA:
                                   (1007)    pop  A
                                   (1008)    and  A,COMP_SERIAL_RX_ERROR
                                   (1009)    swap A,X
                                   (1010)    mov  A,REG[COMP_SERIAL_RX_BUFFER_REG ]                  ; Read data first, then
                                   (1011)                                                            ; determine if data is valid
                                   (1012) 
                                   (1013)  End_COMP_SERIAL_iReadChar:
                                   (1014)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1015)    ret
                                   (1016) .ENDSECTION
                                   (1017) 
                                   (1018) 
                                   (1019) .SECTION
                                   (1020) ;-----------------------------------------------------------------------------
                                   (1021) ;  FUNCTION NAME: COMP_SERIAL_PutString
                                   (1022) ;
                                   (1023) ;  DESCRIPTION:
                                   (1024) ;     Send String out through UART TX port.
                                   (1025) ;-----------------------------------------------------------------------------
                                   (1026) ;
                                   (1027) ;  ARGUMENTS:
                                   (1028) ;     Pointer to String
116A: 08       PUSH  A             (1029) ;     A has MSB of string address
116B: 10       PUSH  X             (1030) ;     X has LSB of string address
116C: 28       ROMX                (1031) ;
116D: A0 0B    JZ    0x1179        (1032) ;  RETURNS:
116F: 9F 56    CALL  0x10C7        (1033) ;     none
1171: 20       POP   X             (1034) ;
1172: 18       POP   A             (1035) ;  SIDE EFFECTS:
1173: 75       INC   X             (1036) ;    The A and X registers may be modified by this or future implementations
1174: DF F5    JNC   0x116A        (1037) ;    of this function.  The same is true for all RAM page pointer registers in
1176: 74       INC   A             (1038) ;    the Large Memory Model.  When necessary, it is the calling function's
1177: 8F F2    JMP   0x116A        (1039) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1040) ;    functions.
                                   (1041) ;          
                                   (1042) ;    Currently only the page pointer registers listed below are modified: 
1179: 38 FE    ADD   SP,254        (1043) ;          IDX_PP
                                   (1044) ;
117B: 7F       RET                 (1045)  COMP_SERIAL_PutString:
                                   (1046) _COMP_SERIAL_PutString:
                                   (1047)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (1048)    RAM_SETPAGE_IDX A
                                   (1049) .PutStringLoop:
                                   (1050)    mov   A,[X]                                   ; Get value pointed to by X
                                   (1051)    jz    End_PutString                           ; Check for end of string
                                   (1052)    call  COMP_SERIAL_PutChar                     ; Send character to Tx port
                                   (1053)    inc   X                                       ; Advance pointer to next character
                                   (1054)    jmp   .PutStringLoop                          ; Get next character
                                   (1055) 
                                   (1056) End_PutString:
                                   (1057)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (1058)    ret
                                   (1059) .ENDSECTION
                                   (1060)     
                                   (1061) .SECTION
                                   (1062) ;-----------------------------------------------------------------------------
                                   (1063) ;  FUNCTION NAME: COMP_SERIAL_Write
                                   (1064) ;
                                   (1065) ;  DESCRIPTION:
                                   (1066) ;     Send String of length X to serial port
                                   (1067) ;-----------------------------------------------------------------------------
                                   (1068) ;
                                   (1069) ;  ARGUMENTS:
                                   (1070) ;     Pointer to String
                                   (1071) ;     [SP-5] Count of characters to send
                                   (1072) ;     [SP-4] has MSB of string address
117C: 50 0D    MOV   A,13          (1073) ;     [SP-3] has LSB of string address
117E: 9F 47    CALL  0x10C7        (1074) ;
1180: 50 0A    MOV   A,10          (1075) ;  RETURNS:
1182: 9F 43    CALL  0x10C7        (1076) ;     none
                                   (1077) ;
1184: 7F       RET                 (1078) ;  SIDE EFFECTS:
                                   (1079) ;    The A and X registers may be modified by this or future implementations
                                   (1080) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1081) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1082) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1083) ;    functions.
                                   (1084) ;          
                                   (1085) ;    Currently only the page pointer registers listed below are modified: 
                                   (1086) ;          IDX_PP
                                   (1087) ;
                                   (1088) CNT_LEN:    equ -5                               ; Length of data to send
                                   (1089) STR_MSB:    equ -4                               ; MSB pointer of string 
                                   (1090) STR_LSB:    equ -3                               ; LSB pointer of string 
                                   (1091) 
                                   (1092)  COMP_SERIAL_Write:
                                   (1093) _COMP_SERIAL_Write:
                                   (1094)    RAM_PROLOGUE RAM_USE_CLASS_3
                                   (1095)    RAM_SETPAGE_IDX2STK                           ; Refer indexed addrs to the stack
                                   (1096)    mov   X, SP                                   ; Establish the frame pointer 
                                   (1097) 
                                   (1098) .NextByteLoop:
                                   (1099)    mov   A, [X+CNT_LEN]                          ; End of the string?
                                   (1100)    jz    .End_Write                              ;   Yes, prepare to exit
                                   (1101)    dec   [X+CNT_LEN]                             ; Decrement counter
                                   (1102) 
                                   (1103)    IF SYSTEM_LARGE_MEMORY_MODEL
                                   (1104)    mov   A, [X+STR_MSB]                          ; Load pointer to char to send
                                   (1105)    ENDIF
                                   (1106) 
                                   (1107)    mov   X, [X+STR_LSB]                          ; Load pointer to char to send
                                   (1108)    RAM_SETPAGE_IDX A                             ; switch index pages
                                   (1109)    mov   A, [X]                                  ; Grab the data
                                   (1110)    InLinePutChar A                               ; Put data in empty TX buf reg
                                   (1111)    mov   X, SP                                   ; Recover frame pointer
                                   (1112)    RAM_SETPAGE_IDX2STK                           ; Prepare for stack access
                                   (1113)    inc   [X+STR_LSB]                             ; Point to next byte, but do not
                                   (1114)    jmp   .NextByteLoop                           ;    cross RAM page boundary!
                                   (1115) 
                                   (1116) .End_Write:
                                   (1117)    RAM_EPILOGUE RAM_USE_CLASS_3
                                   (1118)    ret
                                   (1119) .ENDSECTION
                                   (1120)     
1185: 62 D0 00 MOV   REG[208],0    (1121) 
1188: 55 0B 00 MOV   [11],0        (1122) .SECTION
118B: 62 D0 00 MOV   REG[208],0    (1123) ;-----------------------------------------------------------------------------
118E: 55 0A 00 MOV   [10],0        (1124) ;  FUNCTION NAME: COMP_SERIAL_CWrite
1191: 26 09 00 AND   [9],0         (1125) ;
1194: 62 D0 00 MOV   REG[208],0    (1126) ;             WARNING WARNING NOT COMPLETE
1197: 55 A8 00 MOV   [168],0       (1127) ;
                                   (1128) ;  DESCRIPTION:
119A: 7F       RET                 (1129) ;     Send String of length X to serial port
                                   (1130) ;-----------------------------------------------------------------------------
                                   (1131) ;
                                   (1132) ;  ARGUMENTS:
                                   (1133) ;     [SP-4] MSB of Count of character to send
                                   (1134) ;     [SP-3] LSB of Count of character to send
                                   (1135) ;     [SP-2] has MSB of string address
                                   (1136) ;     [SP-1] has LSB of string address
                                   (1137) ;
                                   (1138) ;  RETURNS:
                                   (1139) ;     none
                                   (1140) ;
                                   (1141) ;  SIDE EFFECTS:
                                   (1142) ;    The A and X registers may be modified by this or future implementations
                                   (1143) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1144) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1145) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1146) ;    functions.
                                   (1147) ;
                                   (1148) CLEN_MSB:   equ -6           ; MSB Length of data to send
                                   (1149) CLEN_LSB:   equ -5           ; LSB Length of data to send
                                   (1150) CSTR_MSB:   equ -4           ; MSB pointer of string
                                   (1151) CSTR_LSB:   equ -3           ; LSB pointer of string
                                   (1152) 
                                   (1153)  COMP_SERIAL_CWrite:
                                   (1154) _COMP_SERIAL_CWrite:
                                   (1155)    RAM_PROLOGUE RAM_USE_CLASS_2
                                   (1156)    mov   X,SP
                                   (1157) .CW_Loop:
                                   (1158)    cmp   [X+CLEN_MSB],0x00                  ; Check for zero counter
                                   (1159)    jnz   .CW_WRITEIT
                                   (1160)    cmp   [X+CLEN_LSB],0x00
                                   (1161)    jz    .End_CWrite                        ; Leave if done
                                   (1162) 
                                   (1163) .CW_WRITEIT:                                
119B: 62 D0 00 MOV   REG[208],0    (1164)    push  X                                  ; Save frame pointer
119E: 51 09    MOV   A,[9]         (1165)    mov   A,[X+CSTR_MSB]
11A0: 21 01    AND   A,1           (1166)    mov   X,[X+CSTR_LSB]
                                   (1167)    romx                                     ; Get character from ROM
11A2: 7F       RET                 (1168)    InLinePutChar A                          ; Put data in empty TX buf reg
                                   (1169)    pop   X                                  ; Restore frame pointer
                                   (1170)    add   [X+CSTR_LSB],1                     ; Increment the string pointer
                                   (1171)    adc   [X+CSTR_MSB],0
                                   (1172)    sub   [X+CLEN_LSB],0x01                  ; Dec the counter
                                   (1173)    sbb   [X+CLEN_MSB],0x00
                                   (1174)    jmp   .CW_Loop
                                   (1175) 
                                   (1176) .End_CWrite:
                                   (1177)    RAM_EPILOGUE RAM_USE_CLASS_2
                                   (1178)    ret
                                   (1179) .ENDSECTION
                                   (1180) 
                                   (1181) 
                                   (1182) .SECTION
                                   (1183) ;-----------------------------------------------------------------------------
                                   (1184) ;  FUNCTION NAME: COMP_SERIAL_CPutString
                                   (1185) ;
                                   (1186) ;  DESCRIPTION:
                                   (1187) ;     Send String out through UART TX port.
                                   (1188) ;-----------------------------------------------------------------------------
                                   (1189) ;
                                   (1190) ;  ARGUMENTS:
                                   (1191) ;     Pointer to String
                                   (1192) ;     A has MSB of string address
                                   (1193) ;     X has LSB of string address
                                   (1194) ;
                                   (1195) ;  RETURNS:
                                   (1196) ;     none
                                   (1197) ;
                                   (1198) ;  SIDE EFFECTS:
                                   (1199) ;    The A and X registers may be modified by this or future implementations
                                   (1200) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1201) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1202) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1203) ;    functions.
                                   (1204) ;
                                   (1205)  COMP_SERIAL_CPutString:
                                   (1206) _COMP_SERIAL_CPutString:
                                   (1207)    RAM_PROLOGUE RAM_USE_CLASS_1
11A3: 62 D0 00 MOV   REG[208],0    (1208)    push  A                                       ; Store ROM pointer
11A6: 51 09    MOV   A,[9]         (1209)    push  X
11A8: 21 F0    AND   A,240         (1210)    romx                                          ; Get character from ROM
11AA: 26 09 0F AND   [9],15        (1211)    jz    .End_CPutString
                                   (1212)    call  COMP_SERIAL_PutChar                     ; Print character
11AD: 7F       RET                 (1213)    pop   X
                                   (1214)    pop   A
                                   (1215)    inc   X                                       ; Inc LSB of pointer
                                   (1216)    jnc   COMP_SERIAL_CPutString                  ; Check for carry
                                   (1217)    inc   A                                       ; Inc MSB of pointer
                                   (1218)    jmp   COMP_SERIAL_CPutString
                                   (1219) 
                                   (1220) 
                                   (1221) .End_CPutString:
                                   (1222)    add   SP, -2
                                   (1223)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1224)    ret
                                   (1225) .ENDSECTION
                                   (1226) 
                                   (1227) 
                                   (1228) .SECTION
                                   (1229) ;-----------------------------------------------------------------------------
                                   (1230) ;  FUNCTION NAME: COMP_SERIAL_PutCRLF
                                   (1231) ;
                                   (1232) ;  DESCRIPTION:
                                   (1233) ;     Send a CR and LF
                                   (1234) ;-----------------------------------------------------------------------------
                                   (1235) ;
                                   (1236) ;  ARGUMENTS:
                                   (1237) ;     none.
                                   (1238) ;
                                   (1239) ;  RETURNS:
                                   (1240) ;     none.
                                   (1241) ;
                                   (1242) ;  SIDE EFFECTS:
11AE: 62 D0 00 MOV   REG[208],0    (1243) ;    The A and X registers may be modified by this or future implementations
11B1: 51 0A    MOV   A,[10]        (1244) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1245) ;    the Large Memory Model.  When necessary, it is the calling function's
11B3: 7F       RET                 (1246) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1247) ;    functions.
                                   (1248) ;
                                   (1249)  COMP_SERIAL_PutCRLF:
                                   (1250) _COMP_SERIAL_PutCRLF:
                                   (1251)    RAM_PROLOGUE RAM_USE_CLASS_1
                                   (1252)    mov  A,0x0D                        ; Send CR
                                   (1253)    call COMP_SERIAL_PutChar
                                   (1254)    mov  A,0x0A                        ; Send LF
                                   (1255)    call COMP_SERIAL_PutChar
                                   (1256)    RAM_EPILOGUE RAM_USE_CLASS_1
                                   (1257)    ret
                                   (1258) .ENDSECTION
                                   (1259) 
                                   (1260) 
                                   (1261) IF (COMP_SERIAL_RXBUF_ENABLE)
                                   (1262) ;=============================================================================
                                   (1263) ;=============================================================================
                                   (1264) ;
                                   (1265) ;     Command Buffer commands
                                   (1266) ;
                                   (1267) ;=============================================================================
                                   (1268) ;=============================================================================
                                   (1269) 
                                   (1270) .SECTION
                                   (1271) ;-----------------------------------------------------------------------------
                                   (1272) ;  FUNCTION NAME: COMP_SERIAL_CmdReset
                                   (1273) ;
                                   (1274) ;  DESCRIPTION:
                                   (1275) ;     Reset command string and status flags
                                   (1276) ;-----------------------------------------------------------------------------
                                   (1277) ;
                                   (1278) ;  ARGUMENTS:
                                   (1279) ;     none.
                                   (1280) ;
                                   (1281) ;  RETURNS:
                                   (1282) ;     none.
                                   (1283) ;
                                   (1284) ;  SIDE EFFECTS:
                                   (1285) ;    The A and X registers may be modified by this or future implementations
                                   (1286) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1287) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1288) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1289) ;    functions.
                                   (1290) ;          
                                   (1291) ;    Currently only the page pointer registers listed below are modified: 
                                   (1292) ;          CUR_PP
                                   (1293) ;
                                   (1294) ;  THEORY of OPERATION or PROCEDURE:
                                   (1295) ;     Clear the command buffer, command counter, and flag.
                                   (1296) ;
                                   (1297)  COMP_SERIAL_CmdReset:
                                   (1298) _COMP_SERIAL_CmdReset:
                                   (1299)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1300)    RAM_SETPAGE_CUR >COMP_SERIAL_aRxBuffer
11B4: 70 BF    AND   F,191         (1301)    mov [COMP_SERIAL_aRxBuffer], 0x00
                                   (1302)    RAM_SETPAGE_CUR >COMP_SERIAL_bRxCnt
11B6: 62 D0 00 MOV   REG[208],0    (1303)    mov [COMP_SERIAL_bRxCnt], 0x00
11B9: 50 0B    MOV   A,11          (1304)    and [COMP_SERIAL_fStatus], 0x00
11BB: 02 A8    ADD   A,[168]       (1305)    RAM_SETPAGE_CUR >ptrParam
11BD: 5C       MOV   X,A           (1306)    mov [ptrParam],0x00
11BE: 62 D3 00 MOV   REG[211],0    (1307)    RAM_EPILOGUE RAM_USE_CLASS_4
11C1: 52 00    MOV   A,[X+0]       (1308)    ret
11C3: B0 04    JNZ   0x11C8        (1309) .ENDSECTION
11C5: 10       PUSH  X             (1310) 
11C6: 80 33    JMP   0x11FA        (1311) 
                                   (1312) .SECTION
                                   (1313) ;-----------------------------------------------------------------------------
                                   (1314) ;  FUNCTION NAME: COMP_SERIAL_bCmdCheck
11C8: 39 2C    CMP   A,44          (1315) ;
11CA: B0 11    JNZ   0x11DC        (1316) ;  DESCRIPTION:
11CC: 75       INC   X             (1317) ;     Check to see if valid command in buffer.
11CD: 76 A8    INC   [168]         (1318) ;-----------------------------------------------------------------------------
11CF: 52 00    MOV   A,[X+0]       (1319) ;
11D1: 3C A8 3F CMP   [168],63      (1320) ;  ARGUMENTS:
11D4: BF F3    JNZ   0x11C8        (1321) ;     none.
                                   (1322) ;
                                   (1323) ;  RETURNS:
11D6: 10       PUSH  X             (1324) ;     BYTE  fStatus - Status of command receive buffer.
                                   (1325) ;                     Returns non-zero value in A if command is valid.
11D7: 56 00 00 MOV   [X+0],0       (1326) ;
11DA: 80 1F    JMP   0x11FA        (1327) ;  SIDE EFFECTS:
                                   (1328) ;    The A and X registers may be modified by this or future implementations
                                   (1329) ;    of this function.  The same is true for all RAM page pointer registers in
11DC: 10       PUSH  X             (1330) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1331) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1332) ;    functions.
11DD: 75       INC   X             (1333) ;          
11DE: 76 A8    INC   [168]         (1334) ;    Currently only the page pointer registers listed below are modified: 
11E0: 3C A8 3F CMP   [168],63      (1335) ;          CUR_PP
11E3: AF F3    JZ    0x11D7        (1336) ;
11E5: 52 00    MOV   A,[X+0]       (1337) ;  THEORY of OPERATION or PROCEDURE:
11E7: A0 12    JZ    0x11FA        (1338) ;     Read the status and control register.
11E9: 39 2C    CMP   A,44          (1339) ;
11EB: BF F1    JNZ   0x11DD        (1340)  COMP_SERIAL_bCmdCheck:
11ED: 56 00 00 MOV   [X+0],0       (1341) _COMP_SERIAL_bCmdCheck:
11F0: 76 A8    INC   [168]         (1342)    RAM_PROLOGUE RAM_USE_CLASS_4
11F2: 3C A8 3F CMP   [168],63      (1343)    RAM_SETPAGE_CUR >COMP_SERIAL_fStatus
11F5: B0 04    JNZ   0x11FA        (1344)    mov A,  [COMP_SERIAL_fStatus]
11F7: 55 A8 3F MOV   [168],63      (1345)    and A, COMP_SERIAL_RX_BUF_CMDTERM             ; Mask off Command status
                                   (1346)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1347)    ret
11FA: 20       POP   X             (1348) .ENDSECTION
11FB: 10       PUSH  X             (1349)     
11FC: 3D 00 00 CMP   [X+0],0       (1350) 
11FF: B0 0B    JNZ   0x120B        (1351) .SECTION
1201: 20       POP   X             (1352) ;-----------------------------------------------------------------------------
1202: 57 00    MOV   X,0           (1353) ;  FUNCTION NAME: COMP_SERIAL_bErrCheck
1204: 50 00    MOV   A,0           (1354) ;
1206: 70 3F    AND   F,63
1208: 71 C0    OR    F,192         (1355) ;  DESCRIPTION:
                                   (1356) ;     Check to see if an error has occured since last CmdReset
120A: 7F       RET                 (1357) ;-----------------------------------------------------------------------------
                                   (1358) ;
                                   (1359) ;  ARGUMENTS:
120B: 20       POP   X             (1360) ;     none.
120C: 50 00    MOV   A,0           (1361) ;
120E: 70 3F    AND   F,63
1210: 71 C0    OR    F,192         (1362) ;  RETURNS:
                                   (1363) ;     BYTE  fStatus - Status of command receive buffer.
1212: 7F       RET                 (1364) ;                     Returns non-zero value in A if command is valid.
                                   (1365) ;           0x80 => Parity Error
                                   (1366) ;           0x40 => OverRun Error
                                   (1367) ;           0x20 => Framing Error
                                   (1368) ;           0x10 => Software Buffer OverRun
                                   (1369) ;
                                   (1370) ;  SIDE EFFECTS:
                                   (1371) ;    The A and X registers may be modified by this or future implementations
                                   (1372) ;    of this function.  The same is true for all RAM page pointer registers in
                                   (1373) ;    the Large Memory Model.  When necessary, it is the calling function's
                                   (1374) ;    responsibility to perserve their values across calls to fastcall16 
                                   (1375) ;    functions.
                                   (1376) ;          
                                   (1377) ;    Currently only the page pointer registers listed below are modified: 
                                   (1378) ;          CUR_PP
                                   (1379) ;     Error Status is clear when read.
                                   (1380) ;
                                   (1381) ;  THEORY of OPERATION or PROCEDURE:
                                   (1382) ;     Read RX buffer error status and clear status
                                   (1383) ;
                                   (1384)  COMP_SERIAL_bErrCheck:
                                   (1385) _COMP_SERIAL_bErrCheck:
                                   (1386)    RAM_PROLOGUE RAM_USE_CLASS_4
                                   (1387)    RAM_SETPAGE_CUR >COMP_SERIAL_fStatus
                                   (1388)    mov A,  [COMP_SERIAL_fStatus]
                                   (1389)    and A, COMP_SERIAL_RX_BUF_ERROR               ; Mask off Error status
                                   (1390)    and [COMP_SERIAL_fStatus], ~COMP_SERIAL_RX_BUF_ERROR
                                   (1391)    RAM_EPILOGUE RAM_USE_CLASS_4
                                   (1392)    ret
                                   (1393) .ENDSECTION
                                   (1394) 
1213: 62 D0 00 MOV   REG[208],0    (1395) .SECTION
1216: 50 0B    MOV   A,11          (1396) ;-----------------------------------------------------------------------------
1218: 02 A8    ADD   A,[168]       (1397) ;  FUNCTION NAME: COMP_SERIAL_bCmdLength
121A: 5C       MOV   X,A           (1398) ;
121B: 50 00    MOV   A,0           (1399) ;  DESCRIPTION:
                                   (1400) ;     Get length of command string
__text_start:
_main:
121E: 62 D0 00 MOV   REG[208],0    (1401) ;-----------------------------------------------------------------------------
1221: 55 A3 00 MOV   [NUM_MODULES+1],0
1224: 55 A2 00 MOV   [NUM_MODULES],0

FILE: C:\Users\Admin\DOCUME~1\PSOCDE~1.0PR\FAKEMA~1\FAKEMA~1\FAKEMA~1\main.c
(0126) // Author: Jason Tennyson
1227: 62 D0 00 MOV   REG[208],0
122A: 55 A1 00 MOV   [STATE+1],0
122D: 55 A0 00 MOV   [STATE],0
(0127) // Date: 7-10-11
(0128) // File: main.c
(0129) //
1230: 43 E0 20 OR    REG[224],32
(0130) // This is the design for the parent module of Jason Tennyson's Thesis.
(0131) // This design is made for a PSoC CY8C28433-24PVXI.
(0132) //
1233: 71 01    OR    F,1
(0133) // Controller Packet Structure (each field is a byte)
(0134) // -----------------------------------------------------
(0135) // All Packets:
1235: 7C 1E 59 LCALL _unloadAllConfigs
(0136) // START BYTE/START BYTE/SOURCE ID/DESTINATION ID/COMMAND TYPE/PARAM 1/.../PARAM N/END TRANSMIT
(0137) //
(0138) // Servo Packet Structure (each field is a byte)
1238: 7C 21 E7 LCALL _bootWait
123B: 80 21    JMP   0x125D
(0139) // -----------------------------------------------------
(0140) // Source Packets:
(0141) // START BYTE/START BYTE/DESTINATION ID/LENGTH/COMMAND TYPE/PARAM 1/.../PARAM N/CHECKSUM
(0142) //
(0143) // Return Packets:
123D: 62 D0 00 MOV   REG[208],0
1240: 3C A2 00 CMP   [NUM_MODULES],0
1243: B0 0B    JNZ   0x124F
1245: 3C A3 00 CMP   [NUM_MODULES+1],0
1248: B0 06    JNZ   0x124F
(0144) // START BYTE/START BYTE/SOURCE ID/LENGTH/ERROR/PARAM1/.../PARAM N/CHECKSUM
(0145) 
124A: 7C 1E 80 LCALL _initializeChildren
(0146) #include <m8c.h>        	// Part-specific constants and macros.
124D: 80 0F    JMP   0x125D
(0147) #include "PSoCAPI.h"    	// PSoC API definitions for all User Modules.
124F: 10       PUSH  X
1250: 7C 11 9B LCALL 0x119B
1253: 62 D0 00 MOV   REG[208],0
1256: 20       POP   X
1257: 39 00    CMP   A,0
1259: A0 03    JZ    0x125D
(0148) #include "psocdynamic.h"	// Required for dynamically swapping configurations at run time.
(0149) #include <stdlib.h>			// Required for converting character arrays to and from floats and ints.
125B: 93 30    CALL  _decodeTransmission
125D: 8F DF    JMP   0x123D
125F: 8F FF    JMP   0x125F
(0150) 
(0151) //#include <string.h>
(0152) 
(0153) // These are declarations of all of the timer interrupts that are used for all configurations.
(0154) #pragma interrupt_handler TX_TIMEOUT_ISR
(0155) #pragma interrupt_handler RX_TIMEOUT_ISR
_pingModule:
  module_id            --> X-5
1261: 10       PUSH  X
1262: 4F       MOV   X,SP
(0156) 
(0157) // These defines are used as parameters of the configToggle function.
1263: 50 00    MOV   A,0
1265: 08       PUSH  A
1266: 50 01    MOV   A,1
1268: 08       PUSH  A
1269: 7C 1D B2 LCALL _configToggle
126C: 38 FE    ADD   SP,254
(0158) // Passing one or the other in the function call switches the system between PC and RX modes.
(0159) #define		PC_MODE						(1)
(0160) #define		RX_MODE						(2)
126E: 10       PUSH  X
126F: 50 FC    MOV   A,252
1271: 7C 09 75 LCALL 0x0975
1274: 20       POP   X
(0161) 
1275: 10       PUSH  X
1276: 50 FC    MOV   A,252
1278: 7C 08 9C LCALL 0x089C
127B: 20       POP   X
(0162) // These defines are used as comparisons to find what port the newest module is connected to.
127C: 10       PUSH  X
127D: 50 FC    MOV   A,252
127F: 7C 09 75 LCALL 0x0975
1282: 20       POP   X
(0163) #define		PORT_1						('1')
1283: 10       PUSH  X
1284: 50 FC    MOV   A,252
1286: 7C 08 9C LCALL 0x089C
1289: 20       POP   X
(0164) #define		PORT_2						('2')
128A: 10       PUSH  X
128B: 50 00    MOV   A,0
128D: 7C 09 75 LCALL 0x0975
1290: 20       POP   X
(0165) #define		PORT_3						('3')
1291: 10       PUSH  X
1292: 50 00    MOV   A,0
1294: 7C 08 9C LCALL 0x089C
1297: 20       POP   X
(0166) #define		PORT_4						('4')
1298: 62 D0 00 MOV   REG[208],0
129B: 52 FC    MOV   A,[X-4]
129D: 10       PUSH  X
129E: 7C 09 75 LCALL 0x0975
12A1: 20       POP   X
(0167) 
12A2: 62 D0 00 MOV   REG[208],0
12A5: 52 FC    MOV   A,[X-4]
12A7: 10       PUSH  X
12A8: 7C 08 9C LCALL 0x089C
12AB: 20       POP   X
(0168) // This is the module type identifier.
12AC: 10       PUSH  X
12AD: 50 CB    MOV   A,203
12AF: 7C 09 75 LCALL 0x0975
12B2: 20       POP   X
(0169) #define		TYPE						('2')
12B3: 10       PUSH  X
12B4: 50 CB    MOV   A,203
12B6: 7C 08 9C LCALL 0x089C
12B9: 20       POP   X
(0170) 
12BA: 10       PUSH  X
12BB: 50 FD    MOV   A,253
12BD: 7C 09 75 LCALL 0x0975
12C0: 20       POP   X
(0171) // These defines are used as transmission indicators.
12C1: 10       PUSH  X
12C2: 50 FD    MOV   A,253
12C4: 7C 08 9C LCALL 0x089C
12C7: 20       POP   X
(0172) #define		START_TRANSMIT				(252)	// Indicates the beginning of a transmission.
12C8: 10       PUSH  X
12C9: 50 FD    MOV   A,253
12CB: 7C 09 75 LCALL 0x0975
12CE: 20       POP   X
(0173) #define		END_TRANSMIT				(253)	// Indicates the end of a transmission.
12CF: 10       PUSH  X
12D0: 50 FD    MOV   A,253
12D2: 7C 08 9C LCALL 0x089C
12D5: 20       POP   X
(0174) #define		COMMAND_TYPE_SPACE			(200)	// The number where reserved command types start.
(0175) #define		HELLO_BYTE					(200)	// Indicates parent is ready to talk.
(0176) #define		ID_ASSIGNMENT				(201)	// Indicates an ID assignment from the parent.
12D6: 7C 22 01 LCALL _xmitWait
(0177) #define		ID_ASSIGN_OK				(202)	// Indicates an ID assignment is acknowledged.
(0178) #define		PING						(203)	// Indicates that someone is pinging someone else.
(0179) #define		CLEAR_CONFIG				(204)	// Indicates that the parent is asking for a config clear.
12D9: 50 00    MOV   A,0
12DB: 08       PUSH  A
12DC: 50 02    MOV   A,2
12DE: 08       PUSH  A
12DF: 7C 1D B2 LCALL _configToggle
12E2: 38 FE    ADD   SP,254
12E4: 80 41    JMP   0x1326
(0180) #define		CONFIG_CLEARED				(205)	// Indicates that a module has cleared its own config.
(0181) #define		PARENT_ID					(0)		// The parent node's ID.
(0182) #define		BROADCAST					(254)	// The broadcast ID for talking to all nodes.
(0183) #define		BLANK_MODULE_ID				(251)	// This is the ID of an unconfigured module.
(0184) #define		SERVO_START					(255)	// The start byte of a servo.
12E6: 91 DD    CALL  _validTransmission
12E8: 62 D0 00 MOV   REG[208],0
12EB: 3C 9D 00 CMP   [__r0],0
12EE: B0 06    JNZ   0x12F5
12F0: 3C 9C 00 CMP   [__r1],0
12F3: A0 32    JZ    0x1326
(0185) 
(0186) // These defines are used to fill in the instruction we are using on the servo.
(0187) #define		PING_SERVO					(1)		// This is the instruction number for ping.
12F5: 62 D0 00 MOV   REG[208],0
12F8: 3C A9 CB CMP   [COMMAND_TYPE],203
12FB: B0 2A    JNZ   0x1326
(0188) #define		READ_SERVO					(2)		// This is the instruction number for a read.
(0189) #define		WRITE_SERVO					(3)		// This is the instruction number for a write.
(0190) #define		RESET_SERVO					(6)		// This is the instruction to reset the servo EEPROM.
12FD: 62 D0 00 MOV   REG[208],0
1300: 3C AA 00 CMP   [COMMAND_DESTINATION],0
1303: B0 22    JNZ   0x1326
(0191) 
(0192) // These defines are used for transmission timing.
(0193) #define 	RX_TIMEOUT_DURATION			(5)		// This is receive wait time in 1 ms units.
1305: 62 D0 00 MOV   REG[208],0
1308: 51 AB    MOV   A,[COMMAND_SOURCE]
130A: 62 D0 00 MOV   REG[208],0
130D: 53 9C    MOV   [__r1],A
130F: 50 00    MOV   A,0
1311: 3B FB    CMP   A,[X-5]
1313: B0 12    JNZ   0x1326
1315: 51 9C    MOV   A,[__r1]
1317: 3B FC    CMP   A,[X-4]
1319: B0 0C    JNZ   0x1326
(0194) 
(0195) // These defines are used for the initial probing stage.
131B: 62 D0 00 MOV   REG[208],0
131E: 55 9C 01 MOV   [__r1],1
1321: 55 9D 00 MOV   [__r0],0
1324: 80 27    JMP   0x134C
1326: 62 D0 00 MOV   REG[208],0
1329: 51 9F    MOV   A,[TIMEOUT+1]
132B: 11 05    SUB   A,5
132D: 51 9E    MOV   A,[TIMEOUT]
132F: 31 80    XOR   A,128
1331: 19 80    SBB   A,128
1333: CF B2    JC    0x12E6
(0196) #define		BOOT_WAIT_TIME				(500)	// The time in milliseconds to wait at startup.
(0197) #define		INIT_WAIT_TIME				(2)		// Initial wait time between module probes.
(0198) #define		MAX_TIMEOUTS				(50)	// Number of timeouts allowed before hello mode exit.
(0199) 
(0200) // This is the maximum number of allowable modules per branch out from the parent.
(0201) #define		MAX_MODULES					(250)
(0202) 
1335: 10       PUSH  X
1336: 7C 0A 06 LCALL 0x0A06
1339: 20       POP   X
(0203) // Receives a mode identifier and toggles to that mode.
133A: 62 D0 00 MOV   REG[208],0
133D: 55 9F 00 MOV   [TIMEOUT+1],0
1340: 55 9E 00 MOV   [TIMEOUT],0
(0204) void configToggle(int mode);
(0205) // Pings the index passed to it. Returns 1 on success, 0 on fail.
1343: 62 D0 00 MOV   REG[208],0
1346: 55 9C 00 MOV   [__r1],0
1349: 55 9D 00 MOV   [__r0],0
134C: 20       POP   X
134D: 7F       RET   
(0206) int pingModule(int module_id);
(0207) // Assigns an ID to a module.
(0208) int assignID(int assigned_ID);
(0209) // Attempts to read a valid transmission and store it.
_assignID:
  assigned_ID          --> X-5
134E: 10       PUSH  X
134F: 4F       MOV   X,SP
(0210) int validTransmission(void);
(0211) // Reads a PC command and translates it to the correct packet type.
1350: 50 00    MOV   A,0
1352: 08       PUSH  A
1353: 50 01    MOV   A,1
1355: 08       PUSH  A
1356: 7C 1D B2 LCALL _configToggle
1359: 38 FE    ADD   SP,254
(0212) void decodeTransmission(void);
(0213) // Sends out a hello message packet.
(0214) void sayHello(void);
135B: 10       PUSH  X
135C: 50 FC    MOV   A,252
135E: 7C 09 75 LCALL 0x0975
1361: 20       POP   X
(0215) // Servo instruction function that sends read or write commands.
1362: 10       PUSH  X
1363: 50 FC    MOV   A,252
1365: 7C 08 9C LCALL 0x089C
1368: 20       POP   X
(0216) void servoInstruction(char id, char length, char instruction, char address, char value);
1369: 10       PUSH  X
136A: 50 FC    MOV   A,252
136C: 7C 09 75 LCALL 0x0975
136F: 20       POP   X
(0217) // Servo instruction function that sends long two-byte write commands.
1370: 10       PUSH  X
1371: 50 FC    MOV   A,252
1373: 7C 08 9C LCALL 0x089C
1376: 20       POP   X
(0218) void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2);
1377: 10       PUSH  X
1378: 50 00    MOV   A,0
137A: 7C 09 75 LCALL 0x0975
137D: 20       POP   X
(0219) // Immediately performs a non-blocking read char operation, and returns 0 upon failure.
137E: 10       PUSH  X
137F: 50 00    MOV   A,0
1381: 7C 08 9C LCALL 0x089C
1384: 20       POP   X
(0220) char iReadChar(void);
1385: 10       PUSH  X
1386: 50 FB    MOV   A,251
1388: 7C 09 75 LCALL 0x0975
138B: 20       POP   X
(0221) // Performs a blocking read char operation.
138C: 10       PUSH  X
138D: 50 FB    MOV   A,251
138F: 7C 08 9C LCALL 0x089C
1392: 20       POP   X
(0222) char readChar(void);
1393: 10       PUSH  X
1394: 50 C9    MOV   A,201
1396: 7C 09 75 LCALL 0x0975
1399: 20       POP   X
(0223) // Checks the current mode and unloads the configuration for that mode.
139A: 10       PUSH  X
139B: 50 C9    MOV   A,201
139D: 7C 08 9C LCALL 0x089C
13A0: 20       POP   X
(0224) void unloadAllConfigs(void);
13A1: 62 D0 00 MOV   REG[208],0
13A4: 52 FC    MOV   A,[X-4]
13A6: 10       PUSH  X
13A7: 7C 09 75 LCALL 0x0975
13AA: 20       POP   X
(0225) // Unloads the configuration corresponding to the number passed to it.
13AB: 62 D0 00 MOV   REG[208],0
13AE: 52 FC    MOV   A,[X-4]
13B0: 10       PUSH  X
13B1: 7C 08 9C LCALL 0x089C
13B4: 20       POP   X
(0226) void unloadConfig(int config_num);
13B5: 10       PUSH  X
13B6: 50 FD    MOV   A,253
13B8: 7C 09 75 LCALL 0x0975
13BB: 20       POP   X
(0227) // Initialization function for the child module controllers.
13BC: 10       PUSH  X
13BD: 50 FD    MOV   A,253
13BF: 7C 08 9C LCALL 0x089C
13C2: 20       POP   X
(0228) void initializeChildren(void);
13C3: 10       PUSH  X
13C4: 50 FD    MOV   A,253
13C6: 7C 09 75 LCALL 0x0975
13C9: 20       POP   X
(0229) // Static wait time of approximately 50 microseconds for use after starting a transmission.
13CA: 10       PUSH  X
13CB: 50 FD    MOV   A,253
13CD: 7C 08 9C LCALL 0x089C
13D0: 20       POP   X
(0230) void xmitWait(void);
(0231) // Wait before transmitting in the case of repetitive transmissions.
(0232) void preXmitWait(int currentState);
13D1: 7C 22 01 LCALL _xmitWait
(0233) // Function that waits for BOOT_WAIT_TIME milliseconds.
(0234) void bootWait(void);
(0235) // Listen for a child and record the port value.
13D4: 50 00    MOV   A,0
13D6: 08       PUSH  A
13D7: 50 02    MOV   A,2
13D9: 08       PUSH  A
13DA: 7C 1D B2 LCALL _configToggle
13DD: 38 FE    ADD   SP,254
13DF: 80 41    JMP   0x1421
(0236) int childListen(void);
(0237) 
(0238) int TIMEOUT;				// This flag is incremented if there is a timeout.
(0239) int NUM_MODULES;			// Stores the number of modules that have been discovered.
(0240) int STATE;					// Stores the current configuration state of the system.
13E1: 90 E2    CALL  _validTransmission
13E3: 62 D0 00 MOV   REG[208],0
13E6: 3C 9D 00 CMP   [__r0],0
13E9: B0 06    JNZ   0x13F0
13EB: 3C 9C 00 CMP   [__r1],0
13EE: A0 32    JZ    0x1421
(0241) char CHILD;					// The child port value stored from initialization.
(0242) 
(0243) char COMMAND_SOURCE;		// Stores who the current command is from.
13F0: 62 D0 00 MOV   REG[208],0
13F3: 3C A9 CA CMP   [COMMAND_TYPE],202
13F6: B0 2A    JNZ   0x1421
(0244) char COMMAND_DESTINATION;	// Stores who the current command is for.
(0245) char COMMAND_TYPE;			// Stores the type of command that was just read.
(0246) char PARAM[10];				// Stores a parameters that accompanies the command (if any).
13F8: 62 D0 00 MOV   REG[208],0
13FB: 3C AA 00 CMP   [COMMAND_DESTINATION],0
13FE: B0 22    JNZ   0x1421
(0247) 
(0248) void main()
(0249) {	
1400: 62 D0 00 MOV   REG[208],0
1403: 51 AB    MOV   A,[COMMAND_SOURCE]
1405: 62 D0 00 MOV   REG[208],0
1408: 53 9C    MOV   [__r1],A
140A: 50 00    MOV   A,0
140C: 3B FB    CMP   A,[X-5]
140E: B0 12    JNZ   0x1421
1410: 51 9C    MOV   A,[__r1]
1412: 3B FC    CMP   A,[X-4]
1414: B0 0C    JNZ   0x1421
(0250) 	NUM_MODULES = 0;	// Initialize the number of modules.
(0251) 	STATE = 0;			// Initialize the current hardware state.
1416: 62 D0 00 MOV   REG[208],0
1419: 55 9C 01 MOV   [__r1],1
141C: 55 9D 00 MOV   [__r0],0
141F: 80 27    JMP   0x1447
1421: 62 D0 00 MOV   REG[208],0
1424: 51 9F    MOV   A,[TIMEOUT+1]
1426: 11 05    SUB   A,5
1428: 51 9E    MOV   A,[TIMEOUT]
142A: 31 80    XOR   A,128
142C: 19 80    SBB   A,128
142E: CF B2    JC    0x13E1
(0252) 	
(0253) 	// Activate GPIO ISR.
(0254) 	M8C_EnableIntMask(INT_MSK0,INT_MSK0_GPIO);
(0255) 	
(0256) 	// Turn on global interrupts for the transmission timeout timer.
(0257) 	M8C_EnableGInt;
(0258) 	
1430: 10       PUSH  X
1431: 7C 0A 06 LCALL 0x0A06
1434: 20       POP   X
(0259) 	// Unload all of the configurations.
1435: 62 D0 00 MOV   REG[208],0
1438: 55 9F 00 MOV   [TIMEOUT+1],0
143B: 55 9E 00 MOV   [TIMEOUT],0
(0260) 	unloadAllConfigs();
(0261) 	
143E: 62 D0 00 MOV   REG[208],0
1441: 55 9C 00 MOV   [__r1],0
1444: 55 9D 00 MOV   [__r0],0
1447: 20       POP   X
1448: 7F       RET   
(0262) 	// Wait for every module to boot.
(0263) 	bootWait();
(0264) 	
(0265) 	while(1)
(0266) 	{
(0267) 		// If there are no modules, find some. Otherwise, look for computer commands.
(0268) 		if(!NUM_MODULES)
_sayHello:
1449: 50 00    MOV   A,0
144B: 08       PUSH  A
144C: 50 01    MOV   A,1
144E: 08       PUSH  A
144F: 7C 1D B2 LCALL _configToggle
1452: 38 FE    ADD   SP,254
(0269) 		{
(0270) 			initializeChildren();
(0271) 		}
1454: 10       PUSH  X
1455: 50 FC    MOV   A,252
1457: 7C 09 75 LCALL 0x0975
145A: 20       POP   X
(0272) 		else if(COMP_SERIAL_bCmdCheck())
145B: 10       PUSH  X
145C: 50 FC    MOV   A,252
145E: 7C 08 9C LCALL 0x089C
1461: 20       POP   X
(0273) 		{
1462: 10       PUSH  X
1463: 50 FC    MOV   A,252
1465: 7C 09 75 LCALL 0x0975
1468: 20       POP   X
(0274) 			decodeTransmission();
1469: 10       PUSH  X
146A: 50 FC    MOV   A,252
146C: 7C 08 9C LCALL 0x089C
146F: 20       POP   X
(0275) 		}
1470: 10       PUSH  X
1471: 50 00    MOV   A,0
1473: 7C 09 75 LCALL 0x0975
1476: 20       POP   X
(0276) 	}
1477: 10       PUSH  X
1478: 50 00    MOV   A,0
147A: 7C 08 9C LCALL 0x089C
147D: 20       POP   X
(0277) }
147E: 10       PUSH  X
147F: 50 FB    MOV   A,251
1481: 7C 09 75 LCALL 0x0975
1484: 20       POP   X
(0278) 
1485: 10       PUSH  X
1486: 50 FB    MOV   A,251
1488: 7C 08 9C LCALL 0x089C
148B: 20       POP   X
(0279) int pingModule(int module_id)
148C: 10       PUSH  X
148D: 50 C8    MOV   A,200
148F: 7C 09 75 LCALL 0x0975
1492: 20       POP   X
(0280) {
1493: 10       PUSH  X
1494: 50 C8    MOV   A,200
1496: 7C 08 9C LCALL 0x089C
1499: 20       POP   X
(0281) 	// Toggle into PC mode.
149A: 10       PUSH  X
149B: 50 FD    MOV   A,253
149D: 7C 09 75 LCALL 0x0975
14A0: 20       POP   X
(0282) 	configToggle(PC_MODE);
14A1: 10       PUSH  X
14A2: 50 FD    MOV   A,253
14A4: 7C 08 9C LCALL 0x089C
14A7: 20       POP   X
(0283) 	
14A8: 10       PUSH  X
14A9: 50 FD    MOV   A,253
14AB: 7C 09 75 LCALL 0x0975
14AE: 20       POP   X
(0284) 	// Transmit a ping to everyone.
14AF: 10       PUSH  X
14B0: 50 FD    MOV   A,253
14B2: 7C 08 9C LCALL 0x089C
14B5: 20       POP   X
(0285) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte one
(0286) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte one
(0287) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte two
14B6: 7C 22 01 LCALL _xmitWait
(0288) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte two
(0289) 	TX_REPEATER_14_PutChar(PARENT_ID);			// My ID
(0290) 	TX_REPEATER_23_PutChar(PARENT_ID);			// My ID
14B9: 50 00    MOV   A,0
14BB: 08       PUSH  A
14BC: 50 02    MOV   A,2
14BE: 08       PUSH  A
14BF: 7C 1D B2 LCALL _configToggle
14C2: 38 FE    ADD   SP,254
14C4: 7F       RET   
(0291) 	TX_REPEATER_14_PutChar(module_id);			// Destination ID
(0292) 	TX_REPEATER_23_PutChar(module_id);			// Destination ID
(0293) 	TX_REPEATER_14_PutChar(PING);				// This is a ping response
(0294) 	TX_REPEATER_23_PutChar(PING);				// This is a ping response
(0295) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
_validTransmission:
  i                    --> X+1
  tempByte             --> X+0
14C5: 10       PUSH  X
14C6: 4F       MOV   X,SP
14C7: 38 03    ADD   SP,3
(0296) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
14C9: 56 02 00 MOV   [X+2],0
14CC: 56 01 00 MOV   [X+1],0
(0297) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
14CF: 56 00 00 MOV   [X+0],0
14D2: 80 9E    JMP   0x1571
(0298) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
(0299) 	
(0300) 	// Make completely sure we're done.
(0301) 	xmitWait();
(0302) 	
(0303) 	// Switch to listening mode.
(0304) 	configToggle(RX_MODE);
14D4: 7C 21 4B LCALL _iReadChar
14D7: 62 D0 00 MOV   REG[208],0
14DA: 39 FC    CMP   A,252
14DC: B0 94    JNZ   0x1571
(0305) 	
14DE: 80 83    JMP   0x1562
(0306) 	// Listen for the response.
(0307) 	while(TIMEOUT < RX_TIMEOUT_DURATION)
(0308) 	{
(0309) 		if(validTransmission())
(0310) 		{
14E0: 7C 21 4B LCALL _iReadChar
14E3: 54 00    MOV   [X+0],A
14E5: 39 00    CMP   A,0
14E7: A0 7A    JZ    0x1562
(0311) 			// If the response is what we are looking for.
(0312) 			if(COMMAND_TYPE == PING)
(0313) 			{
14E9: 3D 00 FC CMP   [X+0],252
14EC: A0 75    JZ    0x1562
(0314) 				// If this is for me, check who it was from.
(0315) 				if(COMMAND_DESTINATION == PARENT_ID)
(0316) 				{
14EE: 52 00    MOV   A,[X+0]
14F0: 62 D0 00 MOV   REG[208],0
14F3: 53 AB    MOV   [COMMAND_SOURCE],A
14F5: 80 5D    JMP   0x1553
(0317) 					// If it's from the right module, return 1.
(0318) 					if(COMMAND_SOURCE == module_id)
(0319) 					{
(0320) 						return 1;
(0321) 					}
(0322) 				}
14F7: 7C 21 4B LCALL _iReadChar
14FA: 62 D0 00 MOV   REG[208],0
14FD: 54 00    MOV   [X+0],A
14FF: 39 00    CMP   A,0
1501: A0 51    JZ    0x1553
(0323) 			}
(0324) 		}
(0325) 	}
1503: 3D 00 C8 CMP   [X+0],200
1506: C0 4C    JC    0x1553
(0326) 
(0327) 	RX_TIMEOUT_Stop();
(0328) 	TIMEOUT = 0;
1508: 52 00    MOV   A,[X+0]
150A: 62 D0 00 MOV   REG[208],0
150D: 53 A9    MOV   [COMMAND_TYPE],A
150F: 80 34    JMP   0x1544
(0329) 	
(0330) 	return 0;
(0331) }
(0332) 
(0333) int assignID(int assigned_ID)
(0334) {	
1511: 7C 21 4B LCALL _iReadChar
1514: 62 D0 00 MOV   REG[208],0
1517: 54 00    MOV   [X+0],A
1519: 39 00    CMP   A,0
151B: A0 28    JZ    0x1544
(0335) 	// Switch to PC mode.
(0336) 	configToggle(PC_MODE);
(0337) 
151D: 3D 00 FD CMP   [X+0],253
1520: A0 18    JZ    0x1539
(0338) 	// Transmit an ID assignment.
(0339) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte one
1522: 52 02    MOV   A,[X+2]
1524: 01 8B    ADD   A,139
1526: 53 9C    MOV   [__r1],A
1528: 52 01    MOV   A,[X+1]
152A: 09 00    ADC   A,0
152C: 60 D5    MOV   REG[213],A
152E: 52 00    MOV   A,[X+0]
1530: 3F 9C    MVI   [__r1],A
(0340) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte one
1532: 77 02    INC   [X+2]
1534: 0F 01 00 ADC   [X+1],0
(0341) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte two
1537: 80 0C    JMP   0x1544
(0342) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte two
(0343) 	TX_REPEATER_14_PutChar(PARENT_ID);			// My ID
(0344) 	TX_REPEATER_23_PutChar(PARENT_ID);			// My ID
1539: 62 D0 00 MOV   REG[208],0
153C: 55 9C 01 MOV   [__r1],1
153F: 55 9D 00 MOV   [__r0],0
1542: 80 46    JMP   0x1589
1544: 62 D0 00 MOV   REG[208],0
1547: 51 9F    MOV   A,[TIMEOUT+1]
1549: 11 05    SUB   A,5
154B: 51 9E    MOV   A,[TIMEOUT]
154D: 31 80    XOR   A,128
154F: 19 80    SBB   A,128
1551: CF BF    JC    0x1511
1553: 62 D0 00 MOV   REG[208],0
1556: 51 9F    MOV   A,[TIMEOUT+1]
1558: 11 05    SUB   A,5
155A: 51 9E    MOV   A,[TIMEOUT]
155C: 31 80    XOR   A,128
155E: 19 80    SBB   A,128
1560: CF 96    JC    0x14F7
1562: 62 D0 00 MOV   REG[208],0
1565: 51 9F    MOV   A,[TIMEOUT+1]
1567: 11 05    SUB   A,5
1569: 51 9E    MOV   A,[TIMEOUT]
156B: 31 80    XOR   A,128
156D: 19 80    SBB   A,128
156F: CF 70    JC    0x14E0
1571: 62 D0 00 MOV   REG[208],0
1574: 51 9F    MOV   A,[TIMEOUT+1]
1576: 11 05    SUB   A,5
1578: 51 9E    MOV   A,[TIMEOUT]
157A: 31 80    XOR   A,128
157C: 19 80    SBB   A,128
157E: CF 55    JC    0x14D4
(0345) 	TX_REPEATER_14_PutChar(BLANK_MODULE_ID);	// Destination ID
(0346) 	TX_REPEATER_23_PutChar(BLANK_MODULE_ID);	// Destination ID
(0347) 	TX_REPEATER_14_PutChar(ID_ASSIGNMENT);		// This is an ID assignment
(0348) 	TX_REPEATER_23_PutChar(ID_ASSIGNMENT);		// This is an ID assignment
(0349) 	TX_REPEATER_14_PutChar(assigned_ID);		// This is the new ID
(0350) 	TX_REPEATER_23_PutChar(assigned_ID);		// This is the new ID
(0351) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
(0352) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
(0353) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
(0354) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
(0355) 	
(0356) 	// Make completely sure we're done.
(0357) 	xmitWait();
1580: 62 D0 00 MOV   REG[208],0
1583: 55 9C 00 MOV   [__r1],0
1586: 55 9D 00 MOV   [__r0],0
1589: 38 FD    ADD   SP,253
158B: 20       POP   X
158C: 7F       RET   
(0358) 	
(0359) 	// Switch to listening mode.
(0360) 	configToggle(RX_MODE);
(0361) 	
(0362) 	// Listen for the response.
_decodeTransmission:
  speed                --> X+10
  angle                --> X+8
  total                --> X+6
  ID                   --> X+5
  runningTotal         --> X+3
  tempByte             --> X+2
  param                --> X+0
158D: 10       PUSH  X
158E: 4F       MOV   X,SP
158F: 38 0C    ADD   SP,12
(0363) 	while(TIMEOUT < RX_TIMEOUT_DURATION)
(0364) 	{
1591: 56 05 00 MOV   [X+5],0
(0365) 		if(validTransmission())
1594: 56 02 00 MOV   [X+2],0
(0366) 		{
(0367) 			// If this is the response we are looking for.
(0368) 			if(COMMAND_TYPE == ID_ASSIGN_OK)
1597: 56 07 00 MOV   [X+7],0
159A: 56 06 00 MOV   [X+6],0
(0369) 			{
159D: 56 04 00 MOV   [X+4],0
15A0: 56 03 00 MOV   [X+3],0
(0370) 				// If this is for me, check who it was from.
(0371) 				if(COMMAND_DESTINATION == PARENT_ID)
(0372) 				{
15A3: 10       PUSH  X
15A4: 7C 11 B4 LCALL 0x11B4
15A7: 62 D0 00 MOV   REG[208],0
15AA: 53 9D    MOV   [__r0],A
15AC: 5A 9C    MOV   [__r1],X
15AE: 20       POP   X
15AF: 51 9C    MOV   A,[__r1]
15B1: 54 01    MOV   [X+1],A
15B3: 51 9D    MOV   A,[__r0]
15B5: 54 00    MOV   [X+0],A
15B7: 3C 9D 00 CMP   [__r0],0
15BA: B0 06    JNZ   0x15C1
15BC: 3C 9C 00 CMP   [__r1],0
15BF: A6 1A    JZ    0x1BDA
(0373) 					// If it is from the right module, return 1.
(0374) 					if(COMMAND_SOURCE == assigned_ID)
15C1: 62 D0 00 MOV   REG[208],0
15C4: 52 01    MOV   A,[X+1]
15C6: 53 9C    MOV   [__r1],A
15C8: 52 00    MOV   A,[X+0]
15CA: 60 D4    MOV   REG[212],A
15CC: 3E 9C    MVI   A,[__r1]
15CE: 53 9C    MOV   [__r1],A
15D0: 55 9D 00 MOV   [__r0],0
15D3: 3C 9D 00 CMP   [__r0],0
15D6: B0 05    JNZ   0x15DC
15D8: 39 78    CMP   A,120
15DA: A0 0E    JZ    0x15E9
15DC: 62 D0 00 MOV   REG[208],0
15DF: 3C 9D 00 CMP   [__r0],0
15E2: B0 11    JNZ   0x15F4
15E4: 3C 9C 58 CMP   [__r1],88
15E7: B0 0C    JNZ   0x15F4
(0375) 					{
(0376) 						return 1;
(0377) 					}
15E9: 62 D0 00 MOV   REG[208],0
15EC: 55 A3 00 MOV   [NUM_MODULES+1],0
15EF: 55 A2 00 MOV   [NUM_MODULES],0
(0378) 				}
15F2: 85 E7    JMP   0x1BDA
(0379) 			}
15F4: 62 D0 00 MOV   REG[208],0
15F7: 52 01    MOV   A,[X+1]
15F9: 53 9C    MOV   [__r1],A
15FB: 52 00    MOV   A,[X+0]
15FD: 60 D4    MOV   REG[212],A
15FF: 3E 9C    MVI   A,[__r1]
1601: 53 9C    MOV   [__r1],A
1603: 55 9D 00 MOV   [__r0],0
1606: 3C 9D 00 CMP   [__r0],0
1609: B0 05    JNZ   0x160F
160B: 39 6E    CMP   A,110
160D: A0 0E    JZ    0x161C
160F: 62 D0 00 MOV   REG[208],0
1612: 3C 9D 00 CMP   [__r0],0
1615: B0 35    JNZ   0x164B
1617: 3C 9C 4E CMP   [__r1],78
161A: B0 30    JNZ   0x164B
(0380) 		}
(0381) 	}
161C: 50 00    MOV   A,0
161E: 08       PUSH  A
161F: 50 0A    MOV   A,10
1621: 08       PUSH  A
1622: 62 D0 00 MOV   REG[208],0
1625: 51 A2    MOV   A,[NUM_MODULES]
1627: 08       PUSH  A
1628: 51 A3    MOV   A,[NUM_MODULES+1]
162A: 08       PUSH  A
162B: 52 00    MOV   A,[X+0]
162D: 08       PUSH  A
162E: 52 01    MOV   A,[X+1]
1630: 08       PUSH  A
1631: 7C 25 34 LCALL _itoa
1634: 38 FA    ADD   SP,250
(0382) 	
1636: 10       PUSH  X
1637: 52 00    MOV   A,[X+0]
1639: 08       PUSH  A
163A: 52 01    MOV   A,[X+1]
163C: 5C       MOV   X,A
163D: 18       POP   A
163E: 7C 11 04 LCALL 0x1104
1641: 20       POP   X
(0383) 	RX_TIMEOUT_Stop();
1642: 10       PUSH  X
1643: 50 0A    MOV   A,10
1645: 7C 10 C7 LCALL 0x10C7
1648: 20       POP   X
(0384) 	TIMEOUT = 0;
1649: 85 90    JMP   0x1BDA
(0385) 	
164B: 62 D0 00 MOV   REG[208],0
164E: 52 01    MOV   A,[X+1]
1650: 53 9C    MOV   [__r1],A
1652: 52 00    MOV   A,[X+0]
1654: 60 D4    MOV   REG[212],A
1656: 3E 9C    MVI   A,[__r1]
1658: 53 9C    MOV   [__r1],A
165A: 55 9D 00 MOV   [__r0],0
165D: 3C 9D 00 CMP   [__r0],0
1660: B0 05    JNZ   0x1666
1662: 39 77    CMP   A,119
1664: A0 0E    JZ    0x1673
1666: 62 D0 00 MOV   REG[208],0
1669: 3C 9D 00 CMP   [__r0],0
166C: B2 14    JNZ   0x1881
166E: 3C 9C 57 CMP   [__r1],87
1671: B2 0F    JNZ   0x1881
(0386) 	return 0;
(0387) }
1673: 10       PUSH  X
1674: 7C 11 B4 LCALL 0x11B4
1677: 62 D0 00 MOV   REG[208],0
167A: 53 9D    MOV   [__r0],A
167C: 5A 9C    MOV   [__r1],X
167E: 20       POP   X
167F: 51 9C    MOV   A,[__r1]
1681: 54 01    MOV   [X+1],A
1683: 51 9D    MOV   A,[__r0]
1685: 54 00    MOV   [X+0],A
1687: 3C 9D 00 CMP   [__r0],0
168A: B0 06    JNZ   0x1691
168C: 3C 9C 00 CMP   [__r1],0
168F: A5 4A    JZ    0x1BDA
(0388) 
(0389) // This function transmits a hello message.
(0390) void sayHello(void)
1691: 52 00    MOV   A,[X+0]
1693: 08       PUSH  A
1694: 52 01    MOV   A,[X+1]
1696: 08       PUSH  A
1697: 7C 23 F3 LCALL _atoi
169A: 38 FE    ADD   SP,254
169C: 62 D0 00 MOV   REG[208],0
169F: 51 9C    MOV   A,[__r1]
16A1: 54 05    MOV   [X+5],A
(0391) {
(0392) 	// Toggle into PC mode.
16A3: 10       PUSH  X
16A4: 7C 11 B4 LCALL 0x11B4
16A7: 62 D0 00 MOV   REG[208],0
16AA: 53 9D    MOV   [__r0],A
16AC: 5A 9C    MOV   [__r1],X
16AE: 20       POP   X
16AF: 51 9C    MOV   A,[__r1]
16B1: 54 01    MOV   [X+1],A
16B3: 51 9D    MOV   A,[__r0]
16B5: 54 00    MOV   [X+0],A
16B7: 3C 9D 00 CMP   [__r0],0
16BA: B0 06    JNZ   0x16C1
16BC: 3C 9C 00 CMP   [__r1],0
16BF: A5 1A    JZ    0x1BDA
(0393) 	configToggle(PC_MODE);
(0394) 	
16C1: 62 D0 00 MOV   REG[208],0
16C4: 52 01    MOV   A,[X+1]
16C6: 53 9C    MOV   [__r1],A
16C8: 52 00    MOV   A,[X+0]
16CA: 60 D4    MOV   REG[212],A
16CC: 3E 9C    MVI   A,[__r1]
16CE: 53 9C    MOV   [__r1],A
16D0: 55 9D 00 MOV   [__r0],0
16D3: 3C 9D 00 CMP   [__r0],0
16D6: B0 05    JNZ   0x16DC
16D8: 39 61    CMP   A,97
16DA: A0 0E    JZ    0x16E9
16DC: 62 D0 00 MOV   REG[208],0
16DF: 3C 9D 00 CMP   [__r0],0
16E2: B0 84    JNZ   0x1767
16E4: 3C 9C 41 CMP   [__r1],65
16E7: B0 7F    JNZ   0x1767
(0395) 	// Transmit an ID assignment.
(0396) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte one
16E9: 10       PUSH  X
16EA: 7C 11 B4 LCALL 0x11B4
16ED: 62 D0 00 MOV   REG[208],0
16F0: 53 9D    MOV   [__r0],A
16F2: 5A 9C    MOV   [__r1],X
16F4: 20       POP   X
16F5: 51 9C    MOV   A,[__r1]
16F7: 54 01    MOV   [X+1],A
16F9: 51 9D    MOV   A,[__r0]
16FB: 54 00    MOV   [X+0],A
16FD: 3C 9D 00 CMP   [__r0],0
1700: B0 06    JNZ   0x1707
1702: 3C 9C 00 CMP   [__r1],0
1705: A4 D4    JZ    0x1BDA
(0397) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte one
(0398) 	TX_REPEATER_14_PutChar(START_TRANSMIT);	// Start byte two
(0399) 	TX_REPEATER_23_PutChar(START_TRANSMIT);		// Start byte two
1707: 52 00    MOV   A,[X+0]
1709: 08       PUSH  A
170A: 52 01    MOV   A,[X+1]
170C: 08       PUSH  A
170D: 7C 23 F3 LCALL _atoi
1710: 38 FE    ADD   SP,254
1712: 62 D0 00 MOV   REG[208],0
1715: 51 9C    MOV   A,[__r1]
1717: 54 07    MOV   [X+7],A
1719: 51 9D    MOV   A,[__r0]
171B: 54 06    MOV   [X+6],A
(0400) 	TX_REPEATER_14_PutChar(PARENT_ID);			// My ID
(0401) 	TX_REPEATER_23_PutChar(PARENT_ID);			// My ID
(0402) 	TX_REPEATER_14_PutChar(BLANK_MODULE_ID);	// Destination ID
171D: 50 01    MOV   A,1
171F: 08       PUSH  A
1720: 50 00    MOV   A,0
1722: 08       PUSH  A
1723: 52 06    MOV   A,[X+6]
1725: 08       PUSH  A
1726: 52 07    MOV   A,[X+7]
1728: 08       PUSH  A
1729: 7C 23 61 LCALL __divmod_16X16_16
172C: 38 FE    ADD   SP,254
172E: 18       POP   A
172F: 53 9C    MOV   [__r1],A
1731: 18       POP   A
1732: 51 9C    MOV   A,[__r1]
1734: 54 08    MOV   [X+8],A
(0403) 	TX_REPEATER_23_PutChar(BLANK_MODULE_ID);	// Destination ID
1736: 50 01    MOV   A,1
1738: 08       PUSH  A
1739: 50 00    MOV   A,0
173B: 08       PUSH  A
173C: 52 06    MOV   A,[X+6]
173E: 08       PUSH  A
173F: 52 07    MOV   A,[X+7]
1741: 08       PUSH  A
1742: 7C 23 61 LCALL __divmod_16X16_16
1745: 18       POP   A
1746: 53 9C    MOV   [__r1],A
1748: 18       POP   A
1749: 38 FE    ADD   SP,254
174B: 51 9C    MOV   A,[__r1]
174D: 54 09    MOV   [X+9],A
(0404) 	TX_REPEATER_14_PutChar(HELLO_BYTE);		// This is a hello message
(0405) 	TX_REPEATER_23_PutChar(HELLO_BYTE);			// This is a hello message
(0406) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
174F: 52 09    MOV   A,[X+9]
1751: 08       PUSH  A
1752: 52 08    MOV   A,[X+8]
1754: 08       PUSH  A
1755: 50 1E    MOV   A,30
1757: 08       PUSH  A
1758: 50 03    MOV   A,3
175A: 08       PUSH  A
175B: 50 05    MOV   A,5
175D: 08       PUSH  A
175E: 52 05    MOV   A,[X+5]
1760: 08       PUSH  A
1761: 95 6E    CALL  _longServoInstruction
1763: 38 FA    ADD   SP,250
(0407) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
(0408) 	TX_REPEATER_14_PutChar(END_TRANSMIT);		// This is the end of this transmission
1765: 84 74    JMP   0x1BDA
(0409) 	TX_REPEATER_23_PutChar(END_TRANSMIT);		// This is the end of this transmission
1767: 62 D0 00 MOV   REG[208],0
176A: 52 01    MOV   A,[X+1]
176C: 53 9C    MOV   [__r1],A
176E: 52 00    MOV   A,[X+0]
1770: 60 D4    MOV   REG[212],A
1772: 3E 9C    MVI   A,[__r1]
1774: 53 9C    MOV   [__r1],A
1776: 55 9D 00 MOV   [__r0],0
1779: 3C 9D 00 CMP   [__r0],0
177C: B0 05    JNZ   0x1782
177E: 39 70    CMP   A,112
1780: A0 0E    JZ    0x178F
1782: 62 D0 00 MOV   REG[208],0
1785: 3C 9D 00 CMP   [__r0],0
1788: B0 45    JNZ   0x17CE
178A: 3C 9C 50 CMP   [__r1],80
178D: B0 40    JNZ   0x17CE
(0410) 	
(0411) 	// Make completely sure we're done.
178F: 10       PUSH  X
1790: 7C 11 B4 LCALL 0x11B4
1793: 62 D0 00 MOV   REG[208],0
1796: 53 9D    MOV   [__r0],A
1798: 5A 9C    MOV   [__r1],X
179A: 20       POP   X
179B: 51 9C    MOV   A,[__r1]
179D: 54 01    MOV   [X+1],A
179F: 51 9D    MOV   A,[__r0]
17A1: 54 00    MOV   [X+0],A
17A3: 3C 9D 00 CMP   [__r0],0
17A6: B0 06    JNZ   0x17AD
17A8: 3C 9C 00 CMP   [__r1],0
17AB: A4 2E    JZ    0x1BDA
(0412) 	xmitWait();
(0413) 	
(0414) 	// Switch back to listening mode.
17AD: 52 00    MOV   A,[X+0]
17AF: 08       PUSH  A
17B0: 52 01    MOV   A,[X+1]
17B2: 08       PUSH  A
17B3: 7C 23 F3 LCALL _atoi
17B6: 62 D0 00 MOV   REG[208],0
17B9: 51 9C    MOV   A,[__r1]
17BB: 08       PUSH  A
17BC: 50 18    MOV   A,24
17BE: 08       PUSH  A
17BF: 50 03    MOV   A,3
17C1: 08       PUSH  A
17C2: 50 04    MOV   A,4
17C4: 08       PUSH  A
17C5: 52 05    MOV   A,[X+5]
17C7: 08       PUSH  A
17C8: 94 3B    CALL  _servoInstruction
17CA: 38 F9    ADD   SP,249
(0415) 	configToggle(RX_MODE);
(0416) }
17CC: 84 0D    JMP   0x1BDA
(0417) 
17CE: 62 D0 00 MOV   REG[208],0
17D1: 52 01    MOV   A,[X+1]
17D3: 53 9C    MOV   [__r1],A
17D5: 52 00    MOV   A,[X+0]
17D7: 60 D4    MOV   REG[212],A
17D9: 3E 9C    MVI   A,[__r1]
17DB: 53 9C    MOV   [__r1],A
17DD: 55 9D 00 MOV   [__r0],0
17E0: 3C 9D 00 CMP   [__r0],0
17E3: B0 05    JNZ   0x17E9
17E5: 39 73    CMP   A,115
17E7: A0 0E    JZ    0x17F6
17E9: 62 D0 00 MOV   REG[208],0
17EC: 3C 9D 00 CMP   [__r0],0
17EF: B3 EA    JNZ   0x1BDA
17F1: 3C 9C 53 CMP   [__r1],83
17F4: B3 E5    JNZ   0x1BDA
(0418) // This function returns whether or not a valid transmission has been received.
(0419) int validTransmission(void)
17F6: 10       PUSH  X
17F7: 7C 11 B4 LCALL 0x11B4
17FA: 62 D0 00 MOV   REG[208],0
17FD: 53 9D    MOV   [__r0],A
17FF: 5A 9C    MOV   [__r1],X
1801: 20       POP   X
1802: 51 9C    MOV   A,[__r1]
1804: 54 01    MOV   [X+1],A
1806: 51 9D    MOV   A,[__r0]
1808: 54 00    MOV   [X+0],A
180A: 3C 9D 00 CMP   [__r0],0
180D: B0 06    JNZ   0x1814
180F: 3C 9C 00 CMP   [__r1],0
1812: A3 C7    JZ    0x1BDA
(0420) {
(0421) 	int i = 0;			// Index for looping.
(0422) 	char tempByte = 0;	// Temporary byte storage.
1814: 52 00    MOV   A,[X+0]
1816: 08       PUSH  A
1817: 52 01    MOV   A,[X+1]
1819: 08       PUSH  A
181A: 7C 23 F3 LCALL _atoi
181D: 38 FE    ADD   SP,254
181F: 62 D0 00 MOV   REG[208],0
1822: 51 9C    MOV   A,[__r1]
1824: 54 07    MOV   [X+7],A
1826: 51 9D    MOV   A,[__r0]
1828: 54 06    MOV   [X+6],A
(0423) 	
(0424) 	// These loops and conditionals are arranged in a way that allows this read
(0425) 	// operation to be completely non-blocking.
182A: 3D 06 00 CMP   [X+6],0
182D: B0 06    JNZ   0x1834
182F: 3D 07 00 CMP   [X+7],0
1832: A3 A7    JZ    0x1BDA
(0426) 	while(TIMEOUT < RX_TIMEOUT_DURATION)
(0427) 	{
(0428) 		// Wait until we read a start transmit byte.
1834: 62 D0 00 MOV   REG[208],0
1837: 50 01    MOV   A,1
1839: 08       PUSH  A
183A: 50 00    MOV   A,0
183C: 08       PUSH  A
183D: 52 06    MOV   A,[X+6]
183F: 08       PUSH  A
1840: 52 07    MOV   A,[X+7]
1842: 08       PUSH  A
1843: 7C 23 61 LCALL __divmod_16X16_16
1846: 38 FE    ADD   SP,254
1848: 18       POP   A
1849: 53 9C    MOV   [__r1],A
184B: 18       POP   A
184C: 51 9C    MOV   A,[__r1]
184E: 54 0A    MOV   [X+10],A
(0429) 		if(iReadChar() == START_TRANSMIT)
1850: 50 01    MOV   A,1
1852: 08       PUSH  A
1853: 50 00    MOV   A,0
1855: 08       PUSH  A
1856: 52 06    MOV   A,[X+6]
1858: 08       PUSH  A
1859: 52 07    MOV   A,[X+7]
185B: 08       PUSH  A
185C: 7C 23 61 LCALL __divmod_16X16_16
185F: 18       POP   A
1860: 53 9C    MOV   [__r1],A
1862: 18       POP   A
1863: 38 FE    ADD   SP,254
1865: 51 9C    MOV   A,[__r1]
1867: 54 0B    MOV   [X+11],A
(0430) 		{
(0431) 			// While we haven't timed out, look for something other than a start byte.
(0432) 			while(TIMEOUT < RX_TIMEOUT_DURATION)
1869: 52 0B    MOV   A,[X+11]
186B: 08       PUSH  A
186C: 52 0A    MOV   A,[X+10]
186E: 08       PUSH  A
186F: 50 20    MOV   A,32
1871: 08       PUSH  A
1872: 50 03    MOV   A,3
1874: 08       PUSH  A
1875: 50 05    MOV   A,5
1877: 08       PUSH  A
1878: 52 05    MOV   A,[X+5]
187A: 08       PUSH  A
187B: 94 54    CALL  _longServoInstruction
187D: 38 FA    ADD   SP,250
(0433) 			{
(0434) 				// If we find a nonzero byte...
(0435) 				if(tempByte = iReadChar())
(0436) 				{
(0437) 					// If the byte we found isn't a start byte...
(0438) 					if(tempByte != START_TRANSMIT)
187F: 83 5A    JMP   0x1BDA
(0439) 					{
1881: 62 D0 00 MOV   REG[208],0
1884: 52 01    MOV   A,[X+1]
1886: 53 9C    MOV   [__r1],A
1888: 52 00    MOV   A,[X+0]
188A: 60 D4    MOV   REG[212],A
188C: 3E 9C    MVI   A,[__r1]
188E: 53 9C    MOV   [__r1],A
1890: 55 9D 00 MOV   [__r0],0
1893: 3C 9D 00 CMP   [__r0],0
1896: B0 05    JNZ   0x189C
1898: 39 72    CMP   A,114
189A: A0 0E    JZ    0x18A9
189C: 62 D0 00 MOV   REG[208],0
189F: 3C 9D 00 CMP   [__r0],0
18A2: B3 37    JNZ   0x1BDA
18A4: 3C 9C 52 CMP   [__r1],82
18A7: B3 32    JNZ   0x1BDA
(0440) 						// This byte is probably the command source.
(0441) 						COMMAND_SOURCE = tempByte;
18A9: 10       PUSH  X
18AA: 7C 11 B4 LCALL 0x11B4
18AD: 62 D0 00 MOV   REG[208],0
18B0: 53 9D    MOV   [__r0],A
18B2: 5A 9C    MOV   [__r1],X
18B4: 20       POP   X
18B5: 51 9C    MOV   A,[__r1]
18B7: 54 01    MOV   [X+1],A
18B9: 51 9D    MOV   A,[__r0]
18BB: 54 00    MOV   [X+0],A
18BD: 3C 9D 00 CMP   [__r0],0
18C0: B0 06    JNZ   0x18C7
18C2: 3C 9C 00 CMP   [__r1],0
18C5: A3 14    JZ    0x1BDA
(0442) 						
(0443) 						// Look for the rest of the command before we time out.
(0444) 						while(TIMEOUT < RX_TIMEOUT_DURATION)
18C7: 52 00    MOV   A,[X+0]
18C9: 08       PUSH  A
18CA: 52 01    MOV   A,[X+1]
18CC: 08       PUSH  A
18CD: 7C 23 F3 LCALL _atoi
18D0: 38 FE    ADD   SP,254
18D2: 62 D0 00 MOV   REG[208],0
18D5: 51 9C    MOV   A,[__r1]
18D7: 54 05    MOV   [X+5],A
(0445) 						{
(0446) 							// If we read another nonzero byte...
18D9: 10       PUSH  X
18DA: 7C 11 B4 LCALL 0x11B4
18DD: 62 D0 00 MOV   REG[208],0
18E0: 53 9D    MOV   [__r0],A
18E2: 5A 9C    MOV   [__r1],X
18E4: 20       POP   X
18E5: 51 9C    MOV   A,[__r1]
18E7: 54 01    MOV   [X+1],A
18E9: 51 9D    MOV   A,[__r0]
18EB: 54 00    MOV   [X+0],A
18ED: 3C 9D 00 CMP   [__r0],0
18F0: B0 06    JNZ   0x18F7
18F2: 3C 9C 00 CMP   [__r1],0
18F5: A2 E4    JZ    0x1BDA
(0447) 							if(tempByte = iReadChar())
(0448) 							{
18F7: 62 D0 00 MOV   REG[208],0
18FA: 52 01    MOV   A,[X+1]
18FC: 53 9C    MOV   [__r1],A
18FE: 52 00    MOV   A,[X+0]
1900: 60 D4    MOV   REG[212],A
1902: 3E 9C    MVI   A,[__r1]
1904: 53 9C    MOV   [__r1],A
1906: 55 9D 00 MOV   [__r0],0
1909: 3C 9D 00 CMP   [__r0],0
190C: B0 05    JNZ   0x1912
190E: 39 61    CMP   A,97
1910: A0 0E    JZ    0x191F
1912: 62 D0 00 MOV   REG[208],0
1915: 3C 9D 00 CMP   [__r0],0
1918: B0 C6    JNZ   0x19DF
191A: 3C 9C 41 CMP   [__r1],65
191D: B0 C1    JNZ   0x19DF
(0449) 								// If that byte is in the command type indicator space...
(0450) 								if(tempByte >= COMMAND_TYPE_SPACE)
(0451) 								{
191F: 56 08 00 MOV   [X+8],0
(0452) 									// Store the command type.
1922: 56 09 00 MOV   [X+9],0
(0453) 									COMMAND_TYPE = tempByte;
(0454) 									
(0455) 									// Continue reading if we have not timed out yet.
1925: 50 02    MOV   A,2
1927: 08       PUSH  A
1928: 50 24    MOV   A,36
192A: 08       PUSH  A
192B: 50 02    MOV   A,2
192D: 08       PUSH  A
192E: 50 04    MOV   A,4
1930: 08       PUSH  A
1931: 52 05    MOV   A,[X+5]
1933: 08       PUSH  A
1934: 92 CF    CALL  _servoInstruction
(0456) 									while(TIMEOUT < RX_TIMEOUT_DURATION)
(0457) 									{
(0458) 										// If we read a nonzero byte...
1936: 50 00    MOV   A,0
1938: 08       PUSH  A
1939: 50 02    MOV   A,2
193B: 08       PUSH  A
193C: 94 74    CALL  _configToggle
193E: 38 F9    ADD   SP,249
1940: 80 8D    JMP   0x19CE
(0459) 										if(tempByte = iReadChar())
(0460) 										{
(0461) 											// Store the parameter if it is not the end indicator.
(0462) 											if(tempByte != END_TRANSMIT)
(0463) 											{
(0464) 												PARAM[i] = tempByte;
1942: 7C 21 4B LCALL _iReadChar
1945: 62 D0 00 MOV   REG[208],0
1948: 3B 05    CMP   A,[X+5]
194A: B0 83    JNZ   0x19CE
(0465) 												i++;
194C: 80 72    JMP   0x19BF
(0466) 											}
(0467) 											else
(0468) 											{
(0469) 												return 1;
194E: 97 FB    CALL  _iReadChar
1950: 62 D0 00 MOV   REG[208],0
1953: 39 04    CMP   A,4
1955: B0 69    JNZ   0x19BF
(0470) 											}
(0471) 										}
(0472) 									}
1957: 7C 21 99 LCALL _readChar
195A: 62 D0 00 MOV   REG[208],0
195D: 39 00    CMP   A,0
195F: B0 56    JNZ   0x19B6
(0473) 								}
(0474) 							}
(0475) 						}
1961: 7C 21 99 LCALL _readChar
1964: 62 D0 00 MOV   REG[208],0
1967: 54 08    MOV   [X+8],A
(0476) 					}
1969: 7C 21 99 LCALL _readChar
196C: 62 D0 00 MOV   REG[208],0
196F: 54 09    MOV   [X+9],A
(0477) 				}
(0478) 			}
(0479) 		}
1971: 50 00    MOV   A,0
1973: 08       PUSH  A
1974: 50 01    MOV   A,1
1976: 08       PUSH  A
1977: 94 39    CALL  _configToggle
(0480) 	}
(0481) 	
(0482) 	return 0;
1979: 52 08    MOV   A,[X+8]
197B: 54 07    MOV   [X+7],A
197D: 52 09    MOV   A,[X+9]
197F: 54 06    MOV   [X+6],A
(0483) }
(0484) 
(0485) // This function decodes the transmission and takes the correct action.
1981: 50 00    MOV   A,0
1983: 08       PUSH  A
1984: 50 0A    MOV   A,10
1986: 08       PUSH  A
1987: 52 06    MOV   A,[X+6]
1989: 08       PUSH  A
198A: 52 07    MOV   A,[X+7]
198C: 08       PUSH  A
198D: 52 00    MOV   A,[X+0]
198F: 08       PUSH  A
1990: 52 01    MOV   A,[X+1]
1992: 08       PUSH  A
1993: 7C 25 34 LCALL _itoa
1996: 38 F8    ADD   SP,248
(0486) void decodeTransmission(void)
(0487) {
(0488) 	char* param;			// Stores the most recent parameter from the buffer.
1998: 10       PUSH  X
1999: 52 00    MOV   A,[X+0]
199B: 08       PUSH  A
199C: 52 01    MOV   A,[X+1]
199E: 5C       MOV   X,A
199F: 18       POP   A
19A0: 7C 11 04 LCALL 0x1104
19A3: 20       POP   X
(0489) 	char ID = 0;			// Stores the target module ID.
19A4: 10       PUSH  X
19A5: 50 0A    MOV   A,10
19A7: 7C 10 C7 LCALL 0x10C7
19AA: 20       POP   X
(0490) 	char tempByte = 0;		// Temporary byte storage.
(0491) 	char angle[2];			// Store the two angle bytes for the servo.
(0492) 	char speed[2];			// Store the two speed bytes for the servo.
19AB: 62 D0 00 MOV   REG[208],0
19AE: 55 9F 05 MOV   [TIMEOUT+1],5
19B1: 55 9E 00 MOV   [TIMEOUT],0
(0493) 	int total = 0;			// Used to store the converted total of angle or speed bytes.
19B4: 80 0A    JMP   0x19BF
(0494) 	int runningTotal = 0;	// Used as part of the dynamic checksum calculation.
(0495) 	
(0496) 	// Read a parameter from the buffer.
(0497) 	if(param = COMP_SERIAL_szGetParam())
19B6: 62 D0 00 MOV   REG[208],0
19B9: 55 9F 05 MOV   [TIMEOUT+1],5
19BC: 55 9E 00 MOV   [TIMEOUT],0
19BF: 62 D0 00 MOV   REG[208],0
19C2: 51 9F    MOV   A,[TIMEOUT+1]
19C4: 11 05    SUB   A,5
19C6: 51 9E    MOV   A,[TIMEOUT]
19C8: 31 80    XOR   A,128
19CA: 19 80    SBB   A,128
19CC: CF 81    JC    0x194E
19CE: 62 D0 00 MOV   REG[208],0
19D1: 51 9F    MOV   A,[TIMEOUT+1]
19D3: 11 05    SUB   A,5
19D5: 51 9E    MOV   A,[TIMEOUT]
19D7: 31 80    XOR   A,128
19D9: 19 80    SBB   A,128
19DB: CF 66    JC    0x1942
(0498) 	{
(0499) 		if((param[0] == 'x') || (param[0] == 'X'))
(0500) 		{
(0501) 			// Reset the robot.
(0502) 			NUM_MODULES = 0;
(0503) 		}
19DD: 81 FC    JMP   0x1BDA
(0504) 		else if((param[0] == 'n') || (param[0] == 'N'))
19DF: 62 D0 00 MOV   REG[208],0
19E2: 52 01    MOV   A,[X+1]
19E4: 53 9C    MOV   [__r1],A
19E6: 52 00    MOV   A,[X+0]
19E8: 60 D4    MOV   REG[212],A
19EA: 3E 9C    MVI   A,[__r1]
19EC: 53 9C    MOV   [__r1],A
19EE: 55 9D 00 MOV   [__r0],0
19F1: 3C 9D 00 CMP   [__r0],0
19F4: B0 05    JNZ   0x19FA
19F6: 39 70    CMP   A,112
19F8: A0 0E    JZ    0x1A07
19FA: 62 D0 00 MOV   REG[208],0
19FD: 3C 9D 00 CMP   [__r0],0
1A00: B0 E6    JNZ   0x1AE7
1A02: 3C 9C 50 CMP   [__r1],80
1A05: B0 E1    JNZ   0x1AE7
(0505) 		{
(0506) 			itoa(param,NUM_MODULES,10);		// Convert the NUM_MODULES int to a char array.
(0507) 			COMP_SERIAL_PutString(param);	// Send that array out to the PC.
1A07: 50 01    MOV   A,1
1A09: 08       PUSH  A
1A0A: 50 18    MOV   A,24
1A0C: 08       PUSH  A
1A0D: 50 02    MOV   A,2
1A0F: 08       PUSH  A
1A10: 50 04    MOV   A,4
1A12: 08       PUSH  A
1A13: 52 05    MOV   A,[X+5]
1A15: 08       PUSH  A
1A16: 91 ED    CALL  _servoInstruction
(0508) 			COMP_SERIAL_PutChar('\n');		// End the transmission with the PC.
(0509) 		}
(0510) 		else if((param[0] == 'w') || (param[0] == 'W'))
1A18: 50 00    MOV   A,0
1A1A: 08       PUSH  A
1A1B: 50 02    MOV   A,2
1A1D: 08       PUSH  A
1A1E: 93 92    CALL  _configToggle
1A20: 38 F9    ADD   SP,249
1A22: 80 B3    JMP   0x1AD6
(0511) 		{
(0512) 			if(param = COMP_SERIAL_szGetParam())
(0513) 			{
(0514) 				// Convert the ID parameter to a char byte.
(0515) 				ID = atoi(param);
1A24: 97 25    CALL  _iReadChar
1A26: 62 D0 00 MOV   REG[208],0
1A29: 3B 05    CMP   A,[X+5]
1A2B: B0 AA    JNZ   0x1AD6
(0516) 				
(0517) 				if(param = COMP_SERIAL_szGetParam())
1A2D: 52 05    MOV   A,[X+5]
1A2F: 54 04    MOV   [X+4],A
1A31: 56 03 00 MOV   [X+3],0
1A34: 80 92    JMP   0x1AC7
(0518) 				{
(0519) 					if((param[0] == 'a') || (param[0] == 'A'))
(0520) 					{
(0521) 						if(param = COMP_SERIAL_szGetParam())
(0522) 						{
1A36: 97 13    CALL  _iReadChar
1A38: 62 D0 00 MOV   REG[208],0
1A3B: 39 03    CMP   A,3
1A3D: B0 89    JNZ   0x1AC7
(0523) 							// Get the angle parameter and convert it to an integer.
(0524) 							total = atoi(param);
(0525) 							
1A3F: 07 04 03 ADD   [X+4],3
1A42: 0F 03 00 ADC   [X+3],0
1A45: 80 72    JMP   0x1AB8
(0526) 							// Convert the integer into bytes.
(0527) 							angle[0] = total%256;
(0528) 							angle[1] = total/256;
(0529) 							
(0530) 							// Send the servo the angle.
(0531) 							longServoInstruction(ID,5,WRITE_SERVO,30,angle[0],angle[1]);
1A47: 97 02    CALL  _iReadChar
1A49: 62 D0 00 MOV   REG[208],0
1A4C: 54 02    MOV   [X+2],A
1A4E: 39 00    CMP   A,0
1A50: A0 67    JZ    0x1AB8
(0532) 						}
(0533) 					}
(0534) 					else if((param[0] == 'p') || (param[0] == 'P'))
1A52: 50 00    MOV   A,0
1A54: 08       PUSH  A
1A55: 50 01    MOV   A,1
1A57: 08       PUSH  A
1A58: 93 58    CALL  _configToggle
1A5A: 38 FE    ADD   SP,254
(0535) 					{
(0536) 						if(param = COMP_SERIAL_szGetParam())
1A5C: 62 D0 00 MOV   REG[208],0
1A5F: 52 02    MOV   A,[X+2]
1A61: 53 9C    MOV   [__r1],A
1A63: 55 9D 00 MOV   [__r0],0
1A66: 50 FF    MOV   A,255
1A68: 12 9C    SUB   A,[__r1]
1A6A: 53 9C    MOV   [__r1],A
1A6C: 50 00    MOV   A,0
1A6E: 1A 9D    SBB   A,[__r0]
1A70: 53 9D    MOV   [__r0],A
1A72: 50 01    MOV   A,1
1A74: 08       PUSH  A
1A75: 50 00    MOV   A,0
1A77: 08       PUSH  A
1A78: 52 03    MOV   A,[X+3]
1A7A: 08       PUSH  A
1A7B: 52 04    MOV   A,[X+4]
1A7D: 08       PUSH  A
1A7E: 7C 23 61 LCALL __divmod_16X16_16
1A81: 38 FE    ADD   SP,254
1A83: 18       POP   A
1A84: 53 9A    MOV   [__r3],A
1A86: 18       POP   A
1A87: 3A 9D    CMP   A,[__r0]
1A89: B0 17    JNZ   0x1AA1
1A8B: 51 9A    MOV   A,[__r3]
1A8D: 3A 9C    CMP   A,[__r1]
1A8F: B0 11    JNZ   0x1AA1
(0537) 						{
(0538) 							// Send the servo the desired power value.
(0539) 							servoInstruction(ID,4,WRITE_SERVO,24,atoi(param));
1A91: 10       PUSH  X
1A92: 50 30    MOV   A,48
1A94: 7C 10 C7 LCALL 0x10C7
1A97: 20       POP   X
(0540) 						}
1A98: 10       PUSH  X
1A99: 50 0A    MOV   A,10
1A9B: 7C 10 C7 LCALL 0x10C7
1A9E: 20       POP   X
(0541) 					}
1A9F: 80 0F    JMP   0x1AAF
(0542) 					else if((param[0] == 's') || (param[0] == 'S'))
(0543) 					{
(0544) 						if(param = COMP_SERIAL_szGetParam())
(0545) 						{
1AA1: 10       PUSH  X
1AA2: 50 31    MOV   A,49
1AA4: 7C 10 C7 LCALL 0x10C7
1AA7: 20       POP   X
(0546) 							// Get the speed parameter and convert it to an integer.
1AA8: 10       PUSH  X
1AA9: 50 0A    MOV   A,10
1AAB: 7C 10 C7 LCALL 0x10C7
1AAE: 20       POP   X
(0547) 							total = atoi(param);
(0548) 							
(0549) 							// If no total, do nothing because 0 is no speed control (undesired).
1AAF: 62 D0 00 MOV   REG[208],0
1AB2: 55 9F 05 MOV   [TIMEOUT+1],5
1AB5: 55 9E 00 MOV   [TIMEOUT],0
1AB8: 62 D0 00 MOV   REG[208],0
1ABB: 51 9F    MOV   A,[TIMEOUT+1]
1ABD: 11 05    SUB   A,5
1ABF: 51 9E    MOV   A,[TIMEOUT]
1AC1: 31 80    XOR   A,128
1AC3: 19 80    SBB   A,128
1AC5: CF 81    JC    0x1A47
1AC7: 62 D0 00 MOV   REG[208],0
1ACA: 51 9F    MOV   A,[TIMEOUT+1]
1ACC: 11 05    SUB   A,5
1ACE: 51 9E    MOV   A,[TIMEOUT]
1AD0: 31 80    XOR   A,128
1AD2: 19 80    SBB   A,128
1AD4: CF 61    JC    0x1A36
1AD6: 62 D0 00 MOV   REG[208],0
1AD9: 51 9F    MOV   A,[TIMEOUT+1]
1ADB: 11 05    SUB   A,5
1ADD: 51 9E    MOV   A,[TIMEOUT]
1ADF: 31 80    XOR   A,128
1AE1: 19 80    SBB   A,128
1AE3: CF 40    JC    0x1A24
(0550) 							if(total)
(0551) 							{
(0552) 								// Convert the integer into bytes.
(0553) 								speed[0] = total%256;
(0554) 								speed[1] = total/256;
(0555) 								
(0556) 								// Write the speed value to the servo.
1AE5: 80 F4    JMP   0x1BDA
(0557) 								longServoInstruction(ID,5,WRITE_SERVO,32,speed[0],speed[1]);
1AE7: 62 D0 00 MOV   REG[208],0
1AEA: 52 01    MOV   A,[X+1]
1AEC: 53 9C    MOV   [__r1],A
1AEE: 52 00    MOV   A,[X+0]
1AF0: 60 D4    MOV   REG[212],A
1AF2: 3E 9C    MVI   A,[__r1]
1AF4: 53 9C    MOV   [__r1],A
1AF6: 55 9D 00 MOV   [__r0],0
1AF9: 3C 9D 00 CMP   [__r0],0
1AFC: B0 05    JNZ   0x1B02
1AFE: 39 74    CMP   A,116
1B00: A0 0E    JZ    0x1B0F
1B02: 62 D0 00 MOV   REG[208],0
1B05: 3C 9D 00 CMP   [__r0],0
1B08: B0 57    JNZ   0x1B60
1B0A: 3C 9C 54 CMP   [__r1],84
1B0D: B0 52    JNZ   0x1B60
(0558) 							}
(0559) 						}
(0560) 					}
(0561) 				}
1B0F: 3D 05 00 CMP   [X+5],0
1B12: B0 11    JNZ   0x1B24
(0562) 			}
(0563) 		}
1B14: 10       PUSH  X
1B15: 50 32    MOV   A,50
1B17: 7C 10 C7 LCALL 0x10C7
1B1A: 20       POP   X
(0564) 		else if((param[0] == 'r') || (param[0] == 'R'))
1B1B: 10       PUSH  X
1B1C: 50 0A    MOV   A,10
1B1E: 7C 10 C7 LCALL 0x10C7
1B21: 20       POP   X
(0565) 		{			
1B22: 80 B7    JMP   0x1BDA
(0566) 			if(param = COMP_SERIAL_szGetParam())
1B24: 62 D0 00 MOV   REG[208],0
1B27: 52 05    MOV   A,[X+5]
1B29: 53 9C    MOV   [__r1],A
1B2B: 50 00    MOV   A,0
1B2D: 08       PUSH  A
1B2E: 51 9C    MOV   A,[__r1]
1B30: 08       PUSH  A
1B31: 7C 12 61 LCALL _pingModule
1B34: 38 FE    ADD   SP,254
1B36: 62 D0 00 MOV   REG[208],0
1B39: 3C 9D 00 CMP   [__r0],0
1B3C: B0 06    JNZ   0x1B43
1B3E: 3C 9C 00 CMP   [__r1],0
1B41: A0 98    JZ    0x1BDA
(0567) 			{
(0568) 				// Extract the target ID param and convert it to an integer.
1B43: 50 00    MOV   A,0
1B45: 08       PUSH  A
1B46: 50 01    MOV   A,1
1B48: 08       PUSH  A
1B49: 92 67    CALL  _configToggle
1B4B: 38 FE    ADD   SP,254
(0569) 				ID = atoi(param);
(0570) 				
1B4D: 10       PUSH  X
1B4E: 62 D0 00 MOV   REG[208],0
1B51: 51 8B    MOV   A,[PARAM]
1B53: 7C 10 C7 LCALL 0x10C7
1B56: 20       POP   X
(0571) 				if(param = COMP_SERIAL_szGetParam())
1B57: 10       PUSH  X
1B58: 50 0A    MOV   A,10
1B5A: 7C 10 C7 LCALL 0x10C7
1B5D: 20       POP   X
(0572) 				{
(0573) 					if((param[0] == 'a') || (param[0] == 'A'))
1B5E: 80 7B    JMP   0x1BDA
(0574) 					{
1B60: 62 D0 00 MOV   REG[208],0
1B63: 52 01    MOV   A,[X+1]
1B65: 53 9C    MOV   [__r1],A
1B67: 52 00    MOV   A,[X+0]
1B69: 60 D4    MOV   REG[212],A
1B6B: 3E 9C    MVI   A,[__r1]
1B6D: 53 9C    MOV   [__r1],A
1B6F: 55 9D 00 MOV   [__r0],0
1B72: 3C 9D 00 CMP   [__r0],0
1B75: B0 05    JNZ   0x1B7B
1B77: 39 63    CMP   A,99
1B79: A0 0E    JZ    0x1B88
1B7B: 62 D0 00 MOV   REG[208],0
1B7E: 3C 9D 00 CMP   [__r0],0
1B81: B0 58    JNZ   0x1BDA
1B83: 3C 9C 43 CMP   [__r1],67
1B86: B0 53    JNZ   0x1BDA
(0575) 						// Initialize the angle bytes to 0.
(0576) 						angle[0] = 0;
(0577) 						angle[1] = 0;
(0578) 						
1B88: 3D 05 00 CMP   [X+5],0
1B8B: B0 14    JNZ   0x1BA0
(0579) 						// Send a request to the servo for its angle.
(0580) 						servoInstruction(ID,4,READ_SERVO,36,2);
1B8D: 10       PUSH  X
1B8E: 62 D0 00 MOV   REG[208],0
1B91: 51 AC    MOV   A,[CHILD]
1B93: 7C 10 C7 LCALL 0x10C7
1B96: 20       POP   X
(0581) 						
1B97: 10       PUSH  X
1B98: 50 0A    MOV   A,10
1B9A: 7C 10 C7 LCALL 0x10C7
1B9D: 20       POP   X
(0582) 						// Switch to read the response.
1B9E: 80 3B    JMP   0x1BDA
(0583) 						configToggle(RX_MODE);
1BA0: 62 D0 00 MOV   REG[208],0
1BA3: 52 05    MOV   A,[X+5]
1BA5: 53 9C    MOV   [__r1],A
1BA7: 50 00    MOV   A,0
1BA9: 08       PUSH  A
1BAA: 51 9C    MOV   A,[__r1]
1BAC: 08       PUSH  A
1BAD: 7C 12 61 LCALL _pingModule
1BB0: 38 FE    ADD   SP,254
1BB2: 62 D0 00 MOV   REG[208],0
1BB5: 3C 9D 00 CMP   [__r0],0
1BB8: B0 06    JNZ   0x1BBF
1BBA: 3C 9C 00 CMP   [__r1],0
1BBD: A0 1C    JZ    0x1BDA
(0584) 							
(0585) 						// Loop until we read a response or time out.
1BBF: 50 00    MOV   A,0
1BC1: 08       PUSH  A
1BC2: 50 01    MOV   A,1
1BC4: 08       PUSH  A
1BC5: 91 EB    CALL  _configToggle
1BC7: 38 FE    ADD   SP,254
(0586) 						while(TIMEOUT < RX_TIMEOUT_DURATION)
(0587) 						{
1BC9: 10       PUSH  X
1BCA: 62 D0 00 MOV   REG[208],0
1BCD: 51 8C    MOV   A,[PARAM+1]
1BCF: 7C 10 C7 LCALL 0x10C7
1BD2: 20       POP   X
(0588) 							// If the response is from the right ID...
1BD3: 10       PUSH  X
1BD4: 50 0A    MOV   A,10
1BD6: 7C 10 C7 LCALL 0x10C7
1BD9: 20       POP   X
(0589) 							if(iReadChar() == ID)
(0590) 							{
(0591) 								while(TIMEOUT < RX_TIMEOUT_DURATION)
(0592) 								{
(0593) 									// The length of the response remainder should be 4.
(0594) 									if(iReadChar() == 4)
(0595) 									{
(0596) 										// The error value should be 0 if successful.
(0597) 										if(readChar() == 0)
1BDA: 62 D0 00 MOV   REG[208],0
1BDD: 3C A0 00 CMP   [STATE],0
1BE0: B0 06    JNZ   0x1BE7
1BE2: 3C A1 01 CMP   [STATE+1],1
1BE5: A0 0D    JZ    0x1BF3
(0598) 										{
(0599) 											// Grab the bytes from the buffer.
1BE7: 50 00    MOV   A,0
1BE9: 08       PUSH  A
1BEA: 50 01    MOV   A,1
1BEC: 08       PUSH  A
1BED: 91 C3    CALL  _configToggle
1BEF: 38 FE    ADD   SP,254
(0600) 											angle[0] = readChar();
1BF1: 80 0F    JMP   0x1C01
(0601) 											angle[1] = readChar();
(0602) 											
(0603) 											// Switch to PC mode to forward the response.
1BF3: 62 D0 00 MOV   REG[208],0
1BF6: 55 9F 00 MOV   [TIMEOUT+1],0
1BF9: 55 9E 00 MOV   [TIMEOUT],0
(0604) 											configToggle(PC_MODE);
1BFC: 10       PUSH  X
1BFD: 7C 11 85 LCALL 0x1185
1C00: 20       POP   X
(0605) 											
1C01: 38 F4    ADD   SP,244
1C03: 20       POP   X
1C04: 7F       RET   
(0606) 											// Convert the bytes to an integer.
(0607) 											total = ((angle[1])*256) + angle[0];
(0608) 											
(0609) 											// Convert the integer to a character array.
(0610) 											itoa(param,total,10);
(0611) 											
_servoInstruction:
  total                --> X+1
  checksum             --> X+0
  value                --> X-8
  address              --> X-7
  instruction          --> X-6
  length               --> X-5
  id                   --> X-4
1C05: 10       PUSH  X
1C06: 4F       MOV   X,SP
1C07: 38 03    ADD   SP,3
(0612) 											// Write the response to the computer.
(0613) 											COMP_SERIAL_PutString(param);
(0614) 											COMP_SERIAL_PutChar('\n');
(0615) 
(0616) 											// Force a timeout to exit all loops.
1C09: 62 D0 00 MOV   REG[208],0
1C0C: 52 FB    MOV   A,[X-5]
1C0E: 53 9C    MOV   [__r1],A
1C10: 55 9D 00 MOV   [__r0],0
1C13: 52 FC    MOV   A,[X-4]
1C15: 02 9C    ADD   A,[__r1]
1C17: 53 9C    MOV   [__r1],A
1C19: 50 00    MOV   A,0
1C1B: 0A 9D    ADC   A,[__r0]
1C1D: 53 9D    MOV   [__r0],A
1C1F: 52 FA    MOV   A,[X-6]
1C21: 04 9C    ADD   [__r1],A
1C23: 0E 9D 00 ADC   [__r0],0
1C26: 52 F9    MOV   A,[X-7]
1C28: 04 9C    ADD   [__r1],A
1C2A: 0E 9D 00 ADC   [__r0],0
1C2D: 52 F8    MOV   A,[X-8]
1C2F: 53 9A    MOV   [__r3],A
1C31: 55 9B 00 MOV   [__r2],0
1C34: 51 9C    MOV   A,[__r1]
1C36: 02 9A    ADD   A,[__r3]
1C38: 54 02    MOV   [X+2],A
1C3A: 51 9D    MOV   A,[__r0]
1C3C: 0A 9B    ADC   A,[__r2]
1C3E: 54 01    MOV   [X+1],A
(0617) 											TIMEOUT = RX_TIMEOUT_DURATION;
(0618) 										}
(0619) 										else
1C40: 50 01    MOV   A,1
1C42: 08       PUSH  A
1C43: 50 00    MOV   A,0
1C45: 08       PUSH  A
1C46: 52 01    MOV   A,[X+1]
1C48: 08       PUSH  A
1C49: 52 02    MOV   A,[X+2]
1C4B: 08       PUSH  A
1C4C: 7C 23 61 LCALL __divmod_16X16_16
1C4F: 38 FE    ADD   SP,254
1C51: 18       POP   A
1C52: 53 9C    MOV   [__r1],A
1C54: 18       POP   A
1C55: 50 FF    MOV   A,255
1C57: 12 9C    SUB   A,[__r1]
1C59: 54 00    MOV   [X+0],A
(0620) 										{
(0621) 											// Force a timeout to exit all loops.
(0622) 											TIMEOUT = RX_TIMEOUT_DURATION;
1C5B: 10       PUSH  X
1C5C: 50 FF    MOV   A,255
1C5E: 7C 09 75 LCALL 0x0975
1C61: 20       POP   X
(0623) 										}
1C62: 10       PUSH  X
1C63: 50 FF    MOV   A,255
1C65: 7C 08 9C LCALL 0x089C
1C68: 20       POP   X
(0624) 									}
1C69: 10       PUSH  X
1C6A: 50 FF    MOV   A,255
1C6C: 7C 09 75 LCALL 0x0975
1C6F: 20       POP   X
(0625) 								}
1C70: 10       PUSH  X
1C71: 50 FF    MOV   A,255
1C73: 7C 08 9C LCALL 0x089C
1C76: 20       POP   X
(0626) 							}
1C77: 10       PUSH  X
1C78: 52 FC    MOV   A,[X-4]
1C7A: 7C 09 75 LCALL 0x0975
1C7D: 20       POP   X
(0627) 						}
1C7E: 10       PUSH  X
1C7F: 52 FC    MOV   A,[X-4]
1C81: 7C 08 9C LCALL 0x089C
1C84: 20       POP   X
(0628) 					}
1C85: 10       PUSH  X
1C86: 52 FB    MOV   A,[X-5]
1C88: 7C 09 75 LCALL 0x0975
1C8B: 20       POP   X
(0629) 					else if ((param[0] == 'p') || (param[0] == 'P'))
1C8C: 10       PUSH  X
1C8D: 52 FB    MOV   A,[X-5]
1C8F: 7C 08 9C LCALL 0x089C
1C92: 20       POP   X
(0630) 					{
1C93: 10       PUSH  X
1C94: 52 FA    MOV   A,[X-6]
1C96: 7C 09 75 LCALL 0x0975
1C99: 20       POP   X
(0631) 						// Send a request to the servo for its power status.
1C9A: 10       PUSH  X
1C9B: 52 FA    MOV   A,[X-6]
1C9D: 7C 08 9C LCALL 0x089C
1CA0: 20       POP   X
(0632) 						servoInstruction(ID,4,READ_SERVO,24,1);
1CA1: 10       PUSH  X
1CA2: 52 F9    MOV   A,[X-7]
1CA4: 7C 09 75 LCALL 0x0975
1CA7: 20       POP   X
(0633) 						
1CA8: 10       PUSH  X
1CA9: 52 F9    MOV   A,[X-7]
1CAB: 7C 08 9C LCALL 0x089C
1CAE: 20       POP   X
(0634) 						// Switch to read the response.
1CAF: 10       PUSH  X
1CB0: 52 F8    MOV   A,[X-8]
1CB2: 7C 09 75 LCALL 0x0975
1CB5: 20       POP   X
(0635) 						configToggle(RX_MODE);
1CB6: 10       PUSH  X
1CB7: 52 F8    MOV   A,[X-8]
1CB9: 7C 08 9C LCALL 0x089C
1CBC: 20       POP   X
(0636) 						
1CBD: 10       PUSH  X
1CBE: 52 00    MOV   A,[X+0]
1CC0: 7C 09 75 LCALL 0x0975
1CC3: 20       POP   X
(0637) 						// Loop until we read a response or time out.
1CC4: 10       PUSH  X
1CC5: 52 00    MOV   A,[X+0]
1CC7: 7C 08 9C LCALL 0x089C
1CCA: 20       POP   X
(0638) 						while(TIMEOUT < RX_TIMEOUT_DURATION)
(0639) 						{
(0640) 							if(iReadChar() == ID)
1CCB: 95 34    CALL  _xmitWait
1CCD: 38 FD    ADD   SP,253
1CCF: 20       POP   X
1CD0: 7F       RET   
(0641) 							{
(0642) 								runningTotal = ID;
(0643) 								// Loop until we read a response or time out.
(0644) 								while(TIMEOUT < RX_TIMEOUT_DURATION)
(0645) 								{
_longServoInstruction:
  total                --> X+1
  checksum             --> X+0
  value2               --> X-9
  value1               --> X-8
  address              --> X-7
  instruction          --> X-6
  length               --> X-5
  id                   --> X-4
1CD1: 10       PUSH  X
1CD2: 4F       MOV   X,SP
1CD3: 38 03    ADD   SP,3
(0646) 									// Check the length of the packet.
(0647) 									if(iReadChar() == 3)
(0648) 									{
(0649) 										// Tack the value onto our running total.
(0650) 										runningTotal += 3;
1CD5: 62 D0 00 MOV   REG[208],0
1CD8: 52 FB    MOV   A,[X-5]
1CDA: 53 9C    MOV   [__r1],A
1CDC: 55 9D 00 MOV   [__r0],0
1CDF: 52 FC    MOV   A,[X-4]
1CE1: 02 9C    ADD   A,[__r1]
1CE3: 53 9C    MOV   [__r1],A
1CE5: 50 00    MOV   A,0
1CE7: 0A 9D    ADC   A,[__r0]
1CE9: 53 9D    MOV   [__r0],A
1CEB: 52 FA    MOV   A,[X-6]
1CED: 04 9C    ADD   [__r1],A
1CEF: 0E 9D 00 ADC   [__r0],0
1CF2: 52 F9    MOV   A,[X-7]
1CF4: 04 9C    ADD   [__r1],A
1CF6: 0E 9D 00 ADC   [__r0],0
1CF9: 52 F8    MOV   A,[X-8]
1CFB: 04 9C    ADD   [__r1],A
1CFD: 0E 9D 00 ADC   [__r0],0
1D00: 52 F7    MOV   A,[X-9]
1D02: 53 9A    MOV   [__r3],A
1D04: 55 9B 00 MOV   [__r2],0
1D07: 51 9C    MOV   A,[__r1]
1D09: 02 9A    ADD   A,[__r3]
1D0B: 54 02    MOV   [X+2],A
1D0D: 51 9D    MOV   A,[__r0]
1D0F: 0A 9B    ADC   A,[__r2]
1D11: 54 01    MOV   [X+1],A
(0651) 										
(0652) 										// Loop until we read a response or time out.
(0653) 										while(TIMEOUT < RX_TIMEOUT_DURATION)
1D13: 50 01    MOV   A,1
1D15: 08       PUSH  A
1D16: 50 00    MOV   A,0
1D18: 08       PUSH  A
1D19: 52 01    MOV   A,[X+1]
1D1B: 08       PUSH  A
1D1C: 52 02    MOV   A,[X+2]
1D1E: 08       PUSH  A
1D1F: 7C 23 61 LCALL __divmod_16X16_16
1D22: 38 FE    ADD   SP,254
1D24: 18       POP   A
1D25: 53 9C    MOV   [__r1],A
1D27: 18       POP   A
1D28: 50 FF    MOV   A,255
1D2A: 12 9C    SUB   A,[__r1]
1D2C: 54 00    MOV   [X+0],A
(0654) 										{
(0655) 											// Check for the checksum or 1.
(0656) 											if(tempByte = iReadChar())
1D2E: 10       PUSH  X
1D2F: 50 FF    MOV   A,255
1D31: 7C 09 75 LCALL 0x0975
1D34: 20       POP   X
(0657) 											{
1D35: 10       PUSH  X
1D36: 50 FF    MOV   A,255
1D38: 7C 08 9C LCALL 0x089C
1D3B: 20       POP   X
(0658) 												// Switch to PC mode to forward the result.
1D3C: 10       PUSH  X
1D3D: 50 FF    MOV   A,255
1D3F: 7C 09 75 LCALL 0x0975
1D42: 20       POP   X
(0659) 												configToggle(PC_MODE);
1D43: 10       PUSH  X
1D44: 50 FF    MOV   A,255
1D46: 7C 08 9C LCALL 0x089C
1D49: 20       POP   X
(0660) 												
1D4A: 10       PUSH  X
1D4B: 52 FC    MOV   A,[X-4]
1D4D: 7C 09 75 LCALL 0x0975
1D50: 20       POP   X
(0661) 												if((runningTotal%256) == (255-tempByte))
1D51: 10       PUSH  X
1D52: 52 FC    MOV   A,[X-4]
1D54: 7C 08 9C LCALL 0x089C
1D57: 20       POP   X
(0662) 												{
1D58: 10       PUSH  X
1D59: 52 FB    MOV   A,[X-5]
1D5B: 7C 09 75 LCALL 0x0975
1D5E: 20       POP   X
(0663) 													// Send a 0 if we hit the checksum.
1D5F: 10       PUSH  X
1D60: 52 FB    MOV   A,[X-5]
1D62: 7C 08 9C LCALL 0x089C
1D65: 20       POP   X
(0664) 													COMP_SERIAL_PutChar('0');
1D66: 10       PUSH  X
1D67: 52 FA    MOV   A,[X-6]
1D69: 7C 09 75 LCALL 0x0975
1D6C: 20       POP   X
(0665) 													COMP_SERIAL_PutChar('\n');
1D6D: 10       PUSH  X
1D6E: 52 FA    MOV   A,[X-6]
1D70: 7C 08 9C LCALL 0x089C
1D73: 20       POP   X
(0666) 												}
1D74: 10       PUSH  X
1D75: 52 F9    MOV   A,[X-7]
1D77: 7C 09 75 LCALL 0x0975
1D7A: 20       POP   X
(0667) 												else
1D7B: 10       PUSH  X
1D7C: 52 F9    MOV   A,[X-7]
1D7E: 7C 08 9C LCALL 0x089C
1D81: 20       POP   X
(0668) 												{
1D82: 10       PUSH  X
1D83: 52 F8    MOV   A,[X-8]
1D85: 7C 09 75 LCALL 0x0975
1D88: 20       POP   X
(0669) 													// Send a 1 if we hit it first.
1D89: 10       PUSH  X
1D8A: 52 F8    MOV   A,[X-8]
1D8C: 7C 08 9C LCALL 0x089C
1D8F: 20       POP   X
(0670) 													COMP_SERIAL_PutChar('1');
1D90: 10       PUSH  X
1D91: 52 F7    MOV   A,[X-9]
1D93: 7C 09 75 LCALL 0x0975
1D96: 20       POP   X
(0671) 													COMP_SERIAL_PutChar('\n');
1D97: 10       PUSH  X
1D98: 52 F7    MOV   A,[X-9]
1D9A: 7C 08 9C LCALL 0x089C
1D9D: 20       POP   X
(0672) 												}
1D9E: 10       PUSH  X
1D9F: 52 00    MOV   A,[X+0]
1DA1: 7C 09 75 LCALL 0x0975
1DA4: 20       POP   X
(0673) 		
1DA5: 10       PUSH  X
1DA6: 52 00    MOV   A,[X+0]
1DA8: 7C 08 9C LCALL 0x089C
1DAB: 20       POP   X
(0674) 												TIMEOUT = RX_TIMEOUT_DURATION;
(0675) 											}
(0676) 										}
1DAC: 94 53    CALL  _xmitWait
1DAE: 38 FD    ADD   SP,253
1DB0: 20       POP   X
1DB1: 7F       RET   
(0677) 									}
(0678) 								}
(0679) 							}
(0680) 						}
(0681) 					}
(0682) 					else if ((param[0] == 't') || (param[0] == 'T'))
_configToggle:
  mode                 --> X-5
1DB2: 10       PUSH  X
1DB3: 4F       MOV   X,SP
(0683) 					{
(0684) 						// If this isn't for the parent, ping the module to get a
1DB4: 43 00 FF OR    REG[0],255
(0685) 						// status packet and return the data.
1DB7: 62 02 00 MOV   REG[2],0
(0686) 						if(ID == 0)
(0687) 						{
(0688) 							COMP_SERIAL_PutChar(TYPE);
(0689) 							COMP_SERIAL_PutChar('\n');
1DBA: 62 D0 00 MOV   REG[208],0
1DBD: 3C A0 00 CMP   [STATE],0
1DC0: B0 06    JNZ   0x1DC7
1DC2: 3C A1 00 CMP   [STATE+1],0
1DC5: A0 10    JZ    0x1DD6
(0690) 						}
(0691) 						else if(pingModule(ID))
1DC7: 62 D0 00 MOV   REG[208],0
1DCA: 51 A0    MOV   A,[STATE]
1DCC: 08       PUSH  A
1DCD: 51 A1    MOV   A,[STATE+1]
1DCF: 08       PUSH  A
1DD0: 90 8E    CALL  _unloadConfig
1DD2: 38 FE    ADD   SP,254
(0692) 						{
1DD4: 80 03    JMP   0x1DD8
(0693) 							configToggle(PC_MODE);
(0694) 												
(0695) 							COMP_SERIAL_PutChar(PARAM[0]);
1DD6: 90 81    CALL  _unloadAllConfigs
(0696) 							COMP_SERIAL_PutChar('\n');
(0697) 						}
(0698) 					}
1DD8: 3D FB 00 CMP   [X-5],0
1DDB: B0 35    JNZ   0x1E11
1DDD: 3D FC 01 CMP   [X-4],1
1DE0: B0 30    JNZ   0x1E11
(0699) 					else if ((param[0] == 'c') || (param[0] == 'C'))
(0700) 					{
1DE2: 7C 06 98 LCALL 0x0698
(0701) 						// If this isn't for the parent, ping the module to get a
(0702) 						// status packet and return the data.
1DE5: 10       PUSH  X
1DE6: 7C 11 85 LCALL 0x1185
1DE9: 20       POP   X
(0703) 						if(ID == 0)
1DEA: 10       PUSH  X
1DEB: 50 01    MOV   A,1
1DED: 7C 10 82 LCALL 0x1082
1DF0: 20       POP   X
(0704) 						{
1DF1: 10       PUSH  X
1DF2: 50 00    MOV   A,0
1DF4: 7C 10 53 LCALL 0x1053
1DF7: 20       POP   X
(0705) 							COMP_SERIAL_PutChar(CHILD);
(0706) 							COMP_SERIAL_PutChar('\n');
1DF8: 10       PUSH  X
1DF9: 50 00    MOV   A,0
1DFB: 7C 09 3C LCALL 0x093C
1DFE: 20       POP   X
(0707) 						}
1DFF: 10       PUSH  X
1E00: 50 00    MOV   A,0
1E02: 7C 08 63 LCALL 0x0863
1E05: 20       POP   X
(0708) 						else if(pingModule(ID))
(0709) 						{	
(0710) 							configToggle(PC_MODE);
1E06: 62 D0 00 MOV   REG[208],0
1E09: 55 A1 01 MOV   [STATE+1],1
1E0C: 55 A0 00 MOV   [STATE],0
(0711) 							
1E0F: 80 44    JMP   0x1E54
(0712) 							COMP_SERIAL_PutChar(PARAM[1]);
1E11: 3D FB 00 CMP   [X-5],0
1E14: B0 3F    JNZ   0x1E54
1E16: 3D FC 02 CMP   [X-4],2
1E19: B0 3A    JNZ   0x1E54
(0713) 							COMP_SERIAL_PutChar('\n');
(0714) 						}
1E1B: 7C 06 31 LCALL 0x0631
(0715) 					}
(0716) 				}
(0717) 			}
(0718) 		}
(0719) 	}
(0720) 	
1E1E: 10       PUSH  X
1E1F: 50 00    MOV   A,0
1E21: 7C 0E E1 LCALL 0x0EE1
1E24: 20       POP   X
(0721) 	// Reset the timeout and switch to PC mode.
(0722) 	if(STATE != PC_MODE)
(0723) 	{
(0724) 		configToggle(PC_MODE);
(0725) 	}
1E25: 10       PUSH  X
1E26: 50 00    MOV   A,0
1E28: 7C 0D 88 LCALL 0x0D88
1E2B: 20       POP   X
(0726) 	else
(0727) 	{
(0728) 		TIMEOUT = 0;
(0729) 		COMP_SERIAL_CmdReset();
(0730) 	}
1E2C: 10       PUSH  X
1E2D: 50 00    MOV   A,0
1E2F: 7C 0C 2F LCALL 0x0C2F
1E32: 20       POP   X
(0731) }
(0732) 
(0733) // This function receives a destination, command length, instruction type, address, and value.
(0734) // With these parameters, the function sends a packet to the communication bus.
(0735) void servoInstruction(char id, char length, char instruction, char address, char value)
1E33: 10       PUSH  X
1E34: 50 00    MOV   A,0
1E36: 7C 0A D6 LCALL 0x0AD6
1E39: 20       POP   X
(0736) {
(0737) 	char checksum;	// The checksum byte value.
(0738) 	int total;		// The total for use in calculating the checksum.
(0739) 	
1E3A: 62 D0 00 MOV   REG[208],0
1E3D: 55 9F 00 MOV   [TIMEOUT+1],0
1E40: 55 9E 00 MOV   [TIMEOUT],0
(0740) 	// Get the total of all bytes.
1E43: 10       PUSH  X
1E44: 7C 09 FA LCALL 0x09FA
(0741) 	total = id + length + instruction + address + value;
1E47: 7C 0A 02 LCALL 0x0A02
1E4A: 20       POP   X
(0742) 	
(0743) 	// Calculate the checksum value for our servo communication.
(0744) 	checksum = 255-(total%256);
1E4B: 62 D0 00 MOV   REG[208],0
1E4E: 55 A1 02 MOV   [STATE+1],2
1E51: 55 A0 00 MOV   [STATE],0
(0745) 	
(0746) 	// Talk to the servo.
(0747) 	TX_REPEATER_14_PutChar(SERVO_START);	// Start byte one
(0748) 	TX_REPEATER_23_PutChar(SERVO_START);	// Start byte one
1E54: 43 02 FF OR    REG[2],255
1E57: 20       POP   X
1E58: 7F       RET   
(0749) 	TX_REPEATER_14_PutChar(SERVO_START);	// Start byte two
(0750) 	TX_REPEATER_23_PutChar(SERVO_START);	// Start byte two
(0751) 	TX_REPEATER_14_PutChar(id);			// The servo ID
(0752) 	TX_REPEATER_23_PutChar(id);				// The servo ID
(0753) 	TX_REPEATER_14_PutChar(length);		// Remaining packet length
(0754) 	TX_REPEATER_23_PutChar(length);			// Remaining packet length
(0755) 	TX_REPEATER_14_PutChar(instruction);	// Servo instruction
_unloadAllConfigs:
1E59: 7C 07 0F LCALL 0x070F
(0756) 	TX_REPEATER_23_PutChar(instruction);	// Servo instruction
1E5C: 7C 06 75 LCALL 0x0675
1E5F: 7F       RET   
(0757) 	TX_REPEATER_14_PutChar(address);		// Target memory address on the servo EEPROM
(0758) 	TX_REPEATER_23_PutChar(address);		// Target memory address on the servo EEPROM
(0759) 	TX_REPEATER_14_PutChar(value);			// The write value or number of bytes to read
(0760) 	TX_REPEATER_23_PutChar(value);			// The write value or number of bytes to read
(0761) 	TX_REPEATER_14_PutChar(checksum);		// This is the end of this transmission
(0762) 	TX_REPEATER_23_PutChar(checksum);		// This is the end of this transmission
_unloadConfig:
  config_num           --> X-5
1E60: 10       PUSH  X
1E61: 4F       MOV   X,SP
(0763) 	
1E62: 3D FB 00 CMP   [X-5],0
1E65: B0 0B    JNZ   0x1E71
1E67: 3D FC 01 CMP   [X-4],1
1E6A: B0 06    JNZ   0x1E71
(0764) 	// Make completely sure we're done.
(0765) 	xmitWait();
1E6C: 7C 07 0F LCALL 0x070F
(0766) }
1E6F: 80 0E    JMP   0x1E7E
(0767) 
1E71: 3D FB 00 CMP   [X-5],0
1E74: B0 09    JNZ   0x1E7E
1E76: 3D FC 02 CMP   [X-4],2
1E79: B0 04    JNZ   0x1E7E
(0768) // This function receives a destination, command length, instruction type, address, and two values.
(0769) void longServoInstruction(char id, char length, char instruction, char address, char value1, char value2)
1E7B: 7C 06 75 LCALL 0x0675
(0770) {
1E7E: 20       POP   X
1E7F: 7F       RET   
(0771) 	char checksum;	// The checksum byte value.
(0772) 	int total;		// The total for use in calculating the checksum.
(0773) 	
(0774) 	// Get the total of all bytes.
_initializeChildren:
  num_timeouts         --> X+4
  ping_tries           --> X+2
  i                    --> X+0
1E80: 10       PUSH  X
1E81: 4F       MOV   X,SP
1E82: 38 06    ADD   SP,6
(0775) 	total = id + length + instruction + address + value1 + value2;
1E84: 56 05 00 MOV   [X+5],0
1E87: 56 04 00 MOV   [X+4],0
(0776) 	
1E8A: 56 03 05 MOV   [X+3],5
1E8D: 56 02 00 MOV   [X+2],0
(0777) 	// Calculate the checksum value for our servo communication.
1E90: 56 01 00 MOV   [X+1],0
1E93: 56 00 00 MOV   [X+0],0
(0778) 	checksum = 255-(total%256);
(0779) 	
(0780) 	// Talk to the servo.
1E96: 62 D0 00 MOV   REG[208],0
1E99: 55 A3 00 MOV   [NUM_MODULES+1],0
1E9C: 55 A2 00 MOV   [NUM_MODULES],0
(0781) 	TX_REPEATER_14_PutChar(SERVO_START);	// Start byte one
(0782) 	TX_REPEATER_23_PutChar(SERVO_START);	// Start byte one
(0783) 	TX_REPEATER_14_PutChar(SERVO_START);	// Start byte two
1E9F: 62 D0 00 MOV   REG[208],0
1EA2: 55 AC 00 MOV   [CHILD],0
1EA5: 80 22    JMP   0x1EC8
(0784) 	TX_REPEATER_23_PutChar(SERVO_START);	// Start byte two
(0785) 	TX_REPEATER_14_PutChar(id);			// The servo ID
(0786) 	TX_REPEATER_23_PutChar(id);				// The servo ID
(0787) 	TX_REPEATER_14_PutChar(length);		// Remaining packet length
(0788) 	TX_REPEATER_23_PutChar(length);			// Remaining packet length
1EA7: 7C 14 49 LCALL _sayHello
(0789) 	TX_REPEATER_14_PutChar(instruction);	// Servo instruction
(0790) 	TX_REPEATER_23_PutChar(instruction);	// Servo instruction
(0791) 	TX_REPEATER_14_PutChar(address);		// Target memory address on the servo EEPROM
1EAA: 91 A2    CALL  _childListen
1EAC: 62 D0 00 MOV   REG[208],0
1EAF: 3C 9D 00 CMP   [__r0],0
1EB2: B0 15    JNZ   0x1EC8
1EB4: 3C 9C 00 CMP   [__r1],0
1EB7: B0 10    JNZ   0x1EC8
(0792) 	TX_REPEATER_23_PutChar(address);		// Target memory address on the servo EEPROM
(0793) 	TX_REPEATER_14_PutChar(value1);		// The first write value
(0794) 	TX_REPEATER_23_PutChar(value1);			// The first write value
1EB9: 62 D0 00 MOV   REG[208],0
1EBC: 51 9F    MOV   A,[TIMEOUT+1]
1EBE: 11 02    SUB   A,2
1EC0: 51 9E    MOV   A,[TIMEOUT]
1EC2: 31 80    XOR   A,128
1EC4: 19 80    SBB   A,128
1EC6: CF F2    JC    0x1EB9
1EC8: 62 D0 00 MOV   REG[208],0
1ECB: 3C AC 00 CMP   [CHILD],0
1ECE: AF D8    JZ    0x1EA7
(0795) 	TX_REPEATER_14_PutChar(value2);		// The second write value
(0796) 	TX_REPEATER_23_PutChar(value2);			// The second write value
(0797) 	TX_REPEATER_14_PutChar(checksum);		// This is the end of this transmission
(0798) 	TX_REPEATER_23_PutChar(checksum);		// This is the end of this transmission
(0799) 	
(0800) 	// Make completely sure we're done.
(0801) 	xmitWait();
(0802) }
(0803) 
(0804) // This function allows the program to pass an RX or TX mode flag for switching between modes on the
(0805) // half duplex UART serial communication line.
(0806) void configToggle(int mode)
(0807) {
(0808) 	// Disconnect from the global bus and leave the pin high.
(0809) 	PRT0DR |= 0b11111111;
(0810) 	PRT0GS &= 0b00000000;
(0811) 
(0812) 	// Unload the configuration of the current state.
(0813) 	// If there is no state, blindly wipe all configurations.
(0814) 	if(STATE)
(0815) 	{
(0816) 		unloadConfig(STATE);
(0817) 	}
(0818) 	else
(0819) 	{
(0820) 		unloadAllConfigs();
(0821) 	}
(0822) 	
(0823) 	if(mode == PC_MODE)
(0824) 	{
(0825) 		LoadConfig_pc_listener();
(0826) 
(0827) 		COMP_SERIAL_CmdReset();								// Initialize the buffer.
(0828) 		COMP_SERIAL_IntCntl(COMP_SERIAL_ENABLE_RX_INT); 	// Enable RX interrupts  
(0829) 		COMP_SERIAL_Start(UART_PARITY_NONE);				// Starts the UART.
(0830) 		
1ED0: 7C 14 49 LCALL _sayHello
1ED3: 80 F7    JMP   0x1FCB
(0831) 		TX_REPEATER_14_Start(TX_REPEATER_14_PARITY_NONE);	// Start the 014 TX repeater.
(0832) 		TX_REPEATER_23_Start(TX_REPEATER_23_PARITY_NONE);	// Start the 23 TX repeater.
(0833) 		
(0834) 		// Store the state.
(0835) 		STATE = PC_MODE;
(0836) 	}
1ED5: 7C 14 C5 LCALL _validTransmission
1ED8: 62 D0 00 MOV   REG[208],0
1EDB: 3C 9D 00 CMP   [__r0],0
1EDE: B0 06    JNZ   0x1EE5
1EE0: 3C 9C 00 CMP   [__r1],0
1EE3: A0 96    JZ    0x1F7A
(0837) 	else if(mode == RX_MODE)
(0838) 	{
1EE5: 62 D0 00 MOV   REG[208],0
1EE8: 3C A9 C8 CMP   [COMMAND_TYPE],200
1EEB: B0 DF    JNZ   0x1FCB
(0839) 		LoadConfig_receiver_config();
(0840) 		
(0841) 		// Start the receivers.
1EED: 62 D0 00 MOV   REG[208],0
1EF0: 3C AA 00 CMP   [COMMAND_DESTINATION],0
1EF3: B0 D7    JNZ   0x1FCB
(0842) 		// The seemingly unnecessary brackets around each line are unfortunately needed.
(0843) 		{
1EF5: 62 D0 00 MOV   REG[208],0
1EF8: 76 A3    INC   [NUM_MODULES+1]
1EFA: 0E A2 00 ADC   [NUM_MODULES],0
(0844) 		// Start listening for a response through child port 1.
1EFD: 56 05 00 MOV   [X+5],0
1F00: 56 04 00 MOV   [X+4],0
(0845) 		RECEIVE_1_Start(RECEIVE_1_PARITY_NONE);
(0846) 		}
1F03: 51 A2    MOV   A,[NUM_MODULES]
1F05: 08       PUSH  A
1F06: 51 A3    MOV   A,[NUM_MODULES+1]
1F08: 08       PUSH  A
1F09: 7C 13 4E LCALL _assignID
1F0C: 38 FE    ADD   SP,254
1F0E: 62 D0 00 MOV   REG[208],0
1F11: 3C 9D 00 CMP   [__r0],0
1F14: B0 B6    JNZ   0x1FCB
1F16: 3C 9C 00 CMP   [__r1],0
1F19: B0 B1    JNZ   0x1FCB
(0847) 		
(0848) 		{
(0849) 		// Start listening for a response through child port 2.
(0850) 		RECEIVE_2_Start(RECEIVE_2_PARITY_NONE);
(0851) 		}
1F1B: 56 01 00 MOV   [X+1],0
1F1E: 56 00 00 MOV   [X+0],0
1F21: 80 2D    JMP   0x1F4F
(0852) 		
(0853) 		{
1F23: 62 D0 00 MOV   REG[208],0
1F26: 51 A2    MOV   A,[NUM_MODULES]
1F28: 08       PUSH  A
1F29: 51 A3    MOV   A,[NUM_MODULES+1]
1F2B: 08       PUSH  A
1F2C: 7C 12 61 LCALL _pingModule
1F2F: 38 FE    ADD   SP,254
1F31: 62 D0 00 MOV   REG[208],0
1F34: 3C 9D 00 CMP   [__r0],0
1F37: B0 06    JNZ   0x1F3E
1F39: 3C 9C 00 CMP   [__r1],0
1F3C: A0 0D    JZ    0x1F4A
(0854) 		// Start listening for a response through child port 3.
(0855) 		RECEIVE_3_Start(RECEIVE_3_PARITY_NONE);
1F3E: 52 03    MOV   A,[X+3]
1F40: 01 01    ADD   A,1
1F42: 54 01    MOV   [X+1],A
1F44: 52 02    MOV   A,[X+2]
1F46: 09 00    ADC   A,0
1F48: 54 00    MOV   [X+0],A
1F4A: 77 01    INC   [X+1]
1F4C: 0F 00 00 ADC   [X+0],0
1F4F: 52 01    MOV   A,[X+1]
1F51: 13 03    SUB   A,[X+3]
1F53: 52 02    MOV   A,[X+2]
1F55: 31 80    XOR   A,128
1F57: 62 D0 00 MOV   REG[208],0
1F5A: 53 97    MOV   [__rX],A
1F5C: 52 00    MOV   A,[X+0]
1F5E: 31 80    XOR   A,128
1F60: 1A 97    SBB   A,[__rX]
1F62: CF C0    JC    0x1F23
(0856) 		}
(0857) 		
(0858) 		{
(0859) 		// Start listening for a response through child port 4.
(0860) 		RECEIVE_4_Start(RECEIVE_4_PARITY_NONE);
1F64: 52 00    MOV   A,[X+0]
1F66: 3B 02    CMP   A,[X+2]
1F68: B0 62    JNZ   0x1FCB
1F6A: 52 01    MOV   A,[X+1]
1F6C: 3B 03    CMP   A,[X+3]
1F6E: B0 5C    JNZ   0x1FCB
(0861) 		}
(0862) 		
1F70: 62 D0 00 MOV   REG[208],0
1F73: 7A A3    DEC   [NUM_MODULES+1]
1F75: 1E A2 00 SBB   [NUM_MODULES],0
(0863) 		// Start response timeout timer and enable its interrupt routine.
(0864) 		TIMEOUT = 0;
(0865) 		RX_TIMEOUT_EnableInt();
(0866) 		RX_TIMEOUT_Start();
(0867) 		
1F78: 80 52    JMP   0x1FCB
(0868) 		// Store the state.
1F7A: 62 D0 00 MOV   REG[208],0
1F7D: 51 9F    MOV   A,[TIMEOUT+1]
1F7F: 11 05    SUB   A,5
1F81: 51 9E    MOV   A,[TIMEOUT]
1F83: 31 80    XOR   A,128
1F85: 19 80    SBB   A,128
1F87: C0 43    JC    0x1FCB
(0869) 		STATE = RX_MODE;
(0870) 	}
(0871) 	
1F89: 62 D0 00 MOV   REG[208],0
1F8C: 3C A2 00 CMP   [NUM_MODULES],0
1F8F: B0 06    JNZ   0x1F96
1F91: 3C A3 00 CMP   [NUM_MODULES+1],0
1F94: A0 08    JZ    0x1F9D
(0872) 	// Reconnect to the global bus.
(0873) 	PRT0GS |= 0b11111111;
1F96: 77 05    INC   [X+5]
1F98: 0F 04 00 ADC   [X+4],0
(0874) }
1F9B: 80 10    JMP   0x1FAC
(0875) 
(0876) // This function blindly unloads all user configurations. This will be called once,
(0877) // when the system initially has no known state.
(0878) void unloadAllConfigs(void)
(0879) {
1F9D: 62 D0 00 MOV   REG[208],0
1FA0: 51 9F    MOV   A,[TIMEOUT+1]
1FA2: 11 02    SUB   A,2
1FA4: 51 9E    MOV   A,[TIMEOUT]
1FA6: 31 80    XOR   A,128
1FA8: 19 80    SBB   A,128
1FAA: CF F2    JC    0x1F9D
(0880) 	UnloadConfig_pc_listener();
(0881) 	UnloadConfig_receiver_config();
(0882) }
(0883) 
1FAC: 62 D0 00 MOV   REG[208],0
1FAF: 51 A3    MOV   A,[NUM_MODULES+1]
1FB1: 11 FA    SUB   A,250
1FB3: 51 A2    MOV   A,[NUM_MODULES]
1FB5: 31 80    XOR   A,128
1FB7: 19 80    SBB   A,128
1FB9: D0 11    JNC   0x1FCB
(0884) // This function unloads the configuration corresponding to the config number passed to it.
(0885) // We do this instead of unloadAllConfigs to cut down on set up time.
1FBB: 62 D0 00 MOV   REG[208],0
1FBE: 51 A0    MOV   A,[STATE]
1FC0: 08       PUSH  A
1FC1: 51 A1    MOV   A,[STATE+1]
1FC3: 08       PUSH  A
1FC4: 92 5A    CALL  _preXmitWait
1FC6: 38 FE    ADD   SP,254
(0886) void unloadConfig(int config_num)
1FC8: 7C 14 49 LCALL _sayHello
1FCB: 52 05    MOV   A,[X+5]
1FCD: 11 32    SUB   A,50
1FCF: 52 04    MOV   A,[X+4]
1FD1: 31 80    XOR   A,128
1FD3: 19 80    SBB   A,128
1FD5: CE FF    JC    0x1ED5
(0887) {
(0888) 	if(config_num == PC_MODE)
(0889) 	{
(0890) 		UnloadConfig_pc_listener();
(0891) 	}
(0892) 	else if(config_num == RX_MODE)
1FD7: 62 D0 00 MOV   REG[208],0
1FDA: 3C A2 00 CMP   [NUM_MODULES],0
1FDD: B0 62    JNZ   0x2040
1FDF: 3C A3 00 CMP   [NUM_MODULES+1],0
1FE2: B0 5D    JNZ   0x2040
(0893) 	{
(0894) 		UnloadConfig_receiver_config();
(0895) 	}
1FE4: 56 01 00 MOV   [X+1],0
1FE7: 56 00 00 MOV   [X+0],0
1FEA: 80 40    JMP   0x202B
(0896) }
(0897) 
1FEC: 62 D0 00 MOV   REG[208],0
1FEF: 51 A3    MOV   A,[NUM_MODULES+1]
1FF1: 01 01    ADD   A,1
1FF3: 62 D0 00 MOV   REG[208],0
1FF6: 53 9C    MOV   [__r1],A
1FF8: 62 D0 00 MOV   REG[208],0
1FFB: 51 A2    MOV   A,[NUM_MODULES]
1FFD: 09 00    ADC   A,0
1FFF: 62 D0 00 MOV   REG[208],0
2002: 08       PUSH  A
2003: 51 9C    MOV   A,[__r1]
2005: 08       PUSH  A
2006: 7C 12 61 LCALL _pingModule
2009: 38 FE    ADD   SP,254
200B: 62 D0 00 MOV   REG[208],0
200E: 3C 9D 00 CMP   [__r0],0
2011: B0 06    JNZ   0x2018
2013: 3C 9C 00 CMP   [__r1],0
2016: A0 0F    JZ    0x2026
(0898) void initializeChildren(void)
(0899) {
2018: 62 D0 00 MOV   REG[208],0
201B: 76 A3    INC   [NUM_MODULES+1]
201D: 0E A2 00 ADC   [NUM_MODULES],0
(0900) 	int num_timeouts = 0;	// The number of consecutive timeouts.
2020: 56 01 00 MOV   [X+1],0
2023: 56 00 00 MOV   [X+0],0
2026: 77 01    INC   [X+1]
2028: 0F 00 00 ADC   [X+0],0
202B: 52 01    MOV   A,[X+1]
202D: 13 03    SUB   A,[X+3]
202F: 52 02    MOV   A,[X+2]
2031: 31 80    XOR   A,128
2033: 62 D0 00 MOV   REG[208],0
2036: 53 97    MOV   [__rX],A
2038: 52 00    MOV   A,[X+0]
203A: 31 80    XOR   A,128
203C: 1A 97    SBB   A,[__rX]
203E: CF AD    JC    0x1FEC
(0901) 	int ping_tries = 5;		// The number of times to try a ping on an unregistered module.
(0902) 	int i = 0;				// An iterator for looping.
(0903) 	
(0904) 	// Set num modules to zero.
(0905) 	NUM_MODULES = 0;
(0906) 	
2040: 50 00    MOV   A,0
2042: 08       PUSH  A
2043: 50 01    MOV   A,1
2045: 08       PUSH  A
2046: 9D 6A    CALL  _configToggle
2048: 38 FE    ADD   SP,254
204A: 38 FA    ADD   SP,250
204C: 20       POP   X
204D: 7F       RET   
(0907) 	// Set the child value to zero.
(0908) 	CHILD = 0;	
(0909) 	
(0910) 	while(CHILD == 0)
(0911) 	{
_childListen:
204E: 80 E3    JMP   0x2132
(0912) 		// Send out a probing message.
(0913) 		sayHello();
(0914) 		
(0915) 		// Listen for a response.
(0916) 		if(!childListen())
(0917) 		{
2050: 10       PUSH  X
2051: 7C 0E F8 LCALL 0x0EF8
2054: 62 D0 00 MOV   REG[208],0
2057: 20       POP   X
2058: 39 FC    CMP   A,252
205A: B0 2E    JNZ   0x2089
(0918) 			// Wait for INIT_WAIT_TIME before we try again.
205C: 80 1B    JMP   0x2078
(0919) 			while(TIMEOUT < INIT_WAIT_TIME){ }
(0920) 		}
(0921) 	}
205E: 10       PUSH  X
205F: 7C 0E F8 LCALL 0x0EF8
2062: 20       POP   X
2063: 39 FD    CMP   A,253
2065: B0 12    JNZ   0x2078
(0922) 	
(0923) /*	while(1)
2067: 62 D0 00 MOV   REG[208],0
206A: 55 AC 31 MOV   [CHILD],49
(0924) 	{
206D: 62 D0 00 MOV   REG[208],0
2070: 55 9C 01 MOV   [__r1],1
2073: 55 9D 00 MOV   [__r0],0
2076: 80 D3    JMP   0x214A
2078: 62 D0 00 MOV   REG[208],0
207B: 51 9F    MOV   A,[TIMEOUT+1]
207D: 11 05    SUB   A,5
207F: 51 9E    MOV   A,[TIMEOUT]
2081: 31 80    XOR   A,128
2083: 19 80    SBB   A,128
2085: CF D8    JC    0x205E
(0925) 		PRT1DR |= 0b00000001;
(0926) 		
(0927) 		if(CHILD == PORT_1)
2087: 80 AA    JMP   0x2132
(0928) 		{
2089: 10       PUSH  X
208A: 7C 0D 9F LCALL 0x0D9F
208D: 62 D0 00 MOV   REG[208],0
2090: 20       POP   X
2091: 39 FC    CMP   A,252
2093: B0 2E    JNZ   0x20C2
(0929) 			xmitWait();
2095: 80 1B    JMP   0x20B1
(0930) 		}
(0931) 		else if(CHILD == PORT_2)
(0932) 		{
2097: 10       PUSH  X
2098: 7C 0D 9F LCALL 0x0D9F
209B: 20       POP   X
209C: 39 FD    CMP   A,253
209E: B0 12    JNZ   0x20B1
(0933) 			xmitWait();
(0934) 			xmitWait();
20A0: 62 D0 00 MOV   REG[208],0
20A3: 55 AC 32 MOV   [CHILD],50
(0935) 		}
20A6: 62 D0 00 MOV   REG[208],0
20A9: 55 9C 01 MOV   [__r1],1
20AC: 55 9D 00 MOV   [__r0],0
20AF: 80 9A    JMP   0x214A
20B1: 62 D0 00 MOV   REG[208],0
20B4: 51 9F    MOV   A,[TIMEOUT+1]
20B6: 11 05    SUB   A,5
20B8: 51 9E    MOV   A,[TIMEOUT]
20BA: 31 80    XOR   A,128
20BC: 19 80    SBB   A,128
20BE: CF D8    JC    0x2097
(0936) 		else if(CHILD == PORT_3)
(0937) 		{
(0938) 			xmitWait();
20C0: 80 71    JMP   0x2132
(0939) 			xmitWait();
20C2: 10       PUSH  X
20C3: 7C 0C 46 LCALL 0x0C46
20C6: 62 D0 00 MOV   REG[208],0
20C9: 20       POP   X
20CA: 39 FC    CMP   A,252
20CC: B0 2E    JNZ   0x20FB
(0940) 			xmitWait();
20CE: 80 1B    JMP   0x20EA
(0941) 		}
(0942) 		else if(CHILD == PORT_4)
(0943) 		{
20D0: 10       PUSH  X
20D1: 7C 0C 46 LCALL 0x0C46
20D4: 20       POP   X
20D5: 39 FD    CMP   A,253
20D7: B0 12    JNZ   0x20EA
(0944) 			xmitWait();
(0945) 			xmitWait();
20D9: 62 D0 00 MOV   REG[208],0
20DC: 55 AC 33 MOV   [CHILD],51
(0946) 			xmitWait();
20DF: 62 D0 00 MOV   REG[208],0
20E2: 55 9C 01 MOV   [__r1],1
20E5: 55 9D 00 MOV   [__r0],0
20E8: 80 61    JMP   0x214A
20EA: 62 D0 00 MOV   REG[208],0
20ED: 51 9F    MOV   A,[TIMEOUT+1]
20EF: 11 05    SUB   A,5
20F1: 51 9E    MOV   A,[TIMEOUT]
20F3: 31 80    XOR   A,128
20F5: 19 80    SBB   A,128
20F7: CF D8    JC    0x20D0
(0947) 			xmitWait();
(0948) 		}
(0949) 		
20F9: 80 38    JMP   0x2132
(0950) 		PRT1DR &= 0b11111110;
20FB: 10       PUSH  X
20FC: 7C 0A ED LCALL 0x0AED
20FF: 62 D0 00 MOV   REG[208],0
2102: 20       POP   X
2103: 39 FC    CMP   A,252
2105: B0 2C    JNZ   0x2132
(0951) 		xmitWait();
2107: 80 1B    JMP   0x2123
(0952) 	}
(0953) */	
(0954) 	// Send out a probing message.
2109: 10       PUSH  X
210A: 7C 0A ED LCALL 0x0AED
210D: 20       POP   X
210E: 39 FD    CMP   A,253
2110: B0 12    JNZ   0x2123
(0955) 	sayHello();
(0956) 	
2112: 62 D0 00 MOV   REG[208],0
2115: 55 AC 34 MOV   [CHILD],52
(0957) 	// This loop continuously probes and listens at intervals
2118: 62 D0 00 MOV   REG[208],0
211B: 55 9C 01 MOV   [__r1],1
211E: 55 9D 00 MOV   [__r0],0
2121: 80 28    JMP   0x214A
2123: 62 D0 00 MOV   REG[208],0
2126: 51 9F    MOV   A,[TIMEOUT+1]
2128: 11 05    SUB   A,5
212A: 51 9E    MOV   A,[TIMEOUT]
212C: 31 80    XOR   A,128
212E: 19 80    SBB   A,128
2130: CF D8    JC    0x2109
2132: 62 D0 00 MOV   REG[208],0
2135: 51 9F    MOV   A,[TIMEOUT+1]
2137: 11 05    SUB   A,5
2139: 51 9E    MOV   A,[TIMEOUT]
213B: 31 80    XOR   A,128
213D: 19 80    SBB   A,128
213F: CF 10    JC    0x2050
(0958) 	// set by the RX_TIMEOUT_DURATION variable.
(0959) 	while(num_timeouts < MAX_TIMEOUTS)
(0960) 	{	
(0961) 		if(validTransmission())
(0962) 		{
(0963) 			if(COMMAND_TYPE == HELLO_BYTE)	// Someone else is out there!
2141: 62 D0 00 MOV   REG[208],0
2144: 55 9C 00 MOV   [__r1],0
2147: 55 9D 00 MOV   [__r0],0
214A: 7F       RET   
(0964) 			{
(0965) 				// If this is for me, assign them an ID.
(0966) 				if(COMMAND_DESTINATION == PARENT_ID)
(0967) 				{
(0968) 					NUM_MODULES++;			// Increment the number of modules connected.
(0969) 					num_timeouts = 0;		// Reset number of timeouts since we found someone.
_iReadChar:
214B: 62 D0 00 MOV   REG[208],0
214E: 3C AC 31 CMP   [CHILD],49
2151: B0 0B    JNZ   0x215D
(0970) 		
(0971) 					if(!assignID(NUM_MODULES))
2153: 10       PUSH  X
2154: 7C 0E F8 LCALL 0x0EF8
2157: 62 D0 00 MOV   REG[208],0
215A: 20       POP   X
215B: 80 3C    JMP   0x2198
(0972) 					{
(0973) 						// If the module did not respond that the ID was assigned,
215D: 62 D0 00 MOV   REG[208],0
2160: 3C AC 32 CMP   [CHILD],50
2163: B0 0B    JNZ   0x216F
(0974) 						// make an effort to ping it in case that transmission was lost
(0975) 						// before ultimately deciding that the module didn't configure.
2165: 10       PUSH  X
2166: 7C 0D 9F LCALL 0x0D9F
2169: 62 D0 00 MOV   REG[208],0
216C: 20       POP   X
216D: 80 2A    JMP   0x2198
(0976) 						for(i = 0; i < ping_tries; i++)
(0977) 						{	
216F: 62 D0 00 MOV   REG[208],0
2172: 3C AC 33 CMP   [CHILD],51
2175: B0 0B    JNZ   0x2181
(0978) 							if(pingModule(NUM_MODULES))
(0979) 							{
2177: 10       PUSH  X
2178: 7C 0C 46 LCALL 0x0C46
217B: 62 D0 00 MOV   REG[208],0
217E: 20       POP   X
217F: 80 18    JMP   0x2198
(0980) 								i = ping_tries+1;
(0981) 							}
2181: 62 D0 00 MOV   REG[208],0
2184: 3C AC 34 CMP   [CHILD],52
2187: B0 0B    JNZ   0x2193
(0982) 						}
(0983) 						
2189: 10       PUSH  X
218A: 7C 0A ED LCALL 0x0AED
218D: 62 D0 00 MOV   REG[208],0
2190: 20       POP   X
2191: 80 06    JMP   0x2198
(0984) 						// If we landed right at ping_tries, we failed.
(0985) 						if(i == ping_tries)
(0986) 						{
(0987) 							NUM_MODULES--;
2193: 62 D0 00 MOV   REG[208],0
2196: 50 00    MOV   A,0
2198: 7F       RET   
(0988) 						}
(0989) 					}
(0990) 				}
(0991) 			}
(0992) 		}
(0993) 		else if(TIMEOUT >= RX_TIMEOUT_DURATION)
(0994) 		{	
_readChar:
2199: 62 D0 00 MOV   REG[208],0
219C: 3C AC 31 CMP   [CHILD],49
219F: B0 0B    JNZ   0x21AB
(0995) 			// Only increment the number of timeouts if we have found a module.
(0996) 			if(NUM_MODULES)
21A1: 10       PUSH  X
21A2: 7C 0E F0 LCALL 0x0EF0
21A5: 62 D0 00 MOV   REG[208],0
21A8: 20       POP   X
21A9: 80 3C    JMP   0x21E6
(0997) 			{
(0998) 				num_timeouts++;
21AB: 62 D0 00 MOV   REG[208],0
21AE: 3C AC 32 CMP   [CHILD],50
21B1: B0 0B    JNZ   0x21BD
(0999) 			}
(1000) 			else
21B3: 10       PUSH  X
21B4: 7C 0D 97 LCALL 0x0D97
21B7: 62 D0 00 MOV   REG[208],0
21BA: 20       POP   X
21BB: 80 2A    JMP   0x21E6
(1001) 			{
(1002) 				// Wait additional time between transmissions if no modules have been found.
21BD: 62 D0 00 MOV   REG[208],0
21C0: 3C AC 33 CMP   [CHILD],51
21C3: B0 0B    JNZ   0x21CF
(1003) 				// This is done to give the first child a chance to configure if it hasn't.
(1004) 				while(TIMEOUT < INIT_WAIT_TIME) { }
21C5: 10       PUSH  X
21C6: 7C 0C 3E LCALL 0x0C3E
21C9: 62 D0 00 MOV   REG[208],0
21CC: 20       POP   X
21CD: 80 18    JMP   0x21E6
(1005) 			}
(1006) 			
21CF: 62 D0 00 MOV   REG[208],0
21D2: 3C AC 34 CMP   [CHILD],52
21D5: B0 0B    JNZ   0x21E1
(1007) 			// If we are not maxed out on modules, look for more.
(1008) 			if(NUM_MODULES < MAX_MODULES)
21D7: 10       PUSH  X
21D8: 7C 0A E5 LCALL 0x0AE5
21DB: 62 D0 00 MOV   REG[208],0
21DE: 20       POP   X
21DF: 80 06    JMP   0x21E6
(1009) 			{
(1010) 				preXmitWait(STATE);
(1011) 				sayHello();
(1012) 			}
21E1: 62 D0 00 MOV   REG[208],0
21E4: 50 00    MOV   A,0
21E6: 7F       RET   
(1013) 		}
(1014) 	}
(1015) 	
(1016) 	// If we didn't find any new modules, check to see if some already exist.
(1017) 	if(!NUM_MODULES)
(1018) 	{
_bootWait:
21E7: 50 00    MOV   A,0
21E9: 08       PUSH  A
21EA: 50 02    MOV   A,2
21EC: 08       PUSH  A
21ED: 9B C3    CALL  _configToggle
21EF: 38 FE    ADD   SP,254
(1019) 		// Try to ping the next module up from our current number ping_tries times.
(1020) 		for(i = 0; i < ping_tries; i++)
(1021) 		{	
21F1: 62 D0 00 MOV   REG[208],0
21F4: 51 9F    MOV   A,[TIMEOUT+1]
21F6: 11 F4    SUB   A,244
21F8: 51 9E    MOV   A,[TIMEOUT]
21FA: 31 80    XOR   A,128
21FC: 19 81    SBB   A,129
21FE: CF F2    JC    0x21F1
2200: 7F       RET   
(1022) 			if(pingModule(NUM_MODULES+1))
(1023) 			{
(1024) 				NUM_MODULES++;
(1025) 				i = 0;
_xmitWait:
  i                    --> X+0
2201: 10       PUSH  X
2202: 4F       MOV   X,SP
2203: 38 02    ADD   SP,2
(1026) 			}
(1027) 		}
(1028) 	}
2205: 56 01 00 MOV   [X+1],0
2208: 56 00 00 MOV   [X+0],0
220B: 77 01    INC   [X+1]
220D: 0F 00 00 ADC   [X+0],0
2210: 52 01    MOV   A,[X+1]
2212: 11 19    SUB   A,25
2214: 52 00    MOV   A,[X+0]
2216: 31 80    XOR   A,128
2218: 19 80    SBB   A,128
221A: CF F0    JC    0x220B
221C: 38 FE    ADD   SP,254
221E: 20       POP   X
221F: 7F       RET   
(1029) 	
(1030) 	// Switch back to PC mode.
(1031) 	configToggle(PC_MODE);
(1032) }
(1033) 
(1034) // This function listens for children and registers the port that they talk to.
(1035) int childListen(void)
_preXmitWait:
  currentState         --> X-5
2220: 10       PUSH  X
2221: 4F       MOV   X,SP
(1036) {	
2222: 62 D0 00 MOV   REG[208],0
2225: 3C A0 00 CMP   [STATE],0
2228: B0 34    JNZ   0x225D
222A: 3C A1 01 CMP   [STATE+1],1
222D: B0 2F    JNZ   0x225D
(1037) 	// Wait to either hear a child or time out.
(1038) 	while(TIMEOUT < RX_TIMEOUT_DURATION)
222F: 62 D0 00 MOV   REG[208],0
2232: 55 9F 00 MOV   [TIMEOUT+1],0
2235: 55 9E 00 MOV   [TIMEOUT],0
(1039) 	{		
2238: 10       PUSH  X
2239: 7C 07 E8 LCALL 0x07E8
(1040) 		// Check all of the ports for a start byte. Only one port will produce one.
223C: 7C 07 F0 LCALL 0x07F0
223F: 20       POP   X
(1041) 		// Only non-blocking commands are used to avoid getting stuck listening downstream.
(1042) 		if(RECEIVE_1_cReadChar() == START_TRANSMIT)
(1043) 		{
2240: 62 D0 00 MOV   REG[208],0
2243: 3C 9E 00 CMP   [TIMEOUT],0
2246: B0 06    JNZ   0x224D
2248: 3C 9F 00 CMP   [TIMEOUT+1],0
224B: AF F4    JZ    0x2240
(1044) 			while(TIMEOUT < RX_TIMEOUT_DURATION)
(1045) 			{
(1046) 				if(RECEIVE_1_cReadChar() == END_TRANSMIT)
224D: 10       PUSH  X
224E: 7C 07 F4 LCALL 0x07F4
2251: 20       POP   X
(1047) 				{
2252: 62 D0 00 MOV   REG[208],0
2255: 55 9F 00 MOV   [TIMEOUT+1],0
2258: 55 9E 00 MOV   [TIMEOUT],0
(1048) 					CHILD = PORT_1;
225B: 80 3C    JMP   0x2298
(1049) 					return 1;
225D: 62 D0 00 MOV   REG[208],0
2260: 3C A0 00 CMP   [STATE],0
2263: B0 34    JNZ   0x2298
2265: 3C A1 02 CMP   [STATE+1],2
2268: B0 2F    JNZ   0x2298
(1050) 				}
(1051) 			}
226A: 10       PUSH  X
226B: 7C 0A 06 LCALL 0x0A06
226E: 20       POP   X
(1052) 		}
226F: 62 D0 00 MOV   REG[208],0
2272: 55 9F 00 MOV   [TIMEOUT+1],0
2275: 55 9E 00 MOV   [TIMEOUT],0
(1053) 		else if(RECEIVE_2_cReadChar() == START_TRANSMIT)
2278: 10       PUSH  X
2279: 7C 0A 02 LCALL 0x0A02
227C: 20       POP   X
(1054) 		{
(1055) 			while(TIMEOUT < RX_TIMEOUT_DURATION)
(1056) 			{
227D: 62 D0 00 MOV   REG[208],0
2280: 3C 9E 00 CMP   [TIMEOUT],0
2283: B0 06    JNZ   0x228A
2285: 3C 9F 00 CMP   [TIMEOUT+1],0
2288: AF F4    JZ    0x227D
(1057) 				if(RECEIVE_2_cReadChar() == END_TRANSMIT)
(1058) 				{
(1059) 					CHILD = PORT_2;
228A: 10       PUSH  X
228B: 7C 0A 06 LCALL 0x0A06
228E: 20       POP   X
(1060) 					return 1;
228F: 62 D0 00 MOV   REG[208],0
2292: 55 9F 00 MOV   [TIMEOUT+1],0
2295: 55 9E 00 MOV   [TIMEOUT],0
(1061) 				}
2298: 20       POP   X
2299: 7F       RET   
(1062) 			}
(1063) 		}
(1064) 		else if(RECEIVE_3_cReadChar() == START_TRANSMIT)
(1065) 		{
_TX_TIMEOUT_ISR:
229A: 71 C0    OR    F,192
229C: 08       PUSH  A
229D: 5D D0    MOV   A,REG[208]
229F: 08       PUSH  A
(1066) 			while(TIMEOUT < RX_TIMEOUT_DURATION)
(1067) 			{
22A0: 62 D0 00 MOV   REG[208],0
22A3: 76 9F    INC   [TIMEOUT+1]
22A5: 0E 9E 00 ADC   [TIMEOUT],0
(1068) 				if(RECEIVE_3_cReadChar() == END_TRANSMIT)
(1069) 				{
22A8: 62 DA FD MOV   REG[218],253
22AB: 18       POP   A
22AC: 60 D0    MOV   REG[208],A
22AE: 18       POP   A
22AF: 7E       RETI  
(1070) 					CHILD = PORT_3;
(1071) 					return 1;
(1072) 				}
(1073) 			}
_RX_TIMEOUT_ISR:
22B0: 71 C0    OR    F,192
22B2: 08       PUSH  A
22B3: 5D D0    MOV   A,REG[208]
22B5: 08       PUSH  A
(1074) 		}
(1075) 		else if(RECEIVE_4_cReadChar() == START_TRANSMIT)
22B6: 62 D0 00 MOV   REG[208],0
22B9: 76 9F    INC   [TIMEOUT+1]
22BB: 0E 9E 00 ADC   [TIMEOUT],0
(1076) 		{
(1077) 			while(TIMEOUT < RX_TIMEOUT_DURATION)
22BE: 62 DA FD MOV   REG[218],253
22C1: 18       POP   A
22C2: 60 D0    MOV   REG[208],A
22C4: 18       POP   A
22C5: 7E       RETI  

FILE: lib\psocdynamicint.asm
                                   (0001) ; Generated by PSoC Designer 5.0.985.0
                                   (0002) ;
                                   (0003) ;
                                   (0004) ;  fakemasterINT.asm
                                   (0005) ;
                                   (0006) ;  Data: 29 October, 2001
                                   (0007) ;  Copyright Cypress MicroSystems 2001
                                   (0008) ;
                                   (0009) ;  This file is generated by the Device Editor on Application Generation.
                                   (0010) ;  It contains dispatch code that ensures that interrupt vectors are 
                                   (0011) ;  serviced by the appropriate ISR depending on the currently active
                                   (0012) ;  configuration.
                                   (0013) ;  
                                   (0014) ;  DO NOT EDIT THIS FILE MANUALLY, AS IT IS OVERWRITTEN!!!
                                   (0015) ;  Edits to this file will not be preserved.
                                   (0016) ;
                                   (0017) include "PSoCDynamic.inc"
                                   (0018) include "m8c.inc"
                                   (0019) export	Dispatch_INTERRUPT_10
                                   (0020) export	Dispatch_INTERRUPT_11
                                   (0021) export	Dispatch_INTERRUPT_14
                                   (0022) export	Dispatch_INTERRUPT_15
                                   (0023) export	Dispatch_INTERRUPT_9
                                   (0024) 
                                   (0025) 
                                   (0026) Dispatch_INTERRUPT_10:
22C6: 08       PUSH  A             (0027) 	push	a
22C7: 50 00    MOV   A,0           (0028) 	mov		a,0
22C9: 47 08 02 TST   [8],2         (0029) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
22CC: B0 0C    JNZ   0x22D9        (0030) 	jnz		Dispatch_INTERRUPT_10_END
22CE: 50 04    MOV   A,4           (0031) 	mov		a,4
22D0: 47 08 01 TST   [8],1         (0032) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
22D3: B0 05    JNZ   0x22D9        (0033) 	jnz		Dispatch_INTERRUPT_10_END
22D5: 18       POP   A             (0034) 	pop		a
22D6: 7E       RETI                (0035) 	reti
                                   (0036) ; Stop Code Compressor from breaking table alignment
                                   (0037) ; The next instruction does not get executed.
22D7: 71 00    OR    F,0           (0038) 	Suspend_CodeCompressor
                                   (0039) Dispatch_INTERRUPT_10_END:
22D9: E0 01    JACC  0x22DB        (0040) 	jacc	Dispatch_INTERRUPT_10_TBL
                                   (0041) Dispatch_INTERRUPT_10_TBL:
22DB: 18       POP   A             (0042) 	pop		a
22DC: 7D 09 21 LJMP  0x0921        (0043) 	ljmp	_TX_REPEATER_14_ISR
22DF: 18       POP   A             (0044) 	pop		a
22E0: 7D 0E 65 LJMP  0x0E65        (0045) 	ljmp	_RECEIVE_1_ISR
                                   (0046) ; Resume Code Compressor.
                                   (0047) ; The next instruction does not get executed.
22E3: 38 00    ADD   SP,0          (0048) 	Resume_CodeCompressor
                                   (0049) 
                                   (0050) Dispatch_INTERRUPT_11:
22E5: 08       PUSH  A             (0051) 	push	a
22E6: 50 00    MOV   A,0           (0052) 	mov		a,0
22E8: 47 08 02 TST   [8],2         (0053) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
22EB: B0 0C    JNZ   0x22F8        (0054) 	jnz		Dispatch_INTERRUPT_11_END
22ED: 50 04    MOV   A,4           (0055) 	mov		a,4
22EF: 47 08 01 TST   [8],1         (0056) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
22F2: B0 05    JNZ   0x22F8        (0057) 	jnz		Dispatch_INTERRUPT_11_END
22F4: 18       POP   A             (0058) 	pop		a
22F5: 7E       RETI                (0059) 	reti
                                   (0060) ; Stop Code Compressor from breaking table alignment
                                   (0061) ; The next instruction does not get executed.
22F6: 71 00    OR    F,0           (0062) 	Suspend_CodeCompressor
                                   (0063) Dispatch_INTERRUPT_11_END:
22F8: E0 01    JACC  0x22FA        (0064) 	jacc	Dispatch_INTERRUPT_11_TBL
                                   (0065) Dispatch_INTERRUPT_11_TBL:
22FA: 18       POP   A             (0066) 	pop		a
22FB: 7D 08 48 LJMP  0x0848        (0067) 	ljmp	_TX_REPEATER_23_ISR
22FE: 18       POP   A             (0068) 	pop		a
22FF: 7D 0D 0C LJMP  0x0D0C        (0069) 	ljmp	_RECEIVE_2_ISR
                                   (0070) ; Resume Code Compressor.
                                   (0071) ; The next instruction does not get executed.
2302: 38 00    ADD   SP,0          (0072) 	Resume_CodeCompressor
                                   (0073) 
                                   (0074) Dispatch_INTERRUPT_14:
2304: 08       PUSH  A             (0075) 	push	a
2305: 50 00    MOV   A,0           (0076) 	mov		a,0
2307: 47 08 02 TST   [8],2         (0077) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
230A: B0 0C    JNZ   0x2317        (0078) 	jnz		Dispatch_INTERRUPT_14_END
230C: 50 04    MOV   A,4           (0079) 	mov		a,4
230E: 47 08 01 TST   [8],1         (0080) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
2311: B0 05    JNZ   0x2317        (0081) 	jnz		Dispatch_INTERRUPT_14_END
2313: 18       POP   A             (0082) 	pop		a
2314: 7E       RETI                (0083) 	reti
                                   (0084) ; Stop Code Compressor from breaking table alignment
                                   (0085) ; The next instruction does not get executed.
2315: 71 00    OR    F,0           (0086) 	Suspend_CodeCompressor
                                   (0087) Dispatch_INTERRUPT_14_END:
2317: E0 01    JACC  0x2319        (0088) 	jacc	Dispatch_INTERRUPT_14_TBL
                                   (0089) Dispatch_INTERRUPT_14_TBL:
2319: 18       POP   A             (0090) 	pop		a
231A: 7D 0F BE LJMP  0x0FBE        (0091) 	ljmp	_COMP_SERIAL_TX_ISR
231D: 18       POP   A             (0092) 	pop		a
231E: 7D 0B B3 LJMP  0x0BB3        (0093) 	ljmp	_RECEIVE_3_ISR
                                   (0094) ; Resume Code Compressor.
                                   (0095) ; The next instruction does not get executed.
2321: 38 00    ADD   SP,0          (0096) 	Resume_CodeCompressor
                                   (0097) 
                                   (0098) Dispatch_INTERRUPT_15:
2323: 08       PUSH  A             (0099) 	push	a
2324: 50 00    MOV   A,0           (0100) 	mov		a,0
2326: 47 08 02 TST   [8],2         (0101) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
2329: B0 0C    JNZ   0x2336        (0102) 	jnz		Dispatch_INTERRUPT_15_END
232B: 50 04    MOV   A,4           (0103) 	mov		a,4
232D: 47 08 01 TST   [8],1         (0104) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
2330: B0 05    JNZ   0x2336        (0105) 	jnz		Dispatch_INTERRUPT_15_END
2332: 18       POP   A             (0106) 	pop		a
2333: 7E       RETI                (0107) 	reti
                                   (0108) ; Stop Code Compressor from breaking table alignment
                                   (0109) ; The next instruction does not get executed.
2334: 71 00    OR    F,0           (0110) 	Suspend_CodeCompressor
                                   (0111) Dispatch_INTERRUPT_15_END:
2336: E0 01    JACC  0x2338        (0112) 	jacc	Dispatch_INTERRUPT_15_TBL
                                   (0113) Dispatch_INTERRUPT_15_TBL:
2338: 18       POP   A             (0114) 	pop		a
2339: 7D 0F BF LJMP  0x0FBF        (0115) 	ljmp	_COMP_SERIAL_RX_ISR
233C: 18       POP   A             (0116) 	pop		a
233D: 7D 0A 5A LJMP  0x0A5A        (0117) 	ljmp	_RECEIVE_4_ISR
                                   (0118) ; Resume Code Compressor.
                                   (0119) ; The next instruction does not get executed.
2340: 38 00    ADD   SP,0          (0120) 	Resume_CodeCompressor
                                   (0121) 
                                   (0122) Dispatch_INTERRUPT_9:
2342: 08       PUSH  A             (0123) 	push	a
2343: 50 00    MOV   A,0           (0124) 	mov		a,0
2345: 47 08 02 TST   [8],2         (0125) 	tst		[ACTIVE_CONFIG_STATUS+pc_listener_ADDR_OFF], pc_listener_BIT
2348: B0 0C    JNZ   0x2355        (0126) 	jnz		Dispatch_INTERRUPT_9_END
234A: 50 04    MOV   A,4           (0127) 	mov		a,4
234C: 47 08 01 TST   [8],1         (0128) 	tst		[ACTIVE_CONFIG_STATUS+receiver_config_ADDR_OFF], receiver_config_BIT
234F: B0 05    JNZ   0x2355        (0129) 	jnz		Dispatch_INTERRUPT_9_END
2351: 18       POP   A             (0130) 	pop		a
2352: 7E       RETI                (0131) 	reti
                                   (0132) ; Stop Code Compressor from breaking table alignment
                                   (0133) ; The next instruction does not get executed.
2353: 71 00    OR    F,0           (0134) 	Suspend_CodeCompressor
                                   (0135) Dispatch_INTERRUPT_9_END:
2355: E0 01    JACC  0x2357        (0136) 	jacc	Dispatch_INTERRUPT_9_TBL
                                   (0137) Dispatch_INTERRUPT_9_TBL:
2357: 18       POP   A             (0138) 	pop		a
2358: 7D 22 9A LJMP  _TX_TIMEOUT_ISR(0139) 	ljmp	_TX_TIMEOUT_ISR
235B: 18       POP   A             (0140) 	pop		a
235C: 7D 22 B0 LJMP  _RX_TIMEOUT_ISR(0141) 	ljmp	_RX_TIMEOUT_ISR
                                   (0142) ; Resume Code Compressor.
                                   (0143) ; The next instruction does not get executed.
                                   (0144) 	Resume_CodeCompressor

FILE: <library>
--------------------------------------------------------------------------------


PSoC Designer Version: 5.0.985.0

Copyright (C) 1994 - 2009 ImageCraft Creations Inc.
ImageCraft, 706 Colorado Ave., Suite 10-88, Palo Alto, CA 94303
info@imagecraft.com, phone (650) 493-9326 FAX (650) 493-9329
http://www.imagecraft.com
lcc source code (C) 1995, by David R. Hanson and AT&T. Reproduced by permission.
Release version 7.01
